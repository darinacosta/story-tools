(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
require('./test-utils');
require('./test-maps');
require('./test-boxes');
require('./test-styleRuleBuilder');
require('./test-ol3StyleConverter');
require('./test-SLDStyleConverter');
require('./test-WPSClassify');
require('./test-styleDirectives.js');
require('./test-timeDirectives.js');
require('./test-styleChoices.js');
require('./test-StyleComplete.js');
require('./test-storyPins.js');
require('./test-timeServices.js');
require('./test-MapConfigTransformer.js');
require('./test-WFSDescribeFeatureType.js');
require('./test-pins.js');

},{"./test-MapConfigTransformer.js":66,"./test-SLDStyleConverter":67,"./test-StyleComplete.js":68,"./test-WFSDescribeFeatureType.js":69,"./test-WPSClassify":70,"./test-boxes":71,"./test-maps":72,"./test-ol3StyleConverter":73,"./test-pins.js":74,"./test-storyPins.js":75,"./test-styleChoices.js":76,"./test-styleDirectives.js":77,"./test-styleRuleBuilder":78,"./test-timeDirectives.js":79,"./test-timeServices.js":80,"./test-utils":81}],2:[function(require,module,exports){
/*eslint-disable no-unused-vars*/
/*!
 * jQuery JavaScript Library v3.1.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2016-07-07T21:44Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};



	function DOMEval( code, doc ) {
		doc = doc || document;

		var script = doc.createElement( "script" );

		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}
/* global Symbol */
// Defining this global in .eslintrc would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.1.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.0
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-01-04
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true;
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {
	// Known :disabled false positives:
	// IE: *[disabled]:not(button, input, select, textarea, optgroup, option, menuitem, fieldset)
	// not IE: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Check form elements and option elements for explicit disabling
		return "label" in elem && elem.disabled === disabled ||
			"form" in elem && elem.disabled === disabled ||

			// Check non-disabled form elements for fieldset[disabled] ancestors
			"form" in elem && elem.disabled === false && (
				// Support: IE6-11+
				// Ancestry is covered for us
				elem.isDisabled === disabled ||

				// Otherwise, assume any non-<option> under fieldset[disabled] is disabled
				/* jshint -W018 */
				elem.isDisabled !== !disabled &&
					("label" in elem || !disabledAncestor( elem )) !== disabled
			);
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				return m ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnotwhite = ( /\S+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			resolve.call( undefined, value );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.call( undefined, value );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnotwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? JSON.parse( data ) :
					data;
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) ),
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== "undefined" ?
				context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Support: IE <=9
		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		//
		// Support: Firefox <=42
		// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
		if ( delegateCount && cur.nodeType &&
			( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push( { elem: cur, handlers: matches } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			return ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

function manipulationTarget( elem, content ) {
	if ( jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		div.style.cssText =
			"box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE <=9 only
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var val,
		valueIsBorderBox = true,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Support: IE <=11 only
	// Running getBoundingClientRect on a disconnected node
	// in IE throws an error.
	if ( elem.getClientRects().length ) {
		val = elem.getBoundingClientRect()[ name ];
	}

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function raf() {
	if ( timerId ) {
		window.requestAnimationFrame( raf );
		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnotwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	// Go to the end state if fx are off or if document is hidden
	if ( jQuery.fx.off || document.hidden ) {
		opt.duration = 0;

	} else {
		opt.duration = typeof opt.duration === "number" ?
			opt.duration : opt.duration in jQuery.fx.speeds ?
				jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.requestAnimationFrame ?
			window.requestAnimationFrame( raf ) :
			window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	if ( window.cancelAnimationFrame ) {
		window.cancelAnimationFrame( timerId );
	} else {
		window.clearInterval( timerId );
	}

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							-1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {
			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




var rclass = /[\t\r\n\f]/g;

function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnotwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + getClass( elem ) + " " ).replace( rclass, " " )
					.indexOf( className ) > -1
			) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g,
	rspaces = /[\x20\t\r\n\f]+/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace( rreturn, "" ) :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} ) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 13
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in uncached url if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rts, "" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( jQuery.isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win, rect, doc,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		rect = elem.getBoundingClientRect();

		// Make sure element is not hidden (display: none)
		if ( rect.width || rect.height ) {
			doc = elem.ownerDocument;
			win = getWindow( doc );
			docElem = doc.documentElement;

			return {
				top: rect.top + win.pageYOffset - docElem.clientTop,
				left: rect.left + win.pageXOffset - docElem.clientLeft
			};
		}

		// Return zeros for disconnected and hidden elements (gh-2310)
		return rect;
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset = {
				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
			};
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

jQuery.parseJSON = JSON.parse;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}





var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}


return jQuery;
} );

},{}],3:[function(require,module,exports){
exports.time = require('./time/controls');
exports.maps = require('./time/maps');
exports.maps.pins = require('./time/pins');
exports.maps.boxes = require('./time/boxes');
exports.utils = require('./time/utils');

},{"./time/boxes":4,"./time/controls":5,"./time/maps":7,"./time/pins":9,"./time/utils":11}],4:[function(require,module,exports){
var utils = require('./utils');

function Box(options) {
    this.range = options.range || null;
    this.data = options.data || null;
    this.layerIds = options.layerIds || null;
    this.center = options.center || null; // ol.Coordinate
    this.resolution = options.resolution || null;
    this.allowPan = options.allowPan;
    this.allowZoom = options.allowZoom;
    this.speed = options.speed;  // interval, seconds
    this.title = options.title || '';
    this.id = options.id || new Date().getUTCMilliseconds();
    this.zoom = options.zoom || null;
    this._offset = 0;
    if (this.range === null) {
        if(this.data) {
            this.range = utils.createRange(this.data[0], this.data[this.data.length - 1]);
        }else{
            this.range = utils.createRange(options.start_time, options.end_time);
        }
    }
    // @todo possible divide by zero if speed.interval not set!
    this._steps = this.data === null ? Math.floor(this.range.width() / this.speed.interval) + 1: this.data.length;
}
Box.prototype.getSteps = function() {
    return this._steps;
};
Box.prototype.getRange = function() {
    return this.range;
};
Box.prototype.getIndex = function(instant) {
    return this.data ? utils.find(this.data, instant) :
        Math.floor(Math.min(this.range.width(), Math.max(0, instant - this.range.start)) / this.speed.interval);
};
Box.prototype.getDate = function(idx) {
    idx = idx - this._offset;
    return this.data ? this.data[idx] : this.range.start + (idx * this.speed.interval);
};


function getTime(props, prop) {
    var val = props[prop];
    if (typeof val != 'undefined') {
        return val *= 1000;
    }
    return null;
}

/**
 * Load Box from geojson, reprojecting from 4326 to the provided
 * projection.
 * @param {Object} geojson
 * @param {String} projection
 * @returns array of Box features
 */
exports.loadFromGeoJSON = function(geojson, projection) {
    if (projection) {
        projection = ol.proj.get(projection);
    }
    return geojson.features.map(function(f) {
        var props = f.properties;
        //props.the_geom = f.geometry;
        props.id = f.id;
        props.start_time = getTime(props, 'start_time');
        props.end_time = getTime(props, 'end_time');
        return new Box(props, projection);
    });
};

function findBox(boxes, idx) {
    var i, ii;
    var box;
    for (i = 0, ii = boxes.length; i < ii; i++) {
        box = boxes[i];
        if (idx >= box._offset) {
            if (i + 1 < ii) {
                if (idx < boxes[i + 1]._offset) {
                    break;
                }
            } else {
                break;
            }
        }
    }
    return box;
}

exports.BoxModel = function(boxArray) {
    var boxes,
        range,
        steps;
    function updateBoxes(neu) {
        var offset = 0;
        boxes = neu.map(function(b) {
            var box = new Box(b);
            box._offset = offset;
            offset += box.getSteps();
            return box;
        });
        range = utils.computeRange(boxes, 'range');
        steps = offset;
    }
    updateBoxes(boxArray);
    this.getRange = function() {
        return range;
    };
    this.getSteps = function() {
        return steps;
    };
    this.getRangeAt = function(s, e) {
        var start = findBox(boxes, s);
        var end = findBox(boxes, e);
        return utils.createRange(start.getDate(s), end.getDate(e));
    };
    this.getIndex = function(instant) {
        var idx = 0, i;
        if (instant < boxes[0].getRange().start) {
            return 0;
        }
        for (i = 0; i < boxes.length; i++) {
            var box = boxes[i];
            var range = box.getRange();
            if (instant >= range.start && instant <= range.end) {
                idx += box.getIndex(instant);
                break;
            } else {
                idx += box.getSteps();
            }
        }
        return idx;
    };
    this.setRange = function(newRange) {
        if (boxes.length == 1) {
            // @todo support for range
            if (utils.isRangeLike(newRange)) {
                throw new Error('not supported yet');
            }
            boxes[0].data = newRange;
            // @todo must set here or constructor is dumb and doesn't recompute
            boxes[0].range = utils.computeRange(newRange);
        } else {
            // @todo finish
            console.log('more than one story box to update range with!');
        }
        updateBoxes(boxes);
    };
    this.update = function(options) {

    };
};

exports.findBox = findBox;
exports.Box = Box;

},{"./utils":11}],5:[function(require,module,exports){
var utils = require('./utils');
var models = require('./models');
var timeslider = require('./slider');
var line = require('./line');
var maps = require('./maps');

/**
 * Facade object and guts of slider/timeline/playback logic.
 *
 * Since playback is driven by a timeout, all other potential events
 * are fired in an async manner to ensure a uniform API.
 */
function TimeController(model, slider, timeline, controls, chapterCount) {
    this.model = model;
    this.slider = slider;
    this.timeline = timeline;
    this.loop = 'none';

    var self = this,
        currentTimelineWindow = getTimelineWindow(),
        isAdjusting = false,
        started = false,
        timeout = null,
        events = new utils.Events(),
        deferred = [];

    function getTimelineWindow() {
        return utils.createRange(timeline.getWindow());
    }

    function adjust(fun, a, b) {
        if (isAdjusting) {
            return;
        }
        isAdjusting = true;
        try {
            fun(a, b);
        } finally {
            isAdjusting = false;
        }
    }

    function centerTimeline(range) {
        var c = model.mode === 'cumulative' ? range.end : range.center();
        timeline.moveTo(c);
        publishRangeChange(range);
    }

    function adjustSlider(range) {
        if (timeline.isWindowMax()) {
            return;
        }

        var center = range.center();
        var idx = model.getIndex(center);
        if (model.mode === 'cumulative') {
            slider.growTo(idx);
        } else {
            slider.center(idx);
        }
        timeline.setTime(center);
        publishRangeChange(slider.getRange());
    }

    function updateSlider(range) {
        if (utils.rangesEqual(range, currentTimelineWindow)) {
            return;
        }
        range = utils.createRange(range);
        // zoom or scroll event?
        if (range.width() !== currentTimelineWindow.width()) {
            timeline.moveToCurrentTime();
        } else {
            adjustSlider(range);
        }
        currentTimelineWindow = range;
    }

    slider.on('rangeChanged', function(ev, range) {
        clearTimeout();
        adjust(centerTimeline, range);
        schedule();
    });
    timeline.on('rangechanged', function(range) {
        adjust(updateSlider, range);
    });
    timeline.on('select', function(properties) {
        console.log("Selected items: ", properties.items);
    });
    function clearTimeout() {
        if (timeout !== null) {
            window.clearTimeout(timeout);
        }
        timeout = null;
    }

    function move(amt) {
        timeout = null;
        var atEnd;
        if (model.mode === 'cumulative') {
            atEnd = slider.grow(amt);
        } else {
            atEnd = slider.move(amt);
        }
        if (atEnd) {
            if (self.loop === 'chapter') {
                slider.jump(0);
            } else if (self.loop === 'story') {
              var currentChapter = window.location.hash.split("/")[2];
              var nextChapter = currentChapter === undefined || currentChapter === null ? 2 : parseInt(currentChapter) + 1;
              console.log(chapterCount);
              if(nextChapter <= chapterCount) {
                  console.log("Going to Chapter ", nextChapter);
                  window.location.href = '#/chapter/' + nextChapter;
                  slider.jump(0);
              } else {
                console.log("Going to Chapter 1");
                window.location.href = '#/chapter/1';
                slider.jump(0);
              }
            } else {
              self.stop();
            }
        }
        centerTimeline(slider.getRange());
        if (started) {
            schedule();
        }
    }

    function schedule() {
        if (started) {
            // @todo respect playback interval options...
            var wait = model.interval;
            $.when.apply($, deferred).then(function() {
                if (started) {
                    timeout = window.setTimeout(move, wait, 1);
                }
            }, function() {
                // the deferred was rejected, if arguments provided, this
                // represents an error state so don't continue playing
                if (arguments.length === 0 && started && timeout === null) {
                    timeout = window.setTimeout(move, wait, 1);
                } else {
                    self.stop();
                }
            });
            deferred = [];
        }
    }

    function run() {
        publishStateChange("running");
        move(1);
    }

    function publishRangeChange(data) {
        if (typeof data === 'undefined') {
            data = slider.getRange();
        }
        publish("rangeChange", data);
    }

    function publishStateChange(state) {
        publish("stateChange", state);
    }

    function publish(event, data) {
        events.event(event).publish(data);
    }

    this.defer = function(defer) {
        deferred.push(defer);
    };
    this.getCurrentRange = function() {
        return slider.getRange();
    };
    this.update = function(options) {
        model.update(options);
        slider.update(model);
        timeline.update(model);
        window.setTimeout(publishRangeChange, 0);
    };
    this.start = function() {
        if (started) {
            return;
        }
        deferred = [];
        started = true;
        window.setTimeout(run, 0);
    };
    this.stop = function() {
        deferred = [];
        started = false;
        clearTimeout();
        window.setTimeout(publishStateChange, 0, 'stopped');
    };
    this.next = function() {
        clearTimeout();
        window.setTimeout(move, 0, 1);
    };
    this.prev = function() {
        clearTimeout();
        window.setTimeout(move, 0, -1);
    };
    this.isStarted = function() {
        return started;
    };
    this.on = function(event, f) {
        events.event(event).subscribe(f);
    };
}

/**
 * annotation model:
 * title
 * content
 * the_geom
 * start_time
 * end_time
 * in_timeline
 * in_map
 * appearance
 */
function Annotations(annotations) {
    var ann = annotations || [];
    function inTimeline() {
        return ann.filter(function(a) {
            return a.in_timeline;
        });
    }
    this.getTimeLineAnnotatons = function() {
        return inTimeline(true);
    };
    this.update = function(annotations) {
        this.ann = annotations;
    };
}

/**
 * box model:
 * title
 * content
 * the_geom
 * start_time
 * end_time
 * in_timeline
 * in_map
 * appearance
 */
function Boxes(boxes) {
    var box = boxes || [];
    function inTimeline() {
        return box.filter(function(b) {
            return true;//b.in_timeline;
        });
    }
    this.getTimeLineBoxes = function() {
        return inTimeline(true);
    };
    this.update = function(boxes) {
        this.box = boxes;
    };
}


/**
 * common lingo:
 * instant: a single point in time
 * extent, range: has property start and end
 * start, end: long values representing UTC (internal) but generally,
 *             a date
 * interval: multipier * precision
 * precision: tick, second, minute, hour, day, week, month, year
 *            note: tick implies a multipier of 1
 * speed: object with property seconds (framerate) and optional interval
 *
 * options = {
 *   annotations: [ {
 *      title,
 *      content,
 *      the_geom,
 *      start_time,
 *      end_time,
 *      in_timeline,
 *      in_map,
 *      appearance
 *      } ... ],
 *   map: ol.Map,
 *   boxes : [ {
 *      range : {
 *          start, end
 *      },
 *      center: ol.Coordinate,
 *      resolution: float,
 *      static: boolean,
 *      speed: { interval, seconds }
 *      } ... ],
 *   data : [ date ...] | rangeWithInterval,
 *   playback : {
 *      mode: instant | range | cumulative,
 *      fixed: boolean
 *   },
 *   timeLineId : element id,
 *   timeSliderId : element id,
 *   controlsId: element id
 *
 * }
 */
function create(options) {
    // @todo for layers, annotations won't exist and, intially, we won't
    //       have playback settings for layers...
    var model,
        annotations = new Annotations(options.annotations),
        boxes = options.boxes,
        chapterCount = options.chapterCount,
        totalRange,
        slider,
        timeline,
        mapController,
        controls;
    options.boxy = new Boxes(options.boxes);
    // make a default box if none provided
    if (typeof boxes == 'undefined' || boxes.length === 0) {
        var interval = 0, data = null;
        if (Array.isArray(options.data)) {
            data = options.data;
            totalRange = utils.computeRange(options.data);
        } else {
            interval = options.data.interval || utils.pickInterval(options.data);
            totalRange = options.data;
        }
        boxes = [{
                data: data,
                range: totalRange,
                speed: {
                    interval: interval,
                    seconds: 3
                }
            }];
    }

    model = new models.TimeModel(options, boxes, annotations);
    slider = new timeslider.TimeSlider(options.timeSliderId || 'slider', model);
    timeline = new line.TimeLine(options.timeLineId || 'timeline', model);

    var timeControls = new TimeController(model, slider, timeline, controls, chapterCount);
    mapController = new maps.MapController(options, timeControls);
    return timeControls;
}

exports.create = create;
exports.maps = maps;
exports.utils = utils;

},{"./line":6,"./maps":7,"./models":8,"./slider":10,"./utils":11}],6:[function(require,module,exports){
var Timeline = require('vis/lib/timeline/Timeline');
var utils = require('./utils');

/**
 * Display annotations or other temporal instant/extent. Allow adjusting
 * time (either instant or extent) by dragging.
 * @param {type} id
 * @param {type} model
 * @returns {_L1.TimeLine}
 */
exports.TimeLine = function(id, model) {
    var dom = $("#" + id);
    var timeline = null;
    // @revisit - internally the timeline seems to apply the offset when
    //            creating a tool tip, does this cause problems elsewhere?
    var offset = new Date().getTimezoneOffset() * 60 * 1000;

    function init(model) {
        var story_pin_label = 'Story Pin';
        var elements = [], layer_groups = [], groups = [{id: story_pin_label, title: story_pin_label, time: []}], options;
        var range = model.getRange();
        if (range.isEmpty()) {
            range = utils.createRange(Date.now());
        }
        elements = model.annotations.getTimeLineAnnotatons().map(function(ann, i) {
            /*jshint eqnull:true */
            var start = ann.start_time != null ? ann.start_time : range.start;
            var end = ann.end_time != null ? ann.end_time : range.end;
            var type = start === end ? 'box' : 'range';
            return {
                id: ann.id,
                start: start,
                end: end,
                content: ann.content || ann.title,
                title: ann.title,
                type: type,
                group: story_pin_label
            };
        });
        if (model.boxy.box) {
            elementss = model.boxy.box.map(function(box, i) {
                /*jshint eqnull:true */
                var start = box.range != null ? box.range.start : range.start;
                var end = box.range != null ? box.range.end : range.end;
                var type = 'background';
                return {
                    id: 'sb' + box.id,
                    start: start,
                    end: end,
                    content: box.content || box.title,
                    type: type
                };
            });
            elements = elements.concat(elementss);
        }
        layer_groups = $.map(model.storyLayers, function(lyr, i) {
            var id = lyr.get('id');
            var title = lyr.get('title');
            var times = lyr.get('times') || [];

            for (var j = 0; j < times.length; j++) {
                elements.push({
                    id: id + ':' + i + ':' + j,
                    group: id,
                    content: "",
                    start: times[j],
                    type: 'box'
                });
            }

            return {
                id: id,
                content: title
            };
        });

        groups = groups.concat(layer_groups);

        var height = $( document ).height() * 0.35;

        options = {
            min: range.start,
            max: range.end,
            start: range.start,
            end: range.end,
            height: (height < 300)? 138: height,
            maxHeight: 400,
            showCurrentTime: false
        };
        if (timeline === null) {
            timeline = new Timeline(dom.get(0), elements, options);
            timeline.setGroups(groups);
            timeline.setCurrentTime(range.start);
            timeline.addCustomTime();
        } else {
            timeline.setOptions(options);
            timeline.setItems(elements);
            timeline.setGroups(groups);
        }
    }
    init(model);

    // updates from user dragging customtime bar
    // @todo will not update slider currently at min timeline zoom as it
    // is difficult to determine whether an event is from zooming or dragging
    // need to wrap event handling to better differentiate
    timeline.on('timechanged', function() {
        timeline.moveTo(timeline.getCustomTime(), {animate: false});
    });

    this.moveTo = function(time) {
        timeline.moveTo(time, {animate: false});
        this.setTime(time);
    };
    this.setTime = function(time) {
        timeline.setCustomTime(time + offset);
    };
    this.isWindowMax = function() {
        return utils.rangesEqual(timeline.getWindow(), model.getRange());
    };
    this.moveToCurrentTime = function() {
        var current = timeline.getCustomTime().getTime();
        var width = utils.createRange(timeline.getWindow()).width();
        var range = model.getRange();
        if (current === range.start) {
            timeline.setWindow(range.start, range.start + width, {animate: false});
        } else if (current === range.end) {
            timeline.setWindow(range.end - width, range.end, {animate: false});
        } else {
            timeline.moveTo(current, {animate: false});
        }
    };
    this.getWindow = function() {
        return timeline.getWindow();
    };
    this.on = function(ev, cb) {
        timeline.on(ev, cb);
    };
    this.update = init;
    // @todo detect click or dblclick event and position based on % of total width
};

},{"./utils":11,"vis/lib/timeline/Timeline":44}],7:[function(require,module,exports){
/*jshint loopfunc: true */
var utils = require('./utils');
var moment = require('vis/node_modules/moment');

/**
 * Read the provide ol3 WMS capabilities document
 * @param {type} caps
 * @returns an object of name->[date|interval]|interval-range mappings
 */
exports.readCapabilitiesTimeDimensions = function(caps, openlayers2) {
    var dimensions = {};
    function readRange(subparts) {
        if (subparts.length < 2) {
            throw new Error('expected 2 parts for range : ' + subparts);
        }
        var range = utils.createRange(subparts[0], subparts[1]);
        if (subparts.length == 3) {
            range.duration = subparts[2];
            range = new utils.Interval(range);
        }
        return range;
    }
    function readPart(part) {
        var subparts = part.split('/');
        if (subparts.length == 1) {
            return Date.parse(subparts[0]);
        } else {
            return readRange(subparts);
        }
    }
    function parse(dimension) {
        var dims = openlayers2 ? dimension : dimension.split(',');
        if (dims.length == 1) {
            var read = readPart(dims[0]);
            return typeof read === 'number' ? [read] : read;
        }
        return dims.map(readPart);
    }
    if (openlayers2 === true) {
        if (caps.dimensions && caps.dimensions.time) {
            dimensions = parse(caps.dimensions.time.values);
        } else {
            dimensions = undefined;
        }
    } else {
        // @todo need to make layer scanning recursive?
        caps.value.capability.layer.layer.forEach(function(lyr) {
            if (lyr.dimension) {
                dimensions[lyr.name] = parse(lyr.extent[0].value);
            }
        });
    }
    return dimensions;
};

function TileLoadListener(tileStatusCallback) {
    var tilesLoading = {};
    var deferred = $.Deferred(),
          cancelled = false;
    function remainingTiles() {
        var t = 0;
        for (var i in tilesLoading) {
            t += tilesLoading[i];
        }
        return t;
    }
    var listener = {
        deferred: deferred,
        cancel: function() {
            cancelled = true;
            for (var s in tilesLoading) {
                tilesLoading[s] = 0;
            }
            if (deferred) {
                deferred.reject(); // notify we've aborted but w/out error
            }
            if (tileStatusCallback) {
                tileStatusCallback(0);
            }
        },
        tileQueued: function(source) {
            if (cancelled) {
                return;
            }
            var key;
            if (source instanceof ol.source.TileWMS) {
                key = source.getUrls()[0];
            } else if (source instanceof ol.source.ImageWMS) {
                key = source.getUrl();
            }
            tilesLoading[key] = (tilesLoading[key] || 0) + 1;
            if (tileStatusCallback) {
                tileStatusCallback(remainingTiles());
            }
        },
        tileLoaded: function(event, source) {
            if (cancelled) {
                return;
            }
            var key;
            if (source instanceof ol.source.TileWMS) {
                key = source.getUrls()[0];
            } else if (source instanceof ol.source.ImageWMS) {
                key = source.getUrl();
            }
            tilesLoading[key] -= 1;
            var remaining = remainingTiles();
            if (tileStatusCallback) {
                tileStatusCallback(remaining);
            }
            if (remaining === 0 && deferred) {
                deferred.resolve();
            }
        }
    };
    // workaround for when the tiles are cached and no events are triggered
    // this adds a constant (small) additional delay to the current play rate
    // under optimal (cached) conditions
    // @todo can this safely be shortened?
    window.setTimeout(function() {
        if (Object.keys(tilesLoading).length === 0) {
            listener.cancel();
        }
    },100);
    return listener;
}

function filterVectorLayer(storyLayer, range) {
    var timeAttr = storyLayer.get('timeAttribute'), l_features = storyLayer.get('features');
    if (timeAttr === undefined || l_features === undefined) {
        return;
    }
    range = utils.createRange(range);
    // loop over all original features and filter them
    var features = [];
    var layer = storyLayer.getLayer();
    visitAllLayerFeatureTimes(storyLayer, function(f,r) {
        if (range.intersects(r)) {
            features.push(f);
        }
    });
    layer.getSource().clear(true);
    layer.getSource().addFeatures(features);
}


function filterVectorBoxLayer(storyLayer, range) {
    var timeAttr = storyLayer.get('timeAttribute'), l_features = storyLayer.get('features');
    if (timeAttr === undefined || l_features === undefined) {
        return;
    }
    range = utils.createRange(range);
    // loop over all original features and filter them
    var features = [];
    visitAllLayerFeatureTimes(storyLayer, function(f,r) {
        if (range.intersects(r)) {
            features.push(f);
        }
    });

    return features;
}
/**
 * Call the provided visitor function on the specified features using the
 * configuration provided in the layer. The visitor function will be called
 * with the feature, and start and end time, if any. The features visited will
 * be, in order of priority: the provided (optional) features argument, the
 * layer property 'features', the layer's source features.
 * @param {StoryLayer} story layer
 * @param {function} visitor function(feature, start, end)
 * @param {array} features (opitonal)
 */
function visitAllLayerFeatureTimes(storyLayer, visitor, features) {
    var startAtt = storyLayer.get('timeAttribute');
    var endAtt = storyLayer.get('endTimeAttribute');
    var rangeGetter;
    var layer = storyLayer.getLayer();
    features = features || storyLayer.get('features') || layer.getSource().getFeatures();
    if (endAtt) {
        rangeGetter = function(f) {
            if(f.range){
                return f.range;
            }else {
                var start = f.get(startAtt);
                var end = f.get(endAtt);
                return utils.createRange(start, end);
            }
        };
    } else {
        rangeGetter = function(f) {
            if(f.range){
                return f.range;
            }else {
                var start = f.get(startAtt);
                return utils.createRange(start, start);
            }
        };
    }
    utils.visitRanges(features, rangeGetter, visitor);
}

/**
 * Compute the range of the provided features using the layer's configured
 * timeattributes. If the optional features array is omitted, the features
 * will come from the layer.
 * @param {StoryLayer} storyLayer
 * @param {array} features (optional)
 * @returns {storytools.core.time.Range} range of features
 */
exports.computeVectorRange = function(storyLayer, features) {
    var startAtt = storyLayer.get('timeAttribute');
    var endAtt = storyLayer.get('endTimeAttribute');
    var layer = storyLayer.getLayer();
    features = features || storyLayer.get('features') || layer.getSource().getFeatures();
    return utils.computeRange(features, function(f) {
        return utils.createRange(f.get(startAtt), f.get(endAtt));
    });
};

exports.filterVectorLayer = filterVectorLayer;
exports.filterVectorBoxLayer = filterVectorBoxLayer;

exports.MapController = function(options, timeControls) {
    var loadListener = null,
          tileStatusCallback = options.tileStatusCallback,
          storyMap = options.storyMap;
    function layerAdded(layer) {
        var source, image;
        var loaded = function(event) {
            // grab the active loadListener to avoid phantom onloads
            // when listener is cancelled
            var currentListener = loadListener;
            if (currentListener) {
                currentListener.tileLoaded(event, source);
            }
        };
        var loadstart = function() {
            // grab the active loadListener to avoid phantom onloads
            // when listener is cancelled
            var currentListener = loadListener;
            if (currentListener) {
                currentListener.tileQueued(source);
            }
        };
        if (layer instanceof ol.layer.Tile && layer.getSource() instanceof ol.source.TileWMS) {
            source = layer.getSource();
            source.on('tileloadstart', loadstart);
            source.on('tileloadend', loaded);
            // @todo handle onerror and cancel deferred with an example
            // to stop automatic playback
            source.on('tileloaderror', loaded);
        } else if (layer instanceof ol.layer.Image && layer.getSource() instanceof ol.source.ImageWMS) {
            source = layer.getSource();
            source.on('imageloadstart', loadstart);
            source.on('imageloadend', loaded);
            source.on('imageloaderror', loaded);
        }
    }
    function createLoadListener() {
        if (loadListener !== null) {
            loadListener.cancel();
        }
        loadListener = new TileLoadListener(tileStatusCallback);
        return loadListener;
    }

    function updateCenterAndZoom(range){
        var currentBoxes = filterVectorBoxLayer(storyMap.storyBoxesLayer, range);

        if(currentBoxes && currentBoxes.length > 0) {
            var currentBox = currentBoxes[0];
            
            if (currentBox.center) {
                storyMap.animateCenterAndZoom(currentBox.center, currentBox.zoom);
            }
        }else{
            if (storyMap.returnToExtent) {
                storyMap.animateCenterAndZoom(storyMap.getCenter(), storyMap.getZoom());
            }
        }
    }

    function updateLayers(range) {
        var storyLayers = storyMap.getStoryLayers();
        var time = new Date(range.start).toISOString();
        if (range.start != range.end) {
            time += "/" + new Date(range.end).toISOString();
        }
        for (var i = 0; i < storyLayers.getLength(); i++) {
            var storyLayer = storyLayers.item(i), layer = storyLayer.getLayer();
            if ((layer instanceof ol.layer.Tile && layer.getSource() instanceof ol.source.TileWMS) ||
                  (layer instanceof ol.layer.Image && layer.getSource() instanceof ol.source.ImageWMS)) {
                if (storyLayer.get('times')) {
                    layer.getSource().updateParams({TIME: time});
                }
            } else if (layer instanceof ol.layer.Vector) {
                filterVectorLayer(storyLayer, range);
            }
        }
        // this is a non-story layer - not part of the main collection
        filterVectorLayer(storyMap.storyPinsLayer, range);
        if (storyLayers.getLength() >= 1) {
            timeControls.defer(createLoadListener().deferred);
        }
    }
    var me = this;
    me.layers = {};
    storyMap.getStoryLayers().on('add', function(ev) {
        var lyr = ev.element, id = lyr.get('id');
        if (me.layers[id] !== true) {
            layerAdded(lyr.getLayer());
            me.layers[id] = true;
        }
    });
    storyMap.getStoryLayers().forEach(function(lyr) {
        var id = lyr.get('id');
        if (id !== undefined && me.layers[id] !== true) {
            layerAdded(lyr.getLayer());
            me.layers[id] = true;
        }
    });
    timeControls.on('rangeChange', updateCenterAndZoom);
    timeControls.on('rangeChange', updateLayers);
};

},{"./utils":11,"vis/node_modules/moment":63}],8:[function(require,module,exports){
var utils = require('./utils');
var BoxModel = require('./boxes').BoxModel;

/**
 * @todo document me
 */
exports.TimeModel = function(options, boxes, annotations) {
    
    var events = new utils.Events(),
        boxModel = new BoxModel(boxes);

    this.annotations = annotations;
    this.boxes = boxes;
    this.boxy = options.boxy;
    this.storyLayers = [];
    this.fixed = false;
    this.mode = 'instant';
    this.interval = 1000;

    function init(opts) {
        if (opts.hasOwnProperty('fixed')) {
            this.fixed = opts.fixed;
        }

        if (opts.hasOwnProperty('speed') && opts.speed !== undefined) {
            this.interval = opts.speed;
        }

        if (opts.hasOwnProperty('mode') && opts.mode !== undefined) {
            this.mode = opts.mode;
        }
        if (opts.hasOwnProperty('annotations')) {
            this.annotations.update(opts.annotations);
        }
        if (opts.hasOwnProperty('boxes')) {
            this.boxy.update(opts.boxes);
        }

        if (opts.hasOwnProperty('storyLayers')) {
            this.storyLayers = opts.storyLayers;
        }

        // @todo is the best name for this
        if (opts.hasOwnProperty('data')) {
            boxModel.setRange(opts.data);
        }
    }

    init.call(this, options);
    this.getRange = function() {
        return boxModel.getRange();
    };
    this.getTotalRange = function() {
        // @todo need to access layers and cached dimension data
        //       and consider annotations?
        throw Error('not implemented');
    };
    this.update = init;
    this.getSteps = function() {
        return boxModel.getSteps();
    };
    this.getIndex = function(instant) {
        return boxModel.getIndex(instant);
    };
    this.getRangeAt = function(i, j) {
        return boxModel.getRangeAt(i, j);
    };
};

},{"./boxes":4,"./utils":11}],9:[function(require,module,exports){
var format = new ol.format.GeoJSON();


var StoryPin = function(data, projection) {
    ol.Feature.call(this, data);
    if (data) {
        if (data.the_geom) {
            var geom = data.the_geom;
            if (typeof geom === 'string' || 'type' in geom) {
                geom = format.readGeometry(geom, {
                    featureProjection: projection
                });
            }
            this.setGeometry(geom);
            delete data.the_geom;
        }
        this.setId(data.id);
    }
};
StoryPin.prototype = Object.create(ol.Feature.prototype);
StoryPin.prototype.constructor = StoryPin;
// expose these simply for the timeline - it doesn't know they're features
['id','start_time','end_time','content','title','in_timeline','in_map'].forEach(function(prop) {
    Object.defineProperty(StoryPin.prototype, prop, {
        get: function() {
            var val = this.get(prop);
            return typeof val === 'undefined' ? null : val;
        },
        set: function(val) {
            this.set(prop, val);
        }
    });
});

/*
 var start = ann.start_time != null ? ann.start_time : range.start;
 var end = ann.end_time != null ? ann.end_time : range.end;
 var type = start === end ? 'box' : 'range';
 return {
 id: ann.id,
 start: start,
 end: end,
 content: ann.content || ann.title,
 title: ann.title,
 type: type
 };
 */

function getTime(props, prop) {
    var val = props[prop];
    if (typeof val != 'undefined') {
        return val *= 1000;
    }
    return null;
}

/**
 * Load StoryPins from geojson, reprojecting from 4326 to the provided
 * projection.
 * @param {Object} geojson
 * @param {String} projection
 * @returns array of StoryPin features
 */
exports.loadFromGeoJSON = function(geojson, projection) {
    if (projection) {
        projection = ol.proj.get(projection);
    }
    return geojson.features.map(function(f) {
        var props = f.properties;
        props.the_geom = f.geometry;
        props.id = f.id;
        props.start_time = getTime(props, 'start_time');
        props.end_time = getTime(props, 'end_time');
        return new StoryPin(props, projection);
    });
};

exports.StoryPin = StoryPin;

},{}],10:[function(require,module,exports){
/**
 * Visual feedback of complete story line. Allow dragging of range, click
 * to position.
 *
 * Playback Modes
 * - fixed cumulative (min fixed at 0, max adjusts with tick)
 * - fixed range playback (range fixed, window adjusts with tick)
 * - fixed instant (like fixed range but range of 0)
 * - open range playback (fully adjustable min/max, window adjusts with tick)
 *
 * Internal model
 * - 0-N where N is either the number of instants or the total number of extents
 *
 * @param {type} id
 * @param {type} model
 * @returns {TimeSlider}
 */
exports.TimeSlider = function(id, model) {
    var slider = $("#" + id);
    var initialized = false;
    var singleSlider;

    function init(model) {
        var options = {
            step: 1,
            start: [0, 0],
            animate: false,
            connect: true,
            range: {
                min: 0,
                max: model.getSteps() - 1
            },
            behaviour: 'drag-snap'
        };
        singleSlider = false;

        /*if (model.fixed) {
            // @todo need model interval
        }*/

        if (model.mode === 'cumulative') {
            singleSlider = true;
            options.connect = 'lower';
        } else if (model.mode === 'instant') {
            singleSlider = true;
            options.connect = false;
        } else if (model.mode === 'range') {
            if (model.fixed) {
                // ideally we'd support snap but it breaks fixed
                options.behaviour = 'drag-fixed';
            }
        } else {
            throw "invalid model mode : " + model.mode;
        }

        if (initialized) {
            // have to update values based on current state
            var range = getSliderRangeInternal();
            if (singleSlider) {
                options.start = range[0];
            } else {
                if (range[0] === range[1]) {
                    range[1] += 1;
                }
                options.start = range;
            }
        } else if (singleSlider) {
            options.start = 0;
        }
        slider.noUiSlider(options, initialized);
        if (!initialized) {
            slider.bind('slide', function(ev) {
                var range = getRange();
                slider.trigger('rangeChanged', range);
            });
        }
        initialized = true;
    }

    init(model);

    function getSliderRangeInternal() {
        var range = slider.val();
        if (! Array.isArray(range)) {
            range = parseInt(range, 10);
            range = [model.mode === 'cumulative' ? 0 : range, range];
        } else {
            range = range.map(function(i) { return parseInt(i, 10); });
        }
        return range;
    }

    function getRange() {
        var range = getSliderRangeInternal();
        return model.getRangeAt(range[0], range[1]);
    }

    function width() {
        var range = getSliderRangeInternal();
        return range[1] - range[0];
    }

    function isAtEnd(left) {
        var range = getSliderRangeInternal();
        if (left) {
            return range[0] === 0;
        }
        return range[1] === model.getSteps()-1;
    }

    function setValue(val) {
        // normalize nouislider.val to handle array
        if (singleSlider) {
            slider.val(val[1]);
        } else {
            slider.val(val);
        }
    }

    this.slider = slider;
    this.on = function() {
        slider.on.apply(slider, arguments);
    };
    this.getSliderRangeInternal = getSliderRangeInternal;
    this.center = function(index) {
        var half = Math.floor(width() / 2);
        setValue([index - half, index + half]);
    };
    this.move = function(amt) {
        var vals  = getSliderRangeInternal();
        vals[0] += amt;
        vals[1] += amt;
        setValue(vals);
        return isAtEnd(amt < 0);
    };
    this.grow = function(amt) {
        var vals = getSliderRangeInternal();
        vals[1] += amt;
        setValue(vals);
        return isAtEnd(false);
    };
    this.growTo = function(where) {
        var vals = getSliderRangeInternal();
        vals[1] = where;
        setValue(vals);
        return isAtEnd(false);
    };
    this.jump = function(to) {
        setValue([to, to + width()]);
    };
    this.getRange = getRange;
    this.update = init;
};

},{}],11:[function(require,module,exports){
var moment = require('vis/node_modules/moment');

/**
 * Get the number of milliseconds from the provided arg.
 * @param arg - either Date, range (returns start), string or number
 * @returns milliseconds or null if nothing provided
 */
getTime = function(arg) {
    var type = typeof arg;
    if (type === 'number') {
        return arg;
    }
    if (arg instanceof Date) {
        return arg.getTime();
    }
    if (type === 'string') {
        return Date.parse(arg);
    }
    /*jshint eqnull:true */
    if (arg == null) {
        return null;
    }
    if (isRangeLike(arg)) {
        /*jshint eqnull:true */
        return getTime(arg.start != null ? arg.start : arg.end);
    }
    throw new Error('cannot call getTime with ' + type + ", : " + arg);
};

isRangeLike = function(object) {
    /*jshint eqnull:true */
    return object != null && (object.hasOwnProperty('start') || object.hasOwnProperty('end'));
};

exports.isRangeLike = isRangeLike;

exports.createRange = function(start, end) {
    if (arguments.length === 1) {
        var other = start;
        if (isRangeLike(other)) {
            start = other.start;
            end = other.end;
        } else {
            end = start;
        }
    }
    /*jshint eqnull:true */
    if (start != null && end != null && start > end) {
        throw new Error('start > end');
    }
    return new Range(getTime(start), getTime(end));
};

exports.rangesEqual = function(a, b) {
    return getTime(a.start) === getTime(b.start) &&
        getTime(a.end) === getTime(b.end);
};

function rangeContains(range, time) {
    /*jshint eqnull:true */
    if (time == null) {
        throw new Error('invalid time argument');
    }
    /*jshint eqnull:true */
    return ((range.start != null ? time >= range.start : true) &&
           (range.end != null ? time < range.end : true)) ||
           range.start === range.end && time === range.start;
}

exports.parseISODuration = function(duration) {
    var values = exports.isoDurationToMoment(duration);
    return moment.duration(values).asMilliseconds();
};

exports.Interval = function(start, end, duration) {
    if (typeof start === 'object') {
        var opts = start;
        start = opts.start;
        end = opts.end;
        duration = opts.duration;
    }
    if (start === end) {
        throw new Error('interval should have width');
    }
    Range.call(this, start, end);
    this.duration = duration;
    this.interval = exports.parseISODuration(this.duration);
    this.offset = exports.createOffsetter(this);
};

function Range(start, end) {
    if (isNaN(start) || isNaN(end)) {
        throw new Error('invalid start and/or end');
    }
    this.start = start;
    this.end = end;
}
/**
 * extend this Range by another. This algorithm will consider an open-ended
 * range to represent a minimum of start and maximum of end.
 * @param {type} other
 * @returns {undefined}
 */
Range.prototype.extend = function(other) {
    /*jshint eqnull:true */
    if (!isRangeLike(other)) {
        other = exports.createRange(other);
    }
    var start = getTime(other.start);
    var end = getTime(other.end);
    if (start == null) {
        start = end;
    }
    if (end == null) {
        end = start;
    }
    if (start != null) {
        if (this.start == null) {
            this.start = start;
        } else {
            this.start = Math.min(this.start, start);
        }
    }
    if (end != null) {
        if (this.end == null) {
            this.end = end;
        } else {
            this.end = Math.max(this.end, end);
        }
    }
};
Range.prototype.intersects = function(other) {
    if (isRangeLike(other)) {
        /*jshint eqnull:true */
        var es = other.start == null ? Number.MIN_VALUE : other.start;
        var ee = other.end == null ? Number.MAX_VALUE : other.end;
        // intersection if (any)
        // effective end in this range
        // effective start in this range
        // effective start before and effective end after
        return rangeContains(this, es) ||
            rangeContains(this, ee) ||
            es <= this.start && ee >= this.end;
    } else {
        return rangeContains(this, getTime(other));
    }
};
Range.prototype.toString = function() {
    return new Date(this.start).toUTCString() + " : " + new Date(this.end).toUTCString();
};
Range.prototype.center = function() {
    return Math.floor(this.start + (this.end - this.start) / 2);
};
Range.prototype.width = function() {
    return this.end - this.start;
};
Range.prototype.isEmpty = function() {
    /*jshint eqnull:true */
    return this.end == null && this.start == null;
};
exports.Range = Range;



/**
 * Compute the overall range of provided args. Args may be an array of:
 * date or long, range, object with property/function yielding range for the
 * object.
 * @param {type} args
 * @returns range will have start/end even if the same time.
 */
exports.computeRange = function(args, rangeGetter) {
    var range = new Range(null, null);
    exports.visitRanges(args, rangeGetter, function(arg, r) {
        range.extend(r);
    });
    /*jshint eqnull:true */
    if (range.start == null) {
        range.start = range.end;
    }
    if (range.end == null) {
        range.end = range.start;
    }
    return range;
};

exports.visitRanges = function(objects, rangeGetter, visitor) {
    var getRange;
    if (typeof rangeGetter == 'string') {
        getRange = function(object) {
            return object[rangeGetter];
        };
    } else if (typeof rangeGetter == 'function') {
        getRange = rangeGetter;
    } else {
        getRange = function(object) {
            return isRangeLike(object) ? object : exports.createRange(object);
        };
    }
    for (var i = 0, ii = objects.length; i < ii; i++) {
        var object = objects[i];
        visitor(object, getRange(object));
    }
};

/** for the given what, find the index in the items that what is closest
 * to. items must be sorted. The lowest closest value possible is returned.
 */
exports.binarySearch = function(items, what) {
    var start = 0;
    var stop = items.length - 1;
    var mid = stop + start / 2 | 0;
    var val;
    if (what < items[0]) {
        return 0;
    }
    if (what > items[stop]) {
        return items.length - 1;
    }
    while ((val = items[mid]) !== what && start < stop) {
        if (what > val) {
            if (what < items[mid + 1]) {
                return mid;
            }
        } else if (what < val) {
            if (what > items[mid - 1]) {
                return mid - 1;
            }
            stop = mid - 1;
        }
        mid = stop + start / 2 | 0;
    }
    return mid;
};

exports.find = function(items, what) {
    if (what < items[0]) {
        return 0;
    }
    for (var i = 0, ii = items.length - 1; i < ii; i++) {
        if (what >= items[i] && what < items[i + 1]) {
            return i;
        }
    }
    return items.length - 1;
};

exports.Events = function() {
    var topics = {};

    // @todo introduce setting topics with arguments and logging/exception
    // on un-fired event

    function event(id) {
        var callbacks, method,
                topic = id && topics[ id ];
        if (!topic) {
            callbacks = jQuery.Callbacks();
            topic = {
                publish: callbacks.fire,
                subscribe: callbacks.add,
                unsubscribe: callbacks.remove
            };
            if (id) {
                topics[ id ] = topic;
            }
        }
        return topic;
    }

    return {
        event: event
    };
};

exports.pickInterval = function(range) {
    var intervals = [
        moment.duration(1, 'seconds').asMilliseconds(),
        moment.duration(1, 'minutes').asMilliseconds(),
        moment.duration(1, 'hours').asMilliseconds(),
        moment.duration(1, 'days').asMilliseconds(),
        moment.duration(1, 'weeks').asMilliseconds(),
        moment.duration(1, 'months').asMilliseconds(),
        moment.duration(1, 'years').asMilliseconds()
    ];
    return intervals[Math.max(exports.find(intervals, range.width()) - 1, 0)];
};

exports.getTime = getTime;

/**
 * Read an iso duration into a moment.js object.
 * @param {string} duration
 * @returns {object} with moment.js info
 */
exports.isoDurationToMoment = function(duration) {
    if (duration.charAt(0) != 'P') {
        throw new Error('expected P as starting duration : ' + duration);
    }
    var pattern = /(\d+)(\w)/g;
    var date = null, time = null, values = {};
    duration = duration.substring(1);
    if (duration.indexOf('T') >= 0) {
        var parts = duration.split('T');
        date = parts[0];
        time = parts[1];
    } else {
        date = duration;
    }
    var mapping = {
        'Y': 'years',
        'M': 'months',
        'W': 'weeks',
        'D': 'days',
        'H': 'hours',
        'm': 'minutes',
        'S': 'seconds'
    };
    function parse(chunk, time) {
        function read(amount, part) {
            if (time && part == 'M') {
                part = 'm';
            }
            var mappedTo = mapping[part];
            if (typeof mappedTo == 'undefined') {
                throw Error('unknown duration specifier : ' + part);
            }
            values[mappedTo] = parseFloat(amount);
        }
        var next;
        while ((next = pattern.exec(chunk)) !== null) {
            read(next[1], next[2]);
        }
    }
    if (date !== null) {
        parse(date, false);
    }
    if (time !== null) {
        parse(time, true);
    }
    return values;
};

/**
 * Get a function for the provided duration that computes a new timestamp based on a
 * provided date and optional multiplier (negative for reverse).
 * @param {string} iso duration
 * @returns {function} offsetter(timestamp, multiplier=1)
 */
exports.createOffsetter = function(intervalOrDuration) {
    var duration = typeof intervalOrDuration === 'string' ? intervalOrDuration: intervalOrDuration.duration;
    var values = exports.isoDurationToMoment(duration);
    // as of writing, moment assumes y=365d and m=30d resulting in slow
    // day of month shifts that break ticks from matching
    // so we take care of this using a more accurate approach
    // ** the current approach breaks down if the day of month is greater than
    // 28 and day of month will no longer be retained (will shift)
    if ('years' in values || 'months' in values) {
        var years = values.years;
        var months = values.months;
        values.years = 0;
        values.months = 0;
        var millis = moment.duration(values).asMilliseconds();
        return function(ts, mult) {
            mult = mult || 1;
            var d = new Date(ts);
            /*jshint eqnull:true */
            var y = d.getUTCFullYear();
            if (years != null) {
                y += mult * years;
            }
            var m = d.getUTCMonth();
            if (months != null) {
                m += mult * months;
            }
            d.setUTCFullYear(y, m);
            return d.getTime() + (mult * millis);
        };
    } else {
        var offset = moment.duration(values).asMilliseconds();
        return function(ts, mult) {
            mult = mult || 1;
            return ts + (mult * offset);
        };
    }
};

},{"vis/node_modules/moment":63}],12:[function(require,module,exports){
//'use strict';
exports.SLDStyleConverter = function() {
    return {
        generateStyle: function(style, layerName, asString) {
            var config = this.convertJSON(style, layerName);
            if (!this.context) {
                this.context = new owsjs.Jsonix.Context([owsjs.mappings.XLink_1_0, owsjs.mappings.Filter_1_0_0, owsjs.mappings.GML_2_1_2, owsjs.mappings.SLD_1_0_0], {
                    namespacePrefixes: {
                        'http://www.w3.org/1999/xlink': 'xlink',
                        'http://www.opengis.net/sld': 'sld',
                        'http://www.opengis.net/ogc': 'ogc'
                    }
                });
                this.marshaller = this.context.createMarshaller();
            }
            if (asString === true) {
                return this.marshaller.marshalString(config);
            } else {
                return this.marshaller.marshalDocument(config);
            }
        },
        createFill: function(style, styleRule) {
            return {
                cssParameter: [{
                    name: 'fill',
                    content: [(styleRule && styleRule.style.symbol.fillColor) ? styleRule.style.symbol.fillColor : style.symbol.fillColor]
                }, {
                    name: 'fill-opacity',
                    content: [String(styleRule ? (styleRule.style.symbol.fillOpacity || 100) / 100 : (style.symbol.fillOpacity || 100) / 100)]
                }]
            };
        },
        createStroke: function(style, styleRule) {
            var dashArray;
            if (style.stroke.strokeStyle === 'dashed') {
                dashArray = '5';
            } else if (style.stroke.strokeStyle ==='dotted') {
                dashArray = '1 2';
            }
            return {
                cssParameter: [{
                    name: 'stroke',
                    content: [(styleRule && styleRule.style.stroke.strokeColor) ? styleRule.style.stroke.strokeColor : style.stroke.strokeColor]
                }, {
                    name: 'stroke-width',
                    content: style.stroke.strokeWidth ? [String(style.stroke.strokeWidth)] : undefined
                }, {
                    name: 'stroke-opacity',
                    content: style.stroke.strokeOpacity ? [String(style.stroke.strokeOpacity / 100)] : undefined
                }, {
                    name: 'stroke-dasharray',
                    content: dashArray ? [dashArray] : undefined
                }]
            };
        },
        createPolygonSymbolizer: function(style, styleRule) {
            var fill = this.createFill(style, styleRule);
            var stroke = this.createStroke(style);
            var polygon = {
                name: {
                    localPart: 'PolygonSymbolizer',
                    namespaceURI: "http://www.opengis.net/sld"
                },
                value: {
                    fill: fill,
                    stroke: stroke
                }
            };
            return polygon;
        },
        createPointSymbolizer: function(style, styleRule) {
            var fill = this.createFill(style, styleRule); 
            var stroke = this.createStroke(style);
            var graphicOrMark;
            if (style.symbol && style.symbol.graphic) {
                var a = document.createElement("a");
                // @todo appending icon commons attributes should go elsewhere
                a.href = style.symbol.graphic + '?' +
                    'fill=' + encodeURIComponent((styleRule && styleRule.style.symbol.fillColor) ? styleRule.style.symbol.fillColor : style.symbol.fillColor) +
                    "&stroke=" + encodeURIComponent(style.stroke.strokeColor);
                graphicOrMark = [{
                        TYPE_NAME: "SLD_1_0_0.ExternalGraphic",
                        fill: fill,
                        stroke: stroke,
                        format: "image/svg+xml",
                        onlineResource: {
                            href: a.href
                        }
                    }];
            } else {
                graphicOrMark = [{
                        TYPE_NAME: "SLD_1_0_0.Mark",
                        fill: fill,
                        stroke: stroke,
                        wellKnownName: style.symbol && style.symbol.shape || 'circle'
                    }];
            }
            var opacity = 1;
            if (style.symbol && angular.isDefined(style.symbol.fillOpacity)) {
                opacity = Math.max(0.01, style.symbol.fillOpacity) / 100;
            }
            return {
                name: {
                    localPart: 'PointSymbolizer',
                    namespaceURI: "http://www.opengis.net/sld"
                },
                value: {
                    graphic: {
                        externalGraphicOrMark: graphicOrMark,
                        opacity: {
                            content: [String(opacity)]
                        },
                        size: {
                            content: [String(styleRule && styleRule.style.symbol && styleRule.style.symbol.size ||
                                  style.symbol && style.symbol.size || 10)]
                        },
                        rotation: style.symbol && style.symbol.rotationAttribute ? {
                            content: [style.symbol.rotationUnits === 'degrees' ? {
                                name: {
                                    localPart: "PropertyName",
                                    namespaceURI: "http://www.opengis.net/ogc"
                                },
                                value: {
                                    content: [style.symbol.rotationAttribute]
                                }
                            } : {
                                name: {
                                    localPart: "Div",
                                    namespaceURI: "http://www.opengis.net/ogc"
                                },
                                value: {
                                    expression: [{
                                        name: {
                                            localPart: "PropertyName",
                                            namespaceURI: "http://www.opengis.net/ogc"
                                        },
                                        value: {
                                            content: [style.symbol.rotationAttribute]
                                        }
                                    }, {
                                        name: {
                                            localPart: "Div",
                                            namespaceURI: "http://www.opengis.net/ogc"
                                        },
                                        value: {
                                            expression: [{
                                                name: {
                                                    localPart: "Function",
                                                    namespaceURI: "http://www.opengis.net/ogc"
                                                },
                                                value: {
                                                    name: "pi"
                                                }
                                            }, {
                                                name: {
                                                    localPart: "Literal",
                                                    namespaceURI: "http://www.opengis.net/ogc"
                                                },
                                                value: {
                                                    content: ["360"]
                                                }
                                            }]
                                        }
                                    }]
                                }
                            }]
                        } : undefined
                    }
                }
            };
        },
        createLineSymbolizer: function(style, styleRule) {
            return {
                name: {
                    localPart: 'LineSymbolizer',
                    namespaceURI: "http://www.opengis.net/sld"
                },
                value: {
                    stroke: this.createStroke(style, styleRule)
                }
            };
        },
        createTextSymbolizer: function(style) {
            var fontFamily;
            var styleFontFamily = style.label.fontFamily.toLowerCase();
            if (styleFontFamily === 'serif') {
                fontFamily  = 'Serif';
            } else if (styleFontFamily === 'sans-serif') {
                fontFamily = 'SansSerif';
            } else if (styleFontFamily === 'cursive') {
                fontFamily = 'Comic Sans MS';
            } else if (styleFontFamily === 'monospace') {
                fontFamily = 'Courier New';
            }
            return {
                name: {
                    localPart: 'TextSymbolizer',
                    namespaceURI: "http://www.opengis.net/sld"
                },
                value: {
                    fill: {
                        cssParameter: [{
                                name: 'fill',
                                content: [style.label.fillColor]
                            }]
                    },
                    halo: {
                        fill: {
                            cssParameter: [{
                                name: 'fill',
                                content: ['#FFFFFF']
                            }]
                        },
                        radius: {
                            content: ['1']
                        }
                    },
                    labelPlacement: {
                        linePlacement: {}
                    },
                    font: {
                        cssParameter: [{
                                name: 'font-family',
                                content: fontFamily ? [fontFamily]: undefined
                            }, {
                                name: 'font-size',
                                content: [String(style.label.fontSize)]
                            }, {
                                name: 'font-style',
                                content: [style.label.fontStyle]
                            }, {
                                name: 'font-weight',
                                content: [style.label.fontWeight]
                            }]
                    },
                    label: {
                        content: [{
                                name: {
                                    localPart: "PropertyName",
                                    namespaceURI: "http://www.opengis.net/ogc"
                                },
                                value: {
                                    content: [style.label.attribute]
                                }
                            }]
                    },
                    vendorOption: [{
                        name: 'maxDisplacement',
                        content: '40'
                    }, {
                        name: 'autoWrap',
                        content: '40'
                    }, {
                        name: 'spaceAround',
                        content: '0'
                    }, {
                        name: 'followLine',
                        content: 'false'
                    }, {
                        name: 'group',
                        content: 'yes'
                    }, {
                        name: 'goodnessOfFit',
                        content: '0.2'
                    }, {
                        name: 'conflictResolution',
                        content: 'true'
                    }]
                }
            };
        },
        convertJSON: function(style, layerName) {
            var result = {
                name: {
                    namespaceURI: 'http://www.opengis.net/sld',
                    localPart: 'StyledLayerDescriptor'
                }
            };
            result.value = {
                version: "1.0.0",
                namedLayerOrUserLayer: [{
                        TYPE_NAME: "SLD_1_0_0.NamedLayer",
                        name: layerName,
                        namedStyleOrUserStyle: [{
                                TYPE_NAME: "SLD_1_0_0.UserStyle",
                                featureTypeStyle: [{
                                        rule: []
                                    }]
                            }]
                    }]
            };
            var rule, ruleContainer = result.value.namedLayerOrUserLayer[0].namedStyleOrUserStyle[0].featureTypeStyle[0].rule;
            if (style.rules) {
                for (var i = 0, ii = style.rules.length; i < ii; ++i) {
                    var styleRule = style.rules[i];
                    var filter;
                    if (styleRule.value) {
                        filter = {
                            comparisonOps: {
                                name: {
                                    namespaceURI: "http://www.opengis.net/ogc",
                                    localPart: "PropertyIsEqualTo"
                                },
                                value: {
                                    expression: [{
                                            name: {
                                                namespaceURI: "http://www.opengis.net/ogc",
                                                localPart: "PropertyName"
                                            },
                                            value: {
                                                content: [style.classify.attribute]
                                            }
                                        }, {
                                            name: {
                                                namespaceURI: "http://www.opengis.net/ogc",
                                                localPart: "Literal"
                                            },
                                            value: {
                                                content: [String(styleRule.value)]
                                            }
                                        }]
                                }
                            }
                        };
                    } else if (styleRule.range) {
                        filter = {
                            comparisonOps: {
                                name: {
                                    namespaceURI: "http://www.opengis.net/ogc",
                                    localPart: "PropertyIsBetween"
                                },
                                value: {
                                    expression: {
                                        name: {
                                            namespaceURI: "http://www.opengis.net/ogc",
                                            localPart: "PropertyName"
                                        },
                                        value: {
                                            content: [style.classify.attribute]
                                        }
                                    },
                                    lowerBoundary: {
                                        expression: {
                                            name: {
                                                namespaceURI: "http://www.opengis.net/ogc",
                                                localPart: "Literal"
                                            },
                                            value: {
                                                content: [String(styleRule.range.min)]
                                            }
                                        }
                                    },
                                    upperBoundary: {
                                        expression: {
                                            name: {
                                                namespaceURI: "http://www.opengis.net/ogc",
                                                localPart: "Literal"
                                            },
                                            value: {
                                                content: [String(styleRule.range.max)]
                                            }
                                        }
                                    }
                                }
                            }
                        };
                    }
                    rule = {
                        title: styleRule.name,
                        name: styleRule.name,
                        filter: filter,
                        symbolizer: []
                    };
                    if (style.geomType === "point") {
                        rule.symbolizer.push(this.createPointSymbolizer(style, styleRule));
                    } else if (style.geomType === "line") {
                        rule.symbolizer.push(this.createLineSymbolizer(style, styleRule));
                    } else if (style.geomType === "polygon") {
                        rule.symbolizer.push(this.createPolygonSymbolizer(style, styleRule));
                    }
                    if (style.label && style.label.attribute !== null) {
                        rule.symbolizer.push(this.createTextSymbolizer(style));
                    }
                    ruleContainer.push(rule);
                }
            } else {
                // single rule, multiple symbolizers
                rule = {
                    symbolizer: []
                };
                ruleContainer.push(rule);
                if (style.geomType === 'point') {
                    rule.symbolizer.push(this.createPointSymbolizer(style));
                } else if (style.geomType === 'line') {
                    rule.symbolizer.push(this.createLineSymbolizer(style));
                } else if (style.geomType === 'polygon') {
                    rule.symbolizer.push(this.createPolygonSymbolizer(style));
                }
                if (style.label && style.label.attribute !== null) {
                    rule.symbolizer.push(this.createTextSymbolizer(style));
                }
            }
            return result;
        }
    };
};

},{}],13:[function(require,module,exports){
exports.StyleComplete = function() {
    return {
        isComplete: function(style) {
            if (style === undefined) {
                return false;
            }

            if (style.classify) {
                if (style.classify.method === "unique") {
                    if (style.classify.attribute === null || style.classify.maxClasses === null || !style.classify.colorPalette) {
                        return false;
                    }
                } else if (style.classify.method === null || style.classify.attribute === null || style.classify.colorRamp === null || style.rules.length === 0) {
                    return false;
                }
            }
            return true;
        }
    };
};

},{}],14:[function(require,module,exports){
//'use strict';

exports.WFSDescribeFeatureType = function() {

    this.parseResult = function(xml) {
        if (!this.context) {
            this.context = new owsjs.Jsonix.Context([
                owsjs.mappings.XSD_1_0
            ]);
            this.unmarshaller = this.context.createUnmarshaller();
        }
        var schema = this.unmarshaller.unmarshalString(xml).value;
        var featureNS = schema.targetNamespace;
        var element = schema.complexType[0].complexContent.extension.sequence.element;
        var fields = [];
        var geometryType, timeAttr;
        for (var i=0, ii=element.length; i<ii; ++i) {
            var el = element[i];
            if (el.type.namespaceURI === 'http://www.opengis.net/gml') {
                var lp = el.type.localPart;
                if (lp.indexOf('Polygon') !== -1) {
                    geometryType = 'polygon';
                } else if (lp.indexOf('LineString') !== -1) {
                    geometryType = 'line';
                } else if (lp.indexOf('Point') !== -1) {
                    geometryType = 'point';
                }
            } else if (el.type.localPart === 'dateTime') {
                if (timeAttr === undefined) {
                    timeAttr = el.name;
                } else {
                    timeAttr = null;
                }
            }
            fields.push({name: el.name, type: el.type.localPart, typeNS: el.type.namespaceURI});
        }
        return {
            timeAttribute: timeAttr,
            featureNS: featureNS,
            geomType: geometryType,
            attributes: fields
        };
    };

};

},{}],15:[function(require,module,exports){
//'use strict';

exports.WPSClassify = function() {

    this.parseResult = function(xml) {
        var doc = new DOMParser().parseFromString(xml, 'application/xml');
        var exceptions = doc.getElementsByTagNameNS('http://www.opengis.net/ows/1.1', 'ExceptionText');
        if (exceptions.length ===0) {
            var classes = doc.getElementsByTagName('Class');
            var rules = [];
            for (var i=0, ii=classes.length; i<ii; ++i) {
                var min = classes[i].getAttribute('lowerBound');
                var max = classes[i].getAttribute('upperBound');
                rules.push({
                    name: min + '-' + max,
                    range: {
                        min: min,
                        max: max
                    }
                });
            }
            return {
                success: true,
                rules: rules
            };
        } else {
            return {
                success: false,
                msg: exceptions[0].textContent
            };
        }
    };

    this.createContext = function() {
        this.context = new owsjs.Jsonix.Context([
            owsjs.mappings.XLink_1_0,
            owsjs.mappings.OWS_1_1_0,
            owsjs.mappings.Filter_1_1_0,
            owsjs.mappings.OWS_1_0_0,
            owsjs.mappings.SMIL_2_0,
            owsjs.mappings.SMIL_2_0_Language,
            owsjs.mappings.GML_3_1_1,
            owsjs.mappings.WFS_1_1_0,
            owsjs.mappings.WPS_1_0_0
        ], {
            namespacePrefixes: {
                'http://www.w3.org/1999/xlink': 'xlink',
                'http://www.opengis.net/wps/1.0.0': 'wps',
                'http://www.opengis.net/ows/1.1': 'ows',
                'http://www.opengis.net/wfs': 'wfs'
            }
        });
        this.marshaller = this.context.createMarshaller();
    };

    this.getUniqueValues = function(data, asString) {
        if (!this.context) {
            this.createContext();
        }
        var config = this.generateMainConfig('gs:Unique', "application/json", data);
        config.value.dataInputs.input.push({
            identifier: {
                value: 'attribute'
            },
            data: {
                literalData: {
                    value: data.attribute
                }
            }
        });
        if (asString === true) {
            return this.marshaller.marshalString(config);
        } else {
            return this.marshaller.marshalDocument(config);
        }
    };

    this.generateMainConfig = function(processId, mimeType, data) {
        return {
            name: {
                localPart: "Execute",
                namespaceURI: "http://www.opengis.net/wps/1.0.0"
            },
            value: {
                service: "WPS",
                version: "1.0.0",
                identifier: {
                    value: processId
                },
                responseForm: {
                    rawDataOutput: {
                        identifier: {
                            value: "results"
                        },
                        mimeType: mimeType
                    }
                },
                dataInputs: {
                    input: [{
                            identifier: {
                                value: 'features'
                            },
                            reference: {
                                method: 'POST',
                                mimeType: 'text/xml',
                                href: 'http://geoserver/wfs',
                                body: {
                                    content: [{
                                            name: {
                                                namespaceURI: "http://www.opengis.net/wfs",
                                                localPart: "GetFeature"
                                            },
                                            value: {
                                                outputFormat: "GML2",
                                                service: "WFS",
                                                version: "1.1.0",
                                                query: [{
                                                        typeName: [{ns: data.featureNS, lp: data.typeName.split(':')[1] || data.typeName, p: data.featurePrefix}]
                                                    }]
                                            }
                                        }]
                                }
                            }
                        }
                    ]
                }
            }
        };
    };

    this.classifyVector = function(data, asString) {
        if (!this.context) {
            this.createContext();
        }
        var config = this.generateMainConfig('vec:FeatureClassStats', undefined, data);
        config.value.dataInputs.input.push({
            identifier: {
                value: 'attribute'
            },
            data: {
                literalData: {
                    value: data.attribute
                }
            }
        }, {
            identifier: {
                value: 'classes'
            },
            data: {
                literalData: {
                    value: String(data.numClasses)
                }
            }
        }, {
            identifier: {
                value: 'method'
            },
            data: {
                literalData: {
                    value: data.method
                }
            }
        }, {
            identifier: {
                value: 'stats'
            },
            data: {
                literalData: {
                    value: 'mean' /* TODO currently we need to send at least 1 stats input */
                }
            }
        });
        if (asString === true) {
            return this.marshaller.marshalString(config);
        } else {
            return this.marshaller.marshalDocument(config);
        }
    };
};

},{}],16:[function(require,module,exports){
exports.MapConfigTransformer = function(data) {
    var layers = [], i, ii, mode = 'instant';
    // look for playback mode in tools
    if (data.tools) {
        for (i=0, ii=data.tools.length; i<ii; ++i) {
            var tool = data.tools[i];
            if (tool.ptype === "gxp_playback" && tool.outputConfig) {
                if (tool.outputConfig.playbackMode === 'cumulative') {
                    mode = 'cumulative';
                }
                // TODO other modes
            }
        }
    }
    for (i=0, ii=data.map.layers.length; i<ii; ++i) {
         var layer = data.map.layers[i];
         // TODO for the editor we also need the invisible layers
         if (layer.visibility === true) {
             var source = data.sources[layer.source];
             var layerConfig = {
                 visibility: layer.visibility,
                 group: layer.group
             };
             if (source.ptype === "gxp_mapquestsource") {
                 layerConfig.type = 'MapQuest';
                 layerConfig.layer = layer.name === 'naip' ? 'sat' : 'osm';
                 layerConfig.title = layer.title;
                 layers.push(layerConfig);
             } else if (source.ptype === "gxp_mapboxsource") {
                 layerConfig.type = 'MapBox';
                 layerConfig.name = layer.name;
                 layerConfig.title = layer.title;
                 layers.push(layerConfig);
             } else if (source.ptype === "gx_olsource" || source.ptype === "gxp_wmscsource") {
                 layerConfig.type = (source.ptype === "gx_olsource") ? layer.type.replace('OpenLayers.Layer.', '') : "WMS";
                 if (layerConfig.type === 'OSM') {
                     if (layerConfig.args && layerConfig.args[0] === 'Humanitarian OpenStreetMap') {
                         layerConfig.type = 'HOT';
                     }
                     layerConfig.title = layer.title;
                 } else if (layerConfig.type === 'WMS') {
                     var params;
                     if (source.ptype === "gx_olsource") {
                         params = layer.args[2] || {};
                         for (var key in params) {
                             if (params[key].constructor === Array) {
                                 params[key.toUpperCase()] = params[key].join(',');
                                 delete params[key];
                             }
                         }
                         layerConfig.url = layer.args[1];
                     } else {
                         params = {
                             LAYERS: layer.name,
                             STYLES: layer.styles,
                             TILED: 'TRUE',
                             FORMAT: layer.format || 'image/png',
                             TRANSPARENT: layer.transparent || 'TRUE'
                         };
                         if (layer.tiled === false) {
                             layerConfig.singleTile = true;
                         }
                         layerConfig.id = layer.name;
                         layerConfig.name = layer.name;
                         layerConfig.title = layer.titleAlias || layer.title;
                         layerConfig.maskings = layer.maskings;
                         // TODO not sure if this is the best place to do this?
                         layerConfig.url = source.url.replace('http://mapstory.org/geoserver/', '/geoserver/');
                     }
                     layerConfig.params = params;
                     layerConfig.params.VERSION = '1.1.1';
                     if (layer.capability) {
                         layerConfig.latlonBBOX = layer.capability.llbbox;
                         // TODO require dependency explicitly?
                         var times = storytools.core.time.maps.readCapabilitiesTimeDimensions(layer.capability, true);
                         if (times !== undefined) {
                             layerConfig.times = times;
                         }
                         // info for custom tileGrid
                         if (layer.capability.tileSets) {
                             for (var srs in layer.capability.tileSets[0].bbox) {
                                 var bbox = layer.capability.tileSets[0].bbox[srs].bbox;
                                 layerConfig.bbox = bbox;
                             }
                             layerConfig.resolutions = layer.capability.tileSets[0].resolutions;
                         }
                     }
                 }
                 layers.push(layerConfig);
             } else if (window.console) {
                 window.console.warn('Unknown source type in map config: ' + source.ptype);
             }
         }
     }
     return {
         id: data.id,
         playbackMode: mode,
         map: {
             center: data.map.center,
             projection: data.map.projection,
             zoom: data.map.zoom,
             layers: layers
         }
     };
};

},{}],17:[function(require,module,exports){
(function() {
  'use strict';

  var module = angular.module('storytools.core.ogc', [
  ]);

  // @todo - provisional default story pins style
  var defaultStyle = [new ol.style.Style({
    fill: new ol.style.Fill({color: 'rgba(255, 0, 0, 0.1)'}),
    stroke: new ol.style.Stroke({color: 'red', width: 1}),
    image: new ol.style.Circle({
      radius: 10,
      fill: new ol.style.Fill({color: 'rgba(255, 0, 0, 0.1)'}),
      stroke: new ol.style.Stroke({color: 'red', width: 1})
    })
  })];

  function StoryMap(data) {
    ol.Object.call(this, data);
    this.map_ = new ol.Map({target: data.target, pixelRatio: 1});
    this.overlay = new ol.FeatureOverlay({
      map: this.map_,
      style: defaultStyle
    });
    this.title = "Default Mapstory";
    this.abstract = "No Information Supplied.";
    this.owner = "";
    this.mode = "instant";
    this.returnToExtent = data.returnToExtent || false;
    this.center = [0,0];
    this.zoom = 2;
    this.storyLayers_ = new ol.Collection();
    this.animationDuration_ = data.animationDuration || 500;
    this.storyBoxesLayer = new StoryLayer({
      timeAttribute: 'start_time',
      endTimeAttribute: 'end_time',
      layer: new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: defaultStyle
      })
    });
    this.storyPinsLayer = new StoryLayer({
      timeAttribute: 'start_time',
      endTimeAttribute: 'end_time',
      layer: new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: defaultStyle
      })
    });
    this.addStoryPinsLayer();
    this.addStoryBoxesLayer();
  }

  StoryMap.prototype = Object.create(ol.Object.prototype);
  StoryMap.prototype.constructor = StoryMap;

  StoryMap.prototype.addStoryPinsLayer = function() {
    this.map_.addLayer(this.storyPinsLayer.getLayer());
  };

  StoryMap.prototype.addStoryBoxesLayer = function() {
    this.map_.addLayer(this.storyBoxesLayer.getLayer());
  };

  StoryMap.prototype.setStoryOwner = function(storyOwner) {
    this.owner =  storyOwner;
  };

  StoryMap.prototype.getStoryOwner = function() {
    return this.owner;
  };

  StoryMap.prototype.getCenter = function() {
    return this.center;
  };

  StoryMap.prototype.getZoom = function() {
    return this.zoom;
  };

  StoryMap.prototype.setStoryTitle = function(storyTitle) {
    this.title =  storyTitle;
  };

  StoryMap.prototype.setCenter = function(center) {
    this.center =  center;
  };

  StoryMap.prototype.setZoom = function(zoom) {
    this.zoom =  zoom;
  };

  StoryMap.prototype.setMode = function(playbackMode) {
    this.mode =  playbackMode;
  };

  StoryMap.prototype.setStoryAbstract = function(storyAbstract) {
    this.abstract =  storyAbstract;
  };


  StoryMap.prototype.getStoryTitle = function() {
    return this.title;
  };

  StoryMap.prototype.getStoryAbstract = function() {
    return this.abstract;
  };

  StoryMap.prototype.setBaseLayer = function(baseLayer) {
    this.set('baselayer', baseLayer);
    this.map_.getLayers().forEach(function(lyr) {
      if (lyr.get('group') === 'background') {
        this.map_.removeLayer(lyr);
      }
    }, this);
    this.map_.getLayers().insertAt(0, this.get('baselayer'));
  };

  StoryMap.prototype.addStoryLayer = function(storyLayer) {
    storyLayer.storyMap_ = this;
    this.storyLayers_.push(storyLayer);
    // keep pins layer on top
    var idx = this.map_.getLayers().getLength(), me = this;
    this.map_.getLayers().forEach(function(sl) {
      if (sl === me.storyPinsLayer) {
        idx -= 1;
      }
    });
    this.map_.getLayers().insertAt(
          idx,
          storyLayer.getLayer()
    );
  };

  StoryMap.prototype.getStoryLayers = function() {
    return this.storyLayers_;
  };

  StoryMap.prototype.getMap = function() {
    return this.map_;
  };

  StoryMap.prototype.clear = function() {
    this.map_.getLayers().clear();
    this.storyLayers_.clear();
    this.addStoryPinsLayer();
  };

  StoryMap.prototype.animatePanAndBounce = function(center, zoom){

    var duration = 2000;
    var start = +new Date();

    var view = this.map_.getView();

    if(view.getCenter() != center){

      var pan = ol.animation.pan({
        duration: this.animationDuration_,
        source: view.getCenter(),
        start: start
      });


      var bounce = ol.animation.bounce({
        duration: duration,
        resolution: 2 * view.getResolution(),
        start: start
      });

      this.map_.beforeRender(pan, bounce);

      view.setCenter(center);
      view.setZoom(zoom);
    }
  };

  StoryMap.prototype.animateCenterAndZoom = function(center, zoom) {
    var view = this.map_.getView();
    if (view.getCenter() !== center || view.getZoom() !== zoom) {
      this.map_.beforeRender(ol.animation.pan({
        duration: this.animationDuration_,
        source: view.getCenter()
      }));
      view.setCenter(center);
      this.map_.beforeRender(ol.animation.zoom({
        resolution: view.getResolution(),
        duration: this.animationDuration_
      }));
      view.setZoom(zoom);
    }
  };

  StoryMap.prototype.setAllowPan = function(allowPan) {
    this.map_.getInteractions().forEach(function(i) {
      if (i instanceof ol.interaction.KeyboardPan ||
            i instanceof ol.interaction.DragPan) {
        i.setActive(allowPan);
      }
    });
  };

  StoryMap.prototype.setAllowZoom = function(allowZoom) {
    var zoomCtrl;
    this.map_.getControls().forEach(function(c) {
      if (c instanceof ol.control.Zoom) {
        zoomCtrl = c;
      }
    });
    if (!allowZoom) {
      this.map_.removeControl(zoomCtrl);
    } else {
      this.map_.addControl(new ol.control.Zoom());
    }
    this.map_.getInteractions().forEach(function(i) {
      if (i instanceof ol.interaction.DoubleClickZoom ||
            i instanceof ol.interaction.PinchZoom ||
            i instanceof ol.interaction.DragZoom ||
            i instanceof ol.interaction.MouseWheelZoom) {
        i.setActive(allowZoom);
      }
    });
  };

  module.constant('StoryMap', StoryMap);

  function EditableStoryMap(data) {
    StoryMap.call(this, data);
  }

  EditableStoryMap.prototype = Object.create(StoryMap.prototype);
  EditableStoryMap.prototype.constructor = EditableStoryMap;

  module.constant('EditableStoryMap', EditableStoryMap);

  EditableStoryMap.prototype.getState = function() {
    var config = {};
    config.map = {
      center: this.map_.getView().getCenter(),
      projection: this.map_.getView().getProjection().getCode(),
      zoom: this.map_.getView().getZoom(),
      layers: []
    };
    var mapId = this.get('id');
    if (mapId >= 0) {
      config.id = mapId;
    }
    var baseLayer = this.get('baselayer');
    if (baseLayer) {
      var baseLayerState = this.get('baselayer').get('state');
      baseLayerState.group = 'background';
      baseLayerState.visibility = true;
      config.map.layers.push(baseLayerState);
    }
    this.storyLayers_.forEach(function(storyLayer) {
      config.map.layers.push(storyLayer.getState());
    });
    return config;
  };

  EditableStoryMap.prototype.removeStoryLayer = function(storyLayer) {
    this.storyLayers_.remove(storyLayer);
    this.map_.removeLayer(storyLayer.getLayer());
  };

  function StoryLayer(data) {
    if (data.times && storytools.core.time.utils.isRangeLike(data.times)) {
      data.times = new storytools.core.time.utils.Interval(data.times);
    }
    ol.Object.call(this, data);
    var layer;
    if (this.get('type') === 'VECTOR') {
      layer = new ol.layer.Vector({source: new ol.source.Vector()});
    } else if (this.get('type') === 'HEATMAP') {
      layer = new ol.layer.Heatmap({
        radius: data.style.radius,
        opacity: data.style.opacity,
        source: new ol.source.Vector()
      });
    } else if (this.get('type') === 'WMS') {
      var config = {
        useOldAsInterimTiles: true
      };
      if (this.get('singleTile') === true) {
        layer = new ol.layer.Image(config);
      } else {
        layer = new ol.layer.Tile(config);
      }
    } else {
      layer = data.layer;
    }
    this.layer_ = layer;
  }

  StoryLayer.prototype = Object.create(ol.Object.prototype);
  StoryLayer.prototype.constructor = StoryLayer;

  StoryLayer.prototype.getStoryMap = function() {
    return this.storyMap_;
  };

  StoryLayer.prototype.setWMSSource = function() {
    var layer = this.getLayer();
    var name = this.get('name');
    var times = this.get('times');
    var singleTile = this.get('singleTile');
    var params = this.get('params') || {
      'LAYERS': name,
      'VERSION': '1.1.0',
      'TILED': true
    };
    if (times) {
      params.TIME = new Date(times.start || times[0]).toISOString();
    }
    if (singleTile) {
      layer.setSource(new ol.source.ImageWMS({
        params: params,
        url: this.get('url'),
        serverType: 'geoserver'
      }));
    } else {
      var tileGrid, resolutions = this.get('resolutions'),
            bbox = this.get('bbox');
      if (resolutions && bbox) {
        tileGrid = new ol.tilegrid.TileGrid({
          extent: bbox,
          resolutions: resolutions
        });
      }
      // @todo use urls for subdomain loading
      layer.setSource(new ol.source.TileWMS({
        url: this.get('url'),
        params: params,
        tileGrid: tileGrid,
        serverType: 'geoserver'
      }));
    }
  };

  StoryLayer.prototype.getState = function() {
    var state = this.getProperties();
    delete state.features;
    return state;
  };

  StoryLayer.prototype.getLayer = function() {
    return this.layer_;
  };

  StoryLayer.prototype.setLayer = function(layer) {
    if (this.layer_ && this.storyMap_) {
      var map = this.storyMap_.map_;
      var idx = map.getLayers().getArray().indexOf(this.layer_);
      map.getLayers().setAt(idx, layer);
    }
    this.layer_ = layer;
  };

  module.constant('StoryLayer', StoryLayer);

  function EditableStoryLayer(data) {
    StoryLayer.call(this, data);
  }

  EditableStoryLayer.prototype = Object.create(StoryLayer.prototype);
  EditableStoryLayer.prototype.constructor = EditableStoryLayer;

  module.constant('EditableStoryLayer', EditableStoryLayer);

  module.service('stAnnotateLayer', function($http, $q) {
    return {
      loadCapabilities: function(storyLayer) {
        var request = 'GetCapabilities', service = 'WMS';
        // always use the virtual service for GetCapabilities
        var url = storyLayer.get('url');
        if (url === '/geoserver/wms') {
          var name = storyLayer.get('name');
          var parts = name.split(':');
          url = url.replace('/geoserver', '/geoserver/' + parts[0] + '/' + parts[1]);
        }
        url = url.replace('http:', '');

        return $http({
          method: 'GET',
          url: url,
          params: {
            'REQUEST': request,
            'SERVICE': service,
            'VERSION': '1.1.1',
            'TILED': true
          }
        }).success(function(data) {
          var context = new owsjs.Jsonix.Context([
            owsjs.mappings.WMSC_1_1_1
          ]);
          var unmarshaller = context.createUnmarshaller();
          var caps = unmarshaller.unmarshalString(data);
          var layer = caps.value.capability.layer;
          storyLayer.set('latlonBBOX', [
            parseFloat(layer.latLonBoundingBox.minx),
            parseFloat(layer.latLonBoundingBox.miny),
            parseFloat(layer.latLonBoundingBox.maxx),
            parseFloat(layer.latLonBoundingBox.maxy)
          ]);
          var vendorSpecificCapabilities = caps.value.capability.vendorSpecificCapabilities;
          var tileSets = (vendorSpecificCapabilities)? vendorSpecificCapabilities.tileSet: [];
          for (var i=0, ii=tileSets.length; i<ii; ++i) {
            if (tileSets[i].srs === 'EPSG:900913') {
              storyLayer.set('resolutions', tileSets[i].resolutions.split(' '));
              var bbox = tileSets[i].boundingBox;
              storyLayer.set('bbox', [
                parseFloat(bbox.minx),
                parseFloat(bbox.miny),
                parseFloat(bbox.maxx),
                parseFloat(bbox.maxy)
              ]);
              break;
            }
          }
          var found = storytools.core.time.maps.readCapabilitiesTimeDimensions(caps);
          var name = storyLayer.get('name');
          if (name in found) {
            storyLayer.set('times', found[name]);
          }
        });
      },
      describeFeatureType: function(storyLayer) {
        var me = this;
        var request = 'DescribeFeatureType', service = 'WFS';
        var id = storyLayer.get('id');
        return $http({
          method: 'GET',
          url: storyLayer.get('url').replace('http:', ''),
          params: {
            'SERVICE': service,
            'VERSION': '1.0.0',
            'REQUEST': request,
            'TYPENAME': id
          }
        }).success(function(data) {
          var parser = new storytools.edit.WFSDescribeFeatureType.WFSDescribeFeatureType();
          var layerInfo = parser.parseResult(data);
          if (layerInfo.timeAttribute) {
            storyLayer.set('timeAttribute', layerInfo.timeAttribute);
          } else if (storyLayer.get('timeEndpoint')) {
            me.getTimeAttribute(storyLayer);
          }
          var parts = id.split(':');
          storyLayer.set('typeName', id);
          storyLayer.set('featurePrefix', parts[0]);
          storyLayer.set('featureNS', layerInfo.featureNS);
          storyLayer.set('geomType', layerInfo.geomType);
          storyLayer.set('attributes', layerInfo.attributes);
        });
      },
      getTimeAttribute: function(storyLayer) {
        var me = this;
        return $http({
          method: 'GET',
          url: storyLayer.get('timeEndpoint')
        }).success(function(data) {
          storyLayer.set('timeAttribute', data.attribute);
          if (data.endAttribute) {
            storyLayer.set('endTimeAttribute', data.endAttribute);
          }
        });
      },
      getStyleName: function(storyLayer) {
        if (storyLayer.get('canStyleWMS')) {
          var me = this;
          return $http({
            method: 'GET',
            url: storyLayer.get('path') + 'rest/layers/' + storyLayer.get('id') + '.json'
          }).success(function(response) {
            storyLayer.set('styleName', response.layer.defaultStyle.name);
          });
        } else {
          return $q.when('');
        }
      },
      getFeatures: function(storyLayer, map) {
        var name = storyLayer.get('id');
        var wfsUrl = storyLayer.get('url') + '?service=WFS&version=1.1.0&request=GetFeature&typename=' +
              name + '&outputFormat=application/json' +
              '&srsName=' + map.getView().getProjection().getCode();
        return $http({
          method: 'GET',
          url: wfsUrl
        }).success(function(response) {
          var layer = storyLayer.getLayer();
          var features = new ol.format.GeoJSON().readFeatures(response);
          storyLayer.set('features', features);
        });
      }
    };
  });

  module.service('stBaseLayerBuilder', function() {
    return {
      buildLayer: function(data) {
        if (data.type === 'MapQuest') {
          return new ol.layer.Tile({
            state: data,
            title: data.title,
            group: 'background',
            source: new ol.source.MapQuest({layer: data.layer})
          });
        } else if (data.type === 'HOT') {
          return new ol.layer.Tile({
            state: data,
            title: data.title,
            group: 'background',
            source: new ol.source.OSM({
              attributions: [
                new ol.Attribution({
                  html: 'Tiles courtesy of <a href="//hot.openstreetmap.org/" target="_blank">Humanitarian OpenStreetMap Team</a>'
                }),
                ol.source.OSM.ATTRIBUTION
              ],
              crossOrigin: null,
              url: '//{a-c}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png'
            })
          });
        } else if (data.type === 'OSM') {
          return new ol.layer.Tile({
            state: data,
            title: data.title,
            group: 'background',
            source: new ol.source.OSM()
          });
        } else if (data.type === 'MapBox') {
          var layer = new ol.layer.Tile({state: data, title: data.title, group: 'background'});
          var name = data.name;
          var urls = [
            '//a.tiles.mapbox.com/v1/mapbox.',
            '//b.tiles.mapbox.com/v1/mapbox.',
            '//c.tiles.mapbox.com/v1/mapbox.',
            '//d.tiles.mapbox.com/v1/mapbox.'
          ];
          var tileUrlFunction = function(tileCoord, pixelRatio, projection) {
            var zxy = tileCoord;
            if (zxy[1] < 0 || zxy[2] < 0) {
              return "";
            }
            return urls[Math.round(Math.random()*3)] + name + '/' +
                  zxy[0].toString()+'/'+ zxy[1].toString() +'/'+
                  zxy[2].toString() +'.png';
          };
          layer.setSource(new ol.source.TileImage({
            crossOrigin: null,
            attributions: [
              new ol.Attribution({
                html: /^world/.test(name) ?
                      "<a href='//mapbox.com'>MapBox</a> | Some Data &copy; OSM CC-BY-SA | <a href='//mapbox.com/tos'>Terms of Service</a>" :
                      "<a href='//mapbox.com'>MapBox</a> | <a href='//mapbox.com/tos'>Terms of Service</a>"
              })
            ],
            tileGrid: new ol.tilegrid.TileGrid({
              origin: [-128 * 156543.03390625, -128 * 156543.03390625],
              resolutions: [
                156543.03390625, 78271.516953125, 39135.7584765625,
                19567.87923828125, 9783.939619140625, 4891.9698095703125,
                2445.9849047851562, 1222.9924523925781, 611.4962261962891,
                305.74811309814453, 152.87405654907226, 76.43702827453613,
                38.218514137268066, 19.109257068634033, 9.554628534317017,
                4.777314267158508, 2.388657133579254, 1.194328566789627,
                0.5971642833948135
              ]
            }),
            tileUrlFunction: tileUrlFunction
          }));
          return layer;
        } else if (data.type === 'WMS') {
          return new ol.layer.Tile({
            group: "background",
            source: new ol.source.TileWMS({
              url: data.url,
              params: data.params
            })
          });
        } else {
          throw new Error('no type for : ' + JSON.stringify(data));
        }
      }
    };
  });

  module.service('stEditableLayerBuilder', function($q, stAnnotateLayer, stBaseLayerBuilder) {
    return {
      buildEditableLayer: function(data, map) {
        var layer = new EditableStoryLayer(data);
        var deferred = $q.defer();
        var promises = [];
        // TODO add this back when we have WMS-C GetCaps
        var needsCaps = !(data.latlonBBOX && data.times/* && data.bbox && data.resolutions*/);
        if (needsCaps) {
          promises.push(stAnnotateLayer.loadCapabilities(layer));
        }
        var needsDFT = !data.attributes;
        if (needsDFT) {
          promises.push(stAnnotateLayer.describeFeatureType(layer));
        }
        if ((data.type === 'VECTOR' || data.type === 'HEATMAP') && !data.features) {
          promises.push(stAnnotateLayer.getFeatures(layer, map));
        } else {
          promises.push(stAnnotateLayer.getStyleName(layer));
        }
        $q.all(
              promises
        ).then(function() {
                // this needs to be done here when everything is resolved
                if (layer.get('features')) {
                  var times = layer.get('times');
                  if (times) {
                    var start = times.start || times[0];
                    storytools.core.time.maps.filterVectorLayer(layer, {start: start, end: start});
                  } else {
                    layer.getLayer().getSource().addFeatures(layer.get('features'));
                  }
                } else {
                  layer.setWMSSource();
                }
                deferred.resolve(layer);
              }, function() {
                deferred.reject(arguments);
              });
        return deferred.promise;
      }
    };
  });

  module.service('stLayerBuilder', function($q) {
    return {
      buildLayer: function(data, map) {
        var layer = new StoryLayer(data);
        var deferred = $q.defer();
        layer.setWMSSource();
        deferred.resolve(layer);
        return deferred.promise;
      }
    };
  });

  module.service('stStoryMapBaseBuilder', function(stBaseLayerBuilder) {
    return {
      defaultMap: function(storymap) {
        storymap.getMap().setView(new ol.View({center: [0,0], zoom: 3}));
        this.setBaseLayer(storymap, {
         title: 'World Light',
                    type: 'MapBox',
                    name: 'world-light'
        });
      },
      setBaseLayer: function(storymap, data) {
        var baseLayer = stBaseLayerBuilder.buildLayer(data);
        storymap.setBaseLayer(baseLayer);
      }
    };
  });

  module.service('stStoryMapBuilder', function(stLayerBuilder, stStoryMapBaseBuilder) {
    return {
      modifyStoryMap: function(storymap, data) {
        storymap.clear();
        var mapConfig = storytools.mapstory.MapConfigTransformer.MapConfigTransformer(data);
        if (mapConfig.id >= 0) {
          storymap.set('id', mapConfig.id);
          storymap.setMode(mapConfig.playbackMode);
          if (data.about !== undefined){
            storymap.setStoryTitle(data.about.title);
            storymap.setStoryAbstract(data.about.abstract);
            storymap.setStoryOwner(data.about.owner);
          }

          storymap.setCenter(mapConfig.map.center);
          storymap.setZoom(mapConfig.map.zoom);
        }
        for (var i = 0, ii = mapConfig.map.layers.length; i < ii; ++i) {
          var layerConfig = mapConfig.map.layers[i];
          if (layerConfig.group === 'background' && layerConfig.visibility === true) {
            stStoryMapBaseBuilder.setBaseLayer(storymap, layerConfig);
          } else {
            /*jshint loopfunc: true */
            stLayerBuilder.buildLayer(layerConfig, storymap.getMap()).then(function(sl) {
              // TODO insert at the correct index
              storymap.addStoryLayer(sl);
            });
          }
        }
        storymap.getMap().setView(new ol.View({
          center: mapConfig.map.center,
          zoom: mapConfig.map.zoom,
          minZoom: 3,
          maxZoom: 17
        }));
      }
    };
  });

  module.service('stEditableStoryMapBuilder', function(stStoryMapBaseBuilder, stEditableLayerBuilder) {
    return {
      modifyStoryLayer: function(storylayer, newType) {
        var data = storylayer.getProperties();
        var storymap = storylayer.getStoryMap();
        data.type = newType ? newType : ((data.type === 'WMS') ? 'VECTOR' : 'WMS');
        if (data.type === 'WMS') {
          delete data.features;
        }
        stEditableLayerBuilder.buildEditableLayer(data, storymap.getMap()).then(function(sl) {
          // sequence is important here, first change layer, then the type.
          storylayer.setLayer(sl.getLayer());
          storylayer.set('type', sl.get('type'));
        });
      },
      modifyStoryMap: function(storymap, data) {
        storymap.clear();
        var mapConfig = storytools.mapstory.MapConfigTransformer.MapConfigTransformer(data);
        if (mapConfig.id >= 0) {
          storymap.set('id', mapConfig.id);
          storymap.setMode(mapConfig.playbackMode);
          if (data.about !== undefined){
            storymap.setStoryTitle(data.about.title);
            storymap.setStoryAbstract(data.about.abstract);
            storymap.setStoryOwner(data.about.owner);
          }
        }
        for (var i = 0, ii = mapConfig.map.layers.length; i < ii; ++i) {
          var layerConfig = mapConfig.map.layers[i];
          if (layerConfig.group === 'background' && layerConfig.visibility === true) {
            stStoryMapBaseBuilder.setBaseLayer(storymap, layerConfig);
          } else {
            /*jshint loopfunc: true */
            stEditableLayerBuilder.buildEditableLayer(layerConfig, storymap.getMap()).then(function(sl) {
              // TODO insert at the correct index
              storymap.addStoryLayer(sl);
            });
          }
        }
        storymap.getMap().setView(new ol.View({
          center: mapConfig.map.center,
          zoom: mapConfig.map.zoom,
          projection: mapConfig.map.projection,
          minZoom: 3,
          maxZoom: 17
        }));
      }
    };
  });

})();

},{}],18:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.core.pins', [
    ]);

    var pins = storytools.core.maps.pins;

    function StoryPinLayerManager() {
        this.storyPins = [];
        this.map = null;
    }
    StoryPinLayerManager.prototype.pinsChanged = function(pins, action) {
        var i;
        if (action == 'delete') {
            for (i = 0; i < pins.length; i++) {
                var pin = pins[i];
                for (var j = 0, jj = this.storyPins.length; j < jj; j++) {
                    if (this.storyPins[j].id == pin.id) {
                        this.storyPins.splice(j, 1);
                        break;
                    }
                }
            }
        } else if (action == 'add') {
            for (i = 0; i < pins.length; i++) {
                this.storyPins.push(pins[i]);
            }
        } else if (action == 'change') {
            // provided edits could be used to optimize below
        } else {
            throw new Error('action? :' + action);
        }
        // @todo optimize by looking at changes
        var times = this.storyPins.map(function(p) {
            if (p.start_time > p.end_time) {
                return storytools.core.utils.createRange(p.end_time, p.start_time);
            } else {
                return storytools.core.utils.createRange(p.start_time, p.end_time);
            }
        });
        this.map.storyPinsLayer.set('times', times);
        this.map.storyPinsLayer.set('features', this.storyPins);
    };
    StoryPinLayerManager.prototype.loadFromGeoJSON = function(geojson, projection, overwrite) {

        if (overwrite){
            this.storyPins = [];
        }

        if (geojson && geojson.features) {
            var loaded = pins.loadFromGeoJSON(geojson, projection);
            this.pinsChanged(loaded, 'add', true);
        }
    };

    module.service('StoryPinLayerManager', StoryPinLayerManager);

    module.constant('StoryPin', pins.StoryPin);

    // @todo naive implementation on local storage for now
    module.service('stAnnotationsStore', function(StoryPinLayerManager) {
        function path(mapid) {
            return '/maps/' + mapid + '/annotations';
        }
        function get(mapid) {
            var saved = localStorage.getItem(path(mapid));
            saved = (saved === null) ? [] : JSON.parse(saved);
            // TODO is this still needed?
            /*saved.forEach(function(s) {
                s.the_geom = format.readGeometry(s.the_geom);
            });*/
            return saved;
        }
        function set(mapid, annotations) {
            // TODO is this still needed?
            /*annotations.forEach(function(s) {
                if (s.the_geom && !angular.isString(s.the_geom)) {
                    s.the_geom = format.writeGeometry(s.the_geom);
                }
            });*/
            localStorage.setItem(path(mapid),
                new ol.format.GeoJSON().writeFeatures(annotations,
                    {dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857'})
            );
        }
        return {
            loadAnnotations: function(mapid, projection) {
                return StoryPinLayerManager.loadFromGeoJSON(get(mapid), projection);
            },
            deleteAnnotations: function(annotations) {
                var saved = get();
                var toDelete = annotations.map(function(d) {
                    return d.id;
                });
                saved = saved.filter(function(s) {
                    return toDelete.indexOf(s.id) < 0;
                });
                set(saved);
            },
            saveAnnotations: function(mapid, annotations) {
                var saved = get();
                var maxId = 0;
                saved.forEach(function(s) {
                    maxId = Math.max(maxId, s.id);
                });
                var clones = [];
                annotations.forEach(function(a) {
                    if (typeof a.id == 'undefined') {
                        a.id = ++maxId;
                    }
                    var clone = a.clone();
                    if (a.get('start_time') !== undefined) {
                        clone.set('start_time', a.get('start_time')/1000);
                    }
                    if (a.get('end_time') !== undefined) {
                        clone.set('end_time', a.get('end_time')/1000);
                    }
                    clones.push(clone);
                });
                set(mapid, clones);
            }
        };
    });

})();

},{}],19:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.core.style.ol3StyleConverter', []);

    module.factory('ol3MarkRenderer', function(ol3StyleConverter) {
        return function(shapeName, size) {
            var black = ol3StyleConverter.getColor('#000000');
            var strokeWidth = 3; // hack to fix down-scaling for x and cross
            var opts = {color: black, width: strokeWidth};
            var canvas = angular.element(ol3StyleConverter.generateShape({
                    symbol: {shape: shapeName, size: size - strokeWidth}
                },
                new ol.style.Fill(opts),
                new ol.style.Stroke(opts)).getImage());
            return canvas;
        };
    });

    module.factory('ol3StyleConverter', function(stSvgIcon) {
        return {
            generateShapeConfig: function(style, fill, stroke) {
                var shape = style.symbol.shape,
                    // final size is actually (2 * (radius + stroke.width)) + 1
                    radius = style.symbol.size / 2;
                if (shape === 'circle') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        radius: radius
                    };
                } else if (shape === 'square') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        points: 4,
                        radius: radius,
                        angle: Math.PI / 4
                    };
                } else if (shape === 'triangle') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        points: 3,
                        radius: radius,
                        angle: 0
                    };
                } else if (shape === 'star') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        points: 5,
                        radius: radius,
                        radius2: 0.5*radius,
                        angle: 0
                    };
                } else if (shape === 'cross') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        points: 4,
                        radius: radius,
                        radius2: 0,
                        angle: 0
                    };
                } else if (shape === 'x') {
                    return {
                        fill: fill,
                        stroke: stroke,
                        points: 4,
                        radius: radius,
                        radius2: 0,
                        angle: Math.PI / 4
                    };
                }
            },
            calculateRotation: function(style, feature) {
                if (style.symbol && style.symbol.rotationAttribute) {
                    if (style.symbol.rotationUnits === 'radians') {
                        return feature.get(style.symbol.rotationAttribute);
                    } else {
                        return (feature.get(style.symbol.rotationAttribute)/360)*Math.PI;
                    }
                } else {
                    return undefined;
                }
            },
            generateShape: function(style, fill, stroke, feature) {
                var config = this.generateShapeConfig(style, fill, stroke);
                if (config && feature) {
                    config.rotation = this.calculateRotation(style, feature);
                }
                if (style.symbol.graphic) {
                    var info = stSvgIcon.getImage(style.symbol.graphic, fill.getColor(), stroke.getColor(), true);
                    return new ol.style.Icon({
                        src: info.dataURI,
                        rotation: this.calculateRotation(style, feature),
                        scale: style.symbol.size / Math.max(info.width, info.height),
                        opacity: style.symbol.opacity
                    });
                } else if (style.symbol.shape === 'circle') {
                    return new ol.style.Circle(config);
                } else {
                    return new ol.style.RegularShape(config);
                }
            },
            getText: function(style, feature) {
                if (style.label && style.label.attribute) {
                    return '' + feature.get(style.label.attribute);
                } else {
                    return undefined;
                }
            },
            generateText: function(style, stroke, feature) {
                if (style.label && style.label.attribute !== null) {
                    return new ol.style.Text({
                        fill: new ol.style.Fill({color: style.label.fillColor}),
                        stroke: stroke,
                        font: style.label.fontStyle + ' ' + style.label.fontWeight + ' ' + style.label.fontSize + 'px ' + style.label.fontFamily,
                        text: this.getText(style, feature)
                    });
                }
            },
            getColor: function(color, opacity) {
                var rgba = ol.color.asArray(color);
                if (opacity !== undefined) {
                    rgba = rgba.slice();
                    rgba[3] = opacity/100;
                }
                return 'rgba(' + rgba.join(',') + ')';
            },
            generateCacheKey: function(style, feature) {
                var text = this.getText(style, feature);
                var classify = (style.classify && style.classify.attribute) ? feature.get(style.classify.attribute) : undefined;
                var rotation = (style.symbol && style.symbol.rotationAttribute) ? feature.get(style.symbol.rotationAttribute): undefined;
                return text + '|' + classify + '|' + rotation;
            },
            generateStyle: function(style, feature, resolution) {
                var result, key2;
                if (!this.styleCache_) {
                    this.styleCache_ = {};
                }
                var key = JSON.stringify(style);
                if (this.styleCache_[key]) {
                    if (!this.styleCache_[key].length) {
                        key2 = this.generateCacheKey(style, feature);
                        if (this.styleCache_[key][key2]) {
                            return this.styleCache_[key][key2];
                        }
                    } else {
                        return this.styleCache_[key];
                    }
                }
                var stroke;
                if (style.stroke) {
                    var lineDash;
                    if (style.stroke.strokeStyle === 'dashed') {
                        lineDash = [5];
                    } else if (style.stroke.strokeStyle === 'dotted') {
                        lineDash = [1,2];
                    }
                    stroke = new ol.style.Stroke({
                        lineDash: lineDash,
                        color: this.getColor(style.stroke.strokeColor, style.stroke.strokeOpacity),
                        width: style.stroke.strokeWidth
                    });
                }
                if (style.classify && style.classify.attribute !== null) {
                    var label;
                    for (var i=0, ii=style.rules.length; i<ii; ++i) {
                        var rule = style.rules[i];
                        var attrVal = feature.get(style.classify.attribute);
                        var match = false;
                        if (rule.value !== undefined) {
                            match = attrVal === rule.value;
                        } else if (rule.range) {
                            match = (attrVal >= rule.range.min && attrVal <= rule.range.max);
                        }
                        if (match) {
                            label = this.generateText(style, stroke, feature);
                            if (style.geomType === 'point' && rule.style.symbol.fillColor) {
                                result = [new ol.style.Style({
                                    text: label,
                                    image: this.generateShape(style, new ol.style.Fill({color: rule.style.symbol.fillColor}), stroke, feature)
                                })];
                            } else if (style.geomType === 'line' && rule.style.stroke.strokeColor) {
                                result = [new ol.style.Style({
                                    text: label,
                                    stroke: new ol.style.Stroke({
                                        color: rule.style.stroke.strokeColor,
                                        width: 2
                                    })
                                })];
                            } else if (style.geomType === 'polygon' && rule.style.symbol.fillColor) {
                                result = [new ol.style.Style({
                                    text: label,
                                    stroke: stroke,
                                    fill: new ol.style.Fill({
                                        color: rule.style.symbol.fillColor
                                    })
                                })];
                            }
                        }
                    }
                    if (result) {
                        if (!this.styleCache_[key]) {
                            this.styleCache_[key] = {};
                        }
                        key2 = this.generateCacheKey(style, feature);
                        this.styleCache_[key][key2] = result;
                    }
                } else {
                    var fill = new ol.style.Fill({
                        color: this.getColor(style.symbol.fillColor, style.symbol.fillOpacity)
                    });
                    result = [
                        new ol.style.Style({
                            image: this.generateShape(style, fill, stroke, feature),
                            fill: fill,
                            stroke: stroke,
                            text: this.generateText(style, stroke, feature)
                        })
                    ];
                }
                if (result) {
                    var hasText = result[0].getText();
                    if (hasText || (style.classify && style.classify.attribute) || (style.symbol && style.symbol.rotationAttribute)) {
                        if (!this.styleCache_[key]) {
                            this.styleCache_[key] = {};
                        }
                        key2= this.generateCacheKey(style, feature);
                        this.styleCache_[key][key2] = result;
                    } else {
                        this.styleCache_[key] = result;
                    }
                }
                return result;
            }
        };
    });
})();

},{}],20:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.core.style.svgIcon', []);

    module.factory('stSvgIcon', function($cacheFactory, $http, $q, $log) {
        var element = angular.element(document.createElement('div'));
        var imageCache = $cacheFactory('stSvgImage');
        var dataCache = $cacheFactory('stSvgData');
        function process(svg, fill, stroke) {
            element.html(svg);
            // @todo make smarter
            ['path', 'polygon', 'circle', 'ellipse', 'rect', 'line', 'polyline'].forEach(function(el) {
                angular.forEach(element.find(el), function(e) {
                    // @todo does it make sense to override stroke width?
                    e = angular.element(e);
                    var css = {
                        opacity: 1
                    };
                    var existingFill = e.css('fill') || e.attr('fill') || '';
                    if (existingFill != 'none' && existingFill != 'rgb(255, 255, 255)' && existingFill.toLowerCase() != '#ffffff') {
                        css.fill = fill;
                    }
                    var existingStroke = e.css('stroke') || e.attr('stroke');
                    if (existingStroke != 'none') {
                        css.stroke = stroke;
                    }
                    e.css(css);
                });
            });
            var root = element.find('svg');
            var width = parseInt(root.attr('width'));
            var height = parseInt(root.attr('height'));
            // ugh - we're totally guessing here but things go badly without:
            // on firefox: ns_error_not_available on calling canvas.drawimage
            // on chrome: very large icon (default size as it renders)
            // we might be able to set the src on an img element and figure this out...
            if (isNaN(width) || isNaN(height)) {
                root.attr('width', 64);
                root.attr('height', 64);
                width = 64;
                height = 64;
            }
            var dataURI = 'data:image/svg+xml;base64,' + btoa(element.html());
            return {
                dataURI: dataURI,
                width: width,
                height: height
            };
        }
        return {
            getImage: function(svgURI, fill, stroke, sync) {
                var key = svgURI + fill + stroke;
                var cached = imageCache.get(key);
                var deferred = $q.defer();
                if (cached) {
                    if (sync) {
                        return cached;
                    }
                    deferred.resolve(cached);
                } else {
                    if (sync) {
                        var svg = dataCache.get(svgURI);
                        if (svg) {
                            var imageInfo = process(svg, fill, stroke);
                            imageInfo.uri = svgURI;
                            imageCache.put(key, imageInfo);
                            return imageInfo;
                        }
                        $log.warning('no svg for', svgURI);
                        return null;
                    }
                    this.getImageData(svgURI).then(function(response) {
                        var imageInfo = process(response.data, fill, stroke);
                        imageInfo.uri = svgURI;
                        imageCache.put(key, imageInfo);
                        deferred.resolve(imageInfo);
                    }, function() {
                        deferred.reject('error');
                    });
                }
                return deferred.promise;
            },
            getImageData: function(svgURI) {
                return $http.get(svgURI, {cache: true}).success(function(response) {
                    dataCache.put(svgURI, response);
                    return response;
                }).error(function() {
                    $log.warn('error fetching ' + svgURI);
                });
            }
        };
    });

})();

},{}],21:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.core.time.services', []);

    var stutils = storytools.core.time.utils;

    /**
     * Compute a sorted, unique array of ticks for the provided layers. The
     * algorithm uses any provided instant or extent(start value used) list values
     * and looks at the total range of all interval values creating a tick at the
     * minimum interval for the total range. See the tests for examples.
     * @param {array|ol.Map} layersWithTime
     * @returns array of ticks
     */
    function computeTicks(layersWithTime) {
        // allow a map to be passed in
        if (!angular.isArray(layersWithTime)) {
            var storyMap = layersWithTime;
            layersWithTime = storyMap.getStoryLayers().getArray().filter(function(l) {
                var times = l.get('times');
                /*jshint eqnull:true */
                return times != null;
            });
            layersWithTime.push(storyMap.storyPinsLayer);
            layersWithTime.push(storyMap.storyBoxesLayer);
        }
        var ticks = {};
        var totalRange = null;
        var intervals = [];
        function addTick(add) {
            add = stutils.getTime(add);
            if (add !== null && ! (add in ticks)) {
                ticks[add] = 1;
            }
        }
        layersWithTime.forEach(function(l) {
            var times = l.get('times');
            var range;
            if (angular.isArray(times)) {
                // an array of instants or extents
                range = stutils.computeRange(times);
                if (times.length) {
                    if (stutils.isRangeLike(times[0])) {
                        times.forEach(function(r) {
                            addTick(r.start);
                            if (totalRange === null) {
                                totalRange = stutils.createRange(r);
                            } else {
                                totalRange.extend(r);
                            }
                        });
                    } else {
                        times.forEach(function(r) {
                            addTick(r);
                        });
                    }
                }
                // add a tick at the end to ensure we get there
                /*jshint eqnull:true */
                if (range.end != null) {
                    addTick(range.end);
                }
            } else if (times) {
                // a interval (range+duration)
                range = times;
                intervals.push(times);
            }
            if (totalRange === null) {
                // copy, will be modifying
                totalRange = stutils.createRange(range);
            } else {
                totalRange.extend(range);
            }
        });
        if (intervals.length) {
            intervals.sort(function(a, b) {
                return a.interval - b.interval;
            });
            var smallest = intervals[0];
            var start = totalRange.start;
            while (start <= totalRange.end) {
                addTick(start);
                start = smallest.offset(start);
            }
        }
        ticks = Object.getOwnPropertyNames(ticks).map(function(t) {
            return parseInt(t);
        });
        return ticks.sort(function(a, b) {
            return a - b;
        });
    }

    function TimeControlsManager($log, $rootScope, StoryPinLayerManager, MapManager) {
        this.timeControls = null;
        var timeControlsManager = this;

        function maybeCreateTimeControls(update) {
            $log.debug("Creating TimeControls with boxes: ");
           // $log.debug(StoryBoxLayerManager.storyBoxes);
            if (timeControlsManager.timeControls !== null) {
                if (update) {
                    var values = update();
                    if (values) {
                        timeControlsManager.timeControls.update(values);
                    }
                }
                return;
            }
            var range = computeTicks(MapManager.storyMap);
            if (range.length) {
                var annotations = StoryPinLayerManager.storyPins;
                timeControlsManager.timeControls = storytools.core.time.create({
                    annotations: annotations,
                    storyMap: MapManager.storyMap,
                    storyLayers: MapManager.storyMap.getStoryLayers().getArray(),
                    data: range,
                    mode: MapManager.storyMap.mode,
                    tileStatusCallback: function(remaining) {
                        $rootScope.$broadcast('tilesLoaded', remaining);
                    },
                    chapterCount: MapManager.chapterCount
                });
                timeControlsManager.timeControls.on('rangeChange', function(range) {
                    timeControlsManager.currentRange = range;
                });
            }
        }

        MapManager.storyMap.getStoryLayers().on('change:length', function() {
            maybeCreateTimeControls(function() {
                var range = computeTicks(MapManager.storyMap);
                if (range.length) {
                    return {
                        storyLayers: MapManager.storyMap.getStoryLayers().getArray(),
                        data: range
                    };
                }
            });
        });
        var pinsLayer = MapManager.storyMap.storyPinsLayer;
        var boxesLayer = MapManager.storyMap.storyBoxesLayer;
        pinsLayer.on('change:features', function() {
            maybeCreateTimeControls(function() {
                var range = computeTicks(MapManager.storyMap);
                if (range.length) {
                    return {
                        storyLayers: MapManager.storyMap.getStoryLayers().getArray(),
                        annotations: pinsLayer.get("features"),
                        boxes: boxesLayer.get("features"),
                        data: range
                    };
                }
            });
        });

        boxesLayer.on('change:features', function() {
            maybeCreateTimeControls(function() {
                var range = computeTicks(MapManager.storyMap);
                if (range.length) {
                    return {
                        annotations: pinsLayer.get("features"),
                        data: range,
                        boxes: boxesLayer.get("features")
                    };
                }
            });
        });

        maybeCreateTimeControls();
    }

    module.constant('TimeControlsManager', TimeControlsManager);

    module.service('TimeMachine', function() {
        return {
            computeTicks: computeTicks
        };
    });
})();

},{}],22:[function(require,module,exports){
(function() {
    'use strict';
    var module = angular.module('storytools.edit.style.directives', []);

    function editorDirective(name, templateUrl, property, linker) {
        module.directive(name, ['stStyleChoices', function(styleChoices) {
            return {
                restrict: 'E',
                scope: {
                    stModel: "=",
                    property: "@",
                    popover: "@popoverText",
                },
                templateUrl: 'style/widgets/' + templateUrl,
                link: function(scope, element, attrs) {
                    // @todo bleck - grabbing the layer from the parent
                    // should be replaced with something more explicit
                    scope.layer = scope.$parent.layer;
                    scope.$watch(function() {
                        return scope.$parent.layer;
                    }, function(neu) {
                        scope.layer = neu;
                    });
                    // endbleck
                    scope.model = scope.stModel[property || scope.property];
                    scope.styleChoices = styleChoices;
                    if (linker) {
                        linker(scope, element, attrs);
                    }
                }
            };
        }]);
    }

    module.directive('styleEditor', function() {
        return {
            restrict: 'E',
            templateUrl: 'style/style-editor.html',
            controller: 'styleEditorController',
            require: '?styleEditorController',
            scope: {
                layer : '=',
                onChange : '=',
                formChanged : '='
            }
        };
    });

    module.directive('attributeCombo', function($log) {
        return {
            restrict: 'E',
            templateUrl: 'style/widgets/attribute-combo.html',
            scope: {
                layer: '=',
                model: "=stModel",
                onChange: "=?",
                css: "@css",
            },
            link: function(scope, element, attrs) {
                function readAttributes() {
                    var atts = [];
                    if (scope.layer) {
                        scope.layer.get('attributes').forEach(function(a) {
                            var include = true;
                            if (attrs.filter === 'nogeom') {
                                include = a.typeNS !== 'http://www.opengis.net/gml';
                            } else if (attrs.filter === 'number') {
                                include = a.type === 'integer' ||
                                    a.type === 'double' ||
                                    a.type === 'long';
                            } else if (attrs.filter === 'unique') {
                                include = a.type === 'integer' ||
                                    a.type === 'string' ||
                                    a.type === 'long';
                            } else if (attrs.filter) {
                                $log.warn('unknown filter', attrs.filter);
                            }
                            if (attrs.include) {
                                include = attrs.include.indexOf(a.type) >= 0;
                            }
                            if (include) {
                                atts.push(a.name);
                            }
                        });
                        atts.sort();
                        scope.attributes = atts;
                    } else {
                        scope.attributes = [];
                    }
                }
                // @todo is watch actually needed here (possibly the case if reusing the editor)
                scope.$watch('layer', function(neu, old) {
                    if (neu != old) {
                        readAttributes();
                    }
                });
                readAttributes();
                // default property to modify
                scope.property = attrs.property || 'attribute';
                // if not provided, the default behavior is to change the model
                if (!scope.onChange) {
                    scope.onChange = function(property, val) {
                        scope.model[property] = val;
                    };
                }
            }
        };
    });

    editorDirective('symbolEditor', 'symbol-editor.html', 'symbol', function(scope, el, attrs) {
        ['showGraphic', 'showRotation', 'hideColor'].forEach(function(opt) {
            scope[opt] = attrs[opt];
        });
        scope.getSymbolizerText = function(model) {
            return model.shape || model.graphic;
        };
        scope.getSymbolizerImage = function(name) {
            return '';
        };
    });
    editorDirective('strokeEditor', 'stroke-editor.html', 'stroke');
    editorDirective('numberEditor', 'number-editor.html', null, function(scope, el, attrs) {
        var defaults = {
            max: 30,
            min: 0,
            step: 1
        };
        Object.keys(defaults).forEach(function(e) {
            scope[e] = attrs[e] || defaults[e];
        });
        function wheel(ev) {
            var input = el.find('input');
            var min = Number(input.attr('min')) || 0;
            var max = Number(input.attr('max'));
            var step = Number(input.attr('step')) || 1;
            var val = scope.stModel[scope.property];
            var scroll = ev.detail || ev.wheelDelta;
            val = Math.min(max, val + (scroll > 0 ? -step: step));
            val = Math.max(min, val);
            scope.$apply(function() {
                scope.stModel[scope.property] = val;
            });
        }
        el[0].addEventListener('DOMMouseScroll', wheel, false ); // For FF and Opera
        el[0].addEventListener('mousewheel', wheel, false ); // For others
    });
    editorDirective('colorEditor', 'color-editor.html');
    editorDirective('labelEditor', 'label-editor.html', 'label', function(scope) {
        // @todo other options
        scope.styleModel = {
            bold : scope.model.fontWeight == 'bold',
            italic : scope.model.fontStyle == 'italic'
        };
        scope.styleModelChange = function() {
            scope.model.fontWeight = scope.styleModel.bold ? 'bold' : 'normal';
            scope.model.fontStyle = scope.styleModel.italic ? 'italic' : 'normal';
        };
    });

    // @todo break into pieces or make simpler
    // @todo doesn't watch iconCommons.defaults() - can become out of date
    module.directive('graphicEditor', function(stStyleChoices, ol3MarkRenderer, iconCommons, iconCommonsSearch, stSvgIcon) {
        return {
            restrict: 'E',
            templateUrl: 'style/widgets/graphic-editor.html',
            scope: {
                symbol: '='
            },

            link: function(scope, element, attrs) {
                function canvas(symbol) {
                    var el = angular.element(ol3MarkRenderer(symbol, 24));
                    el.addClass('symbol-icon');
                    el.attr('mark', symbol); // for testing until we use data URI
                    return el;
                }
                function image(icon) {
                    var el = angular.element('<img>');
                    el.attr('src', icon.dataURI);
                    el.addClass('symbol-icon');
                    el.attr('graphic', icon.uri);
                    return el;
                }
                // update the element with the data-current-symbol attribute
                // to match the current symbol
                function current() {
                    var el = angular.element(element[0].querySelector('[data-current-symbol]'));
                    el.find('*').remove();
                    if (scope.symbol.shape) {
                        el.append(canvas(scope.symbol.shape));
                    } else if (scope.symbol.graphic) {
                        stSvgIcon.getImage(scope.symbol.graphic, '#000', '#fff').then(function(icon) {
                            el.append(image(icon));
                        });
                    }
                }
                var clicked = function() {
                    var el = angular.element(this);
                    if (el.attr('shape')) {
                        scope.symbol.shape = el.attr('shape');
                        scope.symbol.graphic = null;
                    } else if (el.attr('graphic')) {
                        scope.symbol.shape = null;
                        scope.symbol.graphic = el.attr('graphic');
                    }
                    current();
                };
                // this might be done another way but because we get canvas elements
                // back from ol3 styles, we build the dom manually
                var list = angular.element(element[0].getElementsByClassName('ol-marks'));
                stStyleChoices.symbolizers.forEach(function(s) {
                    var img = canvas(s);
                    img.attr('shape', s);
                    img.on('click', clicked);
                    list.append(img);
                });
                function updateRecent() {
                    list = angular.element(element[0].getElementsByClassName('recent-icons'));
                    list.html('');
                    iconCommons.defaults().then(function(icons) {
                        icons.forEach(function(icon, i) {
                            var img = image(icon);
                            img.on('click', clicked);
                            list.append(img);
                        });
                        // we're relying on this in the tests as a means of
                        // knowing when the recent icons loading has completed
                        scope.recent = icons;
                    });
                }
                // only in scope for triggering in tests
                scope._updateRecent = function() {
                    updateRecent();
                    current();
                };
                scope._updateRecent();
                scope.showIconCommons = function() {
                    iconCommonsSearch.search().then(function(selected) {
                        // since ol3 style creation is sync, preload icon before setting
                        stSvgIcon.getImageData(selected.href).then(function() {
                            scope.symbol.shape = null;
                            scope.symbol.graphic = selected.href;
                            scope._updateRecent();
                        });
                    });
                };
            }
        };
    });

    module.directive('classifyEditor', function() {
        return {
            restrict: 'E',
            templateUrl: 'style/widgets/classify-editor.html',
            scope: true,
            link: function(scope, element, attrs) {
                ['showMethod','showMaxClasses', 'showRange',
                    'showColorRamp','showColorPalette', 'attributeFilter'].forEach(function(opt) {
                    scope[opt] = attrs[opt];
                });
            }
        };
    });

    module.directive('colorRamp', function() {
        return {
            restrict: 'A',
            scope: {
                ramp: "=ramp"
            },
            link: function(scope, element, attrs) {
                function render() {
                    var ctx = element[0].getContext('2d');
                    var gradient = ctx.createLinearGradient(0, 0, attrs.width, 0);
                    Object.getOwnPropertyNames(scope.ramp).forEach(function(stop) {
                        stop = parseFloat(stop);
                        if (!isNaN(stop)) {
                            gradient.addColorStop(stop, scope.ramp[stop]);
                        }
                    });
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, attrs.width, attrs.height);
                }
                scope.$watch('ramp', render);
                render();
            }
        };
    });

    module.directive('colorField', function() {
        var regex = /(^#[0-9a-f]{6}$)|(^#[0-9a-f]{3}$)/i;
        function validColor(value) {
            // @todo support named colors?
            return regex.exec(value);
        }
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function(scope, element, attrs, ctrl) {
                ctrl.$parsers.push(function(viewValue) {
                    ctrl.$setValidity('color', validColor(viewValue));
                    return viewValue;
                });
                ctrl.$formatters.push(function(modelValue) {
                    // when loaded but also possible the picker widget modifies
                    ctrl.$setValidity('color', validColor(modelValue));
                    return modelValue;
                });
            }
        };
    });

    module.directive('noClose', function() {
        return {
            link: function($scope, $element) {
                $element.on('click', function($event) {
                    $event.stopPropagation();
                });
            }
        };
    });

    module.directive('styleTypeEditor', function($compile, $templateCache) {
        return {
            restrict: "E",
            link: function(scope, element, attrs) {
                scope.$watch('currentEditor', function() {
                    var currentEditor = scope.currentEditor;
                    if (scope.currentEditor) {
                        var templateUrl = 'style/types/' + currentEditor.name.replace(' ', '-') + ".html";
                        element.html($templateCache.get(templateUrl));
                        $compile(element.contents())(scope);
                    } else {
                        element.html('');
                    }
                });
            }
        };
    });

    module.directive('rulesEditor', function() {
        return {
            restrict: 'E',
            templateUrl: 'style/rules-editor.html',
            link: function(scope, element, attrs) {
                scope.deleteRule = function(rule) {
                    scope.activeStyle.rules = scope.activeStyle.rules.filter(function(r) {
                        return r !== rule;
                    });
                };
            }
        };
    });
})();

},{}],23:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.edit.style.iconCommons', []);

    module.factory('iconCommons', function($q, stSvgIcon, stRecentChoices) {
        return {
            defaults: function() {
                return $q.all(stRecentChoices.icons.recent.map(function(uri) {
                    return stSvgIcon.getImage(uri);
                }));
            }
        };
    });

    module.factory('iconCommonsSearch', function($http, $modal, $injector) {
        var iconCommonsHost = $injector.has('iconCommonsHost') ?
            $injector.get('iconCommonsHost') : 'http://localhost:8000';
        function fixHrefs(stuff) {
            var toFix = stuff.icons || stuff;
            for (var i = 0, ii = toFix.length; i < ii; i++) {
                toFix[i].href = iconCommonsHost + toFix[i].href;
            }
            return stuff;
        }
        return {
            tagEndpoint: iconCommonsHost + '/icons/icon',
            search: function() {
                this.modal = $modal.open({
                    size: 'lg',
                    controller: 'iconCommonsController',
                    templateUrl: 'style/widgets/icon-commons-search.html'
                });
                return this.modal ? this.modal.result : null;
            },
            getCollections: function() {
                return $http.get(iconCommonsHost + '/icons/collections').success(function(data) {
                    return fixHrefs(data);
                });
            },
            getMore: function(collection) {
                var href = collection.href;
                if (href.indexOf(iconCommonsHost) !== 0) {
                    href = iconCommonsHost + href;
                }
                return $http.get(href, {
                    params: {
                        page: collection._nextPage
                    }
                }).success(function(data) {
                    return fixHrefs(data);
                });
            },
            getCollectionIcons: function(collection) {
                var params = {};
                if (collection._nextPage) {
                    params.page = collection._nextPage;
                }
                return $http.get(iconCommonsHost + collection.href, {
                    params: params
                }).success(function(data) {
                    return fixHrefs(data);
                });
            },
            getByTag: function(tag) {
                return $http.get(this.tagEndpoint, {
                    params: {
                        tag: tag
                    }
                }).success(function(data) {
                    return fixHrefs(data);
                });
            },
            getTags: function(q) {
                return $http.get(iconCommonsHost + '/icons/search/tags', {
                    params: {
                        query: q
                    }
                }).then(function(response) {
                    return response.data.tags;
                });
            }
        };
    });

    module.controller('iconCommonsController', function($scope, iconCommonsSearch, stRecentChoices) {
        var tagCollection = {
            href: iconCommonsSearch.tagEndpoint
        }, collection = {
        };
        function handleCollections(collection, response) {
            var icons = response.data.icons;
            if (collection._icons) {
                collection._icons = collection._icons.concat(icons);
            } else {
                collection._icons = icons;
            }
            collection._more = response.data.page < response.data.pages;
            collection._nextPage = response.data.page + 1;
            $scope.icons = collection;
        }
        $scope.loadMore = function() {
            iconCommonsSearch.getMore($scope.icons).then(function(data) {
                handleCollections($scope.icons, data);
            });
        };
        $scope.close = function() {
            stRecentChoices.icons.add($scope.selectedIcon.href);
            iconCommonsSearch.modal.close($scope.selectedIcon);
        };
        $scope.dismiss = function() {
            iconCommonsSearch.modal.dismiss();
        };
        $scope.tagSelect = function(tag) {
            tagCollection._icons = [];
            iconCommonsSearch.getByTag(tag).then(function(data) {
                handleCollections(tagCollection, data);
            });
        };
        $scope.viewCollections = function() {
            $scope.icons = collection;
        };
        $scope.viewTags = function() {
            $scope.icons = tagCollection;
        };
        $scope.collectionSelect = function(collection) {
            collection._icons = [];
            iconCommonsSearch.getCollectionIcons(collection).then(function(data) {
                handleCollections(collection, data);
            });
        };
        $scope.iconSelected = function(icon, done) {
            $scope.selectedIcon = icon;
            if (done) {
                $scope.close();
            }
        };
        $scope.selectedClass = function(icon) {
            return icon === $scope.selectedIcon ? 'active' : null;
        };
        $scope.getTags = iconCommonsSearch.getTags;
        iconCommonsSearch.getCollections().then(function(response) {
            $scope.collections = response.data.collections;
        });
    });
})();
},{}],24:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.edit.style.styleChoices', []);

    module.factory('stStyleChoices', function() {
        return {
            symbolizers: [
                'circle', 'square', 'triangle', 'star', 'cross', 'x'
            ],
            rotationUnits: [
                'degrees', 'radians'
            ],
            strokeStyle: [
                'solid', 'dashed', 'dotted'
            ],
            fontFamily: [
                'serif', 'sans-serif', 'cursive', 'monospace'
            ],
            colorRamps: [
                {
                    0: '#ff0000',
                    1: '#0000ff'
                },
                {
                    0: '#00ff00',
                    1: '#ffff00'
                }
            ],
            // @todo build these statically ahead of time using color-scheme-js
            colorPalettes: [
                {
                    name: 'colors 1',
                    vals: ["#ff9900", "#b36b00", "#ffe6bf", "#ffcc80",
                        "#00b366", "#007d48", "#bfffe4", "#80ffc9",
                        "#400099", "#2d006b", "#dabfff", "#b580ff"]
                },
                {
                    name: 'colors 2',
                    vals: ["#ff99aa", "#b36baa", "#aae6bf", "#aacc80",
                        "#00b366", "#007d48", "#bfaae4", "#80aac9",
                        "#40aa99", "#2daa6b", "#dabfaa", "#b580aa"]
                }
            ],
            classMethods: [
                'Natural Breaks',
                'Equal Interval',
                'Quantile'/*,
                'Geometric Interval',
                'Standard Deviation'*/
            ],
            getPalette: function(name) {
                var found = this.colorPalettes.filter(function(p) {
                    return p.name === name;
                });
                return found.length ? found[0] : null;
            }
        };
    });

    module.factory('stRecentChoices', function() {
        return {
            icons: new RecentChoices('icons', 24)
        };
    });

    function RecentChoices(name, max) {
        this._max = max;
        this._key = 'stRecentChoices-' + name;
        var saved = localStorage.getItem(this._key);
        this.recent = saved ? JSON.parse(saved) : [];
    }

    RecentChoices.prototype.clear = function() {
        this.recent = [];
        localStorage.setItem(this._key, JSON.stringify(this.recent));
    };

    RecentChoices.prototype.add = function(choice) {
        if (this.recent.indexOf(choice) === -1) {
            this.recent.push(choice);
            if (this.recent.length > this._max) {
                this.recent.shift();
            }
            localStorage.setItem(this._key, JSON.stringify(this.recent));
        }
    };

})();

},{}],25:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.edit.style.styleRuleBuilder', [
        'storytools.edit.style.styleTypes',
        'storytools.edit.style.styleChoices'
    ]);

    module.factory('stStyleRuleBuilder', function(stStyleTypes, stStyleChoices) {
        function hex(v) {
            return ('00' + v.toString(16)).slice(-2);
        }
        function colorRampValues(ramp, num) {
            if (num === 1) {
                return [ramp[0]];
            }
            var colors = [];
            var rampStops = Object.keys(ramp).filter(function(x) {
                return x.toString().charAt(0) != '$';
            });
            rampStops.sort();
            var ms = rampStops.map(function(k) {
                var val = ramp[k];
                return [parseInt('0x' + val.substr(1, 2)),
                    parseInt('0x' + val.substr(3, 2)),
                    parseInt('0x' + val.substr(5, 2))
                ];
            });
            var step = 1.0 / (num - 1);
            function getStops(val) {
                // @todo find stops
                return [rampStops[0], rampStops[1]];
            }

            // @todo hsv interpolation (yields brighter colors)?
            for (var i = 0; i < num; i++) {
                var val = i * step;
                var stops = getStops(val);
                var r = (val - stops[0]) / (stops[1] - stops[0]);
                var start = ms[stops[0]];
                var stop = ms[stops[1]];
                var red = Math.floor(start[0] + (stop[0] - start[0]) * r);
                var green = Math.floor(start[1] + (stop[1] - start[1]) * r);
                var blue = Math.floor(start[2] + (stop[2] - start[2]) * r);
                colors.push('#' + hex(red) + hex(green) + hex(blue));
            }
            return colors;
        }
        function buildRule(rule, context) {
            var type = context.styleType.rule;
            var ruleStyle = {};
            angular.forEach(type, function(copyRule, styleProp) {
                var target = {};
                angular.forEach(copyRule, function(copySource, copyDest) {
                    var val = null;
                    switch (copySource) {
                        case 'color':
                            if (context.colors) {
                                val = context.colors[context.index % context.colors.length];
                            }
                            break;
                        case 'range':
                            if (context.rangeStep) {
                                val = Math.round(context.rangeStep * context.index);
                            }
                            break;
                        default:
                            throw 'invalid copySource ' + copySource;
                    }
                    if (val !== null) {
                        target[copyDest] = val;
                    }
                });
                ruleStyle[styleProp] = target;
            });
            rule.style = ruleStyle;
        }

        return {
            _colorRampValues: colorRampValues,
            buildRuleStyles: function(style) {
                var colors;
                var rangeStep;
                if (style.classify) {
                    if (style.classify.colorRamp) {
                        colors = colorRampValues(style.classify.colorRamp, style.rules.length);
                    } else if (style.classify.colorPalette) {
                        var palette = stStyleChoices.getPalette(style.classify.colorPalette);
                        // @todo interpolate if needed?
                        colors = palette.vals;
                    }
                    if (style.classify.range) {
                        rangeStep = (style.classify.range.max - style.classify.range.min) / style.rules.length;
                    }
                }
                var context = {
                    colors: colors,
                    rangeStep: rangeStep,
                    style: style,
                    styleType: stStyleTypes.getStyleType(style.typeName)
                };
                style.rules.forEach(function(r, i) {
                    context.index = i;
                    buildRule(r, context);
                });
            }
        };
    });
})();

},{}],26:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.edit.style.styleTypes', []);

    var defaultSymbol = {
        size: 10,
        shape: 'circle',
        graphic: null,
        graphicType: null,
        fillColor: '#f59620',
        fillOpacity: 70,
        rotationAttribute: null,
        rotationUnits: 'degrees'
    };

    var defaultStroke = {
        strokeColor: '#f59620',
        strokeWidth: 1,
        strokeStyle: 'solid',
        strokeOpacity: 100
    };

    var defaultLabel = {
        attribute: null,
        fillColor: '#f59620',
        fontFamily: 'Serif',
        fontSize: 10,
        fontStyle: 'normal',
        fontWeight: 'normal',
        placement: 'point'
    };

    var defaultUniqueClass = {
        method: 'unique',
        attribute: null,
        maxClasses: 5,
        colorRamp: null
    };

    var defaultBreaksClass = {
        method: null,
        attribute: null,
        maxClasses: 5,
        colorRamp: null
    };

    var defaultRangeClass = {
        method: null,
        attribute: null,
        maxClasses: 5,
        range: {
            min: 0,
            max: 16
        }
    };

    var types = [
        {
            name: 'simple point',
            displayName: 'Simple',
            prototype: {
                geomType: 'point'
            }
        },
        {
            name: 'unique point',
            displayName: 'Unique',
            prototype: {
                geomType: 'point',
                classify: defaultUniqueClass
            },
            rule: {
                symbol : {
                    fillColor: 'color'
                }
            }
        },
        {
            name: 'class point',
            displayName: 'Choropleth',
            prototype: {
                geomType: 'point',
                classify: defaultBreaksClass
            },
            rule: {
                symbol : {
                    fillColor: 'color'
                }
            }
        },
        {
            name: 'graduated point',
            displayName: 'Graduated',
            prototype: {
                geomType: 'point',
                classify: defaultRangeClass
            },
            rule: {
                symbol: {
                    size: 'range'
                }
            }
        },
        {
            name: 'heatmap',
            displayName: 'HeatMap',
            prototype: {
                geomType: 'point',
                radius: 8,
                opacity: 0.8
            }
        },
        {
            name: 'simple line',
            displayName: 'Simple',
            prototype: {
                geomType: 'line'
            }
        },
        {
            name: 'unique line',
            displayName: 'Unique',
            prototype: {
                geomType: 'line',
                classify: defaultUniqueClass
            },
            rule: {
                stroke : {
                    strokeColor: 'color'
                }
            }
        },
        {
            name: 'simple polygon',
            displayName: 'Simple',
            prototype: {
                geomType: 'polygon'
            }
        },
        {
            name: 'unique polygon',
            displayName: 'Unique',
            prototype: {
                geomType: 'polygon',
                classify: defaultUniqueClass
            },
            rule: {
                symbol : {
                    fillColor: 'color'
                }
            }
        },
        {
            name: 'class polygon',
            displayName: 'Choropleth',
            prototype: {
                geomType: 'polygon',
                classify: defaultBreaksClass
            },
            rule: {
                symbol : {
                    fillColor: 'color'
                }
            }
        }
    ];

    module.run(function($injector) {
        if ($injector.has('stStyleDefaults')) {
            var defaults = $injector.get('stStyleDefaults');
            [defaultSymbol, defaultStroke].forEach(function(s) {
                Object.keys(s).forEach(function(k) {
                    if (k in defaults) {
                        s[k] = defaults[k];
                    }
                });
            });
        }
    });

    module.factory('stStyleTypes', function() {
        return {
            getTypes: function(storyLayer) {
                return angular.copy(types).filter(function(f) {
                    return f.prototype.geomType === storyLayer.get('geomType');
                });
            },
            getStyleType: function(typeName) {
                var match = types.filter(function(t) {
                    return t.name == typeName;
                });
                if (match.length >  1) {
                    throw 'duplicate type names!';
                }
                return match.length === 0 ? null : match[0];
            },
            createStyle: function(styleType) {
                var base = {
                    symbol: defaultSymbol,
                    stroke: defaultStroke,
                    label: defaultLabel,
                    typeName: styleType.name
                };
                var style = angular.extend({}, angular.copy(base), styleType.prototype);
                if ('classify' in style) {
                    style.rules = [];
                }
                return style;
            }
        };
    });
})();

},{}],27:[function(require,module,exports){
(function() {
    'use strict';

    var module = angular.module('storytools.edit.time.directives', []);

    module.directive('stDateTimeField', function() {
        return {
            restrict: 'E',
            templateUrl: 'time/date-time-field.html',
            scope: {
                dateTime: '=',
                currentTime: '='
            },
            link: function(scope, elem) {
                scope.open = function($event) {
                    $event.preventDefault();
                    $event.stopPropagation();

                    scope.opened = true;
                };
            }
        };
    });

    module.directive('isoDateTime', function($log) {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function(scope, elem, attrs, ngModelCtrl) {
                ngModelCtrl.$formatters.push(function(modelValue) {
                    /*jshint eqnull:true */
                    var retval = modelValue != null ? new Date(modelValue).toISOString() : '';
                    return retval;
                });
                ngModelCtrl.$parsers.push(function(viewValue) {
                    var parsed =  Date.parse(viewValue);
                    var valid = !isNaN(parsed);
                    ngModelCtrl.$setValidity('dateTime', valid);
                    return valid ? parsed : null;
                });
                scope.setFromCurrentTime = function() {
                    if (scope.currentTime) {
                        ngModelCtrl.$modelValue = scope.currentTime;
                    } else {
                        $log.error('no current time provided!');
                    }
                };
            }
        };
    });
})();
},{}],28:[function(require,module,exports){
'use strict';

var util = require('./util');
var Queue = require('./Queue');

/**
 * DataSet
 *
 * Usage:
 *     var dataSet = new DataSet({
 *         fieldId: '_id',
 *         type: {
 *             // ...
 *         }
 *     });
 *
 *     dataSet.add(item);
 *     dataSet.add(data);
 *     dataSet.update(item);
 *     dataSet.update(data);
 *     dataSet.remove(id);
 *     dataSet.remove(ids);
 *     var data = dataSet.get();
 *     var data = dataSet.get(id);
 *     var data = dataSet.get(ids);
 *     var data = dataSet.get(ids, options, data);
 *     dataSet.clear();
 *
 * A data set can:
 * - add/remove/update data
 * - gives triggers upon changes in the data
 * - can  import/export data in various data formats
 *
 * @param {Array} [data]    Optional array with initial data
 * @param {Object} [options]   Available options:
 *                             {String} fieldId Field name of the id in the
 *                                              items, 'id' by default.
 *                             {Object.<String, String} type
 *                                              A map with field names as key,
 *                                              and the field type as value.
 *                             {Object} queue   Queue changes to the DataSet,
 *                                              flush them all at once.
 *                                              Queue options:
 *                                              - {number} delay  Delay in ms, null by default
 *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
 * @constructor DataSet
 */
// TODO: add a DataSet constructor DataSet(data, options)
function DataSet(data, options) {
  // correctly read optional arguments
  if (data && !Array.isArray(data)) {
    options = data;
    data = null;
  }

  this._options = options || {};
  this._data = {}; // map with data indexed by id
  this.length = 0; // number of items in the DataSet
  this._fieldId = this._options.fieldId || 'id'; // name of the field containing id
  this._type = {}; // internal field types (NOTE: this can differ from this._options.type)

  // all variants of a Date are internally stored as Date, so we can convert
  // from everything to everything (also from ISODate to Number for example)
  if (this._options.type) {
    for (var field in this._options.type) {
      if (this._options.type.hasOwnProperty(field)) {
        var value = this._options.type[field];
        if (value == 'Date' || value == 'ISODate' || value == 'ASPDate') {
          this._type[field] = 'Date';
        } else {
          this._type[field] = value;
        }
      }
    }
  }

  // TODO: deprecated since version 1.1.1 (or 2.0.0?)
  if (this._options.convert) {
    throw new Error('Option "convert" is deprecated. Use "type" instead.');
  }

  this._subscribers = {}; // event subscribers

  // add initial data when provided
  if (data) {
    this.add(data);
  }

  this.setOptions(options);
}

/**
 * @param {Object} [options]   Available options:
 *                             {Object} queue   Queue changes to the DataSet,
 *                                              flush them all at once.
 *                                              Queue options:
 *                                              - {number} delay  Delay in ms, null by default
 *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
 * @param options
 */
DataSet.prototype.setOptions = function (options) {
  if (options && options.queue !== undefined) {
    if (options.queue === false) {
      // delete queue if loaded
      if (this._queue) {
        this._queue.destroy();
        delete this._queue;
      }
    } else {
      // create queue and update its options
      if (!this._queue) {
        this._queue = Queue.extend(this, {
          replace: ['add', 'update', 'remove']
        });
      }

      if (typeof options.queue === 'object') {
        this._queue.setOptions(options.queue);
      }
    }
  }
};

/**
 * Subscribe to an event, add an event listener
 * @param {String} event        Event name. Available events: 'put', 'update',
 *                              'remove'
 * @param {function} callback   Callback method. Called with three parameters:
 *                                  {String} event
 *                                  {Object | null} params
 *                                  {String | Number} senderId
 */
DataSet.prototype.on = function (event, callback) {
  var subscribers = this._subscribers[event];
  if (!subscribers) {
    subscribers = [];
    this._subscribers[event] = subscribers;
  }

  subscribers.push({
    callback: callback
  });
};

// TODO: remove this deprecated function some day (replaced with `on` since version 0.5, deprecated since v4.0)
DataSet.prototype.subscribe = function () {
  throw new Error('DataSet.subscribe is deprecated. Use DataSet.on instead.');
};

/**
 * Unsubscribe from an event, remove an event listener
 * @param {String} event
 * @param {function} callback
 */
DataSet.prototype.off = function (event, callback) {
  var subscribers = this._subscribers[event];
  if (subscribers) {
    this._subscribers[event] = subscribers.filter(function (listener) {
      return listener.callback != callback;
    });
  }
};

// TODO: remove this deprecated function some day (replaced with `on` since version 0.5, deprecated since v4.0)
DataSet.prototype.unsubscribe = function () {
  throw new Error('DataSet.unsubscribe is deprecated. Use DataSet.off instead.');
};

/**
 * Trigger an event
 * @param {String} event
 * @param {Object | null} params
 * @param {String} [senderId]       Optional id of the sender.
 * @private
 */
DataSet.prototype._trigger = function (event, params, senderId) {
  if (event == '*') {
    throw new Error('Cannot trigger event *');
  }

  var subscribers = [];
  if (event in this._subscribers) {
    subscribers = subscribers.concat(this._subscribers[event]);
  }
  if ('*' in this._subscribers) {
    subscribers = subscribers.concat(this._subscribers['*']);
  }

  for (var i = 0; i < subscribers.length; i++) {
    var subscriber = subscribers[i];
    if (subscriber.callback) {
      subscriber.callback(event, params, senderId || null);
    }
  }
};

/**
 * Add data.
 * Adding an item will fail when there already is an item with the same id.
 * @param {Object | Array} data
 * @param {String} [senderId] Optional sender id
 * @return {Array} addedIds      Array with the ids of the added items
 */
DataSet.prototype.add = function (data, senderId) {
  var addedIds = [],
      id,
      me = this;

  if (Array.isArray(data)) {
    // Array
    for (var i = 0, len = data.length; i < len; i++) {
      id = me._addItem(data[i]);
      addedIds.push(id);
    }
  } else if (data instanceof Object) {
    // Single item
    id = me._addItem(data);
    addedIds.push(id);
  } else {
    throw new Error('Unknown dataType');
  }

  if (addedIds.length) {
    this._trigger('add', { items: addedIds }, senderId);
  }

  return addedIds;
};

/**
 * Update existing items. When an item does not exist, it will be created
 * @param {Object | Array} data
 * @param {String} [senderId] Optional sender id
 * @return {Array} updatedIds     The ids of the added or updated items
 */
DataSet.prototype.update = function (data, senderId) {
  var addedIds = [];
  var updatedIds = [];
  var updatedData = [];
  var me = this;
  var fieldId = me._fieldId;

  var addOrUpdate = function addOrUpdate(item) {
    var id = item[fieldId];
    if (me._data[id]) {
      // update item
      id = me._updateItem(item);
      updatedIds.push(id);
      updatedData.push(item);
    } else {
      // add new item
      id = me._addItem(item);
      addedIds.push(id);
    }
  };

  if (Array.isArray(data)) {
    // Array
    for (var i = 0, len = data.length; i < len; i++) {
      addOrUpdate(data[i]);
    }
  } else if (data instanceof Object) {
    // Single item
    addOrUpdate(data);
  } else {
    throw new Error('Unknown dataType');
  }

  if (addedIds.length) {
    this._trigger('add', { items: addedIds }, senderId);
  }
  if (updatedIds.length) {
    this._trigger('update', { items: updatedIds, data: updatedData }, senderId);
  }

  return addedIds.concat(updatedIds);
};

/**
 * Get a data item or multiple items.
 *
 * Usage:
 *
 *     get()
 *     get(options: Object)
 *
 *     get(id: Number | String)
 *     get(id: Number | String, options: Object)
 *
 *     get(ids: Number[] | String[])
 *     get(ids: Number[] | String[], options: Object)
 *
 * Where:
 *
 * {Number | String} id         The id of an item
 * {Number[] | String{}} ids    An array with ids of items
 * {Object} options             An Object with options. Available options:
 * {String} [returnType]        Type of data to be returned.
 *                              Can be 'Array' (default) or 'Object'.
 * {Object.<String, String>} [type]
 * {String[]} [fields]          field names to be returned
 * {function} [filter]          filter items
 * {String | function} [order]  Order the items by a field name or custom sort function.
 * @throws Error
 */
DataSet.prototype.get = function (args) {
  var me = this;

  // parse the arguments
  var id, ids, options;
  var firstType = util.getType(arguments[0]);
  if (firstType == 'String' || firstType == 'Number') {
    // get(id [, options])
    id = arguments[0];
    options = arguments[1];
  } else if (firstType == 'Array') {
    // get(ids [, options])
    ids = arguments[0];
    options = arguments[1];
  } else {
    // get([, options])
    options = arguments[0];
  }

  // determine the return type
  var returnType;
  if (options && options.returnType) {
    var allowedValues = ['Array', 'Object'];
    returnType = allowedValues.indexOf(options.returnType) == -1 ? 'Array' : options.returnType;
  } else {
    returnType = 'Array';
  }

  // build options
  var type = options && options.type || this._options.type;
  var filter = options && options.filter;
  var items = [],
      item,
      itemId,
      i,
      len;

  // convert items
  if (id != undefined) {
    // return a single item
    item = me._getItem(id, type);
    if (filter && !filter(item)) {
      item = null;
    }
  } else if (ids != undefined) {
    // return a subset of items
    for (i = 0, len = ids.length; i < len; i++) {
      item = me._getItem(ids[i], type);
      if (!filter || filter(item)) {
        items.push(item);
      }
    }
  } else {
    // return all items
    for (itemId in this._data) {
      if (this._data.hasOwnProperty(itemId)) {
        item = me._getItem(itemId, type);
        if (!filter || filter(item)) {
          items.push(item);
        }
      }
    }
  }

  // order the results
  if (options && options.order && id == undefined) {
    this._sort(items, options.order);
  }

  // filter fields of the items
  if (options && options.fields) {
    var fields = options.fields;
    if (id != undefined) {
      item = this._filterFields(item, fields);
    } else {
      for (i = 0, len = items.length; i < len; i++) {
        items[i] = this._filterFields(items[i], fields);
      }
    }
  }

  // return the results
  if (returnType == 'Object') {
    var result = {};
    for (i = 0; i < items.length; i++) {
      result[items[i].id] = items[i];
    }
    return result;
  } else {
    if (id != undefined) {
      // a single item
      return item;
    } else {
      // just return our array
      return items;
    }
  }
};

/**
 * Get ids of all items or from a filtered set of items.
 * @param {Object} [options]    An Object with options. Available options:
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Array} ids
 */
DataSet.prototype.getIds = function (options) {
  var data = this._data,
      filter = options && options.filter,
      order = options && options.order,
      type = options && options.type || this._options.type,
      i,
      len,
      id,
      item,
      items,
      ids = [];

  if (filter) {
    // get filtered items
    if (order) {
      // create ordered list
      items = [];
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          item = this._getItem(id, type);
          if (filter(item)) {
            items.push(item);
          }
        }
      }

      this._sort(items, order);

      for (i = 0, len = items.length; i < len; i++) {
        ids[i] = items[i][this._fieldId];
      }
    } else {
      // create unordered list
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          item = this._getItem(id, type);
          if (filter(item)) {
            ids.push(item[this._fieldId]);
          }
        }
      }
    }
  } else {
    // get all items
    if (order) {
      // create an ordered list
      items = [];
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          items.push(data[id]);
        }
      }

      this._sort(items, order);

      for (i = 0, len = items.length; i < len; i++) {
        ids[i] = items[i][this._fieldId];
      }
    } else {
      // create unordered list
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          item = data[id];
          ids.push(item[this._fieldId]);
        }
      }
    }
  }

  return ids;
};

/**
 * Returns the DataSet itself. Is overwritten for example by the DataView,
 * which returns the DataSet it is connected to instead.
 */
DataSet.prototype.getDataSet = function () {
  return this;
};

/**
 * Execute a callback function for every item in the dataset.
 * @param {function} callback
 * @param {Object} [options]    Available options:
 *                              {Object.<String, String>} [type]
 *                              {String[]} [fields] filter fields
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 */
DataSet.prototype.forEach = function (callback, options) {
  var filter = options && options.filter,
      type = options && options.type || this._options.type,
      data = this._data,
      item,
      id;

  if (options && options.order) {
    // execute forEach on ordered list
    var items = this.get(options);

    for (var i = 0, len = items.length; i < len; i++) {
      item = items[i];
      id = item[this._fieldId];
      callback(item, id);
    }
  } else {
    // unordered
    for (id in data) {
      if (data.hasOwnProperty(id)) {
        item = this._getItem(id, type);
        if (!filter || filter(item)) {
          callback(item, id);
        }
      }
    }
  }
};

/**
 * Map every item in the dataset.
 * @param {function} callback
 * @param {Object} [options]    Available options:
 *                              {Object.<String, String>} [type]
 *                              {String[]} [fields] filter fields
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Object[]} mappedItems
 */
DataSet.prototype.map = function (callback, options) {
  var filter = options && options.filter,
      type = options && options.type || this._options.type,
      mappedItems = [],
      data = this._data,
      item;

  // convert and filter items
  for (var id in data) {
    if (data.hasOwnProperty(id)) {
      item = this._getItem(id, type);
      if (!filter || filter(item)) {
        mappedItems.push(callback(item, id));
      }
    }
  }

  // order items
  if (options && options.order) {
    this._sort(mappedItems, options.order);
  }

  return mappedItems;
};

/**
 * Filter the fields of an item
 * @param {Object | null} item
 * @param {String[]} fields     Field names
 * @return {Object | null} filteredItem or null if no item is provided
 * @private
 */
DataSet.prototype._filterFields = function (item, fields) {
  if (!item) {
    // item is null
    return item;
  }

  var filteredItem = {};

  if (Array.isArray(fields)) {
    for (var field in item) {
      if (item.hasOwnProperty(field) && fields.indexOf(field) != -1) {
        filteredItem[field] = item[field];
      }
    }
  } else {
    for (var field in item) {
      if (item.hasOwnProperty(field) && fields.hasOwnProperty(field)) {
        filteredItem[fields[field]] = item[field];
      }
    }
  }

  return filteredItem;
};

/**
 * Sort the provided array with items
 * @param {Object[]} items
 * @param {String | function} order      A field name or custom sort function.
 * @private
 */
DataSet.prototype._sort = function (items, order) {
  if (util.isString(order)) {
    // order by provided field name
    var name = order; // field name
    items.sort(function (a, b) {
      var av = a[name];
      var bv = b[name];
      return av > bv ? 1 : av < bv ? -1 : 0;
    });
  } else if (typeof order === 'function') {
    // order by sort function
    items.sort(order);
  }
  // TODO: extend order by an Object {field:String, direction:String}
  //       where direction can be 'asc' or 'desc'
  else {
      throw new TypeError('Order must be a function or a string');
    }
};

/**
 * Remove an object by pointer or by id
 * @param {String | Number | Object | Array} id Object or id, or an array with
 *                                              objects or ids to be removed
 * @param {String} [senderId] Optional sender id
 * @return {Array} removedIds
 */
DataSet.prototype.remove = function (id, senderId) {
  var removedIds = [],
      i,
      len,
      removedId;

  if (Array.isArray(id)) {
    for (i = 0, len = id.length; i < len; i++) {
      removedId = this._remove(id[i]);
      if (removedId != null) {
        removedIds.push(removedId);
      }
    }
  } else {
    removedId = this._remove(id);
    if (removedId != null) {
      removedIds.push(removedId);
    }
  }

  if (removedIds.length) {
    this._trigger('remove', { items: removedIds }, senderId);
  }

  return removedIds;
};

/**
 * Remove an item by its id
 * @param {Number | String | Object} id   id or item
 * @returns {Number | String | null} id
 * @private
 */
DataSet.prototype._remove = function (id) {
  if (util.isNumber(id) || util.isString(id)) {
    if (this._data[id]) {
      delete this._data[id];
      this.length--;
      return id;
    }
  } else if (id instanceof Object) {
    var itemId = id[this._fieldId];
    if (itemId && this._data[itemId]) {
      delete this._data[itemId];
      this.length--;
      return itemId;
    }
  }
  return null;
};

/**
 * Clear the data
 * @param {String} [senderId] Optional sender id
 * @return {Array} removedIds    The ids of all removed items
 */
DataSet.prototype.clear = function (senderId) {
  var ids = Object.keys(this._data);

  this._data = {};
  this.length = 0;

  this._trigger('remove', { items: ids }, senderId);

  return ids;
};

/**
 * Find the item with maximum value of a specified field
 * @param {String} field
 * @return {Object | null} item  Item containing max value, or null if no items
 */
DataSet.prototype.max = function (field) {
  var data = this._data,
      max = null,
      maxField = null;

  for (var id in data) {
    if (data.hasOwnProperty(id)) {
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!max || itemField > maxField)) {
        max = item;
        maxField = itemField;
      }
    }
  }

  return max;
};

/**
 * Find the item with minimum value of a specified field
 * @param {String} field
 * @return {Object | null} item  Item containing max value, or null if no items
 */
DataSet.prototype.min = function (field) {
  var data = this._data,
      min = null,
      minField = null;

  for (var id in data) {
    if (data.hasOwnProperty(id)) {
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!min || itemField < minField)) {
        min = item;
        minField = itemField;
      }
    }
  }

  return min;
};

/**
 * Find all distinct values of a specified field
 * @param {String} field
 * @return {Array} values  Array containing all distinct values. If data items
 *                         do not contain the specified field are ignored.
 *                         The returned array is unordered.
 */
DataSet.prototype.distinct = function (field) {
  var data = this._data;
  var values = [];
  var fieldType = this._options.type && this._options.type[field] || null;
  var count = 0;
  var i;

  for (var prop in data) {
    if (data.hasOwnProperty(prop)) {
      var item = data[prop];
      var value = item[field];
      var exists = false;
      for (i = 0; i < count; i++) {
        if (values[i] == value) {
          exists = true;
          break;
        }
      }
      if (!exists && value !== undefined) {
        values[count] = value;
        count++;
      }
    }
  }

  if (fieldType) {
    for (i = 0; i < values.length; i++) {
      values[i] = util.convert(values[i], fieldType);
    }
  }

  return values;
};

/**
 * Add a single item. Will fail when an item with the same id already exists.
 * @param {Object} item
 * @return {String} id
 * @private
 */
DataSet.prototype._addItem = function (item) {
  var id = item[this._fieldId];

  if (id != undefined) {
    // check whether this id is already taken
    if (this._data[id]) {
      // item already exists
      throw new Error('Cannot add item: item with id ' + id + ' already exists');
    }
  } else {
    // generate an id
    id = util.randomUUID();
    item[this._fieldId] = id;
  }

  var d = {};
  for (var field in item) {
    if (item.hasOwnProperty(field)) {
      var fieldType = this._type[field]; // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }
  }
  this._data[id] = d;
  this.length++;

  return id;
};

/**
 * Get an item. Fields can be converted to a specific type
 * @param {String} id
 * @param {Object.<String, String>} [types]  field types to convert
 * @return {Object | null} item
 * @private
 */
DataSet.prototype._getItem = function (id, types) {
  var field, value;

  // get the item from the dataset
  var raw = this._data[id];
  if (!raw) {
    return null;
  }

  // convert the items field types
  var converted = {};
  if (types) {
    for (field in raw) {
      if (raw.hasOwnProperty(field)) {
        value = raw[field];
        converted[field] = util.convert(value, types[field]);
      }
    }
  } else {
    // no field types specified, no converting needed
    for (field in raw) {
      if (raw.hasOwnProperty(field)) {
        value = raw[field];
        converted[field] = value;
      }
    }
  }
  return converted;
};

/**
 * Update a single item: merge with existing item.
 * Will fail when the item has no id, or when there does not exist an item
 * with the same id.
 * @param {Object} item
 * @return {String} id
 * @private
 */
DataSet.prototype._updateItem = function (item) {
  var id = item[this._fieldId];
  if (id == undefined) {
    throw new Error('Cannot update item: item has no id (item: ' + JSON.stringify(item) + ')');
  }
  var d = this._data[id];
  if (!d) {
    // item doesn't exist
    throw new Error('Cannot update item: no item with id ' + id + ' found');
  }

  // merge with current item
  for (var field in item) {
    if (item.hasOwnProperty(field)) {
      var fieldType = this._type[field]; // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }
  }

  return id;
};

module.exports = DataSet;

},{"./Queue":30,"./util":59}],29:[function(require,module,exports){
'use strict';

var util = require('./util');
var DataSet = require('./DataSet');

/**
 * DataView
 *
 * a dataview offers a filtered view on a dataset or an other dataview.
 *
 * @param {DataSet | DataView} data
 * @param {Object} [options]   Available options: see method get
 *
 * @constructor DataView
 */
function DataView(data, options) {
  this._data = null;
  this._ids = {}; // ids of the items currently in memory (just contains a boolean true)
  this.length = 0; // number of items in the DataView
  this._options = options || {};
  this._fieldId = 'id'; // name of the field containing id
  this._subscribers = {}; // event subscribers

  var me = this;
  this.listener = function () {
    me._onEvent.apply(me, arguments);
  };

  this.setData(data);
}

// TODO: implement a function .config() to dynamically update things like configured filter
// and trigger changes accordingly

/**
 * Set a data source for the view
 * @param {DataSet | DataView} data
 */
DataView.prototype.setData = function (data) {
  var ids, i, len;

  if (this._data) {
    // unsubscribe from current dataset
    if (this._data.off) {
      this._data.off('*', this.listener);
    }

    // trigger a remove of all items in memory
    ids = [];
    for (var id in this._ids) {
      if (this._ids.hasOwnProperty(id)) {
        ids.push(id);
      }
    }
    this._ids = {};
    this.length = 0;
    this._trigger('remove', { items: ids });
  }

  this._data = data;

  if (this._data) {
    // update fieldId
    this._fieldId = this._options.fieldId || this._data && this._data.options && this._data.options.fieldId || 'id';

    // trigger an add of all added items
    ids = this._data.getIds({ filter: this._options && this._options.filter });
    for (i = 0, len = ids.length; i < len; i++) {
      id = ids[i];
      this._ids[id] = true;
    }
    this.length = ids.length;
    this._trigger('add', { items: ids });

    // subscribe to new dataset
    if (this._data.on) {
      this._data.on('*', this.listener);
    }
  }
};

/**
 * Refresh the DataView. Useful when the DataView has a filter function
 * containing a variable parameter.
 */
DataView.prototype.refresh = function () {
  var id;
  var ids = this._data.getIds({ filter: this._options && this._options.filter });
  var newIds = {};
  var added = [];
  var removed = [];

  // check for additions
  for (var i = 0; i < ids.length; i++) {
    id = ids[i];
    newIds[id] = true;
    if (!this._ids[id]) {
      added.push(id);
      this._ids[id] = true;
      this.length++;
    }
  }

  // check for removals
  for (id in this._ids) {
    if (this._ids.hasOwnProperty(id)) {
      if (!newIds[id]) {
        removed.push(id);
        delete this._ids[id];
        this.length--;
      }
    }
  }

  // trigger events
  if (added.length) {
    this._trigger('add', { items: added });
  }
  if (removed.length) {
    this._trigger('remove', { items: removed });
  }
};

/**
 * Get data from the data view
 *
 * Usage:
 *
 *     get()
 *     get(options: Object)
 *     get(options: Object, data: Array | DataTable)
 *
 *     get(id: Number)
 *     get(id: Number, options: Object)
 *     get(id: Number, options: Object, data: Array | DataTable)
 *
 *     get(ids: Number[])
 *     get(ids: Number[], options: Object)
 *     get(ids: Number[], options: Object, data: Array | DataTable)
 *
 * Where:
 *
 * {Number | String} id         The id of an item
 * {Number[] | String{}} ids    An array with ids of items
 * {Object} options             An Object with options. Available options:
 *                              {String} [type] Type of data to be returned. Can
 *                                              be 'DataTable' or 'Array' (default)
 *                              {Object.<String, String>} [convert]
 *                              {String[]} [fields] field names to be returned
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * {Array | DataTable} [data]   If provided, items will be appended to this
 *                              array or table. Required in case of Google
 *                              DataTable.
 * @param args
 */
DataView.prototype.get = function (args) {
  var me = this;

  // parse the arguments
  var ids, options, data;
  var firstType = util.getType(arguments[0]);
  if (firstType == 'String' || firstType == 'Number' || firstType == 'Array') {
    // get(id(s) [, options] [, data])
    ids = arguments[0]; // can be a single id or an array with ids
    options = arguments[1];
    data = arguments[2];
  } else {
    // get([, options] [, data])
    options = arguments[0];
    data = arguments[1];
  }

  // extend the options with the default options and provided options
  var viewOptions = util.extend({}, this._options, options);

  // create a combined filter method when needed
  if (this._options.filter && options && options.filter) {
    viewOptions.filter = function (item) {
      return me._options.filter(item) && options.filter(item);
    };
  }

  // build up the call to the linked data set
  var getArguments = [];
  if (ids != undefined) {
    getArguments.push(ids);
  }
  getArguments.push(viewOptions);
  getArguments.push(data);

  return this._data && this._data.get.apply(this._data, getArguments);
};

/**
 * Get ids of all items or from a filtered set of items.
 * @param {Object} [options]    An Object with options. Available options:
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Array} ids
 */
DataView.prototype.getIds = function (options) {
  var ids;

  if (this._data) {
    var defaultFilter = this._options.filter;
    var filter;

    if (options && options.filter) {
      if (defaultFilter) {
        filter = function (item) {
          return defaultFilter(item) && options.filter(item);
        };
      } else {
        filter = options.filter;
      }
    } else {
      filter = defaultFilter;
    }

    ids = this._data.getIds({
      filter: filter,
      order: options && options.order
    });
  } else {
    ids = [];
  }

  return ids;
};

/**
 * Get the DataSet to which this DataView is connected. In case there is a chain
 * of multiple DataViews, the root DataSet of this chain is returned.
 * @return {DataSet} dataSet
 */
DataView.prototype.getDataSet = function () {
  var dataSet = this;
  while (dataSet instanceof DataView) {
    dataSet = dataSet._data;
  }
  return dataSet || null;
};

/**
 * Event listener. Will propagate all events from the connected data set to
 * the subscribers of the DataView, but will filter the items and only trigger
 * when there are changes in the filtered data set.
 * @param {String} event
 * @param {Object | null} params
 * @param {String} senderId
 * @private
 */
DataView.prototype._onEvent = function (event, params, senderId) {
  var i, len, id, item;
  var ids = params && params.items;
  var data = this._data;
  var updatedData = [];
  var added = [];
  var updated = [];
  var removed = [];

  if (ids && data) {
    switch (event) {
      case 'add':
        // filter the ids of the added items
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          item = this.get(id);
          if (item) {
            this._ids[id] = true;
            added.push(id);
          }
        }

        break;

      case 'update':
        // determine the event from the views viewpoint: an updated
        // item can be added, updated, or removed from this view.
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          item = this.get(id);

          if (item) {
            if (this._ids[id]) {
              updated.push(id);
              updatedData.push(params.data[i]);
            } else {
              this._ids[id] = true;
              added.push(id);
            }
          } else {
            if (this._ids[id]) {
              delete this._ids[id];
              removed.push(id);
            } else {
              // nothing interesting for me :-(
            }
          }
        }

        break;

      case 'remove':
        // filter the ids of the removed items
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          if (this._ids[id]) {
            delete this._ids[id];
            removed.push(id);
          }
        }

        break;
    }

    this.length += added.length - removed.length;

    if (added.length) {
      this._trigger('add', { items: added }, senderId);
    }
    if (updated.length) {
      this._trigger('update', { items: updated, data: updatedData }, senderId);
    }
    if (removed.length) {
      this._trigger('remove', { items: removed }, senderId);
    }
  }
};

// copy subscription functionality from DataSet
DataView.prototype.on = DataSet.prototype.on;
DataView.prototype.off = DataSet.prototype.off;
DataView.prototype._trigger = DataSet.prototype._trigger;

// TODO: make these functions deprecated (replaced with `on` and `off` since version 0.5)
DataView.prototype.subscribe = DataView.prototype.on;
DataView.prototype.unsubscribe = DataView.prototype.off;

module.exports = DataView;

},{"./DataSet":28,"./util":59}],30:[function(require,module,exports){
/**
 * A queue
 * @param {Object} options
 *            Available options:
 *            - delay: number    When provided, the queue will be flushed
 *                               automatically after an inactivity of this delay
 *                               in milliseconds.
 *                               Default value is null.
 *            - max: number      When the queue exceeds the given maximum number
 *                               of entries, the queue is flushed automatically.
 *                               Default value of max is Infinity.
 * @constructor
 */
'use strict';

function Queue(options) {
  // options
  this.delay = null;
  this.max = Infinity;

  // properties
  this._queue = [];
  this._timeout = null;
  this._extended = null;

  this.setOptions(options);
}

/**
 * Update the configuration of the queue
 * @param {Object} options
 *            Available options:
 *            - delay: number    When provided, the queue will be flushed
 *                               automatically after an inactivity of this delay
 *                               in milliseconds.
 *                               Default value is null.
 *            - max: number      When the queue exceeds the given maximum number
 *                               of entries, the queue is flushed automatically.
 *                               Default value of max is Infinity.
 * @param options
 */
Queue.prototype.setOptions = function (options) {
  if (options && typeof options.delay !== 'undefined') {
    this.delay = options.delay;
  }
  if (options && typeof options.max !== 'undefined') {
    this.max = options.max;
  }

  this._flushIfNeeded();
};

/**
 * Extend an object with queuing functionality.
 * The object will be extended with a function flush, and the methods provided
 * in options.replace will be replaced with queued ones.
 * @param {Object} object
 * @param {Object} options
 *            Available options:
 *            - replace: Array.<string>
 *                               A list with method names of the methods
 *                               on the object to be replaced with queued ones.
 *            - delay: number    When provided, the queue will be flushed
 *                               automatically after an inactivity of this delay
 *                               in milliseconds.
 *                               Default value is null.
 *            - max: number      When the queue exceeds the given maximum number
 *                               of entries, the queue is flushed automatically.
 *                               Default value of max is Infinity.
 * @return {Queue} Returns the created queue
 */
Queue.extend = function (object, options) {
  var queue = new Queue(options);

  if (object.flush !== undefined) {
    throw new Error('Target object already has a property flush');
  }
  object.flush = function () {
    queue.flush();
  };

  var methods = [{
    name: 'flush',
    original: undefined
  }];

  if (options && options.replace) {
    for (var i = 0; i < options.replace.length; i++) {
      var name = options.replace[i];
      methods.push({
        name: name,
        original: object[name]
      });
      queue.replace(object, name);
    }
  }

  queue._extended = {
    object: object,
    methods: methods
  };

  return queue;
};

/**
 * Destroy the queue. The queue will first flush all queued actions, and in
 * case it has extended an object, will restore the original object.
 */
Queue.prototype.destroy = function () {
  this.flush();

  if (this._extended) {
    var object = this._extended.object;
    var methods = this._extended.methods;
    for (var i = 0; i < methods.length; i++) {
      var method = methods[i];
      if (method.original) {
        object[method.name] = method.original;
      } else {
        delete object[method.name];
      }
    }
    this._extended = null;
  }
};

/**
 * Replace a method on an object with a queued version
 * @param {Object} object   Object having the method
 * @param {string} method   The method name
 */
Queue.prototype.replace = function (object, method) {
  var me = this;
  var original = object[method];
  if (!original) {
    throw new Error('Method ' + method + ' undefined');
  }

  object[method] = function () {
    // create an Array with the arguments
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    // add this call to the queue
    me.queue({
      args: args,
      fn: original,
      context: this
    });
  };
};

/**
 * Queue a call
 * @param {function | {fn: function, args: Array} | {fn: function, args: Array, context: Object}} entry
 */
Queue.prototype.queue = function (entry) {
  if (typeof entry === 'function') {
    this._queue.push({ fn: entry });
  } else {
    this._queue.push(entry);
  }

  this._flushIfNeeded();
};

/**
 * Check whether the queue needs to be flushed
 * @private
 */
Queue.prototype._flushIfNeeded = function () {
  // flush when the maximum is exceeded.
  if (this._queue.length > this.max) {
    this.flush();
  }

  // flush after a period of inactivity when a delay is configured
  clearTimeout(this._timeout);
  if (this.queue.length > 0 && typeof this.delay === 'number') {
    var me = this;
    this._timeout = setTimeout(function () {
      me.flush();
    }, this.delay);
  }
};

/**
 * Flush all queued calls
 */
Queue.prototype.flush = function () {
  while (this._queue.length > 0) {
    var entry = this._queue.shift();
    entry.fn.apply(entry.context || entry.fn, entry.args || []);
  }
};

module.exports = Queue;

},{}],31:[function(require,module,exports){
'use strict';

var Hammer = require('./module/hammer');

/**
 * Register a touch event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.onTouch = function (hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFirst && !isTouching) {
      callback(event);

      isTouching = true;
      setTimeout(function () {
        isTouching = false;
      }, 0);
    }
  };

  hammer.on('hammer.input', callback.inputHandler);
};

// isTouching is true while a touch action is being emitted
// this is a hack to prevent `touch` from being fired twice
var isTouching = false;

/**
 * Register a release event, taking place after a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.onRelease = function (hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFinal && !isReleasing) {
      callback(event);

      isReleasing = true;
      setTimeout(function () {
        isReleasing = false;
      }, 0);
    }
  };

  return hammer.on('hammer.input', callback.inputHandler);
};

// isReleasing is true while a release action is being emitted
// this is a hack to prevent `release` from being fired twice
var isReleasing = false;

/**
 * Unregister a touch event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.offTouch = function (hammer, callback) {
  hammer.off('hammer.input', callback.inputHandler);
};

/**
 * Unregister a release event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.offRelease = exports.offTouch;

},{"./module/hammer":32}],32:[function(require,module,exports){
// Only load hammer.js when in a browser environment
// (loading hammer.js in a node.js environment gives errors)
'use strict';

if (typeof window !== 'undefined') {
  var propagating = require('propagating-hammerjs');
  var Hammer = window['Hammer'] || require('hammerjs');
  module.exports = propagating(Hammer, {
    preventDefault: 'mouse'
  });
} else {
  module.exports = function () {
    throw Error('hammer.js is only available in a browser, not in node.js.');
  };
}

},{"hammerjs":61,"propagating-hammerjs":64}],33:[function(require,module,exports){
// first check if moment.js is already loaded in the browser window, if so,
// use this instance. Else, load via commonjs.
'use strict';

module.exports = typeof window !== 'undefined' && window['moment'] || require('moment');

},{"moment":63}],34:[function(require,module,exports){
(function (global){
'use strict';

var _rng;

var globalVar = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;

if (globalVar && globalVar.crypto && crypto.getRandomValues) {
  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
  // Moderately fast, high quality
  var _rnds8 = new Uint8Array(16);
  _rng = function whatwgRNG() {
    crypto.getRandomValues(_rnds8);
    return _rnds8;
  };
}

if (!_rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var _rnds = new Array(16);
  _rng = function () {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return _rnds;
  };
}

//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required

//var _rng = require('./rng');

// Maps for number <-> hex string conversion
var _byteToHex = [];
var _hexToByte = {};
for (var i = 0; i < 256; i++) {
  _byteToHex[i] = (i + 0x100).toString(16).substr(1);
  _hexToByte[_byteToHex[i]] = i;
}

// **`parse()` - Parse a UUID into it's component bytes**
function parse(s, buf, offset) {
  var i = buf && offset || 0,
      ii = 0;

  buf = buf || [];
  s.toLowerCase().replace(/[0-9a-f]{2}/g, function (oct) {
    if (ii < 16) {
      // Don't overflow!
      buf[i + ii++] = _hexToByte[oct];
    }
  });

  // Zero out remaining bytes if string was short
  while (ii < 16) {
    buf[i + ii++] = 0;
  }

  return buf;
}

// **`unparse()` - Convert UUID byte array (ala parse()) into a string**
function unparse(buf, offset) {
  var i = offset || 0,
      bth = _byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = _rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0,
    _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; n++) {
    b[i + n] = node[n];
  }

  return buf ? buf : unparse(b);
}

// **`v4()` - Generate random UUID**

// See https://github.com/broofa/node-uuid for API details
function v4(options, buf, offset) {
  // Deprecated - 'format' argument, as supported in v1.2
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || _rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ii++) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || unparse(rnds);
}

// Export public API
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
uuid.parse = parse;
uuid.unparse = unparse;

module.exports = uuid;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9BY29zdGEvRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvbW9kdWxlL3V1aWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsSUFBSSxJQUFJLENBQUM7O0FBRVQsSUFBSSxTQUFTLEdBQUcsT0FBTyxNQUFNLEtBQUssV0FBVyxHQUN2QyxNQUFNLEdBQ04sT0FBTyxNQUFNLEtBQUssV0FBVyxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUM7O0FBRXBELElBQUksU0FBUyxJQUFJLFNBQVMsQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRTs7O0FBRzNELE1BQUksTUFBTSxHQUFHLElBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2hDLE1BQUksR0FBRyxTQUFTLFNBQVMsR0FBRztBQUMxQixVQUFNLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQy9CLFdBQU8sTUFBTSxDQUFDO0dBQ2YsQ0FBQztDQUNIOztBQUVELElBQUksQ0FBQyxJQUFJLEVBQUU7Ozs7O0FBS1QsTUFBSSxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDMUIsTUFBSSxHQUFHLFlBQVk7QUFDakIsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDOUIsVUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUEsS0FBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxXQUFXLENBQUM7QUFDdEQsV0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUEsSUFBSyxDQUFDLENBQUEsQUFBQyxHQUFHLElBQUksQ0FBQztLQUMzQzs7QUFFRCxXQUFPLEtBQUssQ0FBQztHQUNkLENBQUM7Q0FD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QUFHckQsTUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEFBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBSSxJQUFJLENBQUM7QUFDbEMsTUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEFBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBSSxJQUFJLENBQUM7OztBQUdsQyxNQUFJLEdBQUcsRUFBRTtBQUNQLFNBQUssSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDOUIsU0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDeEI7R0FDRjs7QUFFRCxTQUFPLEdBQUcsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDN0I7OztBQUdELElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNkLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO0FBQ2IsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDYixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNuQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQzs7QUFFdkIsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbInZhciBfcm5nO1xuXG52YXIgZ2xvYmFsVmFyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBudWxsO1xuXG5pZiAoZ2xvYmFsVmFyICYmIGdsb2JhbFZhci5jcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAvLyBXSEFUV0cgY3J5cHRvLWJhc2VkIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgLy8gTW9kZXJhdGVseSBmYXN0LCBoaWdoIHF1YWxpdHlcbiAgdmFyIF9ybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgX3JuZyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKF9ybmRzOCk7XG4gICAgcmV0dXJuIF9ybmRzODtcbiAgfTtcbn1cblxuaWYgKCFfcm5nKSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIF9ybmRzID0gbmV3IEFycmF5KDE2KTtcbiAgX3JuZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgX3JuZHNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9ybmRzO1xuICB9O1xufVxuXG4vLyAgICAgdXVpZC5qc1xuLy9cbi8vICAgICBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMiBSb2JlcnQgS2llZmZlclxuLy8gICAgIE1JVCBMaWNlbnNlIC0gaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXG4vLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgV2UgZmVhdHVyZVxuLy8gZGV0ZWN0IHRvIGRldGVybWluZSB0aGUgYmVzdCBSTkcgc291cmNlLCBub3JtYWxpemluZyB0byBhIGZ1bmN0aW9uIHRoYXRcbi8vIHJldHVybnMgMTI4LWJpdHMgb2YgcmFuZG9tbmVzcywgc2luY2UgdGhhdCdzIHdoYXQncyB1c3VhbGx5IHJlcXVpcmVkXG5cbi8vdmFyIF9ybmcgPSByZXF1aXJlKCcuL3JuZycpO1xuXG4vLyBNYXBzIGZvciBudW1iZXIgPC0+IGhleCBzdHJpbmcgY29udmVyc2lvblxudmFyIF9ieXRlVG9IZXggPSBbXTtcbnZhciBfaGV4VG9CeXRlID0ge307XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gIF9ieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xuICBfaGV4VG9CeXRlW19ieXRlVG9IZXhbaV1dID0gaTtcbn1cblxuLy8gKipgcGFyc2UoKWAgLSBQYXJzZSBhIFVVSUQgaW50byBpdCdzIGNvbXBvbmVudCBieXRlcyoqXG5mdW5jdGlvbiBwYXJzZShzLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IChidWYgJiYgb2Zmc2V0KSB8fCAwLCBpaSA9IDA7XG5cbiAgYnVmID0gYnVmIHx8IFtdO1xuICBzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWzAtOWEtZl17Mn0vZywgZnVuY3Rpb24gKG9jdCkge1xuICAgIGlmIChpaSA8IDE2KSB7IC8vIERvbid0IG92ZXJmbG93IVxuICAgICAgYnVmW2kgKyBpaSsrXSA9IF9oZXhUb0J5dGVbb2N0XTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFplcm8gb3V0IHJlbWFpbmluZyBieXRlcyBpZiBzdHJpbmcgd2FzIHNob3J0XG4gIHdoaWxlIChpaSA8IDE2KSB7XG4gICAgYnVmW2kgKyBpaSsrXSA9IDA7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufVxuXG4vLyAqKmB1bnBhcnNlKClgIC0gQ29udmVydCBVVUlEIGJ5dGUgYXJyYXkgKGFsYSBwYXJzZSgpKSBpbnRvIGEgc3RyaW5nKipcbmZ1bmN0aW9uIHVucGFyc2UoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMCwgYnRoID0gX2J5dGVUb0hleDtcbiAgcmV0dXJuIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dO1xufVxuXG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbi8vIHJhbmRvbSAjJ3Mgd2UgbmVlZCB0byBpbml0IG5vZGUgYW5kIGNsb2Nrc2VxXG52YXIgX3NlZWRCeXRlcyA9IF9ybmcoKTtcblxuLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG52YXIgX25vZGVJZCA9IFtcbiAgX3NlZWRCeXRlc1swXSB8IDB4MDEsXG4gIF9zZWVkQnl0ZXNbMV0sIF9zZWVkQnl0ZXNbMl0sIF9zZWVkQnl0ZXNbM10sIF9zZWVkQnl0ZXNbNF0sIF9zZWVkQnl0ZXNbNV1cbl07XG5cbi8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG52YXIgX2Nsb2Nrc2VxID0gKF9zZWVkQnl0ZXNbNl0gPDwgOCB8IF9zZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuXG4vLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbnZhciBfbGFzdE1TZWNzID0gMCwgX2xhc3ROU2VjcyA9IDA7XG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICB2YXIgYiA9IGJ1ZiB8fCBbXTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9XG5cbiAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfVxuXG4gIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAvLyBgdGltZV9taWRgXG4gIHZhciB0bWggPSAobXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAvLyBgbm9kZWBcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyBuKyspIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogdW5wYXJzZShiKTtcbn1cblxuLy8gKipgdjQoKWAgLSBHZW5lcmF0ZSByYW5kb20gVVVJRCoqXG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIC8vIERlcHJlY2F0ZWQgLSAnZm9ybWF0JyBhcmd1bWVudCwgYXMgc3VwcG9ydGVkIGluIHYxLjJcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7IGlpKyspIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCB1bnBhcnNlKHJuZHMpO1xufVxuXG4vLyBFeHBvcnQgcHVibGljIEFQSVxudmFyIHV1aWQgPSB2NDtcbnV1aWQudjEgPSB2MTtcbnV1aWQudjQgPSB2NDtcbnV1aWQucGFyc2UgPSBwYXJzZTtcbnV1aWQudW5wYXJzZSA9IHVucGFyc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gdXVpZDtcbiJdfQ==
},{}],35:[function(require,module,exports){
'use strict';

var keycharm = require('keycharm');
var Emitter = require('emitter-component');
var Hammer = require('../module/hammer');
var util = require('../util');

/**
 * Turn an element into an clickToUse element.
 * When not active, the element has a transparent overlay. When the overlay is
 * clicked, the mode is changed to active.
 * When active, the element is displayed with a blue border around it, and
 * the interactive contents of the element can be used. When clicked outside
 * the element, the elements mode is changed to inactive.
 * @param {Element} container
 * @constructor
 */
function Activator(container) {
  this.active = false;

  this.dom = {
    container: container
  };

  this.dom.overlay = document.createElement('div');
  this.dom.overlay.className = 'vis-overlay';

  this.dom.container.appendChild(this.dom.overlay);

  this.hammer = Hammer(this.dom.overlay);
  this.hammer.on('tap', this._onTapOverlay.bind(this));

  // block all touch events (except tap)
  var me = this;
  var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'];
  events.forEach(function (event) {
    me.hammer.on(event, function (event) {
      event.stopPropagation();
    });
  });

  // attach a click event to the window, in order to deactivate when clicking outside the timeline
  if (document && document.body) {
    this.onClick = function (event) {
      if (!_hasParent(event.target, container)) {
        me.deactivate();
      }
    };
    document.body.addEventListener('click', this.onClick);
  }

  if (this.keycharm !== undefined) {
    this.keycharm.destroy();
  }
  this.keycharm = keycharm();

  // keycharm listener only bounded when active)
  this.escListener = this.deactivate.bind(this);
}

// turn into an event emitter
Emitter(Activator.prototype);

// The currently active activator
Activator.current = null;

/**
 * Destroy the activator. Cleans up all created DOM and event listeners
 */
Activator.prototype.destroy = function () {
  this.deactivate();

  // remove dom
  this.dom.overlay.parentNode.removeChild(this.dom.overlay);

  // remove global event listener
  if (this.onClick) {
    document.body.removeEventListener('click', this.onClick);
  }

  // cleanup hammer instances
  this.hammer.destroy();
  this.hammer = null;
  // FIXME: cleaning up hammer instances doesn't work (Timeline not removed from memory)
};

/**
 * Activate the element
 * Overlay is hidden, element is decorated with a blue shadow border
 */
Activator.prototype.activate = function () {
  // we allow only one active activator at a time
  if (Activator.current) {
    Activator.current.deactivate();
  }
  Activator.current = this;

  this.active = true;
  this.dom.overlay.style.display = 'none';
  util.addClassName(this.dom.container, 'vis-active');

  this.emit('change');
  this.emit('activate');

  // ugly hack: bind ESC after emitting the events, as the Network rebinds all
  // keyboard events on a 'change' event
  this.keycharm.bind('esc', this.escListener);
};

/**
 * Deactivate the element
 * Overlay is displayed on top of the element
 */
Activator.prototype.deactivate = function () {
  this.active = false;
  this.dom.overlay.style.display = '';
  util.removeClassName(this.dom.container, 'vis-active');
  this.keycharm.unbind('esc', this.escListener);

  this.emit('change');
  this.emit('deactivate');
};

/**
 * Handle a tap event: activate the container
 * @param event
 * @private
 */
Activator.prototype._onTapOverlay = function (event) {
  // activate the container
  this.activate();
  event.stopPropagation();
};

/**
 * Test whether the element has the requested parent element somewhere in
 * its chain of parent nodes.
 * @param {HTMLElement} element
 * @param {HTMLElement} parent
 * @returns {boolean} Returns true when the parent is found somewhere in the
 *                    chain of parent nodes.
 * @private
 */
function _hasParent(element, parent) {
  while (element) {
    if (element === parent) {
      return true;
    }
    element = element.parentNode;
  }
  return false;
}

module.exports = Activator;

},{"../module/hammer":32,"../util":59,"emitter-component":60,"keycharm":62}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var Hammer = require('../module/hammer');
var hammerUtil = require('../hammerUtil');
var util = require('../util');

var ColorPicker = (function () {
  function ColorPicker() {
    var pixelRatio = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

    _classCallCheck(this, ColorPicker);

    this.pixelRatio = pixelRatio;
    this.generated = false;
    this.centerCoordinates = { x: 289 / 2, y: 289 / 2 };
    this.r = 289 * 0.49;
    this.color = { r: 255, g: 255, b: 255, a: 1.0 };
    this.hueCircle = undefined;
    this.initialColor = { r: 255, g: 255, b: 255, a: 1.0 };
    this.previousColor = undefined;
    this.applied = false;

    // bound by
    this.updateCallback = function () {};

    // create all DOM elements
    this._create();
  }

  /**
   * this inserts the colorPicker into a div from the DOM
   * @param container
   */

  _createClass(ColorPicker, [{
    key: 'insertTo',
    value: function insertTo(container) {
      if (this.hammer !== undefined) {
        this.hammer.destroy();
        this.hammer = undefined;
      }
      this.container = container;
      this.container.appendChild(this.frame);
      this._bindHammer();

      this._setSize();
    }

    /**
     * the callback is executed on apply and save. Bind it to the application
     * @param callback
     */
  }, {
    key: 'setCallback',
    value: function setCallback(callback) {
      if (typeof callback === 'function') {
        this.updateCallback = callback;
      } else {
        throw new Error("Function attempted to set as colorPicker callback is not a function.");
      }
    }
  }, {
    key: '_isColorString',
    value: function _isColorString(color) {
      var htmlColors = { black: '#000000', navy: '#000080', darkblue: '#00008B', mediumblue: '#0000CD', blue: '#0000FF', darkgreen: '#006400', green: '#008000', teal: '#008080', darkcyan: '#008B8B', deepskyblue: '#00BFFF', darkturquoise: '#00CED1', mediumspringgreen: '#00FA9A', lime: '#00FF00', springgreen: '#00FF7F', aqua: '#00FFFF', cyan: '#00FFFF', midnightblue: '#191970', dodgerblue: '#1E90FF', lightseagreen: '#20B2AA', forestgreen: '#228B22', seagreen: '#2E8B57', darkslategray: '#2F4F4F', limegreen: '#32CD32', mediumseagreen: '#3CB371', turquoise: '#40E0D0', royalblue: '#4169E1', steelblue: '#4682B4', darkslateblue: '#483D8B', mediumturquoise: '#48D1CC', indigo: '#4B0082', darkolivegreen: '#556B2F', cadetblue: '#5F9EA0', cornflowerblue: '#6495ED', mediumaquamarine: '#66CDAA', dimgray: '#696969', slateblue: '#6A5ACD', olivedrab: '#6B8E23', slategray: '#708090', lightslategray: '#778899', mediumslateblue: '#7B68EE', lawngreen: '#7CFC00', chartreuse: '#7FFF00', aquamarine: '#7FFFD4', maroon: '#800000', purple: '#800080', olive: '#808000', gray: '#808080', skyblue: '#87CEEB', lightskyblue: '#87CEFA', blueviolet: '#8A2BE2', darkred: '#8B0000', darkmagenta: '#8B008B', saddlebrown: '#8B4513', darkseagreen: '#8FBC8F', lightgreen: '#90EE90', mediumpurple: '#9370D8', darkviolet: '#9400D3', palegreen: '#98FB98', darkorchid: '#9932CC', yellowgreen: '#9ACD32', sienna: '#A0522D', brown: '#A52A2A', darkgray: '#A9A9A9', lightblue: '#ADD8E6', greenyellow: '#ADFF2F', paleturquoise: '#AFEEEE', lightsteelblue: '#B0C4DE', powderblue: '#B0E0E6', firebrick: '#B22222', darkgoldenrod: '#B8860B', mediumorchid: '#BA55D3', rosybrown: '#BC8F8F', darkkhaki: '#BDB76B', silver: '#C0C0C0', mediumvioletred: '#C71585', indianred: '#CD5C5C', peru: '#CD853F', chocolate: '#D2691E', tan: '#D2B48C', lightgrey: '#D3D3D3', palevioletred: '#D87093', thistle: '#D8BFD8', orchid: '#DA70D6', goldenrod: '#DAA520', crimson: '#DC143C', gainsboro: '#DCDCDC', plum: '#DDA0DD', burlywood: '#DEB887', lightcyan: '#E0FFFF', lavender: '#E6E6FA', darksalmon: '#E9967A', violet: '#EE82EE', palegoldenrod: '#EEE8AA', lightcoral: '#F08080', khaki: '#F0E68C', aliceblue: '#F0F8FF', honeydew: '#F0FFF0', azure: '#F0FFFF', sandybrown: '#F4A460', wheat: '#F5DEB3', beige: '#F5F5DC', whitesmoke: '#F5F5F5', mintcream: '#F5FFFA', ghostwhite: '#F8F8FF', salmon: '#FA8072', antiquewhite: '#FAEBD7', linen: '#FAF0E6', lightgoldenrodyellow: '#FAFAD2', oldlace: '#FDF5E6', red: '#FF0000', fuchsia: '#FF00FF', magenta: '#FF00FF', deeppink: '#FF1493', orangered: '#FF4500', tomato: '#FF6347', hotpink: '#FF69B4', coral: '#FF7F50', darkorange: '#FF8C00', lightsalmon: '#FFA07A', orange: '#FFA500', lightpink: '#FFB6C1', pink: '#FFC0CB', gold: '#FFD700', peachpuff: '#FFDAB9', navajowhite: '#FFDEAD', moccasin: '#FFE4B5', bisque: '#FFE4C4', mistyrose: '#FFE4E1', blanchedalmond: '#FFEBCD', papayawhip: '#FFEFD5', lavenderblush: '#FFF0F5', seashell: '#FFF5EE', cornsilk: '#FFF8DC', lemonchiffon: '#FFFACD', floralwhite: '#FFFAF0', snow: '#FFFAFA', yellow: '#FFFF00', lightyellow: '#FFFFE0', ivory: '#FFFFF0', white: '#FFFFFF' };
      if (typeof color === 'string') {
        return htmlColors[color];
      }
    }

    /**
     * Set the color of the colorPicker
     * Supported formats:
     * 'red'                   --> HTML color string
     * '#ffffff'               --> hex string
     * 'rbg(255,255,255)'      --> rgb string
     * 'rgba(255,255,255,1.0)' --> rgba string
     * {r:255,g:255,b:255}     --> rgb object
     * {r:255,g:255,b:255,a:1.0} --> rgba object
     * @param color
     * @param setInitial
     */
  }, {
    key: 'setColor',
    value: function setColor(color) {
      var setInitial = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

      if (color === 'none') {
        return;
      }

      var rgba = undefined;

      // if a html color shorthand is used, convert to hex
      var htmlColor = this._isColorString(color);
      if (htmlColor !== undefined) {
        color = htmlColor;
      }

      // check format
      if (util.isString(color) === true) {
        if (util.isValidRGB(color) === true) {
          var rgbaArray = color.substr(4).substr(0, color.length - 5).split(',');
          rgba = { r: rgbaArray[0], g: rgbaArray[1], b: rgbaArray[2], a: 1.0 };
        } else if (util.isValidRGBA(color) === true) {
          var rgbaArray = color.substr(5).substr(0, color.length - 6).split(',');
          rgba = { r: rgbaArray[0], g: rgbaArray[1], b: rgbaArray[2], a: rgbaArray[3] };
        } else if (util.isValidHex(color) === true) {
          var rgbObj = util.hexToRGB(color);
          rgba = { r: rgbObj.r, g: rgbObj.g, b: rgbObj.b, a: 1.0 };
        }
      } else {
        if (color instanceof Object) {
          if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {
            var alpha = color.a !== undefined ? color.a : '1.0';
            rgba = { r: color.r, g: color.g, b: color.b, a: alpha };
          }
        }
      }

      // set color
      if (rgba === undefined) {
        throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + JSON.stringify(color));
      } else {
        this._setColor(rgba, setInitial);
      }
    }

    /**
     * this shows the color picker at a location. The hue circle is constructed once and stored.
     * @param x
     * @param y
     */
  }, {
    key: 'show',
    value: function show(x, y) {
      this.applied = false;
      this.frame.style.display = 'block';
      this.frame.style.top = y + 'px';
      this.frame.style.left = x + 'px';
      this._generateHueCircle();
    }

    // ------------------------------------------ PRIVATE ----------------------------- //

    /**
     * Hide the picker. Is called by the cancel button.
     * Optional boolean to store the previous color for easy access later on.
     * @param storePrevious
     * @private
     */
  }, {
    key: '_hide',
    value: function _hide() {
      var storePrevious = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      // store the previous color for next time;
      if (storePrevious === true) {
        this.previousColor = util.extend({}, this.color);
      }

      if (this.applied === true) {
        this.updateCallback(this.initialColor);
      }

      this.frame.style.display = 'none';
    }

    /**
     * bound to the save button. Saves and hides.
     * @private
     */
  }, {
    key: '_save',
    value: function _save() {
      this.updateCallback(this.color);
      this.applied = false;
      this._hide();
    }

    /**
     * Bound to apply button. Saves but does not close. Is undone by the cancel button.
     * @private
     */
  }, {
    key: '_apply',
    value: function _apply() {
      this.applied = true;
      this.updateCallback(this.color);
      this._updatePicker(this.color);
    }

    /**
     * load the color from the previous session.
     * @private
     */
  }, {
    key: '_loadLast',
    value: function _loadLast() {
      if (this.previousColor !== undefined) {
        this.setColor(this.previousColor, false);
      } else {
        alert("There is no last color to load...");
      }
    }

    /**
     * set the color, place the picker
     * @param rgba
     * @param setInitial
     * @private
     */
  }, {
    key: '_setColor',
    value: function _setColor(rgba) {
      var setInitial = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

      // store the initial color
      if (setInitial === true) {
        this.initialColor = util.extend({}, rgba);
      }

      this.color = rgba;
      var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);

      var angleConvert = 2 * Math.PI;
      var radius = this.r * hsv.s;
      var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
      var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);

      this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + 'px';
      this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + 'px';

      this._updatePicker(rgba);
    }

    /**
     * bound to opacity control
     * @param value
     * @private
     */
  }, {
    key: '_setOpacity',
    value: function _setOpacity(value) {
      this.color.a = value / 100;
      this._updatePicker(this.color);
    }

    /**
     * bound to brightness control
     * @param value
     * @private
     */
  }, {
    key: '_setBrightness',
    value: function _setBrightness(value) {
      var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.v = value / 100;
      var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba['a'] = this.color.a;
      this.color = rgba;
      this._updatePicker();
    }

    /**
     * update the colorpicker. A black circle overlays the hue circle to mimic the brightness decreasing.
     * @param rgba
     * @private
     */
  }, {
    key: '_updatePicker',
    value: function _updatePicker() {
      var rgba = arguments.length <= 0 || arguments[0] === undefined ? this.color : arguments[0];

      var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);
      var ctx = this.colorPickerCanvas.getContext('2d');
      if (this.pixelRation === undefined) {
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
      }
      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

      // clear the canvas
      var w = this.colorPickerCanvas.clientWidth;
      var h = this.colorPickerCanvas.clientHeight;
      ctx.clearRect(0, 0, w, h);

      ctx.putImageData(this.hueCircle, 0, 0);
      ctx.fillStyle = 'rgba(0,0,0,' + (1 - hsv.v) + ')';
      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
      ctx.fill();

      this.brightnessRange.value = 100 * hsv.v;
      this.opacityRange.value = 100 * rgba.a;

      this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
      this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
    }

    /**
     * used by create to set the size of the canvas.
     * @private
     */
  }, {
    key: '_setSize',
    value: function _setSize() {
      this.colorPickerCanvas.style.width = '100%';
      this.colorPickerCanvas.style.height = '100%';

      this.colorPickerCanvas.width = 289 * this.pixelRatio;
      this.colorPickerCanvas.height = 289 * this.pixelRatio;
    }

    /**
     * create all dom elements
     * TODO: cleanup, lots of similar dom elements
     * @private
     */
  }, {
    key: '_create',
    value: function _create() {
      this.frame = document.createElement('div');
      this.frame.className = 'vis-color-picker';

      this.colorPickerDiv = document.createElement('div');
      this.colorPickerSelector = document.createElement('div');
      this.colorPickerSelector.className = 'vis-selector';
      this.colorPickerDiv.appendChild(this.colorPickerSelector);

      this.colorPickerCanvas = document.createElement('canvas');
      this.colorPickerDiv.appendChild(this.colorPickerCanvas);

      if (!this.colorPickerCanvas.getContext) {
        var noCanvas = document.createElement('DIV');
        noCanvas.style.color = 'red';
        noCanvas.style.fontWeight = 'bold';
        noCanvas.style.padding = '10px';
        noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
        this.colorPickerCanvas.appendChild(noCanvas);
      } else {
        var ctx = this.colorPickerCanvas.getContext("2d");
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

        this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      }

      this.colorPickerDiv.className = 'vis-color';

      this.opacityDiv = document.createElement('div');
      this.opacityDiv.className = 'vis-opacity';

      this.brightnessDiv = document.createElement('div');
      this.brightnessDiv.className = 'vis-brightness';

      this.arrowDiv = document.createElement('div');
      this.arrowDiv.className = 'vis-arrow';

      this.opacityRange = document.createElement('input');
      try {
        this.opacityRange.type = 'range'; // Not supported on IE9
        this.opacityRange.min = '0';
        this.opacityRange.max = '100';
      } catch (err) {}
      this.opacityRange.value = '100';
      this.opacityRange.className = 'vis-range';

      this.brightnessRange = document.createElement('input');
      try {
        this.brightnessRange.type = 'range'; // Not supported on IE9
        this.brightnessRange.min = '0';
        this.brightnessRange.max = '100';
      } catch (err) {}
      this.brightnessRange.value = '100';
      this.brightnessRange.className = 'vis-range';

      this.opacityDiv.appendChild(this.opacityRange);
      this.brightnessDiv.appendChild(this.brightnessRange);

      var me = this;
      this.opacityRange.onchange = function () {
        me._setOpacity(this.value);
      };
      this.opacityRange.oninput = function () {
        me._setOpacity(this.value);
      };
      this.brightnessRange.onchange = function () {
        me._setBrightness(this.value);
      };
      this.brightnessRange.oninput = function () {
        me._setBrightness(this.value);
      };

      this.brightnessLabel = document.createElement("div");
      this.brightnessLabel.className = "vis-label vis-brightness";
      this.brightnessLabel.innerHTML = 'brightness:';

      this.opacityLabel = document.createElement("div");
      this.opacityLabel.className = "vis-label vis-opacity";
      this.opacityLabel.innerHTML = 'opacity:';

      this.newColorDiv = document.createElement("div");
      this.newColorDiv.className = "vis-new-color";
      this.newColorDiv.innerHTML = 'new';

      this.initialColorDiv = document.createElement("div");
      this.initialColorDiv.className = "vis-initial-color";
      this.initialColorDiv.innerHTML = 'initial';

      this.cancelButton = document.createElement("div");
      this.cancelButton.className = "vis-button vis-cancel";
      this.cancelButton.innerHTML = 'cancel';
      this.cancelButton.onclick = this._hide.bind(this, false);

      this.applyButton = document.createElement("div");
      this.applyButton.className = "vis-button vis-apply";
      this.applyButton.innerHTML = 'apply';
      this.applyButton.onclick = this._apply.bind(this);

      this.saveButton = document.createElement("div");
      this.saveButton.className = "vis-button vis-save";
      this.saveButton.innerHTML = 'save';
      this.saveButton.onclick = this._save.bind(this);

      this.loadButton = document.createElement("div");
      this.loadButton.className = "vis-button vis-load";
      this.loadButton.innerHTML = 'load last';
      this.loadButton.onclick = this._loadLast.bind(this);

      this.frame.appendChild(this.colorPickerDiv);
      this.frame.appendChild(this.arrowDiv);
      this.frame.appendChild(this.brightnessLabel);
      this.frame.appendChild(this.brightnessDiv);
      this.frame.appendChild(this.opacityLabel);
      this.frame.appendChild(this.opacityDiv);
      this.frame.appendChild(this.newColorDiv);
      this.frame.appendChild(this.initialColorDiv);

      this.frame.appendChild(this.cancelButton);
      this.frame.appendChild(this.applyButton);
      this.frame.appendChild(this.saveButton);
      this.frame.appendChild(this.loadButton);
    }

    /**
     * bind hammer to the color picker
     * @private
     */
  }, {
    key: '_bindHammer',
    value: function _bindHammer() {
      var _this = this;

      this.drag = {};
      this.pinch = {};
      this.hammer = new Hammer(this.colorPickerCanvas);
      this.hammer.get('pinch').set({ enable: true });

      hammerUtil.onTouch(this.hammer, function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('tap', function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('panstart', function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('panmove', function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('panend', function (event) {
        _this._moveSelector(event);
      });
    }

    /**
     * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
     * @private
     */
  }, {
    key: '_generateHueCircle',
    value: function _generateHueCircle() {
      if (this.generated === false) {
        var ctx = this.colorPickerCanvas.getContext('2d');
        if (this.pixelRation === undefined) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }
        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

        // clear the canvas
        var w = this.colorPickerCanvas.clientWidth;
        var h = this.colorPickerCanvas.clientHeight;
        ctx.clearRect(0, 0, w, h);

        // draw hue circle
        var x = undefined,
            y = undefined,
            hue = undefined,
            sat = undefined;
        this.centerCoordinates = { x: w * 0.5, y: h * 0.5 };
        this.r = 0.49 * w;
        var angleConvert = 2 * Math.PI / 360;
        var hfac = 1 / 360;
        var sfac = 1 / this.r;
        var rgb = undefined;
        for (hue = 0; hue < 360; hue++) {
          for (sat = 0; sat < this.r; sat++) {
            x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
            y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
            rgb = util.HSVToRGB(hue * hfac, sat * sfac, 1);
            ctx.fillStyle = 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
            ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
          }
        }
        ctx.strokeStyle = 'rgba(0,0,0,1)';
        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
        ctx.stroke();

        this.hueCircle = ctx.getImageData(0, 0, w, h);
      }
      this.generated = true;
    }

    /**
     * move the selector. This is called by hammer functions.
     *
     * @param event
     * @private
     */
  }, {
    key: '_moveSelector',
    value: function _moveSelector(event) {
      var rect = this.colorPickerDiv.getBoundingClientRect();
      var left = event.center.x - rect.left;
      var top = event.center.y - rect.top;

      var centerY = 0.5 * this.colorPickerDiv.clientHeight;
      var centerX = 0.5 * this.colorPickerDiv.clientWidth;

      var x = left - centerX;
      var y = top - centerY;

      var angle = Math.atan2(x, y);
      var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);

      var newTop = Math.cos(angle) * radius + centerY;
      var newLeft = Math.sin(angle) * radius + centerX;

      this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + 'px';
      this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + 'px';

      // set color
      var h = angle / (2 * Math.PI);
      h = h < 0 ? h + 1 : h;
      var s = radius / this.r;
      var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.h = h;
      hsv.s = s;
      var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba['a'] = this.color.a;
      this.color = rgba;

      // update previews
      this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
      this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
    }
  }]);

  return ColorPicker;
})();

exports['default'] = ColorPicker;
module.exports = exports['default'];

},{"../hammerUtil":31,"../module/hammer":32,"../util":59}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _ColorPicker = require('./ColorPicker');

var _ColorPicker2 = _interopRequireDefault(_ColorPicker);

/**
 * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.
 * Boolean options are recognised as Boolean
 * Number options should be written as array: [default value, min value, max value, stepsize]
 * Colors should be written as array: ['color', '#ffffff']
 * Strings with should be written as array: [option1, option2, option3, ..]
 *
 * The options are matched with their counterparts in each of the modules and the values used in the configuration are
 *
 * @param parentModule        | the location where parentModule.setOptions() can be called
 * @param defaultContainer    | the default container of the module
 * @param configureOptions    | the fully configured and predefined options set found in allOptions.js
 * @param pixelRatio          | canvas pixel ratio
 */
var util = require('../util');

var Configurator = (function () {
  function Configurator(parentModule, defaultContainer, configureOptions) {
    var pixelRatio = arguments.length <= 3 || arguments[3] === undefined ? 1 : arguments[3];

    _classCallCheck(this, Configurator);

    this.parent = parentModule;
    this.changedOptions = [];
    this.container = defaultContainer;
    this.allowCreation = false;

    this.options = {};
    this.initialized = false;
    this.popupCounter = 0;
    this.defaultOptions = {
      enabled: false,
      filter: true,
      container: undefined,
      showButton: true
    };
    util.extend(this.options, this.defaultOptions);

    this.configureOptions = configureOptions;
    this.moduleOptions = {};
    this.domElements = [];
    this.popupDiv = {};
    this.popupLimit = 5;
    this.popupHistory = {};
    this.colorPicker = new _ColorPicker2['default'](pixelRatio);
    this.wrapper = undefined;
  }

  /**
   * refresh all options.
   * Because all modules parse their options by themselves, we just use their options. We copy them here.
   *
   * @param options
   */

  _createClass(Configurator, [{
    key: 'setOptions',
    value: function setOptions(options) {
      if (options !== undefined) {
        // reset the popup history because the indices may have been changed.
        this.popupHistory = {};
        this._removePopup();

        var enabled = true;
        if (typeof options === 'string') {
          this.options.filter = options;
        } else if (options instanceof Array) {
          this.options.filter = options.join();
        } else if (typeof options === 'object') {
          if (options.container !== undefined) {
            this.options.container = options.container;
          }
          if (options.filter !== undefined) {
            this.options.filter = options.filter;
          }
          if (options.showButton !== undefined) {
            this.options.showButton = options.showButton;
          }
          if (options.enabled !== undefined) {
            enabled = options.enabled;
          }
        } else if (typeof options === 'boolean') {
          this.options.filter = true;
          enabled = options;
        } else if (typeof options === 'function') {
          this.options.filter = options;
          enabled = true;
        }
        if (this.options.filter === false) {
          enabled = false;
        }

        this.options.enabled = enabled;
      }
      this._clean();
    }
  }, {
    key: 'setModuleOptions',
    value: function setModuleOptions(moduleOptions) {
      this.moduleOptions = moduleOptions;
      if (this.options.enabled === true) {
        this._clean();
        if (this.options.container !== undefined) {
          this.container = this.options.container;
        }
        this._create();
      }
    }

    /**
     * Create all DOM elements
     * @private
     */
  }, {
    key: '_create',
    value: function _create() {
      var _this = this;

      this._clean();
      this.changedOptions = [];

      var filter = this.options.filter;
      var counter = 0;
      var show = false;
      for (var option in this.configureOptions) {
        if (this.configureOptions.hasOwnProperty(option)) {
          this.allowCreation = false;
          show = false;
          if (typeof filter === 'function') {
            show = filter(option, []);
            show = show || this._handleObject(this.configureOptions[option], [option], true);
          } else if (filter === true || filter.indexOf(option) !== -1) {
            show = true;
          }

          if (show !== false) {
            this.allowCreation = true;

            // linebreak between categories
            if (counter > 0) {
              this._makeItem([]);
            }
            // a header for the category
            this._makeHeader(option);

            // get the suboptions
            this._handleObject(this.configureOptions[option], [option]);
          }
          counter++;
        }
      }

      if (this.options.showButton === true) {
        (function () {
          var generateButton = document.createElement('div');
          generateButton.className = 'vis-configuration vis-config-button';
          generateButton.innerHTML = 'generate options';
          generateButton.onclick = function () {
            _this._printOptions();
          };
          generateButton.onmouseover = function () {
            generateButton.className = 'vis-configuration vis-config-button hover';
          };
          generateButton.onmouseout = function () {
            generateButton.className = 'vis-configuration vis-config-button';
          };

          _this.optionsContainer = document.createElement('div');
          _this.optionsContainer.className = 'vis-configuration vis-config-option-container';

          _this.domElements.push(_this.optionsContainer);
          _this.domElements.push(generateButton);
        })();
      }

      this._push();
      this.colorPicker.insertTo(this.container);
    }

    /**
     * draw all DOM elements on the screen
     * @private
     */
  }, {
    key: '_push',
    value: function _push() {
      this.wrapper = document.createElement('div');
      this.wrapper.className = 'vis-configuration-wrapper';
      this.container.appendChild(this.wrapper);
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.appendChild(this.domElements[i]);
      }

      this._showPopupIfNeeded();
    }

    /**
     * delete all DOM elements
     * @private
     */
  }, {
    key: '_clean',
    value: function _clean() {
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.removeChild(this.domElements[i]);
      }

      if (this.wrapper !== undefined) {
        this.container.removeChild(this.wrapper);
        this.wrapper = undefined;
      }
      this.domElements = [];

      this._removePopup();
    }

    /**
     * get the value from the actualOptions if it exists
     * @param {array} path    | where to look for the actual option
     * @returns {*}
     * @private
     */
  }, {
    key: '_getValue',
    value: function _getValue(path) {
      var base = this.moduleOptions;
      for (var i = 0; i < path.length; i++) {
        if (base[path[i]] !== undefined) {
          base = base[path[i]];
        } else {
          base = undefined;
          break;
        }
      }
      return base;
    }

    /**
     * all option elements are wrapped in an item
     * @param path
     * @param domElements
     * @private
     */
  }, {
    key: '_makeItem',
    value: function _makeItem(path) {
      var _arguments = arguments,
          _this2 = this;

      if (this.allowCreation === true) {
        var _len, domElements, _key;

        var _ret2 = (function () {
          var item = document.createElement('div');
          item.className = 'vis-configuration vis-config-item vis-config-s' + path.length;

          for (_len = _arguments.length, domElements = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            domElements[_key - 1] = _arguments[_key];
          }

          domElements.forEach(function (element) {
            item.appendChild(element);
          });
          _this2.domElements.push(item);
          return {
            v: _this2.domElements.length
          };
        })();

        if (typeof _ret2 === 'object') return _ret2.v;
      }
      return 0;
    }

    /**
     * header for major subjects
     * @param name
     * @private
     */
  }, {
    key: '_makeHeader',
    value: function _makeHeader(name) {
      var div = document.createElement('div');
      div.className = 'vis-configuration vis-config-header';
      div.innerHTML = name;
      this._makeItem([], div);
    }

    /**
     * make a label, if it is an object label, it gets different styling.
     * @param name
     * @param path
     * @param objectLabel
     * @returns {HTMLElement}
     * @private
     */
  }, {
    key: '_makeLabel',
    value: function _makeLabel(name, path) {
      var objectLabel = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var div = document.createElement('div');
      div.className = 'vis-configuration vis-config-label vis-config-s' + path.length;
      if (objectLabel === true) {
        div.innerHTML = '<i><b>' + name + ':</b></i>';
      } else {
        div.innerHTML = name + ':';
      }
      return div;
    }

    /**
     * make a dropdown list for multiple possible string optoins
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeDropdown',
    value: function _makeDropdown(arr, value, path) {
      var select = document.createElement('select');
      select.className = 'vis-configuration vis-config-select';
      var selectedValue = 0;
      if (value !== undefined) {
        if (arr.indexOf(value) !== -1) {
          selectedValue = arr.indexOf(value);
        }
      }

      for (var i = 0; i < arr.length; i++) {
        var option = document.createElement('option');
        option.value = arr[i];
        if (i === selectedValue) {
          option.selected = 'selected';
        }
        option.innerHTML = arr[i];
        select.appendChild(option);
      }

      var me = this;
      select.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, select);
    }

    /**
     * make a range object for numeric options
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeRange',
    value: function _makeRange(arr, value, path) {
      var defaultValue = arr[0];
      var min = arr[1];
      var max = arr[2];
      var step = arr[3];
      var range = document.createElement('input');
      range.className = 'vis-configuration vis-config-range';
      try {
        range.type = 'range'; // not supported on IE9
        range.min = min;
        range.max = max;
      } catch (err) {}
      range.step = step;

      // set up the popup settings in case they are needed.
      var popupString = '';
      var popupValue = 0;

      if (value !== undefined) {
        var factor = 1.20;
        if (value < 0 && value * factor < min) {
          range.min = Math.ceil(value * factor);
          popupValue = range.min;
          popupString = 'range increased';
        } else if (value / factor < min) {
          range.min = Math.ceil(value / factor);
          popupValue = range.min;
          popupString = 'range increased';
        }
        if (value * factor > max && max !== 1) {
          range.max = Math.ceil(value * factor);
          popupValue = range.max;
          popupString = 'range increased';
        }
        range.value = value;
      } else {
        range.value = defaultValue;
      }

      var input = document.createElement('input');
      input.className = 'vis-configuration vis-config-rangeinput';
      input.value = range.value;

      var me = this;
      range.onchange = function () {
        input.value = this.value;me._update(Number(this.value), path);
      };
      range.oninput = function () {
        input.value = this.value;
      };

      var label = this._makeLabel(path[path.length - 1], path);
      var itemIndex = this._makeItem(path, label, range, input);

      // if a popup is needed AND it has not been shown for this value, show it.
      if (popupString !== '' && this.popupHistory[itemIndex] !== popupValue) {
        this.popupHistory[itemIndex] = popupValue;
        this._setupPopup(popupString, itemIndex);
      }
    }

    /**
     * prepare the popup
     * @param string
     * @param index
     * @private
     */
  }, {
    key: '_setupPopup',
    value: function _setupPopup(string, index) {
      var _this3 = this;

      if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
        var div = document.createElement("div");
        div.id = "vis-configuration-popup";
        div.className = "vis-configuration-popup";
        div.innerHTML = string;
        div.onclick = function () {
          _this3._removePopup();
        };
        this.popupCounter += 1;
        this.popupDiv = { html: div, index: index };
      }
    }

    /**
     * remove the popup from the dom
     * @private
     */
  }, {
    key: '_removePopup',
    value: function _removePopup() {
      if (this.popupDiv.html !== undefined) {
        this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
        clearTimeout(this.popupDiv.hideTimeout);
        clearTimeout(this.popupDiv.deleteTimeout);
        this.popupDiv = {};
      }
    }

    /**
     * Show the popup if it is needed.
     * @private
     */
  }, {
    key: '_showPopupIfNeeded',
    value: function _showPopupIfNeeded() {
      var _this4 = this;

      if (this.popupDiv.html !== undefined) {
        var correspondingElement = this.domElements[this.popupDiv.index];
        var rect = correspondingElement.getBoundingClientRect();
        this.popupDiv.html.style.left = rect.left + "px";
        this.popupDiv.html.style.top = rect.top - 30 + "px"; // 30 is the height;
        document.body.appendChild(this.popupDiv.html);
        this.popupDiv.hideTimeout = setTimeout(function () {
          _this4.popupDiv.html.style.opacity = 0;
        }, 1500);
        this.popupDiv.deleteTimeout = setTimeout(function () {
          _this4._removePopup();
        }, 1800);
      }
    }

    /**
     * make a checkbox for boolean options.
     * @param defaultValue
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeCheckbox',
    value: function _makeCheckbox(defaultValue, value, path) {
      var checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'vis-configuration vis-config-checkbox';
      checkbox.checked = defaultValue;
      if (value !== undefined) {
        checkbox.checked = value;
        if (value !== defaultValue) {
          if (typeof defaultValue === 'object') {
            if (value !== defaultValue.enabled) {
              this.changedOptions.push({ path: path, value: value });
            }
          } else {
            this.changedOptions.push({ path: path, value: value });
          }
        }
      }

      var me = this;
      checkbox.onchange = function () {
        me._update(this.checked, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, checkbox);
    }

    /**
     * make a text input field for string options.
     * @param defaultValue
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeTextInput',
    value: function _makeTextInput(defaultValue, value, path) {
      var checkbox = document.createElement('input');
      checkbox.type = 'text';
      checkbox.className = 'vis-configuration vis-config-text';
      checkbox.value = value;
      if (value !== defaultValue) {
        this.changedOptions.push({ path: path, value: value });
      }

      var me = this;
      checkbox.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, checkbox);
    }

    /**
     * make a color field with a color picker for color fields
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeColorField',
    value: function _makeColorField(arr, value, path) {
      var _this5 = this;

      var defaultColor = arr[1];
      var div = document.createElement('div');
      value = value === undefined ? defaultColor : value;

      if (value !== 'none') {
        div.className = 'vis-configuration vis-config-colorBlock';
        div.style.backgroundColor = value;
      } else {
        div.className = 'vis-configuration vis-config-colorBlock none';
      }

      value = value === undefined ? defaultColor : value;
      div.onclick = function () {
        _this5._showColorPicker(value, div, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, div);
    }

    /**
     * used by the color buttons to call the color picker.
     * @param event
     * @param value
     * @param div
     * @param path
     * @private
     */
  }, {
    key: '_showColorPicker',
    value: function _showColorPicker(value, div, path) {
      var _this6 = this;

      var rect = div.getBoundingClientRect();
      var bodyRect = document.body.getBoundingClientRect();
      var pickerX = rect.left + rect.width + 5;
      var pickerY = rect.top - bodyRect.top + rect.height + 2;
      this.colorPicker.show(pickerX, pickerY);
      this.colorPicker.setColor(value);
      this.colorPicker.setCallback(function (color) {
        var colorString = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + color.a + ')';
        div.style.backgroundColor = colorString;
        _this6._update(colorString, path);
      });
    }

    /**
     * parse an object and draw the correct items
     * @param obj
     * @param path
     * @private
     */
  }, {
    key: '_handleObject',
    value: function _handleObject(obj) {
      var path = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
      var checkOnly = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var show = false;
      var filter = this.options.filter;
      var visibleInSet = false;
      for (var subObj in obj) {
        if (obj.hasOwnProperty(subObj)) {
          show = true;
          var item = obj[subObj];
          var newPath = util.copyAndExtendArray(path, subObj);
          if (typeof filter === 'function') {
            show = filter(subObj, path);

            // if needed we must go deeper into the object.
            if (show === false) {
              if (!(item instanceof Array) && typeof item !== 'string' && typeof item !== 'boolean' && item instanceof Object) {
                this.allowCreation = false;
                show = this._handleObject(item, newPath, true);
                this.allowCreation = checkOnly === false;
              }
            }
          }

          if (show !== false) {
            visibleInSet = true;
            var value = this._getValue(newPath);

            if (item instanceof Array) {
              this._handleArray(item, value, newPath);
            } else if (typeof item === 'string') {
              this._makeTextInput(item, value, newPath);
            } else if (typeof item === 'boolean') {
              this._makeCheckbox(item, value, newPath);
            } else if (item instanceof Object) {
              // collapse the physics options that are not enabled
              var draw = true;
              if (path.indexOf('physics') !== -1) {
                if (this.moduleOptions.physics.solver !== subObj) {
                  draw = false;
                }
              }

              if (draw === true) {
                // initially collapse options with an disabled enabled option.
                if (item.enabled !== undefined) {
                  var enabledPath = util.copyAndExtendArray(newPath, 'enabled');
                  var enabledValue = this._getValue(enabledPath);
                  if (enabledValue === true) {
                    var label = this._makeLabel(subObj, newPath, true);
                    this._makeItem(newPath, label);
                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                  } else {
                    this._makeCheckbox(item, enabledValue, newPath);
                  }
                } else {
                  var label = this._makeLabel(subObj, newPath, true);
                  this._makeItem(newPath, label);
                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                }
              }
            } else {
              console.error('dont know how to handle', item, subObj, newPath);
            }
          }
        }
      }
      return visibleInSet;
    }

    /**
     * handle the array type of option
     * @param optionName
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_handleArray',
    value: function _handleArray(arr, value, path) {
      if (typeof arr[0] === 'string' && arr[0] === 'color') {
        this._makeColorField(arr, value, path);
        if (arr[1] !== value) {
          this.changedOptions.push({ path: path, value: value });
        }
      } else if (typeof arr[0] === 'string') {
        this._makeDropdown(arr, value, path);
        if (arr[0] !== value) {
          this.changedOptions.push({ path: path, value: value });
        }
      } else if (typeof arr[0] === 'number') {
        this._makeRange(arr, value, path);
        if (arr[0] !== value) {
          this.changedOptions.push({ path: path, value: Number(value) });
        }
      }
    }

    /**
     * called to update the network with the new settings.
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_update',
    value: function _update(value, path) {
      var options = this._constructOptions(value, path);

      if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
        this.parent.body.emitter.emit("configChange", options);
      }
      this.initialized = true;
      this.parent.setOptions(options);
    }
  }, {
    key: '_constructOptions',
    value: function _constructOptions(value, path) {
      var optionsObj = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      var pointer = optionsObj;

      // when dropdown boxes can be string or boolean, we typecast it into correct types
      value = value === 'true' ? true : value;
      value = value === 'false' ? false : value;

      for (var i = 0; i < path.length; i++) {
        if (path[i] !== 'global') {
          if (pointer[path[i]] === undefined) {
            pointer[path[i]] = {};
          }
          if (i !== path.length - 1) {
            pointer = pointer[path[i]];
          } else {
            pointer[path[i]] = value;
          }
        }
      }
      return optionsObj;
    }
  }, {
    key: '_printOptions',
    value: function _printOptions() {
      var options = this.getOptions();
      this.optionsContainer.innerHTML = '<pre>var options = ' + JSON.stringify(options, null, 2) + '</pre>';
    }
  }, {
    key: 'getOptions',
    value: function getOptions() {
      var options = {};
      for (var i = 0; i < this.changedOptions.length; i++) {
        this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
      }
      return options;
    }
  }]);

  return Configurator;
})();

exports['default'] = Configurator;
module.exports = exports['default'];

},{"../util":59,"./ColorPicker":36}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var util = require('../util');

var errorFound = false;
var allOptions = undefined;
var printStyle = 'background: #FFeeee; color: #dd0000';
/**
 *  Used to validate options.
 */

var Validator = (function () {
  function Validator() {
    _classCallCheck(this, Validator);
  }

  /**
   * Main function to be called
   * @param options
   * @param subObject
   * @returns {boolean}
   */

  _createClass(Validator, null, [{
    key: 'validate',
    value: function validate(options, referenceOptions, subObject) {
      errorFound = false;
      allOptions = referenceOptions;
      var usedOptions = referenceOptions;
      if (subObject !== undefined) {
        usedOptions = referenceOptions[subObject];
      }
      Validator.parse(options, usedOptions, []);
      return errorFound;
    }

    /**
     * Will traverse an object recursively and check every value
     * @param options
     * @param referenceOptions
     * @param path
     */
  }, {
    key: 'parse',
    value: function parse(options, referenceOptions, path) {
      for (var option in options) {
        if (options.hasOwnProperty(option)) {
          Validator.check(option, options, referenceOptions, path);
        }
      }
    }

    /**
     * Check every value. If the value is an object, call the parse function on that object.
     * @param option
     * @param options
     * @param referenceOptions
     * @param path
     */
  }, {
    key: 'check',
    value: function check(option, options, referenceOptions, path) {
      if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {
        Validator.getSuggestion(option, referenceOptions, path);
      } else if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {
        // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.
        if (Validator.getType(options[option]) === 'object' && referenceOptions['__any__'].__type__ !== undefined) {
          // if the any subgroup is not a predefined object int he configurator we do not look deeper into the object.
          Validator.checkFields(option, options, referenceOptions, '__any__', referenceOptions['__any__'].__type__, path);
        } else {
          Validator.checkFields(option, options, referenceOptions, '__any__', referenceOptions['__any__'], path);
        }
      } else {
        // Since all options in the reference are objects, we can check whether they are supposed to be object to look for the __type__ field.
        if (referenceOptions[option].__type__ !== undefined) {
          // if this should be an object, we check if the correct type has been supplied to account for shorthand options.
          Validator.checkFields(option, options, referenceOptions, option, referenceOptions[option].__type__, path);
        } else {
          Validator.checkFields(option, options, referenceOptions, option, referenceOptions[option], path);
        }
      }
    }

    /**
     *
     * @param {String}  option     | the option property
     * @param {Object}  options    | The supplied options object
     * @param {Object}  referenceOptions    | The reference options containing all options and their allowed formats
     * @param {String}  referenceOption     | Usually this is the same as option, except when handling an __any__ tag.
     * @param {String}  refOptionType       | This is the type object from the reference options
     * @param {Array}   path      | where in the object is the option
     */
  }, {
    key: 'checkFields',
    value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {
      var optionType = Validator.getType(options[option]);
      var refOptionType = refOptionObj[optionType];
      if (refOptionType !== undefined) {
        // if the type is correct, we check if it is supposed to be one of a few select values
        if (Validator.getType(refOptionType) === 'array') {
          if (refOptionType.indexOf(options[option]) === -1) {
            console.log('%cInvalid option detected in "' + option + '".' + ' Allowed values are:' + Validator.print(refOptionType) + ' not "' + options[option] + '". ' + Validator.printLocation(path, option), printStyle);
            errorFound = true;
          } else if (optionType === 'object' && referenceOption !== "__any__") {
            path = util.copyAndExtendArray(path, option);
            Validator.parse(options[option], referenceOptions[referenceOption], path);
          }
        } else if (optionType === 'object' && referenceOption !== "__any__") {
          path = util.copyAndExtendArray(path, option);
          Validator.parse(options[option], referenceOptions[referenceOption], path);
        }
      } else if (refOptionObj['any'] === undefined) {
        // type of the field is incorrect and the field cannot be any
        console.log('%cInvalid type received for "' + option + '". Expected: ' + Validator.print(Object.keys(refOptionObj)) + '. Received [' + optionType + '] "' + options[option] + '"' + Validator.printLocation(path, option), printStyle);
        errorFound = true;
      }
    }
  }, {
    key: 'getType',
    value: function getType(object) {
      var type = typeof object;

      if (type === 'object') {
        if (object === null) {
          return 'null';
        }
        if (object instanceof Boolean) {
          return 'boolean';
        }
        if (object instanceof Number) {
          return 'number';
        }
        if (object instanceof String) {
          return 'string';
        }
        if (Array.isArray(object)) {
          return 'array';
        }
        if (object instanceof Date) {
          return 'date';
        }
        if (object.nodeType !== undefined) {
          return 'dom';
        }
        if (object._isAMomentObject === true) {
          return 'moment';
        }
        return 'object';
      } else if (type === 'number') {
        return 'number';
      } else if (type === 'boolean') {
        return 'boolean';
      } else if (type === 'string') {
        return 'string';
      } else if (type === undefined) {
        return 'undefined';
      }
      return type;
    }
  }, {
    key: 'getSuggestion',
    value: function getSuggestion(option, options, path) {
      var localSearch = Validator.findInOptions(option, options, path, false);
      var globalSearch = Validator.findInOptions(option, allOptions, [], true);

      var localSearchThreshold = 8;
      var globalSearchThreshold = 4;

      if (localSearch.indexMatch !== undefined) {
        console.log('%cUnknown option detected: "' + option + '" in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n', printStyle);
      } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
        console.log('%cUnknown option detected: "' + option + '" in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was misplaced? Matching option found at: ' + Validator.printLocation(globalSearch.path, globalSearch.closestMatch, ''), printStyle);
      } else if (localSearch.distance <= localSearchThreshold) {
        console.log('%cUnknown option detected: "' + option + '". Did you mean "' + localSearch.closestMatch + '"?' + Validator.printLocation(localSearch.path, option), printStyle);
      } else {
        console.log('%cUnknown option detected: "' + option + '". Did you mean one of these: ' + Validator.print(Object.keys(options)) + Validator.printLocation(path, option), printStyle);
      }

      errorFound = true;
    }

    /**
     * traverse the options in search for a match.
     * @param option
     * @param options
     * @param path
     * @param recursive
     * @returns {{closestMatch: string, path: Array, distance: number}}
     */
  }, {
    key: 'findInOptions',
    value: function findInOptions(option, options, path) {
      var recursive = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

      var min = 1e9;
      var closestMatch = '';
      var closestMatchPath = [];
      var lowerCaseOption = option.toLowerCase();
      var indexMatch = undefined;
      for (var op in options) {
        var distance = undefined;
        if (options[op].__type__ !== undefined && recursive === true) {
          var result = Validator.findInOptions(option, options[op], util.copyAndExtendArray(path, op));
          if (min > result.distance) {
            closestMatch = result.closestMatch;
            closestMatchPath = result.path;
            min = result.distance;
            indexMatch = result.indexMatch;
          }
        } else {
          if (op.toLowerCase().indexOf(lowerCaseOption) !== -1) {
            indexMatch = op;
          }
          distance = Validator.levenshteinDistance(option, op);
          if (min > distance) {
            closestMatch = op;
            closestMatchPath = util.copyArray(path);
            min = distance;
          }
        }
      }
      return { closestMatch: closestMatch, path: closestMatchPath, distance: min, indexMatch: indexMatch };
    }
  }, {
    key: 'printLocation',
    value: function printLocation(path, option) {
      var prefix = arguments.length <= 2 || arguments[2] === undefined ? 'Problem value found at: \n' : arguments[2];

      var str = '\n\n' + prefix + 'options = {\n';
      for (var i = 0; i < path.length; i++) {
        for (var j = 0; j < i + 1; j++) {
          str += '  ';
        }
        str += path[i] + ': {\n';
      }
      for (var j = 0; j < path.length + 1; j++) {
        str += '  ';
      }
      str += option + '\n';
      for (var i = 0; i < path.length + 1; i++) {
        for (var j = 0; j < path.length - i; j++) {
          str += '  ';
        }
        str += '}\n';
      }
      return str + '\n\n';
    }
  }, {
    key: 'print',
    value: function print(options) {
      return JSON.stringify(options).replace(/(\")|(\[)|(\])|(,"__type__")/g, "").replace(/(\,)/g, ', ');
    }

    // Compute the edit distance between the two given strings
    // http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
    /*
     Copyright (c) 2011 Andrei Mackenzie
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
  }, {
    key: 'levenshteinDistance',
    value: function levenshteinDistance(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;

      var matrix = [];

      // increment along the first column of each row
      var i;
      for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }

      // increment each column in the first row
      var j;
      for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }

      // Fill in the rest of the matrix
      for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) == a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
            Math.min(matrix[i][j - 1] + 1, // insertion
            matrix[i - 1][j] + 1)); // deletion
          }
        }
      }

      return matrix[b.length][a.length];
    }
  }]);

  return Validator;
})();

exports['default'] = Validator;
exports.printStyle = printStyle;

},{"../util":59}],39:[function(require,module,exports){
'use strict';

var Emitter = require('emitter-component');
var Hammer = require('../module/hammer');
var hammerUtil = require('../hammerUtil');
var util = require('../util');
var DataSet = require('../DataSet');
var DataView = require('../DataView');
var Range = require('./Range');
var ItemSet = require('./component/ItemSet');
var TimeAxis = require('./component/TimeAxis');
var Activator = require('../shared/Activator');
var DateUtil = require('./DateUtil');
var CustomTime = require('./component/CustomTime');

/**
 * Create a timeline visualization
 * @constructor
 */
function Core() {}

// turn Core into an event emitter
Emitter(Core.prototype);

/**
 * Create the main DOM for the Core: a root panel containing left, right,
 * top, bottom, content, and background panel.
 * @param {Element} container  The container element where the Core will
 *                             be attached.
 * @protected
 */
Core.prototype._create = function (container) {
  this.dom = {};

  this.dom.container = container;

  this.dom.root = document.createElement('div');
  this.dom.background = document.createElement('div');
  this.dom.backgroundVertical = document.createElement('div');
  this.dom.backgroundHorizontal = document.createElement('div');
  this.dom.centerContainer = document.createElement('div');
  this.dom.leftContainer = document.createElement('div');
  this.dom.rightContainer = document.createElement('div');
  this.dom.center = document.createElement('div');
  this.dom.left = document.createElement('div');
  this.dom.right = document.createElement('div');
  this.dom.top = document.createElement('div');
  this.dom.bottom = document.createElement('div');
  this.dom.shadowTop = document.createElement('div');
  this.dom.shadowBottom = document.createElement('div');
  this.dom.shadowTopLeft = document.createElement('div');
  this.dom.shadowBottomLeft = document.createElement('div');
  this.dom.shadowTopRight = document.createElement('div');
  this.dom.shadowBottomRight = document.createElement('div');

  this.dom.root.className = 'vis-timeline';
  this.dom.background.className = 'vis-panel vis-background';
  this.dom.backgroundVertical.className = 'vis-panel vis-background vis-vertical';
  this.dom.backgroundHorizontal.className = 'vis-panel vis-background vis-horizontal';
  this.dom.centerContainer.className = 'vis-panel vis-center';
  this.dom.leftContainer.className = 'vis-panel vis-left';
  this.dom.rightContainer.className = 'vis-panel vis-right';
  this.dom.top.className = 'vis-panel vis-top';
  this.dom.bottom.className = 'vis-panel vis-bottom';
  this.dom.left.className = 'vis-content';
  this.dom.center.className = 'vis-content';
  this.dom.right.className = 'vis-content';
  this.dom.shadowTop.className = 'vis-shadow vis-top';
  this.dom.shadowBottom.className = 'vis-shadow vis-bottom';
  this.dom.shadowTopLeft.className = 'vis-shadow vis-top';
  this.dom.shadowBottomLeft.className = 'vis-shadow vis-bottom';
  this.dom.shadowTopRight.className = 'vis-shadow vis-top';
  this.dom.shadowBottomRight.className = 'vis-shadow vis-bottom';

  this.dom.root.appendChild(this.dom.background);
  this.dom.root.appendChild(this.dom.backgroundVertical);
  this.dom.root.appendChild(this.dom.backgroundHorizontal);
  this.dom.root.appendChild(this.dom.centerContainer);
  this.dom.root.appendChild(this.dom.leftContainer);
  this.dom.root.appendChild(this.dom.rightContainer);
  this.dom.root.appendChild(this.dom.top);
  this.dom.root.appendChild(this.dom.bottom);

  this.dom.centerContainer.appendChild(this.dom.center);
  this.dom.leftContainer.appendChild(this.dom.left);
  this.dom.rightContainer.appendChild(this.dom.right);

  this.dom.centerContainer.appendChild(this.dom.shadowTop);
  this.dom.centerContainer.appendChild(this.dom.shadowBottom);
  this.dom.leftContainer.appendChild(this.dom.shadowTopLeft);
  this.dom.leftContainer.appendChild(this.dom.shadowBottomLeft);
  this.dom.rightContainer.appendChild(this.dom.shadowTopRight);
  this.dom.rightContainer.appendChild(this.dom.shadowBottomRight);

  this.on('rangechange', (function () {
    this._redraw(); // this allows overriding the _redraw method
  }).bind(this));
  this.on('touch', this._onTouch.bind(this));
  this.on('pan', this._onDrag.bind(this));

  var me = this;
  this.on('change', function (properties) {
    if (properties && properties.queue == true) {
      // redraw once on next tick
      if (!me._redrawTimer) {
        me._redrawTimer = setTimeout(function () {
          me._redrawTimer = null;
          me._redraw();
        }, 0);
      }
    } else {
      // redraw immediately
      me._redraw();
    }
  });

  // create event listeners for all interesting events, these events will be
  // emitted via emitter
  this.hammer = new Hammer(this.dom.root);
  this.hammer.get('pinch').set({ enable: true });
  this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // 30 is ALL_DIRECTIONS in hammer.
  this.listeners = {};

  var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'
  // TODO: cleanup
  //'touch', 'pinch',
  //'tap', 'doubletap', 'hold',
  //'dragstart', 'drag', 'dragend',
  //'mousewheel', 'DOMMouseScroll' // DOMMouseScroll is needed for Firefox
  ];
  events.forEach(function (type) {
    var listener = function listener(event) {
      if (me.isActive()) {
        me.emit(type, event);
      }
    };
    me.hammer.on(type, listener);
    me.listeners[type] = listener;
  });

  // emulate a touch event (emitted before the start of a pan, pinch, tap, or press)
  hammerUtil.onTouch(this.hammer, (function (event) {
    me.emit('touch', event);
  }).bind(this));

  // emulate a release event (emitted after a pan, pinch, tap, or press)
  hammerUtil.onRelease(this.hammer, (function (event) {
    me.emit('release', event);
  }).bind(this));

  function onMouseWheel(event) {
    if (me.isActive()) {
      me.emit('mousewheel', event);
    }
  }
  this.dom.root.addEventListener('mousewheel', onMouseWheel);
  this.dom.root.addEventListener('DOMMouseScroll', onMouseWheel);

  // size properties of each of the panels
  this.props = {
    root: {},
    background: {},
    centerContainer: {},
    leftContainer: {},
    rightContainer: {},
    center: {},
    left: {},
    right: {},
    top: {},
    bottom: {},
    border: {},
    scrollTop: 0,
    scrollTopMin: 0
  };

  this.customTimes = [];

  // store state information needed for touch events
  this.touch = {};

  this.redrawCount = 0;

  // attach the root panel to the provided container
  if (!container) throw new Error('No container provided');
  container.appendChild(this.dom.root);
};

/**
 * Set options. Options will be passed to all components loaded in the Timeline.
 * @param {Object} [options]
 *                           {String} orientation
 *                              Vertical orientation for the Timeline,
 *                              can be 'bottom' (default) or 'top'.
 *                           {String | Number} width
 *                              Width for the timeline, a number in pixels or
 *                              a css string like '1000px' or '75%'. '100%' by default.
 *                           {String | Number} height
 *                              Fixed height for the Timeline, a number in pixels or
 *                              a css string like '400px' or '75%'. If undefined,
 *                              The Timeline will automatically size such that
 *                              its contents fit.
 *                           {String | Number} minHeight
 *                              Minimum height for the Timeline, a number in pixels or
 *                              a css string like '400px' or '75%'.
 *                           {String | Number} maxHeight
 *                              Maximum height for the Timeline, a number in pixels or
 *                              a css string like '400px' or '75%'.
 *                           {Number | Date | String} start
 *                              Start date for the visible window
 *                           {Number | Date | String} end
 *                              End date for the visible window
 */
Core.prototype.setOptions = function (options) {
  if (options) {
    // copy the known options
    var fields = ['width', 'height', 'minHeight', 'maxHeight', 'autoResize', 'start', 'end', 'clickToUse', 'dataAttributes', 'hiddenDates', 'locale', 'locales', 'moment', 'throttleRedraw'];
    util.selectiveExtend(fields, this.options, options);

    if ('orientation' in options) {
      if (typeof options.orientation === 'string') {
        this.options.orientation = {
          item: options.orientation,
          axis: options.orientation
        };
      } else if (typeof options.orientation === 'object') {
        if ('item' in options.orientation) {
          this.options.orientation.item = options.orientation.item;
        }
        if ('axis' in options.orientation) {
          this.options.orientation.axis = options.orientation.axis;
        }
      }
    }

    if (this.options.orientation.axis === 'both') {
      if (!this.timeAxis2) {
        var timeAxis2 = this.timeAxis2 = new TimeAxis(this.body);
        timeAxis2.setOptions = function (options) {
          var _options = options ? util.extend({}, options) : {};
          _options.orientation = 'top'; // override the orientation option, always top
          TimeAxis.prototype.setOptions.call(timeAxis2, _options);
        };
        this.components.push(timeAxis2);
      }
    } else {
      if (this.timeAxis2) {
        var index = this.components.indexOf(this.timeAxis2);
        if (index !== -1) {
          this.components.splice(index, 1);
        }
        this.timeAxis2.destroy();
        this.timeAxis2 = null;
      }
    }

    // if the graph2d's drawPoints is a function delegate the callback to the onRender property
    if (typeof options.drawPoints == 'function') {
      options.drawPoints = {
        onRender: options.drawPoints
      };
    }

    if ('hiddenDates' in this.options) {
      DateUtil.convertHiddenOptions(this.options.moment, this.body, this.options.hiddenDates);
    }

    if ('clickToUse' in options) {
      if (options.clickToUse) {
        if (!this.activator) {
          this.activator = new Activator(this.dom.root);
        }
      } else {
        if (this.activator) {
          this.activator.destroy();
          delete this.activator;
        }
      }
    }

    if ('showCustomTime' in options) {
      throw new Error('Option `showCustomTime` is deprecated. Create a custom time bar via timeline.addCustomTime(time [, id])');
    }

    // enable/disable autoResize
    this._initAutoResize();
  }

  // propagate options to all components
  this.components.forEach(function (component) {
    return component.setOptions(options);
  });

  // enable/disable configure
  if ('configure' in options) {
    if (!this.configurator) {
      this.configurator = this._createConfigurator();
    }

    this.configurator.setOptions(options.configure);

    // collect the settings of all components, and pass them to the configuration system
    var appliedOptions = util.deepExtend({}, this.options);
    this.components.forEach(function (component) {
      util.deepExtend(appliedOptions, component.options);
    });
    this.configurator.setModuleOptions({ global: appliedOptions });
  }

  // override redraw with a throttled version
  if (!this._origRedraw) {
    this._origRedraw = this._redraw.bind(this);
  }
  this._redraw = util.throttle(this._origRedraw, this.options.throttleRedraw);

  // redraw everything
  this._redraw();
};

/**
 * Returns true when the Timeline is active.
 * @returns {boolean}
 */
Core.prototype.isActive = function () {
  return !this.activator || this.activator.active;
};

/**
 * Destroy the Core, clean up all DOM elements and event listeners.
 */
Core.prototype.destroy = function () {
  // unbind datasets
  this.setItems(null);
  this.setGroups(null);

  // remove all event listeners
  this.off();

  // stop checking for changed size
  this._stopAutoResize();

  // remove from DOM
  if (this.dom.root.parentNode) {
    this.dom.root.parentNode.removeChild(this.dom.root);
  }
  this.dom = null;

  // remove Activator
  if (this.activator) {
    this.activator.destroy();
    delete this.activator;
  }

  // cleanup hammer touch events
  for (var event in this.listeners) {
    if (this.listeners.hasOwnProperty(event)) {
      delete this.listeners[event];
    }
  }
  this.listeners = null;
  this.hammer = null;

  // give all components the opportunity to cleanup
  this.components.forEach(function (component) {
    return component.destroy();
  });

  this.body = null;
};

/**
 * Set a custom time bar
 * @param {Date} time
 * @param {number} [id=undefined] Optional id of the custom time bar to be adjusted.
 */
Core.prototype.setCustomTime = function (time, id) {
  var customTimes = this.customTimes.filter(function (component) {
    return id === component.options.id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }

  if (customTimes.length > 0) {
    customTimes[0].setCustomTime(time);
  }
};

/**
 * Retrieve the current custom time.
 * @param {number} [id=undefined]    Id of the custom time bar.
 * @return {Date | undefined} customTime
 */
Core.prototype.getCustomTime = function (id) {
  var customTimes = this.customTimes.filter(function (component) {
    return component.options.id === id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }
  return customTimes[0].getCustomTime();
};

/**
 * Set a custom title for the custom time bar.
 * @param {String} [title] Custom title
 * @param {number} [id=undefined]    Id of the custom time bar.
 */
Core.prototype.setCustomTimeTitle = function (title, id) {
  var customTimes = this.customTimes.filter(function (component) {
    return component.options.id === id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }
  if (customTimes.length > 0) {
    return customTimes[0].setCustomTitle(title);
  }
};

/**
 * Retrieve meta information from an event.
 * Should be overridden by classes extending Core
 * @param {Event} event
 * @return {Object} An object with related information.
 */
Core.prototype.getEventProperties = function (event) {
  return { event: event };
};

/**
 * Add custom vertical bar
 * @param {Date | String | Number} [time]  A Date, unix timestamp, or
 *                                         ISO date string. Time point where
 *                                         the new bar should be placed.
 *                                         If not provided, `new Date()` will
 *                                         be used.
 * @param {Number | String} [id=undefined] Id of the new bar. Optional
 * @return {Number | String}               Returns the id of the new bar
 */
Core.prototype.addCustomTime = function (time, id) {
  var timestamp = time !== undefined ? util.convert(time, 'Date').valueOf() : new Date();

  var exists = this.customTimes.some(function (customTime) {
    return customTime.options.id === id;
  });
  if (exists) {
    throw new Error('A custom time with id ' + JSON.stringify(id) + ' already exists');
  }

  var customTime = new CustomTime(this.body, util.extend({}, this.options, {
    time: timestamp,
    id: id
  }));

  this.customTimes.push(customTime);
  this.components.push(customTime);
  this._redraw();

  return id;
};

/**
 * Remove previously added custom bar
 * @param {int} id ID of the custom bar to be removed
 * @return {boolean} True if the bar exists and is removed, false otherwise
 */
Core.prototype.removeCustomTime = function (id) {
  var customTimes = this.customTimes.filter(function (bar) {
    return bar.options.id === id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }

  customTimes.forEach((function (customTime) {
    this.customTimes.splice(this.customTimes.indexOf(customTime), 1);
    this.components.splice(this.components.indexOf(customTime), 1);
    customTime.destroy();
  }).bind(this));
};

/**
 * Get the id's of the currently visible items.
 * @returns {Array} The ids of the visible items
 */
Core.prototype.getVisibleItems = function () {
  return this.itemSet && this.itemSet.getVisibleItems() || [];
};

/**
 * Set Core window such that it fits all items
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Core.prototype.fit = function (options) {
  var range = this.getDataRange();

  // skip range set if there is no min and max date
  if (range.min === null && range.max === null) {
    return;
  }

  // apply a margin of 1% left and right of the data
  var interval = range.max - range.min;
  var min = new Date(range.min.valueOf() - interval * 0.01);
  var max = new Date(range.max.valueOf() + interval * 0.01);

  var animation = options && options.animation !== undefined ? options.animation : true;
  this.range.setRange(min, max, animation);
};

/**
 * Calculate the data range of the items start and end dates
 * @returns {{min: Date | null, max: Date | null}}
 * @protected
 */
Core.prototype.getDataRange = function () {
  // must be implemented by Timeline and Graph2d
  throw new Error('Cannot invoke abstract method getDataRange');
};

/**
 * Set the visible window. Both parameters are optional, you can change only
 * start or only end. Syntax:
 *
 *     TimeLine.setWindow(start, end)
 *     TimeLine.setWindow(start, end, options)
 *     TimeLine.setWindow(range)
 *
 * Where start and end can be a Date, number, or string, and range is an
 * object with properties start and end.
 *
 * @param {Date | Number | String | Object} [start] Start date of visible window
 * @param {Date | Number | String} [end]            End date of visible window
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Core.prototype.setWindow = function (start, end, options) {
  var animation;
  if (arguments.length == 1) {
    var range = arguments[0];
    animation = range.animation !== undefined ? range.animation : true;
    this.range.setRange(range.start, range.end, animation);
  } else {
    animation = options && options.animation !== undefined ? options.animation : true;
    this.range.setRange(start, end, animation);
  }
};

/**
 * Move the window such that given time is centered on screen.
 * @param {Date | Number | String} time
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Core.prototype.moveTo = function (time, options) {
  var interval = this.range.end - this.range.start;
  var t = util.convert(time, 'Date').valueOf();

  var start = t - interval / 2;
  var end = t + interval / 2;
  var animation = options && options.animation !== undefined ? options.animation : true;

  this.range.setRange(start, end, animation);
};

/**
 * Get the visible window
 * @return {{start: Date, end: Date}}   Visible range
 */
Core.prototype.getWindow = function () {
  var range = this.range.getRange();
  return {
    start: new Date(range.start),
    end: new Date(range.end)
  };
};

/**
 * Force a redraw. Can be overridden by implementations of Core
 *
 * Note: this function will be overridden on construction with a trottled version
 */
Core.prototype.redraw = function () {
  this._redraw();
};

/**
 * Redraw for internal use. Redraws all components. See also the public
 * method redraw.
 * @protected
 */
Core.prototype._redraw = function () {
  var resized = false;
  var options = this.options;
  var props = this.props;
  var dom = this.dom;

  if (!dom) return; // when destroyed

  DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);

  // update class names
  if (options.orientation == 'top') {
    util.addClassName(dom.root, 'vis-top');
    util.removeClassName(dom.root, 'vis-bottom');
  } else {
    util.removeClassName(dom.root, 'vis-top');
    util.addClassName(dom.root, 'vis-bottom');
  }

  // update root width and height options
  dom.root.style.maxHeight = util.option.asSize(options.maxHeight, '');
  dom.root.style.minHeight = util.option.asSize(options.minHeight, '');
  dom.root.style.width = util.option.asSize(options.width, '');

  // calculate border widths
  props.border.left = (dom.centerContainer.offsetWidth - dom.centerContainer.clientWidth) / 2;
  props.border.right = props.border.left;
  props.border.top = (dom.centerContainer.offsetHeight - dom.centerContainer.clientHeight) / 2;
  props.border.bottom = props.border.top;
  var borderRootHeight = dom.root.offsetHeight - dom.root.clientHeight;
  var borderRootWidth = dom.root.offsetWidth - dom.root.clientWidth;

  // workaround for a bug in IE: the clientWidth of an element with
  // a height:0px and overflow:hidden is not calculated and always has value 0
  if (dom.centerContainer.clientHeight === 0) {
    props.border.left = props.border.top;
    props.border.right = props.border.left;
  }
  if (dom.root.clientHeight === 0) {
    borderRootWidth = borderRootHeight;
  }

  // calculate the heights. If any of the side panels is empty, we set the height to
  // minus the border width, such that the border will be invisible
  props.center.height = dom.center.offsetHeight;
  props.left.height = dom.left.offsetHeight;
  props.right.height = dom.right.offsetHeight;
  props.top.height = dom.top.clientHeight || -props.border.top;
  props.bottom.height = dom.bottom.clientHeight || -props.border.bottom;

  // TODO: compensate borders when any of the panels is empty.

  // apply auto height
  // TODO: only calculate autoHeight when needed (else we cause an extra reflow/repaint of the DOM)
  var contentHeight = Math.max(props.left.height, props.center.height, props.right.height);
  var autoHeight = props.top.height + contentHeight + props.bottom.height + borderRootHeight + props.border.top + props.border.bottom;
  dom.root.style.height = util.option.asSize(options.height, autoHeight + 'px');

  // calculate heights of the content panels
  props.root.height = dom.root.offsetHeight;
  props.background.height = props.root.height - borderRootHeight;
  var containerHeight = props.root.height - props.top.height - props.bottom.height - borderRootHeight;
  props.centerContainer.height = containerHeight;
  props.leftContainer.height = containerHeight;
  props.rightContainer.height = props.leftContainer.height;

  // calculate the widths of the panels
  props.root.width = dom.root.offsetWidth;
  props.background.width = props.root.width - borderRootWidth;
  props.left.width = dom.leftContainer.clientWidth || -props.border.left;
  props.leftContainer.width = props.left.width;
  props.right.width = dom.rightContainer.clientWidth || -props.border.right;
  props.rightContainer.width = props.right.width;
  var centerWidth = props.root.width - props.left.width - props.right.width - borderRootWidth;
  props.center.width = centerWidth;
  props.centerContainer.width = centerWidth;
  props.top.width = centerWidth;
  props.bottom.width = centerWidth;

  // resize the panels
  dom.background.style.height = props.background.height + 'px';
  dom.backgroundVertical.style.height = props.background.height + 'px';
  dom.backgroundHorizontal.style.height = props.centerContainer.height + 'px';
  dom.centerContainer.style.height = props.centerContainer.height + 'px';
  dom.leftContainer.style.height = props.leftContainer.height + 'px';
  dom.rightContainer.style.height = props.rightContainer.height + 'px';

  dom.background.style.width = props.background.width + 'px';
  dom.backgroundVertical.style.width = props.centerContainer.width + 'px';
  dom.backgroundHorizontal.style.width = props.background.width + 'px';
  dom.centerContainer.style.width = props.center.width + 'px';
  dom.top.style.width = props.top.width + 'px';
  dom.bottom.style.width = props.bottom.width + 'px';

  // reposition the panels
  dom.background.style.left = '0';
  dom.background.style.top = '0';
  dom.backgroundVertical.style.left = props.left.width + props.border.left + 'px';
  dom.backgroundVertical.style.top = '0';
  dom.backgroundHorizontal.style.left = '0';
  dom.backgroundHorizontal.style.top = props.top.height + 'px';
  dom.centerContainer.style.left = props.left.width + 'px';
  dom.centerContainer.style.top = props.top.height + 'px';
  dom.leftContainer.style.left = '0';
  dom.leftContainer.style.top = props.top.height + 'px';
  dom.rightContainer.style.left = props.left.width + props.center.width + 'px';
  dom.rightContainer.style.top = props.top.height + 'px';
  dom.top.style.left = props.left.width + 'px';
  dom.top.style.top = '0';
  dom.bottom.style.left = props.left.width + 'px';
  dom.bottom.style.top = props.top.height + props.centerContainer.height + 'px';

  // update the scrollTop, feasible range for the offset can be changed
  // when the height of the Core or of the contents of the center changed
  this._updateScrollTop();

  // reposition the scrollable contents
  var offset = this.props.scrollTop;
  if (options.orientation.item != 'top') {
    offset += Math.max(this.props.centerContainer.height - this.props.center.height - this.props.border.top - this.props.border.bottom, 0);
  }
  dom.center.style.left = '0';
  dom.center.style.top = offset + 'px';
  dom.left.style.left = '0';
  dom.left.style.top = offset + 'px';
  dom.right.style.left = '0';
  dom.right.style.top = offset + 'px';

  // show shadows when vertical scrolling is available
  var visibilityTop = this.props.scrollTop == 0 ? 'hidden' : '';
  var visibilityBottom = this.props.scrollTop == this.props.scrollTopMin ? 'hidden' : '';
  dom.shadowTop.style.visibility = visibilityTop;
  dom.shadowBottom.style.visibility = visibilityBottom;
  dom.shadowTopLeft.style.visibility = visibilityTop;
  dom.shadowBottomLeft.style.visibility = visibilityBottom;
  dom.shadowTopRight.style.visibility = visibilityTop;
  dom.shadowBottomRight.style.visibility = visibilityBottom;

  // redraw all components
  this.components.forEach(function (component) {
    resized = component.redraw() || resized;
  });
  if (resized) {
    // keep repainting until all sizes are settled
    var MAX_REDRAWS = 3; // maximum number of consecutive redraws
    if (this.redrawCount < MAX_REDRAWS) {
      this.redrawCount++;
      this._redraw();
    } else {
      console.log('WARNING: infinite loop in redraw?');
    }
    this.redrawCount = 0;
  }
};

// TODO: deprecated since version 1.1.0, remove some day
Core.prototype.repaint = function () {
  throw new Error('Function repaint is deprecated. Use redraw instead.');
};

/**
 * Set a current time. This can be used for example to ensure that a client's
 * time is synchronized with a shared server time.
 * Only applicable when option `showCurrentTime` is true.
 * @param {Date | String | Number} time     A Date, unix timestamp, or
 *                                          ISO date string.
 */
Core.prototype.setCurrentTime = function (time) {
  if (!this.currentTime) {
    throw new Error('Option showCurrentTime must be true');
  }

  this.currentTime.setCurrentTime(time);
};

/**
 * Get the current time.
 * Only applicable when option `showCurrentTime` is true.
 * @return {Date} Returns the current time.
 */
Core.prototype.getCurrentTime = function () {
  if (!this.currentTime) {
    throw new Error('Option showCurrentTime must be true');
  }

  return this.currentTime.getCurrentTime();
};

/**
 * Convert a position on screen (pixels) to a datetime
 * @param {int}     x    Position on the screen in pixels
 * @return {Date}   time The datetime the corresponds with given position x
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toTime = function (x) {
  return DateUtil.toTime(this, x, this.props.center.width);
};

/**
 * Convert a position on the global screen (pixels) to a datetime
 * @param {int}     x    Position on the screen in pixels
 * @return {Date}   time The datetime the corresponds with given position x
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toGlobalTime = function (x) {
  return DateUtil.toTime(this, x, this.props.root.width);
  //var conversion = this.range.conversion(this.props.root.width);
  //return new Date(x / conversion.scale + conversion.offset);
};

/**
 * Convert a datetime (Date object) into a position on the screen
 * @param {Date}   time A date
 * @return {int}   x    The position on the screen in pixels which corresponds
 *                      with the given date.
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toScreen = function (time) {
  return DateUtil.toScreen(this, time, this.props.center.width);
};

/**
 * Convert a datetime (Date object) into a position on the root
 * This is used to get the pixel density estimate for the screen, not the center panel
 * @param {Date}   time A date
 * @return {int}   x    The position on root in pixels which corresponds
 *                      with the given date.
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toGlobalScreen = function (time) {
  return DateUtil.toScreen(this, time, this.props.root.width);
  //var conversion = this.range.conversion(this.props.root.width);
  //return (time.valueOf() - conversion.offset) * conversion.scale;
};

/**
 * Initialize watching when option autoResize is true
 * @private
 */
Core.prototype._initAutoResize = function () {
  if (this.options.autoResize == true) {
    this._startAutoResize();
  } else {
    this._stopAutoResize();
  }
};

/**
 * Watch for changes in the size of the container. On resize, the Panel will
 * automatically redraw itself.
 * @private
 */
Core.prototype._startAutoResize = function () {
  var me = this;

  this._stopAutoResize();

  this._onResize = function () {
    if (me.options.autoResize != true) {
      // stop watching when the option autoResize is changed to false
      me._stopAutoResize();
      return;
    }

    if (me.dom.root) {
      // check whether the frame is resized
      // Note: we compare offsetWidth here, not clientWidth. For some reason,
      // IE does not restore the clientWidth from 0 to the actual width after
      // changing the timeline's container display style from none to visible
      if (me.dom.root.offsetWidth != me.props.lastWidth || me.dom.root.offsetHeight != me.props.lastHeight) {
        me.props.lastWidth = me.dom.root.offsetWidth;
        me.props.lastHeight = me.dom.root.offsetHeight;

        me.emit('change');
      }
    }
  };

  // add event listener to window resize
  util.addEventListener(window, 'resize', this._onResize);

  this.watchTimer = setInterval(this._onResize, 1000);
};

/**
 * Stop watching for a resize of the frame.
 * @private
 */
Core.prototype._stopAutoResize = function () {
  if (this.watchTimer) {
    clearInterval(this.watchTimer);
    this.watchTimer = undefined;
  }

  // remove event listener on window.resize
  if (this._onResize) {
    util.removeEventListener(window, 'resize', this._onResize);
    this._onResize = null;
  }
};

/**
 * Start moving the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onTouch = function (event) {
  this.touch.allowDragging = true;
  this.touch.initialScrollTop = this.props.scrollTop;
};

/**
 * Start moving the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onPinch = function (event) {
  this.touch.allowDragging = false;
};

/**
 * Move the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onDrag = function (event) {
  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.touch.allowDragging) return;

  var delta = event.deltaY;

  var oldScrollTop = this._getScrollTop();
  var newScrollTop = this._setScrollTop(this.touch.initialScrollTop + delta);

  if (newScrollTop != oldScrollTop) {
    this._redraw(); // TODO: this causes two redraws when dragging, the other is triggered by rangechange already
    this.emit("verticalDrag");
  }
};

/**
 * Apply a scrollTop
 * @param {Number} scrollTop
 * @returns {Number} scrollTop  Returns the applied scrollTop
 * @private
 */
Core.prototype._setScrollTop = function (scrollTop) {
  this.props.scrollTop = scrollTop;
  this._updateScrollTop();
  return this.props.scrollTop;
};

/**
 * Update the current scrollTop when the height of  the containers has been changed
 * @returns {Number} scrollTop  Returns the applied scrollTop
 * @private
 */
Core.prototype._updateScrollTop = function () {
  // recalculate the scrollTopMin
  var scrollTopMin = Math.min(this.props.centerContainer.height - this.props.center.height, 0); // is negative or zero
  if (scrollTopMin != this.props.scrollTopMin) {
    // in case of bottom orientation, change the scrollTop such that the contents
    // do not move relative to the time axis at the bottom
    if (this.options.orientation.item != 'top') {
      this.props.scrollTop += scrollTopMin - this.props.scrollTopMin;
    }
    this.props.scrollTopMin = scrollTopMin;
  }

  // limit the scrollTop to the feasible scroll range
  if (this.props.scrollTop > 0) this.props.scrollTop = 0;
  if (this.props.scrollTop < scrollTopMin) this.props.scrollTop = scrollTopMin;

  return this.props.scrollTop;
};

/**
 * Get the current scrollTop
 * @returns {number} scrollTop
 * @private
 */
Core.prototype._getScrollTop = function () {
  return this.props.scrollTop;
};

/**
 * Load a configurator
 * @return {Object}
 * @private
 */
Core.prototype._createConfigurator = function () {
  throw new Error('Cannot invoke abstract method _createConfigurator');
};

module.exports = Core;

},{"../DataSet":28,"../DataView":29,"../hammerUtil":31,"../module/hammer":32,"../shared/Activator":35,"../util":59,"./DateUtil":40,"./Range":41,"./component/CustomTime":48,"./component/ItemSet":50,"./component/TimeAxis":51,"emitter-component":60}],40:[function(require,module,exports){

/**
 * used in Core to convert the options into a volatile variable
 * 
 * @param {function} moment
 * @param {Object} body
 * @param {Array | Object} hiddenDates
 */
"use strict";

exports.convertHiddenOptions = function (moment, body, hiddenDates) {
  if (hiddenDates && !Array.isArray(hiddenDates)) {
    return exports.convertHiddenOptions(moment, body, [hiddenDates]);
  }

  body.hiddenDates = [];
  if (hiddenDates) {
    if (Array.isArray(hiddenDates) == true) {
      for (var i = 0; i < hiddenDates.length; i++) {
        if (hiddenDates[i].repeat === undefined) {
          var dateItem = {};
          dateItem.start = moment(hiddenDates[i].start).toDate().valueOf();
          dateItem.end = moment(hiddenDates[i].end).toDate().valueOf();
          body.hiddenDates.push(dateItem);
        }
      }
      body.hiddenDates.sort(function (a, b) {
        return a.start - b.start;
      }); // sort by start time
    }
  }
};

/**
 * create new entrees for the repeating hidden dates
 * @param {function} moment
 * @param {Object} body
 * @param {Array | Object} hiddenDates
 */
exports.updateHiddenDates = function (moment, body, hiddenDates) {
  if (hiddenDates && !Array.isArray(hiddenDates)) {
    return exports.updateHiddenDates(moment, body, [hiddenDates]);
  }

  if (hiddenDates && body.domProps.centerContainer.width !== undefined) {
    exports.convertHiddenOptions(moment, body, hiddenDates);

    var start = moment(body.range.start);
    var end = moment(body.range.end);

    var totalRange = body.range.end - body.range.start;
    var pixelTime = totalRange / body.domProps.centerContainer.width;

    for (var i = 0; i < hiddenDates.length; i++) {
      if (hiddenDates[i].repeat !== undefined) {
        var startDate = moment(hiddenDates[i].start);
        var endDate = moment(hiddenDates[i].end);

        if (startDate._d == "Invalid Date") {
          throw new Error("Supplied start date is not valid: " + hiddenDates[i].start);
        }
        if (endDate._d == "Invalid Date") {
          throw new Error("Supplied end date is not valid: " + hiddenDates[i].end);
        }

        var duration = endDate - startDate;
        if (duration >= 4 * pixelTime) {

          var offset = 0;
          var runUntil = end.clone();
          switch (hiddenDates[i].repeat) {
            case "daily":
              // case of time
              if (startDate.day() != endDate.day()) {
                offset = 1;
              }
              startDate.dayOfYear(start.dayOfYear());
              startDate.year(start.year());
              startDate.subtract(7, 'days');

              endDate.dayOfYear(start.dayOfYear());
              endDate.year(start.year());
              endDate.subtract(7 - offset, 'days');

              runUntil.add(1, 'weeks');
              break;
            case "weekly":
              var dayOffset = endDate.diff(startDate, 'days');
              var day = startDate.day();

              // set the start date to the range.start
              startDate.date(start.date());
              startDate.month(start.month());
              startDate.year(start.year());
              endDate = startDate.clone();

              // force
              startDate.day(day);
              endDate.day(day);
              endDate.add(dayOffset, 'days');

              startDate.subtract(1, 'weeks');
              endDate.subtract(1, 'weeks');

              runUntil.add(1, 'weeks');
              break;
            case "monthly":
              if (startDate.month() != endDate.month()) {
                offset = 1;
              }
              startDate.month(start.month());
              startDate.year(start.year());
              startDate.subtract(1, 'months');

              endDate.month(start.month());
              endDate.year(start.year());
              endDate.subtract(1, 'months');
              endDate.add(offset, 'months');

              runUntil.add(1, 'months');
              break;
            case "yearly":
              if (startDate.year() != endDate.year()) {
                offset = 1;
              }
              startDate.year(start.year());
              startDate.subtract(1, 'years');
              endDate.year(start.year());
              endDate.subtract(1, 'years');
              endDate.add(offset, 'years');

              runUntil.add(1, 'years');
              break;
            default:
              console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
              return;
          }
          while (startDate < runUntil) {
            body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
            switch (hiddenDates[i].repeat) {
              case "daily":
                startDate.add(1, 'days');
                endDate.add(1, 'days');
                break;
              case "weekly":
                startDate.add(1, 'weeks');
                endDate.add(1, 'weeks');
                break;
              case "monthly":
                startDate.add(1, 'months');
                endDate.add(1, 'months');
                break;
              case "yearly":
                startDate.add(1, 'y');
                endDate.add(1, 'y');
                break;
              default:
                console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
                return;
            }
          }
          body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
        }
      }
    }
    // remove duplicates, merge where possible
    exports.removeDuplicates(body);
    // ensure the new positions are not on hidden dates
    var startHidden = exports.isHidden(body.range.start, body.hiddenDates);
    var endHidden = exports.isHidden(body.range.end, body.hiddenDates);
    var rangeStart = body.range.start;
    var rangeEnd = body.range.end;
    if (startHidden.hidden == true) {
      rangeStart = body.range.startToFront == true ? startHidden.startDate - 1 : startHidden.endDate + 1;
    }
    if (endHidden.hidden == true) {
      rangeEnd = body.range.endToFront == true ? endHidden.startDate - 1 : endHidden.endDate + 1;
    }
    if (startHidden.hidden == true || endHidden.hidden == true) {
      body.range._applyRange(rangeStart, rangeEnd);
    }
  }
};

/**
 * remove duplicates from the hidden dates list. Duplicates are evil. They mess everything up.
 * Scales with N^2
 * @param body
 */
exports.removeDuplicates = function (body) {
  var hiddenDates = body.hiddenDates;
  var safeDates = [];
  for (var i = 0; i < hiddenDates.length; i++) {
    for (var j = 0; j < hiddenDates.length; j++) {
      if (i != j && hiddenDates[j].remove != true && hiddenDates[i].remove != true) {
        // j inside i
        if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
          hiddenDates[j].remove = true;
        }
        // j start inside i
        else if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].start <= hiddenDates[i].end) {
            hiddenDates[i].end = hiddenDates[j].end;
            hiddenDates[j].remove = true;
          }
          // j end inside i
          else if (hiddenDates[j].end >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
              hiddenDates[i].start = hiddenDates[j].start;
              hiddenDates[j].remove = true;
            }
      }
    }
  }

  for (var i = 0; i < hiddenDates.length; i++) {
    if (hiddenDates[i].remove !== true) {
      safeDates.push(hiddenDates[i]);
    }
  }

  body.hiddenDates = safeDates;
  body.hiddenDates.sort(function (a, b) {
    return a.start - b.start;
  }); // sort by start time
};

exports.printDates = function (dates) {
  for (var i = 0; i < dates.length; i++) {
    console.log(i, new Date(dates[i].start), new Date(dates[i].end), dates[i].start, dates[i].end, dates[i].remove);
  }
};

/**
 * Used in TimeStep to avoid the hidden times.
 * @param {function} moment
 * @param {TimeStep} timeStep
 * @param previousTime
 */
exports.stepOverHiddenDates = function (moment, timeStep, previousTime) {
  var stepInHidden = false;
  var currentValue = timeStep.current.valueOf();
  for (var i = 0; i < timeStep.hiddenDates.length; i++) {
    var startDate = timeStep.hiddenDates[i].start;
    var endDate = timeStep.hiddenDates[i].end;
    if (currentValue >= startDate && currentValue < endDate) {
      stepInHidden = true;
      break;
    }
  }

  if (stepInHidden == true && currentValue < timeStep._end.valueOf() && currentValue != previousTime) {
    var prevValue = moment(previousTime);
    var newValue = moment(endDate);
    //check if the next step should be major
    if (prevValue.year() != newValue.year()) {
      timeStep.switchedYear = true;
    } else if (prevValue.month() != newValue.month()) {
      timeStep.switchedMonth = true;
    } else if (prevValue.dayOfYear() != newValue.dayOfYear()) {
      timeStep.switchedDay = true;
    }

    timeStep.current = newValue;
  }
};

///**
// * Used in TimeStep to avoid the hidden times.
// * @param timeStep
// * @param previousTime
// */
//exports.checkFirstStep = function(timeStep) {
//  var stepInHidden = false;
//  var currentValue = timeStep.current.valueOf();
//  for (var i = 0; i < timeStep.hiddenDates.length; i++) {
//    var startDate = timeStep.hiddenDates[i].start;
//    var endDate = timeStep.hiddenDates[i].end;
//    if (currentValue >= startDate && currentValue < endDate) {
//      stepInHidden = true;
//      break;
//    }
//  }
//
//  if (stepInHidden == true && currentValue <= timeStep._end.valueOf()) {
//    var newValue = moment(endDate);
//    timeStep.current = newValue.toDate();
//  }
//};

/**
 * replaces the Core toScreen methods
 * @param Core
 * @param time
 * @param width
 * @returns {number}
 */
exports.toScreen = function (Core, time, width) {
  if (Core.body.hiddenDates.length == 0) {
    var conversion = Core.range.conversion(width);
    return (time.valueOf() - conversion.offset) * conversion.scale;
  } else {
    var hidden = exports.isHidden(time, Core.body.hiddenDates);
    if (hidden.hidden == true) {
      time = hidden.startDate;
    }

    var duration = exports.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
    time = exports.correctTimeForHidden(Core.options.moment, Core.body.hiddenDates, Core.range, time);

    var conversion = Core.range.conversion(width, duration);
    return (time.valueOf() - conversion.offset) * conversion.scale;
  }
};

/**
 * Replaces the core toTime methods
 * @param body
 * @param range
 * @param x
 * @param width
 * @returns {Date}
 */
exports.toTime = function (Core, x, width) {
  if (Core.body.hiddenDates.length == 0) {
    var conversion = Core.range.conversion(width);
    return new Date(x / conversion.scale + conversion.offset);
  } else {
    var hiddenDuration = exports.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
    var totalDuration = Core.range.end - Core.range.start - hiddenDuration;
    var partialDuration = totalDuration * x / width;
    var accumulatedHiddenDuration = exports.getAccumulatedHiddenDuration(Core.body.hiddenDates, Core.range, partialDuration);

    var newTime = new Date(accumulatedHiddenDuration + partialDuration + Core.range.start);
    return newTime;
  }
};

/**
 * Support function
 *
 * @param hiddenDates
 * @param range
 * @returns {number}
 */
exports.getHiddenDurationBetween = function (hiddenDates, start, end) {
  var duration = 0;
  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;
    // if time after the cutout, and the
    if (startDate >= start && endDate < end) {
      duration += endDate - startDate;
    }
  }
  return duration;
};

/**
 * Support function
 * @param moment
 * @param hiddenDates
 * @param range
 * @param time
 * @returns {{duration: number, time: *, offset: number}}
 */
exports.correctTimeForHidden = function (moment, hiddenDates, range, time) {
  time = moment(time).toDate().valueOf();
  time -= exports.getHiddenDurationBefore(moment, hiddenDates, range, time);
  return time;
};

exports.getHiddenDurationBefore = function (moment, hiddenDates, range, time) {
  var timeOffset = 0;
  time = moment(time).toDate().valueOf();

  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;
    // if time after the cutout, and the
    if (startDate >= range.start && endDate < range.end) {
      if (time >= endDate) {
        timeOffset += endDate - startDate;
      }
    }
  }
  return timeOffset;
};

/**
 * sum the duration from start to finish, including the hidden duration,
 * until the required amount has been reached, return the accumulated hidden duration
 * @param hiddenDates
 * @param range
 * @param time
 * @returns {{duration: number, time: *, offset: number}}
 */
exports.getAccumulatedHiddenDuration = function (hiddenDates, range, requiredDuration) {
  var hiddenDuration = 0;
  var duration = 0;
  var previousPoint = range.start;
  //exports.printDates(hiddenDates)
  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;
    // if time after the cutout, and the
    if (startDate >= range.start && endDate < range.end) {
      duration += startDate - previousPoint;
      previousPoint = endDate;
      if (duration >= requiredDuration) {
        break;
      } else {
        hiddenDuration += endDate - startDate;
      }
    }
  }

  return hiddenDuration;
};

/**
 * used to step over to either side of a hidden block. Correction is disabled on tablets, might be set to true
 * @param hiddenDates
 * @param time
 * @param direction
 * @param correctionEnabled
 * @returns {*}
 */
exports.snapAwayFromHidden = function (hiddenDates, time, direction, correctionEnabled) {
  var isHidden = exports.isHidden(time, hiddenDates);
  if (isHidden.hidden == true) {
    if (direction < 0) {
      if (correctionEnabled == true) {
        return isHidden.startDate - (isHidden.endDate - time) - 1;
      } else {
        return isHidden.startDate - 1;
      }
    } else {
      if (correctionEnabled == true) {
        return isHidden.endDate + (time - isHidden.startDate) + 1;
      } else {
        return isHidden.endDate + 1;
      }
    }
  } else {
    return time;
  }
};

/**
 * Check if a time is hidden
 *
 * @param time
 * @param hiddenDates
 * @returns {{hidden: boolean, startDate: Window.start, endDate: *}}
 */
exports.isHidden = function (time, hiddenDates) {
  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;

    if (time >= startDate && time < endDate) {
      // if the start is entering a hidden zone
      return { hidden: true, startDate: startDate, endDate: endDate };
      break;
    }
  }
  return { hidden: false, startDate: startDate, endDate: endDate };
};

},{}],41:[function(require,module,exports){
'use strict';

var util = require('../util');
var hammerUtil = require('../hammerUtil');
var moment = require('../module/moment');
var Component = require('./component/Component');
var DateUtil = require('./DateUtil');

/**
 * @constructor Range
 * A Range controls a numeric range with a start and end value.
 * The Range adjusts the range based on mouse events or programmatic changes,
 * and triggers events when the range is changing or has been changed.
 * @param {{dom: Object, domProps: Object, emitter: Emitter}} body
 * @param {Object} [options]    See description at Range.setOptions
 */
function Range(body, options) {
  var now = moment().hours(0).minutes(0).seconds(0).milliseconds(0);
  this.start = now.clone().add(-3, 'days').valueOf(); // Number
  this.end = now.clone().add(4, 'days').valueOf(); // Number

  this.body = body;
  this.deltaDifference = 0;
  this.scaleOffset = 0;
  this.startToFront = false;
  this.endToFront = true;

  // default options
  this.defaultOptions = {
    start: null,
    end: null,
    moment: moment,
    direction: 'horizontal', // 'horizontal' or 'vertical'
    moveable: true,
    zoomable: true,
    min: null,
    max: null,
    zoomMin: 10, // milliseconds
    zoomMax: 1000 * 60 * 60 * 24 * 365 * 10000 // milliseconds
  };
  this.options = util.extend({}, this.defaultOptions);

  this.props = {
    touch: {}
  };
  this.animationTimer = null;

  // drag listeners for dragging
  this.body.emitter.on('panstart', this._onDragStart.bind(this));
  this.body.emitter.on('panmove', this._onDrag.bind(this));
  this.body.emitter.on('panend', this._onDragEnd.bind(this));

  // mouse wheel for zooming
  this.body.emitter.on('mousewheel', this._onMouseWheel.bind(this));

  // pinch to zoom
  this.body.emitter.on('touch', this._onTouch.bind(this));
  this.body.emitter.on('pinch', this._onPinch.bind(this));

  this.setOptions(options);
}

Range.prototype = new Component();

/**
 * Set options for the range controller
 * @param {Object} options      Available options:
 *                              {Number | Date | String} start  Start date for the range
 *                              {Number | Date | String} end    End date for the range
 *                              {Number} min    Minimum value for start
 *                              {Number} max    Maximum value for end
 *                              {Number} zoomMin    Set a minimum value for
 *                                                  (end - start).
 *                              {Number} zoomMax    Set a maximum value for
 *                                                  (end - start).
 *                              {Boolean} moveable Enable moving of the range
 *                                                 by dragging. True by default
 *                              {Boolean} zoomable Enable zooming of the range
 *                                                 by pinching/scrolling. True by default
 */
Range.prototype.setOptions = function (options) {
  if (options) {
    // copy the options that we know
    var fields = ['direction', 'min', 'max', 'zoomMin', 'zoomMax', 'moveable', 'zoomable', 'moment', 'activate', 'hiddenDates', 'zoomKey'];
    util.selectiveExtend(fields, this.options, options);

    if ('start' in options || 'end' in options) {
      // apply a new range. both start and end are optional
      this.setRange(options.start, options.end);
    }
  }
};

/**
 * Test whether direction has a valid value
 * @param {String} direction    'horizontal' or 'vertical'
 */
function validateDirection(direction) {
  if (direction != 'horizontal' && direction != 'vertical') {
    throw new TypeError('Unknown direction "' + direction + '". ' + 'Choose "horizontal" or "vertical".');
  }
}

/**
 * Set a new start and end range
 * @param {Date | Number | String} [start]
 * @param {Date | Number | String} [end]
 * @param {boolean | {duration: number, easingFunction: string}} [animation=false]
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 * @param {Boolean} [byUser=false]
 *
 */
Range.prototype.setRange = function (start, end, animation, byUser) {
  if (byUser !== true) {
    byUser = false;
  }
  var finalStart = start != undefined ? util.convert(start, 'Date').valueOf() : null;
  var finalEnd = end != undefined ? util.convert(end, 'Date').valueOf() : null;
  this._cancelAnimation();

  if (animation) {
    // true or an Object
    var me = this;
    var initStart = this.start;
    var initEnd = this.end;
    var duration = typeof animation === 'object' && 'duration' in animation ? animation.duration : 500;
    var easingName = typeof animation === 'object' && 'easingFunction' in animation ? animation.easingFunction : 'easeInOutQuad';
    var easingFunction = util.easingFunctions[easingName];
    if (!easingFunction) {
      throw new Error('Unknown easing function ' + JSON.stringify(easingName) + '. ' + 'Choose from: ' + Object.keys(util.easingFunctions).join(', '));
    }

    var initTime = new Date().valueOf();
    var anyChanged = false;

    var next = function next() {
      if (!me.props.touch.dragging) {
        var now = new Date().valueOf();
        var time = now - initTime;
        var ease = easingFunction(time / duration);
        var done = time > duration;
        var s = done || finalStart === null ? finalStart : initStart + (finalStart - initStart) * ease;
        var e = done || finalEnd === null ? finalEnd : initEnd + (finalEnd - initEnd) * ease;

        changed = me._applyRange(s, e);
        DateUtil.updateHiddenDates(me.options.moment, me.body, me.options.hiddenDates);
        anyChanged = anyChanged || changed;
        if (changed) {
          me.body.emitter.emit('rangechange', { start: new Date(me.start), end: new Date(me.end), byUser: byUser });
        }

        if (done) {
          if (anyChanged) {
            me.body.emitter.emit('rangechanged', { start: new Date(me.start), end: new Date(me.end), byUser: byUser });
          }
        } else {
          // animate with as high as possible frame rate, leave 20 ms in between
          // each to prevent the browser from blocking
          me.animationTimer = setTimeout(next, 20);
        }
      }
    };

    return next();
  } else {
    var changed = this._applyRange(finalStart, finalEnd);
    DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);
    if (changed) {
      var params = { start: new Date(this.start), end: new Date(this.end), byUser: byUser };
      this.body.emitter.emit('rangechange', params);
      this.body.emitter.emit('rangechanged', params);
    }
  }
};

/**
 * Stop an animation
 * @private
 */
Range.prototype._cancelAnimation = function () {
  if (this.animationTimer) {
    clearTimeout(this.animationTimer);
    this.animationTimer = null;
  }
};

/**
 * Set a new start and end range. This method is the same as setRange, but
 * does not trigger a range change and range changed event, and it returns
 * true when the range is changed
 * @param {Number} [start]
 * @param {Number} [end]
 * @return {Boolean} changed
 * @private
 */
Range.prototype._applyRange = function (start, end) {
  var newStart = start != null ? util.convert(start, 'Date').valueOf() : this.start,
      newEnd = end != null ? util.convert(end, 'Date').valueOf() : this.end,
      max = this.options.max != null ? util.convert(this.options.max, 'Date').valueOf() : null,
      min = this.options.min != null ? util.convert(this.options.min, 'Date').valueOf() : null,
      diff;

  // check for valid number
  if (isNaN(newStart) || newStart === null) {
    throw new Error('Invalid start "' + start + '"');
  }
  if (isNaN(newEnd) || newEnd === null) {
    throw new Error('Invalid end "' + end + '"');
  }

  // prevent start < end
  if (newEnd < newStart) {
    newEnd = newStart;
  }

  // prevent start < min
  if (min !== null) {
    if (newStart < min) {
      diff = min - newStart;
      newStart += diff;
      newEnd += diff;

      // prevent end > max
      if (max != null) {
        if (newEnd > max) {
          newEnd = max;
        }
      }
    }
  }

  // prevent end > max
  if (max !== null) {
    if (newEnd > max) {
      diff = newEnd - max;
      newStart -= diff;
      newEnd -= diff;

      // prevent start < min
      if (min != null) {
        if (newStart < min) {
          newStart = min;
        }
      }
    }
  }

  // prevent (end-start) < zoomMin
  if (this.options.zoomMin !== null) {
    var zoomMin = parseFloat(this.options.zoomMin);
    if (zoomMin < 0) {
      zoomMin = 0;
    }
    if (newEnd - newStart < zoomMin) {
      if (this.end - this.start === zoomMin && newStart > this.start && newEnd < this.end) {
        // ignore this action, we are already zoomed to the minimum
        newStart = this.start;
        newEnd = this.end;
      } else {
        // zoom to the minimum
        diff = zoomMin - (newEnd - newStart);
        newStart -= diff / 2;
        newEnd += diff / 2;
      }
    }
  }

  // prevent (end-start) > zoomMax
  if (this.options.zoomMax !== null) {
    var zoomMax = parseFloat(this.options.zoomMax);
    if (zoomMax < 0) {
      zoomMax = 0;
    }

    if (newEnd - newStart > zoomMax) {
      if (this.end - this.start === zoomMax && newStart < this.start && newEnd > this.end) {
        // ignore this action, we are already zoomed to the maximum
        newStart = this.start;
        newEnd = this.end;
      } else {
        // zoom to the maximum
        diff = newEnd - newStart - zoomMax;
        newStart += diff / 2;
        newEnd -= diff / 2;
      }
    }
  }

  var changed = this.start != newStart || this.end != newEnd;

  // if the new range does NOT overlap with the old range, emit checkRangedItems to avoid not showing ranged items (ranged meaning has end time, not necessarily of type Range)
  if (!(newStart >= this.start && newStart <= this.end || newEnd >= this.start && newEnd <= this.end) && !(this.start >= newStart && this.start <= newEnd || this.end >= newStart && this.end <= newEnd)) {
    this.body.emitter.emit('checkRangedItems');
  }

  this.start = newStart;
  this.end = newEnd;
  return changed;
};

/**
 * Retrieve the current range.
 * @return {Object} An object with start and end properties
 */
Range.prototype.getRange = function () {
  return {
    start: this.start,
    end: this.end
  };
};

/**
 * Calculate the conversion offset and scale for current range, based on
 * the provided width
 * @param {Number} width
 * @returns {{offset: number, scale: number}} conversion
 */
Range.prototype.conversion = function (width, totalHidden) {
  return Range.conversion(this.start, this.end, width, totalHidden);
};

/**
 * Static method to calculate the conversion offset and scale for a range,
 * based on the provided start, end, and width
 * @param {Number} start
 * @param {Number} end
 * @param {Number} width
 * @returns {{offset: number, scale: number}} conversion
 */
Range.conversion = function (start, end, width, totalHidden) {
  if (totalHidden === undefined) {
    totalHidden = 0;
  }
  if (width != 0 && end - start != 0) {
    return {
      offset: start,
      scale: width / (end - start - totalHidden)
    };
  } else {
    return {
      offset: 0,
      scale: 1
    };
  }
};

/**
 * Start dragging horizontally or vertically
 * @param {Event} event
 * @private
 */
Range.prototype._onDragStart = function (event) {
  this.deltaDifference = 0;
  this.previousDelta = 0;

  // only allow dragging when configured as movable
  if (!this.options.moveable) return;

  // only start dragging when the mouse is inside the current range
  if (!this._isInsideRange(event)) return;

  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.props.touch.allowDragging) return;

  this.props.touch.start = this.start;
  this.props.touch.end = this.end;
  this.props.touch.dragging = true;

  if (this.body.dom.root) {
    this.body.dom.root.style.cursor = 'move';
  }
};

/**
 * Perform dragging operation
 * @param {Event} event
 * @private
 */
Range.prototype._onDrag = function (event) {
  if (!this.props.touch.dragging) return;

  // only allow dragging when configured as movable
  if (!this.options.moveable) return;

  // TODO: this may be redundant in hammerjs2
  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.props.touch.allowDragging) return;

  var direction = this.options.direction;
  validateDirection(direction);
  var delta = direction == 'horizontal' ? event.deltaX : event.deltaY;
  delta -= this.deltaDifference;
  var interval = this.props.touch.end - this.props.touch.start;

  // normalize dragging speed if cutout is in between.
  var duration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
  interval -= duration;

  var width = direction == 'horizontal' ? this.body.domProps.center.width : this.body.domProps.center.height;
  var diffRange = -delta / width * interval;
  var newStart = this.props.touch.start + diffRange;
  var newEnd = this.props.touch.end + diffRange;

  // snapping times away from hidden zones
  var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, this.previousDelta - delta, true);
  var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, this.previousDelta - delta, true);
  if (safeStart != newStart || safeEnd != newEnd) {
    this.deltaDifference += delta;
    this.props.touch.start = safeStart;
    this.props.touch.end = safeEnd;
    this._onDrag(event);
    return;
  }

  this.previousDelta = delta;
  this._applyRange(newStart, newEnd);

  // fire a rangechange event
  this.body.emitter.emit('rangechange', {
    start: new Date(this.start),
    end: new Date(this.end),
    byUser: true
  });
};

/**
 * Stop dragging operation
 * @param {event} event
 * @private
 */
Range.prototype._onDragEnd = function (event) {
  if (!this.props.touch.dragging) return;

  // only allow dragging when configured as movable
  if (!this.options.moveable) return;

  // TODO: this may be redundant in hammerjs2
  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.props.touch.allowDragging) return;

  this.props.touch.dragging = false;
  if (this.body.dom.root) {
    this.body.dom.root.style.cursor = 'auto';
  }

  // fire a rangechanged event
  this.body.emitter.emit('rangechanged', {
    start: new Date(this.start),
    end: new Date(this.end),
    byUser: true
  });
};

/**
 * Event handler for mouse wheel event, used to zoom
 * Code from http://adomas.org/javascript-mouse-wheel/
 * @param {Event} event
 * @private
 */
Range.prototype._onMouseWheel = function (event) {
  // only allow zooming when configured as zoomable and moveable
  if (!(this.options.zoomable && this.options.moveable)) return;

  // only zoom when the mouse is inside the current range
  if (!this._isInsideRange(event)) return;

  // only zoom when the according key is pressed and the zoomKey option is set
  if (this.options.zoomKey && !event[this.options.zoomKey]) return;

  // retrieve delta
  var delta = 0;
  if (event.wheelDelta) {
    /* IE/Opera. */
    delta = event.wheelDelta / 120;
  } else if (event.detail) {
    /* Mozilla case. */
    // In Mozilla, sign of delta is different than in IE.
    // Also, delta is multiple of 3.
    delta = -event.detail / 3;
  }

  // If delta is nonzero, handle it.
  // Basically, delta is now positive if wheel was scrolled up,
  // and negative, if wheel was scrolled down.
  if (delta) {
    // perform the zoom action. Delta is normally 1 or -1

    // adjust a negative delta such that zooming in with delta 0.1
    // equals zooming out with a delta -0.1
    var scale;
    if (delta < 0) {
      scale = 1 - delta / 5;
    } else {
      scale = 1 / (1 + delta / 5);
    }

    // calculate center, the date to zoom around
    var pointer = getPointer({ x: event.clientX, y: event.clientY }, this.body.dom.center);
    var pointerDate = this._pointerToDate(pointer);

    this.zoom(scale, pointerDate, delta);
  }

  // Prevent default actions caused by mouse wheel
  // (else the page and timeline both zoom and scroll)
  event.preventDefault();
};

/**
 * Start of a touch gesture
 * @private
 */
Range.prototype._onTouch = function (event) {
  this.props.touch.start = this.start;
  this.props.touch.end = this.end;
  this.props.touch.allowDragging = true;
  this.props.touch.center = null;
  this.scaleOffset = 0;
  this.deltaDifference = 0;
};

/**
 * Handle pinch event
 * @param {Event} event
 * @private
 */
Range.prototype._onPinch = function (event) {
  // only allow zooming when configured as zoomable and moveable
  if (!(this.options.zoomable && this.options.moveable)) return;

  this.props.touch.allowDragging = false;

  if (!this.props.touch.center) {
    this.props.touch.center = getPointer(event.center, this.body.dom.center);
  }

  var scale = 1 / (event.scale + this.scaleOffset);
  var centerDate = this._pointerToDate(this.props.touch.center);

  var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
  var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, centerDate);
  var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;

  // calculate new start and end
  var newStart = centerDate - hiddenDurationBefore + (this.props.touch.start - (centerDate - hiddenDurationBefore)) * scale;
  var newEnd = centerDate + hiddenDurationAfter + (this.props.touch.end - (centerDate + hiddenDurationAfter)) * scale;

  // snapping times away from hidden zones
  this.startToFront = 1 - scale <= 0; // used to do the right auto correction with periodic hidden times
  this.endToFront = scale - 1 <= 0; // used to do the right auto correction with periodic hidden times

  var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, 1 - scale, true);
  var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, scale - 1, true);
  if (safeStart != newStart || safeEnd != newEnd) {
    this.props.touch.start = safeStart;
    this.props.touch.end = safeEnd;
    this.scaleOffset = 1 - event.scale;
    newStart = safeStart;
    newEnd = safeEnd;
  }

  this.setRange(newStart, newEnd, false, true);

  this.startToFront = false; // revert to default
  this.endToFront = true; // revert to default
};

/**
 * Test whether the mouse from a mouse event is inside the visible window,
 * between the current start and end date
 * @param {Object} event
 * @return {boolean} Returns true when inside the visible window
 * @private
 */
Range.prototype._isInsideRange = function (event) {
  // calculate the time where the mouse is, check whether inside
  // and no scroll action should happen.
  var clientX = event.center ? event.center.x : event.clientX;
  var x = clientX - util.getAbsoluteLeft(this.body.dom.centerContainer);
  var time = this.body.util.toTime(x);

  return time >= this.start && time <= this.end;
};

/**
 * Helper function to calculate the center date for zooming
 * @param {{x: Number, y: Number}} pointer
 * @return {number} date
 * @private
 */
Range.prototype._pointerToDate = function (pointer) {
  var conversion;
  var direction = this.options.direction;

  validateDirection(direction);

  if (direction == 'horizontal') {
    return this.body.util.toTime(pointer.x).valueOf();
  } else {
    var height = this.body.domProps.center.height;
    conversion = this.conversion(height);
    return pointer.y / conversion.scale + conversion.offset;
  }
};

/**
 * Get the pointer location relative to the location of the dom element
 * @param {{x: Number, y: Number}} touch
 * @param {Element} element   HTML DOM element
 * @return {{x: Number, y: Number}} pointer
 * @private
 */
function getPointer(touch, element) {
  return {
    x: touch.x - util.getAbsoluteLeft(element),
    y: touch.y - util.getAbsoluteTop(element)
  };
}

/**
 * Zoom the range the given scale in or out. Start and end date will
 * be adjusted, and the timeline will be redrawn. You can optionally give a
 * date around which to zoom.
 * For example, try scale = 0.9 or 1.1
 * @param {Number} scale      Scaling factor. Values above 1 will zoom out,
 *                            values below 1 will zoom in.
 * @param {Number} [center]   Value representing a date around which will
 *                            be zoomed.
 */
Range.prototype.zoom = function (scale, center, delta) {
  // if centerDate is not provided, take it half between start Date and end Date
  if (center == null) {
    center = (this.start + this.end) / 2;
  }

  var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
  var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, center);
  var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;

  // calculate new start and end
  var newStart = center - hiddenDurationBefore + (this.start - (center - hiddenDurationBefore)) * scale;
  var newEnd = center + hiddenDurationAfter + (this.end - (center + hiddenDurationAfter)) * scale;

  // snapping times away from hidden zones
  this.startToFront = delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times
  this.endToFront = -delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times
  var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, delta, true);
  var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, -delta, true);
  if (safeStart != newStart || safeEnd != newEnd) {
    newStart = safeStart;
    newEnd = safeEnd;
  }

  this.setRange(newStart, newEnd, false, true);

  this.startToFront = false; // revert to default
  this.endToFront = true; // revert to default
};

/**
 * Move the range with a given delta to the left or right. Start and end
 * value will be adjusted. For example, try delta = 0.1 or -0.1
 * @param {Number}  delta     Moving amount. Positive value will move right,
 *                            negative value will move left
 */
Range.prototype.move = function (delta) {
  // zoom start Date and end Date relative to the centerDate
  var diff = this.end - this.start;

  // apply new values
  var newStart = this.start + diff * delta;
  var newEnd = this.end + diff * delta;

  // TODO: reckon with min and max range

  this.start = newStart;
  this.end = newEnd;
};

/**
 * Move the range to a new center point
 * @param {Number} moveTo      New center point of the range
 */
Range.prototype.moveTo = function (moveTo) {
  var center = (this.start + this.end) / 2;

  var diff = center - moveTo;

  // calculate new start and end
  var newStart = this.start - diff;
  var newEnd = this.end - diff;

  this.setRange(newStart, newEnd);
};

module.exports = Range;

},{"../hammerUtil":31,"../module/moment":33,"../util":59,"./DateUtil":40,"./component/Component":46}],42:[function(require,module,exports){
// Utility functions for ordering and stacking of items
'use strict';

var EPSILON = 0.001; // used when checking collisions, to prevent round-off errors

/**
 * Order items by their start data
 * @param {Item[]} items
 */
exports.orderByStart = function (items) {
  items.sort(function (a, b) {
    return a.data.start - b.data.start;
  });
};

/**
 * Order items by their end date. If they have no end date, their start date
 * is used.
 * @param {Item[]} items
 */
exports.orderByEnd = function (items) {
  items.sort(function (a, b) {
    var aTime = 'end' in a.data ? a.data.end : a.data.start,
        bTime = 'end' in b.data ? b.data.end : b.data.start;

    return aTime - bTime;
  });
};

/**
 * Adjust vertical positions of the items such that they don't overlap each
 * other.
 * @param {Item[]} items
 *            All visible items
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 *            Margins between items and between items and the axis.
 * @param {boolean} [force=false]
 *            If true, all items will be repositioned. If false (default), only
 *            items having a top===null will be re-stacked
 */
exports.stack = function (items, margin, force) {
  var i, iMax;

  if (force) {
    // reset top position of all items
    for (i = 0, iMax = items.length; i < iMax; i++) {
      items[i].top = null;
    }
  }

  // calculate new, non-overlapping positions
  for (i = 0, iMax = items.length; i < iMax; i++) {
    var item = items[i];
    if (item.stack && item.top === null) {
      // initialize top position
      item.top = margin.axis;

      do {
        // TODO: optimize checking for overlap. when there is a gap without items,
        //       you only need to check for items from the next item on, not from zero
        var collidingItem = null;
        for (var j = 0, jj = items.length; j < jj; j++) {
          var other = items[j];
          if (other.top !== null && other !== item && other.stack && exports.collision(item, other, margin.item)) {
            collidingItem = other;
            break;
          }
        }

        if (collidingItem != null) {
          // There is a collision. Reposition the items above the colliding element
          item.top = collidingItem.top + collidingItem.height + margin.item.vertical;
        }
      } while (collidingItem);
    }
  }
};

/**
 * Adjust vertical positions of the items without stacking them
 * @param {Item[]} items
 *            All visible items
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 *            Margins between items and between items and the axis.
 */
exports.nostack = function (items, margin, subgroups) {
  var i, iMax, newTop;

  // reset top position of all items
  for (i = 0, iMax = items.length; i < iMax; i++) {
    if (items[i].data.subgroup !== undefined) {
      newTop = margin.axis;
      for (var subgroup in subgroups) {
        if (subgroups.hasOwnProperty(subgroup)) {
          if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroups[items[i].data.subgroup].index) {
            newTop += subgroups[subgroup].height + margin.item.vertical;
          }
        }
      }
      items[i].top = newTop;
    } else {
      items[i].top = margin.axis;
    }
  }
};

/**
 * Test if the two provided items collide
 * The items must have parameters left, width, top, and height.
 * @param {Item} a          The first item
 * @param {Item} b          The second item
 * @param {{horizontal: number, vertical: number}} margin
 *                          An object containing a horizontal and vertical
 *                          minimum required margin.
 * @return {boolean}        true if a and b collide, else false
 */
exports.collision = function (a, b, margin) {
  return a.left - margin.horizontal + EPSILON < b.left + b.width && a.left + a.width + margin.horizontal - EPSILON > b.left && a.top - margin.vertical + EPSILON < b.top + b.height && a.top + a.height + margin.vertical - EPSILON > b.top;
};

},{}],43:[function(require,module,exports){
'use strict';

var moment = require('../module/moment');
var DateUtil = require('./DateUtil');
var util = require('../util');

/**
 * @constructor  TimeStep
 * The class TimeStep is an iterator for dates. You provide a start date and an
 * end date. The class itself determines the best scale (step size) based on the
 * provided start Date, end Date, and minimumStep.
 *
 * If minimumStep is provided, the step size is chosen as close as possible
 * to the minimumStep but larger than minimumStep. If minimumStep is not
 * provided, the scale is set to 1 DAY.
 * The minimumStep should correspond with the onscreen size of about 6 characters
 *
 * Alternatively, you can set a scale by hand.
 * After creation, you can initialize the class by executing first(). Then you
 * can iterate from the start date to the end date via next(). You can check if
 * the end date is reached with the function hasNext(). After each step, you can
 * retrieve the current date via getCurrent().
 * The TimeStep has scales ranging from milliseconds, seconds, minutes, hours,
 * days, to years.
 *
 * Version: 1.2
 *
 * @param {Date} [start]         The start date, for example new Date(2010, 9, 21)
 *                               or new Date(2010, 9, 21, 23, 45, 00)
 * @param {Date} [end]           The end date
 * @param {Number} [minimumStep] Optional. Minimum step size in milliseconds
 */
function TimeStep(start, end, minimumStep, hiddenDates) {
  this.moment = moment;

  // variables
  this.current = this.moment();
  this._start = this.moment();
  this._end = this.moment();

  this.autoScale = true;
  this.scale = 'day';
  this.step = 1;

  // initialize the range
  this.setRange(start, end, minimumStep);

  // hidden Dates options
  this.switchedDay = false;
  this.switchedMonth = false;
  this.switchedYear = false;
  if (Array.isArray(hiddenDates)) {
    this.hiddenDates = hiddenDates;
  } else if (hiddenDates != undefined) {
    this.hiddenDates = [hiddenDates];
  } else {
    this.hiddenDates = [];
  }

  this.format = TimeStep.FORMAT; // default formatting
}

// Time formatting
TimeStep.FORMAT = {
  minorLabels: {
    millisecond: 'SSS',
    second: 's',
    minute: 'HH:mm',
    hour: 'HH:mm',
    weekday: 'ddd D',
    day: 'D',
    month: 'MMM',
    year: 'YYYY'
  },
  majorLabels: {
    millisecond: 'HH:mm:ss',
    second: 'D MMMM HH:mm',
    minute: 'ddd D MMMM',
    hour: 'ddd D MMMM',
    weekday: 'MMMM YYYY',
    day: 'MMMM YYYY',
    month: 'YYYY',
    year: ''
  }
};

/**
 * Set custom constructor function for moment. Can be used to set dates
 * to UTC or to set a utcOffset.
 * @param {function} moment
 */
TimeStep.prototype.setMoment = function (moment) {
  this.moment = moment;

  // update the date properties, can have a new utcOffset
  this.current = this.moment(this.current);
  this._start = this.moment(this._start);
  this._end = this.moment(this._end);
};

/**
 * Set custom formatting for the minor an major labels of the TimeStep.
 * Both `minorLabels` and `majorLabels` are an Object with properties:
 * 'millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'month', 'year'.
 * @param {{minorLabels: Object, majorLabels: Object}} format
 */
TimeStep.prototype.setFormat = function (format) {
  var defaultFormat = util.deepExtend({}, TimeStep.FORMAT);
  this.format = util.deepExtend(defaultFormat, format);
};

/**
 * Set a new range
 * If minimumStep is provided, the step size is chosen as close as possible
 * to the minimumStep but larger than minimumStep. If minimumStep is not
 * provided, the scale is set to 1 DAY.
 * The minimumStep should correspond with the onscreen size of about 6 characters
 * @param {Date} [start]      The start date and time.
 * @param {Date} [end]        The end date and time.
 * @param {int} [minimumStep] Optional. Minimum step size in milliseconds
 */
TimeStep.prototype.setRange = function (start, end, minimumStep) {
  if (!(start instanceof Date) || !(end instanceof Date)) {
    throw "No legal start or end date in method setRange";
  }

  this._start = start != undefined ? this.moment(start.valueOf()) : new Date();
  this._end = end != undefined ? this.moment(end.valueOf()) : new Date();

  if (this.autoScale) {
    this.setMinimumStep(minimumStep);
  }
};

/**
 * Set the range iterator to the start date.
 */
TimeStep.prototype.start = function () {
  this.current = this._start.clone();
  this.roundToMinor();
};

/**
 * Round the current date to the first minor date value
 * This must be executed once when the current date is set to start Date
 */
TimeStep.prototype.roundToMinor = function () {
  // round to floor
  // IMPORTANT: we have no breaks in this switch! (this is no bug)
  // noinspection FallThroughInSwitchStatementJS
  switch (this.scale) {
    case 'year':
      this.current.year(this.step * Math.floor(this.current.year() / this.step));
      this.current.month(0);
    case 'month':
      this.current.date(1);
    case 'day': // intentional fall through
    case 'weekday':
      this.current.hours(0);
    case 'hour':
      this.current.minutes(0);
    case 'minute':
      this.current.seconds(0);
    case 'second':
      this.current.milliseconds(0);
    //case 'millisecond': // nothing to do for milliseconds
  }

  if (this.step != 1) {
    // round down to the first minor value that is a multiple of the current step size
    switch (this.scale) {
      case 'millisecond':
        this.current.subtract(this.current.milliseconds() % this.step, 'milliseconds');break;
      case 'second':
        this.current.subtract(this.current.seconds() % this.step, 'seconds');break;
      case 'minute':
        this.current.subtract(this.current.minutes() % this.step, 'minutes');break;
      case 'hour':
        this.current.subtract(this.current.hours() % this.step, 'hours');break;
      case 'weekday': // intentional fall through
      case 'day':
        this.current.subtract((this.current.date() - 1) % this.step, 'day');break;
      case 'month':
        this.current.subtract(this.current.month() % this.step, 'month');break;
      case 'year':
        this.current.subtract(this.current.year() % this.step, 'year');break;
      default:
        break;
    }
  }
};

/**
 * Check if the there is a next step
 * @return {boolean}  true if the current date has not passed the end date
 */
TimeStep.prototype.hasNext = function () {
  return this.current.valueOf() <= this._end.valueOf();
};

/**
 * Do the next step
 */
TimeStep.prototype.next = function () {
  var prev = this.current.valueOf();

  // Two cases, needed to prevent issues with switching daylight savings
  // (end of March and end of October)
  if (this.current.month() < 6) {
    switch (this.scale) {
      case 'millisecond':
        this.current.add(this.step, 'millisecond');break;
      case 'second':
        this.current.add(this.step, 'second');break;
      case 'minute':
        this.current.add(this.step, 'minute');break;
      case 'hour':
        this.current.add(this.step, 'hour');
        // in case of skipping an hour for daylight savings, adjust the hour again (else you get: 0h 5h 9h ... instead of 0h 4h 8h ...)
        // TODO: is this still needed now we use the function of moment.js?
        this.current.subtract(this.current.hours() % this.step, 'hour');
        break;
      case 'weekday': // intentional fall through
      case 'day':
        this.current.add(this.step, 'day');break;
      case 'month':
        this.current.add(this.step, 'month');break;
      case 'year':
        this.current.add(this.step, 'year');break;
      default:
        break;
    }
  } else {
    switch (this.scale) {
      case 'millisecond':
        this.current.add(this.step, 'millisecond');break;
      case 'second':
        this.current.add(this.step, 'second');break;
      case 'minute':
        this.current.add(this.step, 'minute');break;
      case 'hour':
        this.current.add(this.step, 'hour');break;
      case 'weekday': // intentional fall through
      case 'day':
        this.current.add(this.step, 'day');break;
      case 'month':
        this.current.add(this.step, 'month');break;
      case 'year':
        this.current.add(this.step, 'year');break;
      default:
        break;
    }
  }

  if (this.step != 1) {
    // round down to the correct major value
    switch (this.scale) {
      case 'millisecond':
        if (this.current.milliseconds() < this.step) this.current.milliseconds(0);break;
      case 'second':
        if (this.current.seconds() < this.step) this.current.seconds(0);break;
      case 'minute':
        if (this.current.minutes() < this.step) this.current.minutes(0);break;
      case 'hour':
        if (this.current.hours() < this.step) this.current.hours(0);break;
      case 'weekday': // intentional fall through
      case 'day':
        if (this.current.date() < this.step + 1) this.current.date(1);break;
      case 'month':
        if (this.current.month() < this.step) this.current.month(0);break;
      case 'year':
        break; // nothing to do for year
      default:
        break;
    }
  }

  // safety mechanism: if current time is still unchanged, move to the end
  if (this.current.valueOf() == prev) {
    this.current = this._end.clone();
  }

  DateUtil.stepOverHiddenDates(this.moment, this, prev);
};

/**
 * Get the current datetime
 * @return {Moment}  current The current date
 */
TimeStep.prototype.getCurrent = function () {
  return this.current;
};

/**
 * Set a custom scale. Autoscaling will be disabled.
 * For example setScale('minute', 5) will result
 * in minor steps of 5 minutes, and major steps of an hour.
 *
 * @param {{scale: string, step: number}} params
 *                               An object containing two properties:
 *                               - A string 'scale'. Choose from 'millisecond', 'second',
 *                                 'minute', 'hour', 'weekday', 'day', 'month', 'year'.
 *                               - A number 'step'. A step size, by default 1.
 *                                 Choose for example 1, 2, 5, or 10.
 */
TimeStep.prototype.setScale = function (params) {
  if (params && typeof params.scale == 'string') {
    this.scale = params.scale;
    this.step = params.step > 0 ? params.step : 1;
    this.autoScale = false;
  }
};

/**
 * Enable or disable autoscaling
 * @param {boolean} enable  If true, autoascaling is set true
 */
TimeStep.prototype.setAutoScale = function (enable) {
  this.autoScale = enable;
};

/**
 * Automatically determine the scale that bests fits the provided minimum step
 * @param {Number} [minimumStep]  The minimum step size in milliseconds
 */
TimeStep.prototype.setMinimumStep = function (minimumStep) {
  if (minimumStep == undefined) {
    return;
  }

  //var b = asc + ds;

  var stepYear = 1000 * 60 * 60 * 24 * 30 * 12;
  var stepMonth = 1000 * 60 * 60 * 24 * 30;
  var stepDay = 1000 * 60 * 60 * 24;
  var stepHour = 1000 * 60 * 60;
  var stepMinute = 1000 * 60;
  var stepSecond = 1000;
  var stepMillisecond = 1;

  // find the smallest step that is larger than the provided minimumStep
  if (stepYear * 1000 > minimumStep) {
    this.scale = 'year';this.step = 1000;
  }
  if (stepYear * 500 > minimumStep) {
    this.scale = 'year';this.step = 500;
  }
  if (stepYear * 100 > minimumStep) {
    this.scale = 'year';this.step = 100;
  }
  if (stepYear * 50 > minimumStep) {
    this.scale = 'year';this.step = 50;
  }
  if (stepYear * 10 > minimumStep) {
    this.scale = 'year';this.step = 10;
  }
  if (stepYear * 5 > minimumStep) {
    this.scale = 'year';this.step = 5;
  }
  if (stepYear > minimumStep) {
    this.scale = 'year';this.step = 1;
  }
  if (stepMonth * 3 > minimumStep) {
    this.scale = 'month';this.step = 3;
  }
  if (stepMonth > minimumStep) {
    this.scale = 'month';this.step = 1;
  }
  if (stepDay * 5 > minimumStep) {
    this.scale = 'day';this.step = 5;
  }
  if (stepDay * 2 > minimumStep) {
    this.scale = 'day';this.step = 2;
  }
  if (stepDay > minimumStep) {
    this.scale = 'day';this.step = 1;
  }
  if (stepDay / 2 > minimumStep) {
    this.scale = 'weekday';this.step = 1;
  }
  if (stepHour * 4 > minimumStep) {
    this.scale = 'hour';this.step = 4;
  }
  if (stepHour > minimumStep) {
    this.scale = 'hour';this.step = 1;
  }
  if (stepMinute * 15 > minimumStep) {
    this.scale = 'minute';this.step = 15;
  }
  if (stepMinute * 10 > minimumStep) {
    this.scale = 'minute';this.step = 10;
  }
  if (stepMinute * 5 > minimumStep) {
    this.scale = 'minute';this.step = 5;
  }
  if (stepMinute > minimumStep) {
    this.scale = 'minute';this.step = 1;
  }
  if (stepSecond * 15 > minimumStep) {
    this.scale = 'second';this.step = 15;
  }
  if (stepSecond * 10 > minimumStep) {
    this.scale = 'second';this.step = 10;
  }
  if (stepSecond * 5 > minimumStep) {
    this.scale = 'second';this.step = 5;
  }
  if (stepSecond > minimumStep) {
    this.scale = 'second';this.step = 1;
  }
  if (stepMillisecond * 200 > minimumStep) {
    this.scale = 'millisecond';this.step = 200;
  }
  if (stepMillisecond * 100 > minimumStep) {
    this.scale = 'millisecond';this.step = 100;
  }
  if (stepMillisecond * 50 > minimumStep) {
    this.scale = 'millisecond';this.step = 50;
  }
  if (stepMillisecond * 10 > minimumStep) {
    this.scale = 'millisecond';this.step = 10;
  }
  if (stepMillisecond * 5 > minimumStep) {
    this.scale = 'millisecond';this.step = 5;
  }
  if (stepMillisecond > minimumStep) {
    this.scale = 'millisecond';this.step = 1;
  }
};

/**
 * Snap a date to a rounded value.
 * The snap intervals are dependent on the current scale and step.
 * Static function
 * @param {Date} date    the date to be snapped.
 * @param {string} scale Current scale, can be 'millisecond', 'second',
 *                       'minute', 'hour', 'weekday, 'day', 'month', 'year'.
 * @param {number} step  Current step (1, 2, 4, 5, ...
 * @return {Date} snappedDate
 */
TimeStep.snap = function (date, scale, step) {
  var clone = moment(date);

  if (scale == 'year') {
    var year = clone.year() + Math.round(clone.month() / 12);
    clone.year(Math.round(year / step) * step);
    clone.month(0);
    clone.date(0);
    clone.hours(0);
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'month') {
    if (clone.date() > 15) {
      clone.date(1);
      clone.add(1, 'month');
      // important: first set Date to 1, after that change the month.
    } else {
        clone.date(1);
      }

    clone.hours(0);
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'day') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 5:
      case 2:
        clone.hours(Math.round(clone.hours() / 24) * 24);break;
      default:
        clone.hours(Math.round(clone.hours() / 12) * 12);break;
    }
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'weekday') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 5:
      case 2:
        clone.hours(Math.round(clone.hours() / 12) * 12);break;
      default:
        clone.hours(Math.round(clone.hours() / 6) * 6);break;
    }
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'hour') {
    switch (step) {
      case 4:
        clone.minutes(Math.round(clone.minutes() / 60) * 60);break;
      default:
        clone.minutes(Math.round(clone.minutes() / 30) * 30);break;
    }
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'minute') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 15:
      case 10:
        clone.minutes(Math.round(clone.minutes() / 5) * 5);
        clone.seconds(0);
        break;
      case 5:
        clone.seconds(Math.round(clone.seconds() / 60) * 60);break;
      default:
        clone.seconds(Math.round(clone.seconds() / 30) * 30);break;
    }
    clone.milliseconds(0);
  } else if (scale == 'second') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 15:
      case 10:
        clone.seconds(Math.round(clone.seconds() / 5) * 5);
        clone.milliseconds(0);
        break;
      case 5:
        clone.milliseconds(Math.round(clone.milliseconds() / 1000) * 1000);break;
      default:
        clone.milliseconds(Math.round(clone.milliseconds() / 500) * 500);break;
    }
  } else if (scale == 'millisecond') {
    var _step = step > 5 ? step / 2 : 1;
    clone.milliseconds(Math.round(clone.milliseconds() / _step) * _step);
  }

  return clone;
};

/**
 * Check if the current value is a major value (for example when the step
 * is DAY, a major value is each first day of the MONTH)
 * @return {boolean} true if current date is major, else false.
 */
TimeStep.prototype.isMajor = function () {
  if (this.switchedYear == true) {
    this.switchedYear = false;
    switch (this.scale) {
      case 'year':
      case 'month':
      case 'weekday':
      case 'day':
      case 'hour':
      case 'minute':
      case 'second':
      case 'millisecond':
        return true;
      default:
        return false;
    }
  } else if (this.switchedMonth == true) {
    this.switchedMonth = false;
    switch (this.scale) {
      case 'weekday':
      case 'day':
      case 'hour':
      case 'minute':
      case 'second':
      case 'millisecond':
        return true;
      default:
        return false;
    }
  } else if (this.switchedDay == true) {
    this.switchedDay = false;
    switch (this.scale) {
      case 'millisecond':
      case 'second':
      case 'minute':
      case 'hour':
        return true;
      default:
        return false;
    }
  }

  var date = this.moment(this.current);
  switch (this.scale) {
    case 'millisecond':
      return date.milliseconds() == 0;
    case 'second':
      return date.seconds() == 0;
    case 'minute':
      return date.hours() == 0 && date.minutes() == 0;
    case 'hour':
      return date.hours() == 0;
    case 'weekday': // intentional fall through
    case 'day':
      return date.date() == 1;
    case 'month':
      return date.month() == 0;
    case 'year':
      return false;
    default:
      return false;
  }
};

/**
 * Returns formatted text for the minor axislabel, depending on the current
 * date and the scale. For example when scale is MINUTE, the current time is
 * formatted as "hh:mm".
 * @param {Date} [date] custom date. if not provided, current date is taken
 */
TimeStep.prototype.getLabelMinor = function (date) {
  if (date == undefined) {
    date = this.current;
  }

  var format = this.format.minorLabels[this.scale];
  return format && format.length > 0 ? this.moment(date).format(format) : '';
};

/**
 * Returns formatted text for the major axis label, depending on the current
 * date and the scale. For example when scale is MINUTE, the major scale is
 * hours, and the hour will be formatted as "hh".
 * @param {Date} [date] custom date. if not provided, current date is taken
 */
TimeStep.prototype.getLabelMajor = function (date) {
  if (date == undefined) {
    date = this.current;
  }

  var format = this.format.majorLabels[this.scale];
  return format && format.length > 0 ? this.moment(date).format(format) : '';
};

TimeStep.prototype.getClassName = function () {
  var _moment = this.moment;
  var m = this.moment(this.current);
  var current = m.locale ? m.locale('en') : m.lang('en'); // old versions of moment have .lang() function
  var step = this.step;

  function even(value) {
    return value / step % 2 == 0 ? ' vis-even' : ' vis-odd';
  }

  function today(date) {
    if (date.isSame(new Date(), 'day')) {
      return ' vis-today';
    }
    if (date.isSame(_moment().add(1, 'day'), 'day')) {
      return ' vis-tomorrow';
    }
    if (date.isSame(_moment().add(-1, 'day'), 'day')) {
      return ' vis-yesterday';
    }
    return '';
  }

  function currentWeek(date) {
    return date.isSame(new Date(), 'week') ? ' vis-current-week' : '';
  }

  function currentMonth(date) {
    return date.isSame(new Date(), 'month') ? ' vis-current-month' : '';
  }

  function currentYear(date) {
    return date.isSame(new Date(), 'year') ? ' vis-current-year' : '';
  }

  switch (this.scale) {
    case 'millisecond':
      return even(current.milliseconds()).trim();

    case 'second':
      return even(current.seconds()).trim();

    case 'minute':
      return even(current.minutes()).trim();

    case 'hour':
      var hours = current.hours();
      if (this.step == 4) {
        hours = hours + '-h' + (hours + 4);
      }
      return 'vis-h' + hours + today(current) + even(current.hours());

    case 'weekday':
      return 'vis-' + current.format('dddd').toLowerCase() + today(current) + currentWeek(current) + even(current.date());

    case 'day':
      var day = current.date();
      var month = current.format('MMMM').toLowerCase();
      return 'vis-day' + day + ' vis-' + month + currentMonth(current) + even(day - 1);

    case 'month':
      return 'vis-' + current.format('MMMM').toLowerCase() + currentMonth(current) + even(current.month());

    case 'year':
      var year = current.year();
      return 'vis-year' + year + currentYear(current) + even(year);

    default:
      return '';
  }
};

module.exports = TimeStep;

},{"../module/moment":33,"../util":59,"./DateUtil":40}],44:[function(require,module,exports){
'use strict';

var Emitter = require('emitter-component');
var Hammer = require('../module/hammer');
var moment = require('../module/moment');
var util = require('../util');
var DataSet = require('../DataSet');
var DataView = require('../DataView');
var Range = require('./Range');
var Core = require('./Core');
var TimeAxis = require('./component/TimeAxis');
var CurrentTime = require('./component/CurrentTime');
var CustomTime = require('./component/CustomTime');
var ItemSet = require('./component/ItemSet');

var Configurator = require('../shared/Configurator');
var Validator = require('../shared/Validator')['default'];
var printStyle = require('../shared/Validator').printStyle;
var allOptions = require('./optionsTimeline').allOptions;
var configureOptions = require('./optionsTimeline').configureOptions;

/**
 * Create a timeline visualization
 * @param {HTMLElement} container
 * @param {vis.DataSet | vis.DataView | Array} [items]
 * @param {vis.DataSet | vis.DataView | Array} [groups]
 * @param {Object} [options]  See Timeline.setOptions for the available options.
 * @constructor
 * @extends Core
 */
function Timeline(container, items, groups, options) {
  if (!(this instanceof Timeline)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // if the third element is options, the forth is groups (optionally);
  if (!(Array.isArray(groups) || groups instanceof DataSet || groups instanceof DataView) && groups instanceof Object) {
    var forthArgument = options;
    options = groups;
    groups = forthArgument;
  }

  var me = this;
  this.defaultOptions = {
    start: null,
    end: null,

    autoResize: true,
    throttleRedraw: 0, // ms

    orientation: {
      axis: 'bottom', // axis orientation: 'bottom', 'top', or 'both'
      item: 'bottom' // not relevant
    },

    moment: moment,

    width: null,
    height: null,
    maxHeight: null,
    minHeight: null
  };
  this.options = util.deepExtend({}, this.defaultOptions);

  // Create the DOM, props, and emitter
  this._create(container);

  // all components listed here will be repainted automatically
  this.components = [];

  this.body = {
    dom: this.dom,
    domProps: this.props,
    emitter: {
      on: this.on.bind(this),
      off: this.off.bind(this),
      emit: this.emit.bind(this)
    },
    hiddenDates: [],
    util: {
      getScale: function getScale() {
        return me.timeAxis.step.scale;
      },
      getStep: function getStep() {
        return me.timeAxis.step.step;
      },

      toScreen: me._toScreen.bind(me),
      toGlobalScreen: me._toGlobalScreen.bind(me), // this refers to the root.width
      toTime: me._toTime.bind(me),
      toGlobalTime: me._toGlobalTime.bind(me)
    }
  };

  // range
  this.range = new Range(this.body);
  this.components.push(this.range);
  this.body.range = this.range;

  // time axis
  this.timeAxis = new TimeAxis(this.body);
  this.timeAxis2 = null; // used in case of orientation option 'both'
  this.components.push(this.timeAxis);

  // current time bar
  this.currentTime = new CurrentTime(this.body);
  this.components.push(this.currentTime);

  // item set
  this.itemSet = new ItemSet(this.body);
  this.components.push(this.itemSet);

  this.itemsData = null; // DataSet
  this.groupsData = null; // DataSet

  this.on('tap', function (event) {
    me.emit('click', me.getEventProperties(event));
  });
  this.on('doubletap', function (event) {
    me.emit('doubleClick', me.getEventProperties(event));
  });
  this.dom.root.oncontextmenu = function (event) {
    me.emit('contextmenu', me.getEventProperties(event));
  };

  // apply options
  if (options) {
    this.setOptions(options);
  }

  // IMPORTANT: THIS HAPPENS BEFORE SET ITEMS!
  if (groups) {
    this.setGroups(groups);
  }

  // create itemset
  if (items) {
    this.setItems(items);
  } else {
    this._redraw();
  }
}

// Extend the functionality from Core
Timeline.prototype = new Core();

/**
 * Load a configurator
 * @return {Object}
 * @private
 */
Timeline.prototype._createConfigurator = function () {
  return new Configurator(this, this.dom.container, configureOptions);
};

/**
 * Force a redraw. The size of all items will be recalculated.
 * Can be useful to manually redraw when option autoResize=false and the window
 * has been resized, or when the items CSS has been changed.
 *
 * Note: this function will be overridden on construction with a trottled version
 */
Timeline.prototype.redraw = function () {
  this.itemSet && this.itemSet.markDirty({ refreshItems: true });
  this._redraw();
};

Timeline.prototype.setOptions = function (options) {
  // validate options
  var errorFound = Validator.validate(options, allOptions);
  if (errorFound === true) {
    console.log('%cErrors have been found in the supplied options object.', printStyle);
  }

  Core.prototype.setOptions.call(this, options);

  if ('type' in options) {
    if (options.type !== this.options.type) {
      this.options.type = options.type;

      // force recreation of all items
      var itemsData = this.itemsData;
      if (itemsData) {
        var selection = this.getSelection();
        this.setItems(null); // remove all
        this.setItems(itemsData); // add all
        this.setSelection(selection); // restore selection
      }
    }
  }
};

/**
 * Set items
 * @param {vis.DataSet | Array | null} items
 */
Timeline.prototype.setItems = function (items) {
  var initialLoad = this.itemsData == null;

  // convert to type DataSet when needed
  var newDataSet;
  if (!items) {
    newDataSet = null;
  } else if (items instanceof DataSet || items instanceof DataView) {
    newDataSet = items;
  } else {
    // turn an array into a dataset
    newDataSet = new DataSet(items, {
      type: {
        start: 'Date',
        end: 'Date'
      }
    });
  }

  // set items
  this.itemsData = newDataSet;
  this.itemSet && this.itemSet.setItems(newDataSet);

  if (initialLoad) {
    if (this.options.start != undefined || this.options.end != undefined) {
      if (this.options.start == undefined || this.options.end == undefined) {
        var range = this.getItemRange();
      }

      var start = this.options.start != undefined ? this.options.start : range.min;
      var end = this.options.end != undefined ? this.options.end : range.max;

      this.setWindow(start, end, { animation: false });
    } else {
      this.fit({ animation: false });
    }
  }
};

/**
 * Set groups
 * @param {vis.DataSet | Array} groups
 */
Timeline.prototype.setGroups = function (groups) {
  // convert to type DataSet when needed
  var newDataSet;
  if (!groups) {
    newDataSet = null;
  } else if (groups instanceof DataSet || groups instanceof DataView) {
    newDataSet = groups;
  } else {
    // turn an array into a dataset
    newDataSet = new DataSet(groups);
  }

  this.groupsData = newDataSet;
  this.itemSet.setGroups(newDataSet);
};

/**
 * Set both items and groups in one go
 * @param {{items: Array | vis.DataSet, groups: Array | vis.DataSet}} data
 */
Timeline.prototype.setData = function (data) {
  if (data && data.groups) {
    this.setGroups(data.groups);
  }

  if (data && data.items) {
    this.setItems(data.items);
  }
};

/**
 * Set selected items by their id. Replaces the current selection
 * Unknown id's are silently ignored.
 * @param {string[] | string} [ids]  An array with zero or more id's of the items to be
 *                                selected. If ids is an empty array, all items will be
 *                                unselected.
 * @param {Object} [options]      Available options:
 *                                `focus: boolean`
 *                                    If true, focus will be set to the selected item(s)
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 *                                    Only applicable when option focus is true.
 */
Timeline.prototype.setSelection = function (ids, options) {
  this.itemSet && this.itemSet.setSelection(ids);

  if (options && options.focus) {
    this.focus(ids, options);
  }
};

/**
 * Get the selected items by their id
 * @return {Array} ids  The ids of the selected items
 */
Timeline.prototype.getSelection = function () {
  return this.itemSet && this.itemSet.getSelection() || [];
};

/**
 * Adjust the visible window such that the selected item (or multiple items)
 * are centered on screen.
 * @param {String | String[]} id     An item id or array with item ids
 * @param {Object} [options]      Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Timeline.prototype.focus = function (id, options) {
  if (!this.itemsData || id == undefined) return;

  var ids = Array.isArray(id) ? id : [id];

  // get the specified item(s)
  var itemsData = this.itemsData.getDataSet().get(ids, {
    type: {
      start: 'Date',
      end: 'Date'
    }
  });

  // calculate minimum start and maximum end of specified items
  var start = null;
  var end = null;
  itemsData.forEach(function (itemData) {
    var s = itemData.start.valueOf();
    var e = 'end' in itemData ? itemData.end.valueOf() : itemData.start.valueOf();

    if (start === null || s < start) {
      start = s;
    }

    if (end === null || e > end) {
      end = e;
    }
  });

  if (start !== null && end !== null) {
    // calculate the new middle and interval for the window
    var middle = (start + end) / 2;
    var interval = Math.max(this.range.end - this.range.start, (end - start) * 1.1);

    var animation = options && options.animation !== undefined ? options.animation : true;
    this.range.setRange(middle - interval / 2, middle + interval / 2, animation);
  }
};

/**
 * Set Timeline window such that it fits all items
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Timeline.prototype.fit = function (options) {
  var animation = options && options.animation !== undefined ? options.animation : true;
  var range = this.getItemRange();
  this.range.setRange(range.min, range.max, animation);
};

/**
 * Determine the range of the items, taking into account their actual width
 * and a margin of 10 pixels on both sides.
 * @return {{min: Date | null, max: Date | null}}
 */
Timeline.prototype.getItemRange = function () {
  var _this = this;

  // get a rough approximation for the range based on the items start and end dates
  var range = this.getDataRange();
  var min = range.min;
  var max = range.max;
  var minItem = null;
  var maxItem = null;

  if (min != null && max != null) {
    var interval;
    var factor;
    var lhs;
    var rhs;
    var delta;

    (function () {
      var getStart = function getStart(item) {
        return util.convert(item.data.start, 'Date').valueOf();
      };

      var getEnd = function getEnd(item) {
        var end = item.data.end != undefined ? item.data.end : item.data.start;
        return util.convert(end, 'Date').valueOf();
      }

      // calculate the date of the left side and right side of the items given
      ;

      interval = max - min;
      // ms
      if (interval <= 0) {
        interval = 10;
      }
      factor = interval / _this.props.center.width;
      util.forEach(_this.itemSet.items, (function (item) {
        item.show();

        var start = getStart(item);
        var end = getEnd(item);

        var left = new Date(start - (item.getWidthLeft() + 10) * factor);
        var right = new Date(end + (item.getWidthRight() + 10) * factor);

        if (left < min) {
          min = left;
          minItem = item;
        }
        if (right > max) {
          max = right;
          maxItem = item;
        }
      }).bind(_this));

      if (minItem && maxItem) {
        lhs = minItem.getWidthLeft() + 10;
        rhs = maxItem.getWidthRight() + 10;
        delta = _this.props.center.width - lhs - rhs;
        // px

        if (delta > 0) {
          min = getStart(minItem) - lhs * interval / delta; // ms
          max = getEnd(maxItem) + rhs * interval / delta; // ms
        }
      }
    })();
  }

  return {
    min: min != null ? new Date(min) : null,
    max: max != null ? new Date(max) : null
  };
};

/**
 * Calculate the data range of the items start and end dates
 * @returns {{min: Date | null, max: Date | null}}
 */
Timeline.prototype.getDataRange = function () {
  var min = null;
  var max = null;

  var dataset = this.itemsData && this.itemsData.getDataSet();
  if (dataset) {
    dataset.forEach(function (item) {
      var start = util.convert(item.start, 'Date').valueOf();
      var end = util.convert(item.end != undefined ? item.end : item.start, 'Date').valueOf();
      if (min === null || start < min) {
        min = start;
      }
      if (max === null || end > max) {
        max = start;
      }
    });
  }

  return {
    min: min != null ? new Date(min) : null,
    max: max != null ? new Date(max) : null
  };
};

/**
 * Generate Timeline related information from an event
 * @param {Event} event
 * @return {Object} An object with related information, like on which area
 *                  The event happened, whether clicked on an item, etc.
 */
Timeline.prototype.getEventProperties = function (event) {
  var clientX = event.center ? event.center.x : event.clientX;
  var clientY = event.center ? event.center.y : event.clientY;
  var x = clientX - util.getAbsoluteLeft(this.dom.centerContainer);
  var y = clientY - util.getAbsoluteTop(this.dom.centerContainer);

  var item = this.itemSet.itemFromTarget(event);
  var group = this.itemSet.groupFromTarget(event);
  var customTime = CustomTime.customTimeFromTarget(event);

  var snap = this.itemSet.options.snap || null;
  var scale = this.body.util.getScale();
  var step = this.body.util.getStep();
  var time = this._toTime(x);
  var snappedTime = snap ? snap(time, scale, step) : time;

  var element = util.getTarget(event);
  var what = null;
  if (item != null) {
    what = 'item';
  } else if (customTime != null) {
    what = 'custom-time';
  } else if (util.hasParent(element, this.timeAxis.dom.foreground)) {
    what = 'axis';
  } else if (this.timeAxis2 && util.hasParent(element, this.timeAxis2.dom.foreground)) {
    what = 'axis';
  } else if (util.hasParent(element, this.itemSet.dom.labelSet)) {
    what = 'group-label';
  } else if (util.hasParent(element, this.currentTime.bar)) {
    what = 'current-time';
  } else if (util.hasParent(element, this.dom.center)) {
    what = 'background';
  }

  return {
    event: event,
    item: item ? item.id : null,
    group: group ? group.groupId : null,
    what: what,
    pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,
    pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,
    x: x,
    y: y,
    time: time,
    snappedTime: snappedTime
  };
};

module.exports = Timeline;

},{"../DataSet":28,"../DataView":29,"../module/hammer":32,"../module/moment":33,"../shared/Configurator":37,"../shared/Validator":38,"../util":59,"./Core":39,"./Range":41,"./component/CurrentTime":47,"./component/CustomTime":48,"./component/ItemSet":50,"./component/TimeAxis":51,"./optionsTimeline":58,"emitter-component":60}],45:[function(require,module,exports){
'use strict';

var util = require('../../util');
var Group = require('./Group');

/**
 * @constructor BackgroundGroup
 * @param {Number | String} groupId
 * @param {Object} data
 * @param {ItemSet} itemSet
 */
function BackgroundGroup(groupId, data, itemSet) {
  Group.call(this, groupId, data, itemSet);

  this.width = 0;
  this.height = 0;
  this.top = 0;
  this.left = 0;
}

BackgroundGroup.prototype = Object.create(Group.prototype);

/**
 * Repaint this group
 * @param {{start: number, end: number}} range
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 * @param {boolean} [restack=false]  Force restacking of all items
 * @return {boolean} Returns true if the group is resized
 */
BackgroundGroup.prototype.redraw = function (range, margin, restack) {
  var resized = false;

  this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);

  // calculate actual size
  this.width = this.dom.background.offsetWidth;

  // apply new height (just always zero for BackgroundGroup
  this.dom.background.style.height = '0';

  // update vertical position of items after they are re-stacked and the height of the group is calculated
  for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
    var item = this.visibleItems[i];
    item.repositionY(margin);
  }

  return resized;
};

/**
 * Show this group: attach to the DOM
 */
BackgroundGroup.prototype.show = function () {
  if (!this.dom.background.parentNode) {
    this.itemSet.dom.background.appendChild(this.dom.background);
  }
};

module.exports = BackgroundGroup;

},{"../../util":59,"./Group":49}],46:[function(require,module,exports){
/**
 * Prototype for visual components
 * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} [body]
 * @param {Object} [options]
 */
"use strict";

function Component(body, options) {
  this.options = null;
  this.props = null;
}

/**
 * Set options for the component. The new options will be merged into the
 * current options.
 * @param {Object} options
 */
Component.prototype.setOptions = function (options) {
  if (options) {
    util.extend(this.options, options);
  }
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
Component.prototype.redraw = function () {
  // should be implemented by the component
  return false;
};

/**
 * Destroy the component. Cleanup DOM and event listeners
 */
Component.prototype.destroy = function () {
  // should be implemented by the component
};

/**
 * Test whether the component is resized since the last time _isResized() was
 * called.
 * @return {Boolean} Returns true if the component is resized
 * @protected
 */
Component.prototype._isResized = function () {
  var resized = this.props._previousWidth !== this.props.width || this.props._previousHeight !== this.props.height;

  this.props._previousWidth = this.props.width;
  this.props._previousHeight = this.props.height;

  return resized;
};

module.exports = Component;

},{}],47:[function(require,module,exports){
'use strict';

var util = require('../../util');
var Component = require('./Component');
var moment = require('../../module/moment');
var locales = require('../locales');

/**
 * A current time bar
 * @param {{range: Range, dom: Object, domProps: Object}} body
 * @param {Object} [options]        Available parameters:
 *                                  {Boolean} [showCurrentTime]
 * @constructor CurrentTime
 * @extends Component
 */
function CurrentTime(body, options) {
  this.body = body;

  // default options
  this.defaultOptions = {
    showCurrentTime: true,

    moment: moment,
    locales: locales,
    locale: 'en'
  };
  this.options = util.extend({}, this.defaultOptions);
  this.offset = 0;

  this._create();

  this.setOptions(options);
}

CurrentTime.prototype = new Component();

/**
 * Create the HTML DOM for the current time bar
 * @private
 */
CurrentTime.prototype._create = function () {
  var bar = document.createElement('div');
  bar.className = 'vis-current-time';
  bar.style.position = 'absolute';
  bar.style.top = '0px';
  bar.style.height = '100%';

  this.bar = bar;
};

/**
 * Destroy the CurrentTime bar
 */
CurrentTime.prototype.destroy = function () {
  this.options.showCurrentTime = false;
  this.redraw(); // will remove the bar from the DOM and stop refreshing

  this.body = null;
};

/**
 * Set options for the component. Options will be merged in current options.
 * @param {Object} options  Available parameters:
 *                          {boolean} [showCurrentTime]
 */
CurrentTime.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    util.selectiveExtend(['showCurrentTime', 'moment', 'locale', 'locales'], this.options, options);
  }
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
CurrentTime.prototype.redraw = function () {
  if (this.options.showCurrentTime) {
    var parent = this.body.dom.backgroundVertical;
    if (this.bar.parentNode != parent) {
      // attach to the dom
      if (this.bar.parentNode) {
        this.bar.parentNode.removeChild(this.bar);
      }
      parent.appendChild(this.bar);

      this.start();
    }

    var now = this.options.moment(new Date().valueOf() + this.offset);
    var x = this.body.util.toScreen(now);

    var locale = this.options.locales[this.options.locale];
    if (!locale) {
      if (!this.warned) {
        console.log('WARNING: options.locales[\'' + this.options.locale + '\'] not found. See http://visjs.org/docs/timeline.html#Localization');
        this.warned = true;
      }
      locale = this.options.locales['en']; // fall back on english when not available
    }
    var title = locale.current + ' ' + locale.time + ': ' + now.format('dddd, MMMM Do YYYY, H:mm:ss');
    title = title.charAt(0).toUpperCase() + title.substring(1);

    this.bar.style.left = x + 'px';
    this.bar.title = title;
  } else {
    // remove the line from the DOM
    if (this.bar.parentNode) {
      this.bar.parentNode.removeChild(this.bar);
    }
    this.stop();
  }

  return false;
};

/**
 * Start auto refreshing the current time bar
 */
CurrentTime.prototype.start = function () {
  var me = this;

  function update() {
    me.stop();

    // determine interval to refresh
    var scale = me.body.range.conversion(me.body.domProps.center.width).scale;
    var interval = 1 / scale / 10;
    if (interval < 30) interval = 30;
    if (interval > 1000) interval = 1000;

    me.redraw();

    // start a renderTimer to adjust for the new time
    me.currentTimeTimer = setTimeout(update, interval);
  }

  update();
};

/**
 * Stop auto refreshing the current time bar
 */
CurrentTime.prototype.stop = function () {
  if (this.currentTimeTimer !== undefined) {
    clearTimeout(this.currentTimeTimer);
    delete this.currentTimeTimer;
  }
};

/**
 * Set a current time. This can be used for example to ensure that a client's
 * time is synchronized with a shared server time.
 * @param {Date | String | Number} time     A Date, unix timestamp, or
 *                                          ISO date string.
 */
CurrentTime.prototype.setCurrentTime = function (time) {
  var t = util.convert(time, 'Date').valueOf();
  var now = new Date().valueOf();
  this.offset = t - now;
  this.redraw();
};

/**
 * Get the current time.
 * @return {Date} Returns the current time.
 */
CurrentTime.prototype.getCurrentTime = function () {
  return new Date(new Date().valueOf() + this.offset);
};

module.exports = CurrentTime;

},{"../../module/moment":33,"../../util":59,"../locales":57,"./Component":46}],48:[function(require,module,exports){
'use strict';

var Hammer = require('../../module/hammer');
var util = require('../../util');
var Component = require('./Component');
var moment = require('../../module/moment');
var locales = require('../locales');

/**
 * A custom time bar
 * @param {{range: Range, dom: Object}} body
 * @param {Object} [options]        Available parameters:
 *                                  {number | string} id
 *                                  {string} locales
 *                                  {string} locale
 * @constructor CustomTime
 * @extends Component
 */

function CustomTime(body, options) {
  this.body = body;

  // default options
  this.defaultOptions = {
    moment: moment,
    locales: locales,
    locale: 'en',
    id: undefined,
    title: undefined
  };
  this.options = util.extend({}, this.defaultOptions);

  if (options && options.time) {
    this.customTime = options.time;
  } else {
    this.customTime = new Date();
  }

  this.eventParams = {}; // stores state parameters while dragging the bar

  this.setOptions(options);

  // create the DOM
  this._create();
}

CustomTime.prototype = new Component();

/**
 * Set options for the component. Options will be merged in current options.
 * @param {Object} options  Available parameters:
 *                                  {number | string} id
 *                                  {string} locales
 *                                  {string} locale
 */
CustomTime.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    util.selectiveExtend(['moment', 'locale', 'locales', 'id'], this.options, options);
  }
};

/**
 * Create the DOM for the custom time
 * @private
 */
CustomTime.prototype._create = function () {
  var bar = document.createElement('div');
  bar['custom-time'] = this;
  bar.className = 'vis-custom-time ' + (this.options.id || '');
  bar.style.position = 'absolute';
  bar.style.top = '0px';
  bar.style.height = '100%';
  this.bar = bar;

  var drag = document.createElement('div');
  drag.style.position = 'relative';
  drag.style.top = '0px';
  drag.style.left = '-10px';
  drag.style.height = '100%';
  drag.style.width = '20px';
  bar.appendChild(drag);

  // attach event listeners
  this.hammer = new Hammer(drag);
  this.hammer.on('panstart', this._onDragStart.bind(this));
  this.hammer.on('panmove', this._onDrag.bind(this));
  this.hammer.on('panend', this._onDragEnd.bind(this));
  this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // 30 is ALL_DIRECTIONS in hammer.
};

/**
 * Destroy the CustomTime bar
 */
CustomTime.prototype.destroy = function () {
  this.hide();

  this.hammer.destroy();
  this.hammer = null;

  this.body = null;
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
CustomTime.prototype.redraw = function () {
  var parent = this.body.dom.backgroundVertical;
  if (this.bar.parentNode != parent) {
    // attach to the dom
    if (this.bar.parentNode) {
      this.bar.parentNode.removeChild(this.bar);
    }
    parent.appendChild(this.bar);
  }

  var x = this.body.util.toScreen(this.customTime);

  var locale = this.options.locales[this.options.locale];
  if (!locale) {
    if (!this.warned) {
      console.log('WARNING: options.locales[\'' + this.options.locale + '\'] not found. See http://visjs.org/docs/timeline.html#Localization');
      this.warned = true;
    }
    locale = this.options.locales['en']; // fall back on english when not available
  }

  var title = this.options.title;
  // To hide the title completely use empty string ''.
  if (title === undefined) {
    title = locale.time + ': ' + this.options.moment(this.customTime).format('dddd, MMMM Do YYYY, H:mm:ss');
    title = title.charAt(0).toUpperCase() + title.substring(1);
  }

  this.bar.style.left = x + 'px';
  this.bar.title = title;

  return false;
};

/**
 * Remove the CustomTime from the DOM
 */
CustomTime.prototype.hide = function () {
  // remove the line from the DOM
  if (this.bar.parentNode) {
    this.bar.parentNode.removeChild(this.bar);
  }
};

/**
 * Set custom time.
 * @param {Date | number | string} time
 */
CustomTime.prototype.setCustomTime = function (time) {
  this.customTime = util.convert(time, 'Date');
  this.redraw();
};

/**
 * Retrieve the current custom time.
 * @return {Date} customTime
 */
CustomTime.prototype.getCustomTime = function () {
  return new Date(this.customTime.valueOf());
};

/**
  * Set custom title.
  * @param {Date | number | string} title
  */
CustomTime.prototype.setCustomTitle = function (title) {
  this.options.title = title;
};

/**
 * Start moving horizontally
 * @param {Event} event
 * @private
 */
CustomTime.prototype._onDragStart = function (event) {
  this.eventParams.dragging = true;
  this.eventParams.customTime = this.customTime;

  event.stopPropagation();
};

/**
 * Perform moving operating.
 * @param {Event} event
 * @private
 */
CustomTime.prototype._onDrag = function (event) {
  if (!this.eventParams.dragging) return;

  var x = this.body.util.toScreen(this.eventParams.customTime) + event.deltaX;
  var time = this.body.util.toTime(x);

  this.setCustomTime(time);

  // fire a timechange event
  this.body.emitter.emit('timechange', {
    id: this.options.id,
    time: new Date(this.customTime.valueOf())
  });

  event.stopPropagation();
};

/**
 * Stop moving operating.
 * @param {Event} event
 * @private
 */
CustomTime.prototype._onDragEnd = function (event) {
  if (!this.eventParams.dragging) return;

  // fire a timechanged event
  this.body.emitter.emit('timechanged', {
    id: this.options.id,
    time: new Date(this.customTime.valueOf())
  });

  event.stopPropagation();
};

/**
 * Find a custom time from an event target:
 * searches for the attribute 'custom-time' in the event target's element tree
 * @param {Event} event
 * @return {CustomTime | null} customTime
 */
CustomTime.customTimeFromTarget = function (event) {
  var target = event.target;
  while (target) {
    if (target.hasOwnProperty('custom-time')) {
      return target['custom-time'];
    }
    target = target.parentNode;
  }

  return null;
};

module.exports = CustomTime;

},{"../../module/hammer":32,"../../module/moment":33,"../../util":59,"../locales":57,"./Component":46}],49:[function(require,module,exports){
'use strict';

var util = require('../../util');
var stack = require('../Stack');
var RangeItem = require('./item/RangeItem');

/**
 * @constructor Group
 * @param {Number | String} groupId
 * @param {Object} data
 * @param {ItemSet} itemSet
 */
function Group(groupId, data, itemSet) {
  this.groupId = groupId;
  this.subgroups = {};
  this.subgroupIndex = 0;
  this.subgroupOrderer = data && data.subgroupOrder;
  this.itemSet = itemSet;

  this.dom = {};
  this.props = {
    label: {
      width: 0,
      height: 0
    }
  };
  this.className = null;

  this.items = {}; // items filtered by groupId of this group
  this.visibleItems = []; // items currently visible in window
  this.orderedItems = {
    byStart: [],
    byEnd: []
  };
  this.checkRangedItems = false; // needed to refresh the ranged items if the window is programatically changed with NO overlap.
  var me = this;
  this.itemSet.body.emitter.on("checkRangedItems", function () {
    me.checkRangedItems = true;
  });

  this._create();

  this.setData(data);
}

/**
 * Create DOM elements for the group
 * @private
 */
Group.prototype._create = function () {
  var label = document.createElement('div');
  if (this.itemSet.options.groupEditable.order) {
    label.className = 'vis-label draggable';
  } else {
    label.className = 'vis-label';
  }
  this.dom.label = label;

  var inner = document.createElement('div');
  inner.className = 'vis-inner';
  label.appendChild(inner);
  this.dom.inner = inner;

  var foreground = document.createElement('div');
  foreground.className = 'vis-group';
  foreground['timeline-group'] = this;
  this.dom.foreground = foreground;

  this.dom.background = document.createElement('div');
  this.dom.background.className = 'vis-group';

  this.dom.axis = document.createElement('div');
  this.dom.axis.className = 'vis-group';

  // create a hidden marker to detect when the Timelines container is attached
  // to the DOM, or the style of a parent of the Timeline is changed from
  // display:none is changed to visible.
  this.dom.marker = document.createElement('div');
  this.dom.marker.style.visibility = 'hidden';
  this.dom.marker.innerHTML = '?';
  this.dom.background.appendChild(this.dom.marker);
};

/**
 * Set the group data for this group
 * @param {Object} data   Group data, can contain properties content and className
 */
Group.prototype.setData = function (data) {
  // update contents
  var content;
  if (this.itemSet.options && this.itemSet.options.groupTemplate) {
    content = this.itemSet.options.groupTemplate(data);
  } else {
    content = data && data.content;
  }

  if (content instanceof Element) {
    this.dom.inner.appendChild(content);
    while (this.dom.inner.firstChild) {
      this.dom.inner.removeChild(this.dom.inner.firstChild);
    }
    this.dom.inner.appendChild(content);
  } else if (content !== undefined && content !== null) {
    this.dom.inner.innerHTML = content;
  } else {
    this.dom.inner.innerHTML = this.groupId || ''; // groupId can be null
  }

  // update title
  this.dom.label.title = data && data.title || '';

  if (!this.dom.inner.firstChild) {
    util.addClassName(this.dom.inner, 'vis-hidden');
  } else {
    util.removeClassName(this.dom.inner, 'vis-hidden');
  }

  // update className
  var className = data && data.className || null;
  if (className != this.className) {
    if (this.className) {
      util.removeClassName(this.dom.label, this.className);
      util.removeClassName(this.dom.foreground, this.className);
      util.removeClassName(this.dom.background, this.className);
      util.removeClassName(this.dom.axis, this.className);
    }
    util.addClassName(this.dom.label, className);
    util.addClassName(this.dom.foreground, className);
    util.addClassName(this.dom.background, className);
    util.addClassName(this.dom.axis, className);
    this.className = className;
  }

  // update style
  if (this.style) {
    util.removeCssText(this.dom.label, this.style);
    this.style = null;
  }
  if (data && data.style) {
    util.addCssText(this.dom.label, data.style);
    this.style = data.style;
  }
};

/**
 * Get the width of the group label
 * @return {number} width
 */
Group.prototype.getLabelWidth = function () {
  return this.props.label.width;
};

/**
 * Repaint this group
 * @param {{start: number, end: number}} range
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 * @param {boolean} [restack=false]  Force restacking of all items
 * @return {boolean} Returns true if the group is resized
 */
Group.prototype.redraw = function (range, margin, restack) {
  var resized = false;

  // force recalculation of the height of the items when the marker height changed
  // (due to the Timeline being attached to the DOM or changed from display:none to visible)
  var markerHeight = this.dom.marker.clientHeight;
  if (markerHeight != this.lastMarkerHeight) {
    this.lastMarkerHeight = markerHeight;

    util.forEach(this.items, function (item) {
      item.dirty = true;
      if (item.displayed) item.redraw();
    });

    restack = true;
  }

  // reposition visible items vertically
  if (typeof this.itemSet.options.order === 'function') {
    // a custom order function

    if (restack) {
      // brute force restack of all items

      // show all items
      var me = this;
      var limitSize = false;
      util.forEach(this.items, function (item) {
        if (!item.displayed) {
          item.redraw();
          me.visibleItems.push(item);
        }
        item.repositionX(limitSize);
      });

      // order all items and force a restacking
      var customOrderedItems = this.orderedItems.byStart.slice().sort(function (a, b) {
        return me.itemSet.options.order(a.data, b.data);
      });
      stack.stack(customOrderedItems, margin, true /* restack=true */);
    }

    this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);
  } else {
    // no custom order function, lazy stacking
    this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);

    if (this.itemSet.options.stack) {
      // TODO: ugly way to access options...
      stack.stack(this.visibleItems, margin, restack);
    } else {
      // no stacking
      stack.nostack(this.visibleItems, margin, this.subgroups);
    }
  }

  // recalculate the height of the group
  var height = this._calculateHeight(margin);

  // calculate actual size and position
  var foreground = this.dom.foreground;
  this.top = foreground.offsetTop;
  this.left = foreground.offsetLeft;
  this.width = foreground.offsetWidth;
  resized = util.updateProperty(this, 'height', height) || resized;

  // recalculate size of label
  resized = util.updateProperty(this.props.label, 'width', this.dom.inner.clientWidth) || resized;
  resized = util.updateProperty(this.props.label, 'height', this.dom.inner.clientHeight) || resized;

  // apply new height
  this.dom.background.style.height = height + 'px';
  this.dom.foreground.style.height = height + 'px';
  this.dom.label.style.height = height + 'px';

  // update vertical position of items after they are re-stacked and the height of the group is calculated
  for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
    var item = this.visibleItems[i];
    item.repositionY(margin);
  }

  return resized;
};

/**
 * recalculate the height of the group
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 * @returns {number} Returns the height
 * @private
 */
Group.prototype._calculateHeight = function (margin) {
  // recalculate the height of the group
  var height;
  var visibleItems = this.visibleItems;
  //var visibleSubgroups = [];
  //this.visibleSubgroups = 0;
  this.resetSubgroups();
  var me = this;
  if (visibleItems.length > 0) {
    var min = visibleItems[0].top;
    var max = visibleItems[0].top + visibleItems[0].height;
    util.forEach(visibleItems, function (item) {
      min = Math.min(min, item.top);
      max = Math.max(max, item.top + item.height);
      if (item.data.subgroup !== undefined) {
        me.subgroups[item.data.subgroup].height = Math.max(me.subgroups[item.data.subgroup].height, item.height);
        me.subgroups[item.data.subgroup].visible = true;
      }
    });
    if (min > margin.axis) {
      // there is an empty gap between the lowest item and the axis
      var offset = min - margin.axis;
      max -= offset;
      util.forEach(visibleItems, function (item) {
        item.top -= offset;
      });
    }
    height = max + margin.item.vertical / 2;
  } else {
    height = 0;
  }
  height = Math.max(height, this.props.label.height);

  return height;
};

/**
 * Show this group: attach to the DOM
 */
Group.prototype.show = function () {
  if (!this.dom.label.parentNode) {
    this.itemSet.dom.labelSet.appendChild(this.dom.label);
  }

  if (!this.dom.foreground.parentNode) {
    this.itemSet.dom.foreground.appendChild(this.dom.foreground);
  }

  if (!this.dom.background.parentNode) {
    this.itemSet.dom.background.appendChild(this.dom.background);
  }

  if (!this.dom.axis.parentNode) {
    this.itemSet.dom.axis.appendChild(this.dom.axis);
  }
};

/**
 * Hide this group: remove from the DOM
 */
Group.prototype.hide = function () {
  var label = this.dom.label;
  if (label.parentNode) {
    label.parentNode.removeChild(label);
  }

  var foreground = this.dom.foreground;
  if (foreground.parentNode) {
    foreground.parentNode.removeChild(foreground);
  }

  var background = this.dom.background;
  if (background.parentNode) {
    background.parentNode.removeChild(background);
  }

  var axis = this.dom.axis;
  if (axis.parentNode) {
    axis.parentNode.removeChild(axis);
  }
};

/**
 * Add an item to the group
 * @param {Item} item
 */
Group.prototype.add = function (item) {
  this.items[item.id] = item;
  item.setParent(this);

  // add to
  if (item.data.subgroup !== undefined) {
    if (this.subgroups[item.data.subgroup] === undefined) {
      this.subgroups[item.data.subgroup] = { height: 0, visible: false, index: this.subgroupIndex, items: [] };
      this.subgroupIndex++;
    }
    this.subgroups[item.data.subgroup].items.push(item);
  }
  this.orderSubgroups();

  if (this.visibleItems.indexOf(item) == -1) {
    var range = this.itemSet.body.range; // TODO: not nice accessing the range like this
    this._checkIfVisible(item, this.visibleItems, range);
  }
};

Group.prototype.orderSubgroups = function () {
  if (this.subgroupOrderer !== undefined) {
    var sortArray = [];
    if (typeof this.subgroupOrderer == 'string') {
      for (var subgroup in this.subgroups) {
        sortArray.push({ subgroup: subgroup, sortField: this.subgroups[subgroup].items[0].data[this.subgroupOrderer] });
      }
      sortArray.sort(function (a, b) {
        return a.sortField - b.sortField;
      });
    } else if (typeof this.subgroupOrderer == 'function') {
      for (var subgroup in this.subgroups) {
        sortArray.push(this.subgroups[subgroup].items[0].data);
      }
      sortArray.sort(this.subgroupOrderer);
    }

    if (sortArray.length > 0) {
      for (var i = 0; i < sortArray.length; i++) {
        this.subgroups[sortArray[i].subgroup].index = i;
      }
    }
  }
};

Group.prototype.resetSubgroups = function () {
  for (var subgroup in this.subgroups) {
    if (this.subgroups.hasOwnProperty(subgroup)) {
      this.subgroups[subgroup].visible = false;
    }
  }
};

/**
 * Remove an item from the group
 * @param {Item} item
 */
Group.prototype.remove = function (item) {
  delete this.items[item.id];
  item.setParent(null);

  // remove from visible items
  var index = this.visibleItems.indexOf(item);
  if (index != -1) this.visibleItems.splice(index, 1);

  if (item.data.subgroup !== undefined) {
    var subgroup = this.subgroups[item.data.subgroup];
    if (subgroup) {
      var itemIndex = subgroup.items.indexOf(item);
      subgroup.items.splice(itemIndex, 1);
      if (!subgroup.items.length) {
        delete this.subgroups[item.data.subgroup];
        this.subgroupIndex--;
      }
      this.orderSubgroups();
    }
  }
};

/**
 * Remove an item from the corresponding DataSet
 * @param {Item} item
 */
Group.prototype.removeFromDataSet = function (item) {
  this.itemSet.removeItem(item.id);
};

/**
 * Reorder the items
 */
Group.prototype.order = function () {
  var array = util.toArray(this.items);
  var startArray = [];
  var endArray = [];

  for (var i = 0; i < array.length; i++) {
    if (array[i].data.end !== undefined) {
      endArray.push(array[i]);
    }
    startArray.push(array[i]);
  }
  this.orderedItems = {
    byStart: startArray,
    byEnd: endArray
  };

  stack.orderByStart(this.orderedItems.byStart);
  stack.orderByEnd(this.orderedItems.byEnd);
};

/**
 * Update the visible items
 * @param {{byStart: Item[], byEnd: Item[]}} orderedItems   All items ordered by start date and by end date
 * @param {Item[]} visibleItems                             The previously visible items.
 * @param {{start: number, end: number}} range              Visible range
 * @return {Item[]} visibleItems                            The new visible items.
 * @private
 */
Group.prototype._updateVisibleItems = function (orderedItems, oldVisibleItems, range) {
  var visibleItems = [];
  var visibleItemsLookup = {}; // we keep this to quickly look up if an item already exists in the list without using indexOf on visibleItems
  var interval = (range.end - range.start) / 4;
  var lowerBound = range.start - interval;
  var upperBound = range.end + interval;
  var item, i;

  // this function is used to do the binary search.
  var searchFunction = function searchFunction(value) {
    if (value < lowerBound) {
      return -1;
    } else if (value <= upperBound) {
      return 0;
    } else {
      return 1;
    }
  };

  // first check if the items that were in view previously are still in view.
  // IMPORTANT: this handles the case for the items with startdate before the window and enddate after the window!
  // also cleans up invisible items.
  if (oldVisibleItems.length > 0) {
    for (i = 0; i < oldVisibleItems.length; i++) {
      this._checkIfVisibleWithReference(oldVisibleItems[i], visibleItems, visibleItemsLookup, range);
    }
  }

  // we do a binary search for the items that have only start values.
  var initialPosByStart = util.binarySearchCustom(orderedItems.byStart, searchFunction, 'data', 'start');

  // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the start values.
  this._traceVisible(initialPosByStart, orderedItems.byStart, visibleItems, visibleItemsLookup, function (item) {
    return item.data.start < lowerBound || item.data.start > upperBound;
  });

  // if the window has changed programmatically without overlapping the old window, the ranged items with start < lowerBound and end > upperbound are not shown.
  // We therefore have to brute force check all items in the byEnd list
  if (this.checkRangedItems == true) {
    this.checkRangedItems = false;
    for (i = 0; i < orderedItems.byEnd.length; i++) {
      this._checkIfVisibleWithReference(orderedItems.byEnd[i], visibleItems, visibleItemsLookup, range);
    }
  } else {
    // we do a binary search for the items that have defined end times.
    var initialPosByEnd = util.binarySearchCustom(orderedItems.byEnd, searchFunction, 'data', 'end');

    // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the end values.
    this._traceVisible(initialPosByEnd, orderedItems.byEnd, visibleItems, visibleItemsLookup, function (item) {
      return item.data.end < lowerBound || item.data.end > upperBound;
    });
  }

  // finally, we reposition all the visible items.
  for (i = 0; i < visibleItems.length; i++) {
    item = visibleItems[i];
    if (!item.displayed) item.show();
    // reposition item horizontally
    item.repositionX();
  }

  // debug
  //console.log("new line")
  //if (this.groupId == null) {
  //  for (i = 0; i < orderedItems.byStart.length; i++) {
  //    item = orderedItems.byStart[i].data;
  //    console.log('start',i,initialPosByStart, item.start.valueOf(), item.content, item.start >= lowerBound && item.start <= upperBound,i == initialPosByStart ? "<------------------- HEREEEE" : "")
  //  }
  //  for (i = 0; i < orderedItems.byEnd.length; i++) {
  //    item = orderedItems.byEnd[i].data;
  //    console.log('rangeEnd',i,initialPosByEnd, item.end.valueOf(), item.content, item.end >= range.start && item.end <= range.end,i == initialPosByEnd ? "<------------------- HEREEEE" : "")
  //  }
  //}

  return visibleItems;
};

Group.prototype._traceVisible = function (initialPos, items, visibleItems, visibleItemsLookup, breakCondition) {
  var item;
  var i;

  if (initialPos != -1) {
    for (i = initialPos; i >= 0; i--) {
      item = items[i];
      if (breakCondition(item)) {
        break;
      } else {
        if (visibleItemsLookup[item.id] === undefined) {
          visibleItemsLookup[item.id] = true;
          visibleItems.push(item);
        }
      }
    }

    for (i = initialPos + 1; i < items.length; i++) {
      item = items[i];
      if (breakCondition(item)) {
        break;
      } else {
        if (visibleItemsLookup[item.id] === undefined) {
          visibleItemsLookup[item.id] = true;
          visibleItems.push(item);
        }
      }
    }
  }
};

/**
 * this function is very similar to the _checkIfInvisible() but it does not
 * return booleans, hides the item if it should not be seen and always adds to
 * the visibleItems.
 * this one is for brute forcing and hiding.
 *
 * @param {Item} item
 * @param {Array} visibleItems
 * @param {{start:number, end:number}} range
 * @private
 */
Group.prototype._checkIfVisible = function (item, visibleItems, range) {
  if (item.isVisible(range)) {
    if (!item.displayed) item.show();
    // reposition item horizontally
    item.repositionX();
    visibleItems.push(item);
  } else {
    if (item.displayed) item.hide();
  }
};

/**
 * this function is very similar to the _checkIfInvisible() but it does not
 * return booleans, hides the item if it should not be seen and always adds to
 * the visibleItems.
 * this one is for brute forcing and hiding.
 *
 * @param {Item} item
 * @param {Array} visibleItems
 * @param {{start:number, end:number}} range
 * @private
 */
Group.prototype._checkIfVisibleWithReference = function (item, visibleItems, visibleItemsLookup, range) {
  if (item.isVisible(range)) {
    if (visibleItemsLookup[item.id] === undefined) {
      visibleItemsLookup[item.id] = true;
      visibleItems.push(item);
    }
  } else {
    if (item.displayed) item.hide();
  }
};

module.exports = Group;

},{"../../util":59,"../Stack":42,"./item/RangeItem":56}],50:[function(require,module,exports){
'use strict';

var Hammer = require('../../module/hammer');
var util = require('../../util');
var DataSet = require('../../DataSet');
var DataView = require('../../DataView');
var TimeStep = require('../TimeStep');
var Component = require('./Component');
var Group = require('./Group');
var BackgroundGroup = require('./BackgroundGroup');
var BoxItem = require('./item/BoxItem');
var PointItem = require('./item/PointItem');
var RangeItem = require('./item/RangeItem');
var BackgroundItem = require('./item/BackgroundItem');

var UNGROUPED = '__ungrouped__'; // reserved group id for ungrouped items
var BACKGROUND = '__background__'; // reserved group id for background items without group

/**
 * An ItemSet holds a set of items and ranges which can be displayed in a
 * range. The width is determined by the parent of the ItemSet, and the height
 * is determined by the size of the items.
 * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
 * @param {Object} [options]      See ItemSet.setOptions for the available options.
 * @constructor ItemSet
 * @extends Component
 */
function ItemSet(body, options) {
  this.body = body;

  this.defaultOptions = {
    type: null, // 'box', 'point', 'range', 'background'
    orientation: {
      item: 'bottom' // item orientation: 'top' or 'bottom'
    },
    align: 'auto', // alignment of box items
    stack: true,
    groupOrderSwap: function groupOrderSwap(fromGroup, toGroup, groups) {
      var targetOrder = toGroup.order;
      toGroup.order = fromGroup.order;
      fromGroup.order = targetOrder;
    },
    groupOrder: 'order',

    selectable: true,
    multiselect: false,

    editable: {
      updateTime: false,
      updateGroup: false,
      add: false,
      remove: false
    },

    groupEditable: {
      order: false,
      add: false,
      remove: false
    },

    snap: TimeStep.snap,

    onAdd: function onAdd(item, callback) {
      callback(item);
    },
    onUpdate: function onUpdate(item, callback) {
      callback(item);
    },
    onMove: function onMove(item, callback) {
      callback(item);
    },
    onRemove: function onRemove(item, callback) {
      callback(item);
    },
    onMoving: function onMoving(item, callback) {
      callback(item);
    },
    onAddGroup: function onAddGroup(item, callback) {
      callback(item);
    },
    onMoveGroup: function onMoveGroup(item, callback) {
      callback(item);
    },
    onRemoveGroup: function onRemoveGroup(item, callback) {
      callback(item);
    },

    margin: {
      item: {
        horizontal: 10,
        vertical: 10
      },
      axis: 20
    }
  };

  // options is shared by this ItemSet and all its items
  this.options = util.extend({}, this.defaultOptions);

  // options for getting items from the DataSet with the correct type
  this.itemOptions = {
    type: { start: 'Date', end: 'Date' }
  };

  this.conversion = {
    toScreen: body.util.toScreen,
    toTime: body.util.toTime
  };
  this.dom = {};
  this.props = {};
  this.hammer = null;

  var me = this;
  this.itemsData = null; // DataSet
  this.groupsData = null; // DataSet

  // listeners for the DataSet of the items
  this.itemListeners = {
    'add': function add(event, params, senderId) {
      me._onAdd(params.items);
    },
    'update': function update(event, params, senderId) {
      me._onUpdate(params.items);
    },
    'remove': function remove(event, params, senderId) {
      me._onRemove(params.items);
    }
  };

  // listeners for the DataSet of the groups
  this.groupListeners = {
    'add': function add(event, params, senderId) {
      me._onAddGroups(params.items);
    },
    'update': function update(event, params, senderId) {
      me._onUpdateGroups(params.items);
    },
    'remove': function remove(event, params, senderId) {
      me._onRemoveGroups(params.items);
    }
  };

  this.items = {}; // object with an Item for every data item
  this.groups = {}; // Group object for every group
  this.groupIds = [];

  this.selection = []; // list with the ids of all selected nodes
  this.stackDirty = true; // if true, all items will be restacked on next redraw

  this.touchParams = {}; // stores properties while dragging
  this.groupTouchParams = {};
  // create the HTML DOM

  this._create();

  this.setOptions(options);
}

ItemSet.prototype = new Component();

// available item types will be registered here
ItemSet.types = {
  background: BackgroundItem,
  box: BoxItem,
  range: RangeItem,
  point: PointItem
};

/**
 * Create the HTML DOM for the ItemSet
 */
ItemSet.prototype._create = function () {
  var frame = document.createElement('div');
  frame.className = 'vis-itemset';
  frame['timeline-itemset'] = this;
  this.dom.frame = frame;

  // create background panel
  var background = document.createElement('div');
  background.className = 'vis-background';
  frame.appendChild(background);
  this.dom.background = background;

  // create foreground panel
  var foreground = document.createElement('div');
  foreground.className = 'vis-foreground';
  frame.appendChild(foreground);
  this.dom.foreground = foreground;

  // create axis panel
  var axis = document.createElement('div');
  axis.className = 'vis-axis';
  this.dom.axis = axis;

  // create labelset
  var labelSet = document.createElement('div');
  labelSet.className = 'vis-labelset';
  this.dom.labelSet = labelSet;

  // create ungrouped Group
  this._updateUngrouped();

  // create background Group
  var backgroundGroup = new BackgroundGroup(BACKGROUND, null, this);
  backgroundGroup.show();
  this.groups[BACKGROUND] = backgroundGroup;

  // attach event listeners
  // Note: we bind to the centerContainer for the case where the height
  //       of the center container is larger than of the ItemSet, so we
  //       can click in the empty area to create a new item or deselect an item.
  this.hammer = new Hammer(this.body.dom.centerContainer);

  // drag items when selected
  this.hammer.on('hammer.input', (function (event) {
    if (event.isFirst) {
      this._onTouch(event);
    }
  }).bind(this));
  this.hammer.on('panstart', this._onDragStart.bind(this));
  this.hammer.on('panmove', this._onDrag.bind(this));
  this.hammer.on('panend', this._onDragEnd.bind(this));
  this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // 30 is ALL_DIRECTIONS in hammer.

  // single select (or unselect) when tapping an item
  this.hammer.on('tap', this._onSelectItem.bind(this));

  // multi select when holding mouse/touch, or on ctrl+click
  this.hammer.on('press', this._onMultiSelectItem.bind(this));

  // add item on doubletap
  this.hammer.on('doubletap', this._onAddItem.bind(this));

  this.groupHammer = new Hammer(this.body.dom.leftContainer);
  this.groupHammer.on('panstart', this._onGroupDragStart.bind(this));
  this.groupHammer.on('panmove', this._onGroupDrag.bind(this));
  this.groupHammer.on('panend', this._onGroupDragEnd.bind(this));
  this.groupHammer.get('pan').set({ threshold: 5, direction: 30 });

  // attach to the DOM
  this.show();
};

/**
 * Set options for the ItemSet. Existing options will be extended/overwritten.
 * @param {Object} [options] The following options are available:
 *                           {String} type
 *                              Default type for the items. Choose from 'box'
 *                              (default), 'point', 'range', or 'background'.
 *                              The default style can be overwritten by
 *                              individual items.
 *                           {String} align
 *                              Alignment for the items, only applicable for
 *                              BoxItem. Choose 'center' (default), 'left', or
 *                              'right'.
 *                           {String} orientation.item
 *                              Orientation of the item set. Choose 'top' or
 *                              'bottom' (default).
 *                           {Function} groupOrder
 *                              A sorting function for ordering groups
 *                           {Boolean} stack
 *                              If true (default), items will be stacked on
 *                              top of each other.
 *                           {Number} margin.axis
 *                              Margin between the axis and the items in pixels.
 *                              Default is 20.
 *                           {Number} margin.item.horizontal
 *                              Horizontal margin between items in pixels.
 *                              Default is 10.
 *                           {Number} margin.item.vertical
 *                              Vertical Margin between items in pixels.
 *                              Default is 10.
 *                           {Number} margin.item
 *                              Margin between items in pixels in both horizontal
 *                              and vertical direction. Default is 10.
 *                           {Number} margin
 *                              Set margin for both axis and items in pixels.
 *                           {Boolean} selectable
 *                              If true (default), items can be selected.
 *                           {Boolean} multiselect
 *                              If true, multiple items can be selected.
 *                              False by default.
 *                           {Boolean} editable
 *                              Set all editable options to true or false
 *                           {Boolean} editable.updateTime
 *                              Allow dragging an item to an other moment in time
 *                           {Boolean} editable.updateGroup
 *                              Allow dragging an item to an other group
 *                           {Boolean} editable.add
 *                              Allow creating new items on double tap
 *                           {Boolean} editable.remove
 *                              Allow removing items by clicking the delete button
 *                              top right of a selected item.
 *                           {Function(item: Item, callback: Function)} onAdd
 *                              Callback function triggered when an item is about to be added:
 *                              when the user double taps an empty space in the Timeline.
 *                           {Function(item: Item, callback: Function)} onUpdate
 *                              Callback function fired when an item is about to be updated.
 *                              This function typically has to show a dialog where the user
 *                              change the item. If not implemented, nothing happens.
 *                           {Function(item: Item, callback: Function)} onMove
 *                              Fired when an item has been moved. If not implemented,
 *                              the move action will be accepted.
 *                           {Function(item: Item, callback: Function)} onRemove
 *                              Fired when an item is about to be deleted.
 *                              If not implemented, the item will be always removed.
 */
ItemSet.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    var fields = ['type', 'align', 'order', 'stack', 'selectable', 'multiselect', 'groupOrder', 'dataAttributes', 'template', 'groupTemplate', 'hide', 'snap', 'groupOrderSwap'];
    util.selectiveExtend(fields, this.options, options);

    if ('orientation' in options) {
      if (typeof options.orientation === 'string') {
        this.options.orientation.item = options.orientation === 'top' ? 'top' : 'bottom';
      } else if (typeof options.orientation === 'object' && 'item' in options.orientation) {
        this.options.orientation.item = options.orientation.item;
      }
    }

    if ('margin' in options) {
      if (typeof options.margin === 'number') {
        this.options.margin.axis = options.margin;
        this.options.margin.item.horizontal = options.margin;
        this.options.margin.item.vertical = options.margin;
      } else if (typeof options.margin === 'object') {
        util.selectiveExtend(['axis'], this.options.margin, options.margin);
        if ('item' in options.margin) {
          if (typeof options.margin.item === 'number') {
            this.options.margin.item.horizontal = options.margin.item;
            this.options.margin.item.vertical = options.margin.item;
          } else if (typeof options.margin.item === 'object') {
            util.selectiveExtend(['horizontal', 'vertical'], this.options.margin.item, options.margin.item);
          }
        }
      }
    }

    if ('editable' in options) {
      if (typeof options.editable === 'boolean') {
        this.options.editable.updateTime = options.editable;
        this.options.editable.updateGroup = options.editable;
        this.options.editable.add = options.editable;
        this.options.editable.remove = options.editable;
      } else if (typeof options.editable === 'object') {
        util.selectiveExtend(['updateTime', 'updateGroup', 'add', 'remove'], this.options.editable, options.editable);
      }
    }

    if ('groupEditable' in options) {
      if (typeof options.groupEditable === 'boolean') {
        this.options.groupEditable.order = options.groupEditable;
        this.options.groupEditable.add = options.groupEditable;
        this.options.groupEditable.remove = options.groupEditable;
      } else if (typeof options.groupEditable === 'object') {
        util.selectiveExtend(['order', 'add', 'remove'], this.options.groupEditable, options.groupEditable);
      }
    }

    // callback functions
    var addCallback = (function (name) {
      var fn = options[name];
      if (fn) {
        if (!(fn instanceof Function)) {
          throw new Error('option ' + name + ' must be a function ' + name + '(item, callback)');
        }
        this.options[name] = fn;
      }
    }).bind(this);
    ['onAdd', 'onUpdate', 'onRemove', 'onMove', 'onMoving', 'onAddGroup', 'onMoveGroup', 'onRemoveGroup'].forEach(addCallback);

    // force the itemSet to refresh: options like orientation and margins may be changed
    this.markDirty();
  }
};

/**
 * Mark the ItemSet dirty so it will refresh everything with next redraw.
 * Optionally, all items can be marked as dirty and be refreshed.
 * @param {{refreshItems: boolean}} [options]
 */
ItemSet.prototype.markDirty = function (options) {
  this.groupIds = [];
  this.stackDirty = true;

  if (options && options.refreshItems) {
    util.forEach(this.items, function (item) {
      item.dirty = true;
      if (item.displayed) item.redraw();
    });
  }
};

/**
 * Destroy the ItemSet
 */
ItemSet.prototype.destroy = function () {
  this.hide();
  this.setItems(null);
  this.setGroups(null);

  this.hammer = null;

  this.body = null;
  this.conversion = null;
};

/**
 * Hide the component from the DOM
 */
ItemSet.prototype.hide = function () {
  // remove the frame containing the items
  if (this.dom.frame.parentNode) {
    this.dom.frame.parentNode.removeChild(this.dom.frame);
  }

  // remove the axis with dots
  if (this.dom.axis.parentNode) {
    this.dom.axis.parentNode.removeChild(this.dom.axis);
  }

  // remove the labelset containing all group labels
  if (this.dom.labelSet.parentNode) {
    this.dom.labelSet.parentNode.removeChild(this.dom.labelSet);
  }
};

/**
 * Show the component in the DOM (when not already visible).
 * @return {Boolean} changed
 */
ItemSet.prototype.show = function () {
  // show frame containing the items
  if (!this.dom.frame.parentNode) {
    this.body.dom.center.appendChild(this.dom.frame);
  }

  // show axis with dots
  if (!this.dom.axis.parentNode) {
    this.body.dom.backgroundVertical.appendChild(this.dom.axis);
  }

  // show labelset containing labels
  if (!this.dom.labelSet.parentNode) {
    this.body.dom.left.appendChild(this.dom.labelSet);
  }
};

/**
 * Set selected items by their id. Replaces the current selection
 * Unknown id's are silently ignored.
 * @param {string[] | string} [ids] An array with zero or more id's of the items to be
 *                                  selected, or a single item id. If ids is undefined
 *                                  or an empty array, all items will be unselected.
 */
ItemSet.prototype.setSelection = function (ids) {
  var i, ii, id, item;

  if (ids == undefined) ids = [];
  if (!Array.isArray(ids)) ids = [ids];

  // unselect currently selected items
  for (i = 0, ii = this.selection.length; i < ii; i++) {
    id = this.selection[i];
    item = this.items[id];
    if (item) item.unselect();
  }

  // select items
  this.selection = [];
  for (i = 0, ii = ids.length; i < ii; i++) {
    id = ids[i];
    item = this.items[id];
    if (item) {
      this.selection.push(id);
      item.select();
    }
  }
};

/**
 * Get the selected items by their id
 * @return {Array} ids  The ids of the selected items
 */
ItemSet.prototype.getSelection = function () {
  return this.selection.concat([]);
};

/**
 * Get the id's of the currently visible items.
 * @returns {Array} The ids of the visible items
 */
ItemSet.prototype.getVisibleItems = function () {
  var range = this.body.range.getRange();
  var left = this.body.util.toScreen(range.start);
  var right = this.body.util.toScreen(range.end);

  var ids = [];
  for (var groupId in this.groups) {
    if (this.groups.hasOwnProperty(groupId)) {
      var group = this.groups[groupId];
      var rawVisibleItems = group.visibleItems;

      // filter the "raw" set with visibleItems into a set which is really
      // visible by pixels
      for (var i = 0; i < rawVisibleItems.length; i++) {
        var item = rawVisibleItems[i];
        // TODO: also check whether visible vertically
        if (item.left < right && item.left + item.width > left) {
          ids.push(item.id);
        }
      }
    }
  }

  return ids;
};

/**
 * Deselect a selected item
 * @param {String | Number} id
 * @private
 */
ItemSet.prototype._deselect = function (id) {
  var selection = this.selection;
  for (var i = 0, ii = selection.length; i < ii; i++) {
    if (selection[i] == id) {
      // non-strict comparison!
      selection.splice(i, 1);
      break;
    }
  }
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
ItemSet.prototype.redraw = function () {
  var margin = this.options.margin,
      range = this.body.range,
      asSize = util.option.asSize,
      options = this.options,
      orientation = options.orientation.item,
      resized = false,
      frame = this.dom.frame;

  // recalculate absolute position (before redrawing groups)
  this.props.top = this.body.domProps.top.height + this.body.domProps.border.top;
  this.props.left = this.body.domProps.left.width + this.body.domProps.border.left;

  // update class name
  frame.className = 'vis-itemset';

  // reorder the groups (if needed)
  resized = this._orderGroups() || resized;

  // check whether zoomed (in that case we need to re-stack everything)
  // TODO: would be nicer to get this as a trigger from Range
  var visibleInterval = range.end - range.start;
  var zoomed = visibleInterval != this.lastVisibleInterval || this.props.width != this.props.lastWidth;
  if (zoomed) this.stackDirty = true;
  this.lastVisibleInterval = visibleInterval;
  this.props.lastWidth = this.props.width;

  var restack = this.stackDirty;
  var firstGroup = this._firstGroup();
  var firstMargin = {
    item: margin.item,
    axis: margin.axis
  };
  var nonFirstMargin = {
    item: margin.item,
    axis: margin.item.vertical / 2
  };
  var height = 0;
  var minHeight = margin.axis + margin.item.vertical;

  // redraw the background group
  this.groups[BACKGROUND].redraw(range, nonFirstMargin, restack);

  // redraw all regular groups
  util.forEach(this.groups, function (group) {
    var groupMargin = group == firstGroup ? firstMargin : nonFirstMargin;
    var groupResized = group.redraw(range, groupMargin, restack);
    resized = groupResized || resized;
    height += group.height;
  });
  height = Math.max(height, minHeight);
  this.stackDirty = false;

  // update frame height
  frame.style.height = asSize(height);

  // calculate actual size
  this.props.width = frame.offsetWidth;
  this.props.height = height;

  // reposition axis
  this.dom.axis.style.top = asSize(orientation == 'top' ? this.body.domProps.top.height + this.body.domProps.border.top : this.body.domProps.top.height + this.body.domProps.centerContainer.height);
  this.dom.axis.style.left = '0';

  // check if this component is resized
  resized = this._isResized() || resized;

  return resized;
};

/**
 * Get the first group, aligned with the axis
 * @return {Group | null} firstGroup
 * @private
 */
ItemSet.prototype._firstGroup = function () {
  var firstGroupIndex = this.options.orientation.item == 'top' ? 0 : this.groupIds.length - 1;
  var firstGroupId = this.groupIds[firstGroupIndex];
  var firstGroup = this.groups[firstGroupId] || this.groups[UNGROUPED];

  return firstGroup || null;
};

/**
 * Create or delete the group holding all ungrouped items. This group is used when
 * there are no groups specified.
 * @protected
 */
ItemSet.prototype._updateUngrouped = function () {
  var ungrouped = this.groups[UNGROUPED];
  var background = this.groups[BACKGROUND];
  var item, itemId;

  if (this.groupsData) {
    // remove the group holding all ungrouped items
    if (ungrouped) {
      ungrouped.hide();
      delete this.groups[UNGROUPED];

      for (itemId in this.items) {
        if (this.items.hasOwnProperty(itemId)) {
          item = this.items[itemId];
          item.parent && item.parent.remove(item);
          var groupId = this._getGroupId(item.data);
          var group = this.groups[groupId];
          group && group.add(item) || item.hide();
        }
      }
    }
  } else {
    // create a group holding all (unfiltered) items
    if (!ungrouped) {
      var id = null;
      var data = null;
      ungrouped = new Group(id, data, this);
      this.groups[UNGROUPED] = ungrouped;

      for (itemId in this.items) {
        if (this.items.hasOwnProperty(itemId)) {
          item = this.items[itemId];
          ungrouped.add(item);
        }
      }

      ungrouped.show();
    }
  }
};

/**
 * Get the element for the labelset
 * @return {HTMLElement} labelSet
 */
ItemSet.prototype.getLabelSet = function () {
  return this.dom.labelSet;
};

/**
 * Set items
 * @param {vis.DataSet | null} items
 */
ItemSet.prototype.setItems = function (items) {
  var me = this,
      ids,
      oldItemsData = this.itemsData;

  // replace the dataset
  if (!items) {
    this.itemsData = null;
  } else if (items instanceof DataSet || items instanceof DataView) {
    this.itemsData = items;
  } else {
    throw new TypeError('Data must be an instance of DataSet or DataView');
  }

  if (oldItemsData) {
    // unsubscribe from old dataset
    util.forEach(this.itemListeners, function (callback, event) {
      oldItemsData.off(event, callback);
    });

    // remove all drawn items
    ids = oldItemsData.getIds();
    this._onRemove(ids);
  }

  if (this.itemsData) {
    // subscribe to new dataset
    var id = this.id;
    util.forEach(this.itemListeners, function (callback, event) {
      me.itemsData.on(event, callback, id);
    });

    // add all new items
    ids = this.itemsData.getIds();
    this._onAdd(ids);

    // update the group holding all ungrouped items
    this._updateUngrouped();
  }
};

/**
 * Get the current items
 * @returns {vis.DataSet | null}
 */
ItemSet.prototype.getItems = function () {
  return this.itemsData;
};

/**
 * Set groups
 * @param {vis.DataSet} groups
 */
ItemSet.prototype.setGroups = function (groups) {
  var me = this,
      ids;

  // unsubscribe from current dataset
  if (this.groupsData) {
    util.forEach(this.groupListeners, function (callback, event) {
      me.groupsData.off(event, callback);
    });

    // remove all drawn groups
    ids = this.groupsData.getIds();
    this.groupsData = null;
    this._onRemoveGroups(ids); // note: this will cause a redraw
  }

  // replace the dataset
  if (!groups) {
    this.groupsData = null;
  } else if (groups instanceof DataSet || groups instanceof DataView) {
    this.groupsData = groups;
  } else {
    throw new TypeError('Data must be an instance of DataSet or DataView');
  }

  if (this.groupsData) {
    // subscribe to new dataset
    var id = this.id;
    util.forEach(this.groupListeners, function (callback, event) {
      me.groupsData.on(event, callback, id);
    });

    // draw all ms
    ids = this.groupsData.getIds();
    this._onAddGroups(ids);
  }

  // update the group holding all ungrouped items
  this._updateUngrouped();

  // update the order of all items in each group
  this._order();

  this.body.emitter.emit('change', { queue: true });
};

/**
 * Get the current groups
 * @returns {vis.DataSet | null} groups
 */
ItemSet.prototype.getGroups = function () {
  return this.groupsData;
};

/**
 * Remove an item by its id
 * @param {String | Number} id
 */
ItemSet.prototype.removeItem = function (id) {
  var item = this.itemsData.get(id),
      dataset = this.itemsData.getDataSet();

  if (item) {
    // confirm deletion
    this.options.onRemove(item, function (item) {
      if (item) {
        // remove by id here, it is possible that an item has no id defined
        // itself, so better not delete by the item itself
        dataset.remove(id);
      }
    });
  }
};

/**
 * Get the time of an item based on it's data and options.type
 * @param {Object} itemData
 * @returns {string} Returns the type
 * @private
 */
ItemSet.prototype._getType = function (itemData) {
  return itemData.type || this.options.type || (itemData.end ? 'range' : 'box');
};

/**
 * Get the group id for an item
 * @param {Object} itemData
 * @returns {string} Returns the groupId
 * @private
 */
ItemSet.prototype._getGroupId = function (itemData) {
  var type = this._getType(itemData);
  if (type == 'background' && itemData.group == undefined) {
    return BACKGROUND;
  } else {
    return this.groupsData ? itemData.group : UNGROUPED;
  }
};

/**
 * Handle updated items
 * @param {Number[]} ids
 * @protected
 */
ItemSet.prototype._onUpdate = function (ids) {
  var me = this;

  ids.forEach((function (id) {
    var itemData = me.itemsData.get(id, me.itemOptions);
    var item = me.items[id];
    var type = me._getType(itemData);

    var constructor = ItemSet.types[type];
    var selected;

    if (item) {
      // update item
      if (!constructor || !(item instanceof constructor)) {
        // item type has changed, delete the item and recreate it
        selected = item.selected; // preserve selection of this item
        me._removeItem(item);
        item = null;
      } else {
        me._updateItem(item, itemData);
      }
    }

    if (!item) {
      // create item
      if (constructor) {
        item = new constructor(itemData, me.conversion, me.options);
        item.id = id; // TODO: not so nice setting id afterwards
        me._addItem(item);
        if (selected) {
          this.selection.push(id);
          item.select();
        }
      } else if (type == 'rangeoverflow') {
        // TODO: deprecated since version 2.1.0 (or 3.0.0?). cleanup some day
        throw new TypeError('Item type "rangeoverflow" is deprecated. Use css styling instead: ' + '.vis-item.vis-range .vis-item-content {overflow: visible;}');
      } else {
        throw new TypeError('Unknown item type "' + type + '"');
      }
    }
  }).bind(this));

  this._order();
  this.stackDirty = true; // force re-stacking of all items next redraw
  this.body.emitter.emit('change', { queue: true });
};

/**
 * Handle added items
 * @param {Number[]} ids
 * @protected
 */
ItemSet.prototype._onAdd = ItemSet.prototype._onUpdate;

/**
 * Handle removed items
 * @param {Number[]} ids
 * @protected
 */
ItemSet.prototype._onRemove = function (ids) {
  var count = 0;
  var me = this;
  ids.forEach(function (id) {
    var item = me.items[id];
    if (item) {
      count++;
      me._removeItem(item);
    }
  });

  if (count) {
    // update order
    this._order();
    this.stackDirty = true; // force re-stacking of all items next redraw
    this.body.emitter.emit('change', { queue: true });
  }
};

/**
 * Update the order of item in all groups
 * @private
 */
ItemSet.prototype._order = function () {
  // reorder the items in all groups
  // TODO: optimization: only reorder groups affected by the changed items
  util.forEach(this.groups, function (group) {
    group.order();
  });
};

/**
 * Handle updated groups
 * @param {Number[]} ids
 * @private
 */
ItemSet.prototype._onUpdateGroups = function (ids) {
  this._onAddGroups(ids);
};

/**
 * Handle changed groups (added or updated)
 * @param {Number[]} ids
 * @private
 */
ItemSet.prototype._onAddGroups = function (ids) {
  var me = this;

  ids.forEach(function (id) {
    var groupData = me.groupsData.get(id);
    var group = me.groups[id];

    if (!group) {
      // check for reserved ids
      if (id == UNGROUPED || id == BACKGROUND) {
        throw new Error('Illegal group id. ' + id + ' is a reserved id.');
      }

      var groupOptions = Object.create(me.options);
      util.extend(groupOptions, {
        height: null
      });

      group = new Group(id, groupData, me);
      me.groups[id] = group;

      // add items with this groupId to the new group
      for (var itemId in me.items) {
        if (me.items.hasOwnProperty(itemId)) {
          var item = me.items[itemId];
          if (item.data.group == id) {
            group.add(item);
          }
        }
      }

      group.order();
      group.show();
    } else {
      // update group
      group.setData(groupData);
    }
  });

  this.body.emitter.emit('change', { queue: true });
};

/**
 * Handle removed groups
 * @param {Number[]} ids
 * @private
 */
ItemSet.prototype._onRemoveGroups = function (ids) {
  var groups = this.groups;
  ids.forEach(function (id) {
    var group = groups[id];

    if (group) {
      group.hide();
      delete groups[id];
    }
  });

  this.markDirty();

  this.body.emitter.emit('change', { queue: true });
};

/**
 * Reorder the groups if needed
 * @return {boolean} changed
 * @private
 */
ItemSet.prototype._orderGroups = function () {
  if (this.groupsData) {
    // reorder the groups
    var groupIds = this.groupsData.getIds({
      order: this.options.groupOrder
    });

    var changed = !util.equalArray(groupIds, this.groupIds);
    if (changed) {
      // hide all groups, removes them from the DOM
      var groups = this.groups;
      groupIds.forEach(function (groupId) {
        groups[groupId].hide();
      });

      // show the groups again, attach them to the DOM in correct order
      groupIds.forEach(function (groupId) {
        groups[groupId].show();
      });

      this.groupIds = groupIds;
    }

    return changed;
  } else {
    return false;
  }
};

/**
 * Add a new item
 * @param {Item} item
 * @private
 */
ItemSet.prototype._addItem = function (item) {
  this.items[item.id] = item;

  // add to group
  var groupId = this._getGroupId(item.data);
  var group = this.groups[groupId];
  if (group) group.add(item);
};

/**
 * Update an existing item
 * @param {Item} item
 * @param {Object} itemData
 * @private
 */
ItemSet.prototype._updateItem = function (item, itemData) {
  var oldGroupId = item.data.group;
  var oldSubGroupId = item.data.subgroup;

  // update the items data (will redraw the item when displayed)
  item.setData(itemData);

  // update group
  if (oldGroupId != item.data.group || oldSubGroupId != item.data.subgroup) {
    var oldGroup = this.groups[oldGroupId];
    if (oldGroup) oldGroup.remove(item);

    var groupId = this._getGroupId(item.data);
    var group = this.groups[groupId];
    if (group) group.add(item);
  }
};

/**
 * Delete an item from the ItemSet: remove it from the DOM, from the map
 * with items, and from the map with visible items, and from the selection
 * @param {Item} item
 * @private
 */
ItemSet.prototype._removeItem = function (item) {
  // remove from DOM
  item.hide();

  // remove from items
  delete this.items[item.id];

  // remove from selection
  var index = this.selection.indexOf(item.id);
  if (index != -1) this.selection.splice(index, 1);

  // remove from group
  item.parent && item.parent.remove(item);
};

/**
 * Create an array containing all items being a range (having an end date)
 * @param array
 * @returns {Array}
 * @private
 */
ItemSet.prototype._constructByEndArray = function (array) {
  var endArray = [];

  for (var i = 0; i < array.length; i++) {
    if (array[i] instanceof RangeItem) {
      endArray.push(array[i]);
    }
  }
  return endArray;
};

/**
 * Register the clicked item on touch, before dragStart is initiated.
 *
 * dragStart is initiated from a mousemove event, AFTER the mouse/touch is
 * already moving. Therefore, the mouse/touch can sometimes be above an other
 * DOM element than the item itself.
 *
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onTouch = function (event) {
  // store the touched item, used in _onDragStart
  this.touchParams.item = this.itemFromTarget(event);
  this.touchParams.dragLeftItem = event.target.dragLeftItem || false;
  this.touchParams.dragRightItem = event.target.dragRightItem || false;
  this.touchParams.itemProps = null;
};

/**
 * Given an group id, returns the index it has.
 *
 * @param {Number} groupID
 * @private
 */
ItemSet.prototype._getGroupIndex = function (groupId) {
  for (var i = 0; i < this.groupIds.length; i++) {
    if (groupId == this.groupIds[i]) return i;
  }
};

/**
 * Start dragging the selected events
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDragStart = function (event) {
  var item = this.touchParams.item || null;
  var me = this;
  var props;

  if (item && item.selected) {

    if (!this.options.editable.updateTime && !this.options.editable.updateGroup && !item.editable) {
      return;
    }

    // override options.editable
    if (item.editable === false) {
      return;
    }

    var dragLeftItem = this.touchParams.dragLeftItem;
    var dragRightItem = this.touchParams.dragRightItem;

    if (dragLeftItem) {
      props = {
        item: dragLeftItem,
        initialX: event.center.x,
        dragLeft: true,
        data: this._cloneItemData(item.data)
      };

      this.touchParams.itemProps = [props];
    } else if (dragRightItem) {
      props = {
        item: dragRightItem,
        initialX: event.center.x,
        dragRight: true,
        data: this._cloneItemData(item.data)
      };

      this.touchParams.itemProps = [props];
    } else {
      this.touchParams.selectedItem = item;

      var baseGroupIndex = this._getGroupIndex(item.data.group);

      this.touchParams.itemProps = this.getSelection().map((function (id) {
        var item = me.items[id];
        var groupIndex = me._getGroupIndex(item.data.group);
        return {
          item: item,
          initialX: event.center.x,
          groupOffset: baseGroupIndex - groupIndex,
          data: this._cloneItemData(item.data)
        };
      }).bind(this));
    }

    event.stopPropagation();
  } else if (this.options.editable.add && (event.srcEvent.ctrlKey || event.srcEvent.metaKey)) {
    // create a new range item when dragging with ctrl key down
    this._onDragStartAddItem(event);
  }
};

/**
 * Start creating a new range item by dragging.
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDragStartAddItem = function (event) {
  var snap = this.options.snap || null;
  var xAbs = util.getAbsoluteLeft(this.dom.frame);
  var x = event.center.x - xAbs - 10; // minus 10 to compensate for the drag starting as soon as you've moved 10px
  var time = this.body.util.toTime(x);
  var scale = this.body.util.getScale();
  var step = this.body.util.getStep();
  var start = snap ? snap(time, scale, step) : start;
  var end = start;

  var itemData = {
    type: 'range',
    start: start,
    end: end,
    content: 'new item'
  };

  var id = util.randomUUID();
  itemData[this.itemsData._fieldId] = id;

  var group = this.groupFromTarget(event);
  if (group) {
    itemData.group = group.groupId;
  }

  var newItem = new RangeItem(itemData, this.conversion, this.options);
  newItem.id = id; // TODO: not so nice setting id afterwards
  newItem.data = this._cloneItemData(itemData);
  this._addItem(newItem);

  var props = {
    item: newItem,
    dragRight: true,
    initialX: event.center.x,
    data: newItem.data
  };
  this.touchParams.itemProps = [props];

  event.stopPropagation();
};

/**
 * Drag selected items
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDrag = function (event) {
  if (this.touchParams.itemProps) {
    event.stopPropagation();

    var me = this;
    var snap = this.options.snap || null;
    var xOffset = this.body.dom.root.offsetLeft + this.body.domProps.left.width;
    var scale = this.body.util.getScale();
    var step = this.body.util.getStep();

    //only calculate the new group for the item that's actually dragged
    var selectedItem = this.touchParams.selectedItem;
    var updateGroupAllowed = me.options.editable.updateGroup;
    var newGroupBase = null;
    if (updateGroupAllowed && selectedItem) {
      if (selectedItem.data.group != undefined) {
        // drag from one group to another
        var group = me.groupFromTarget(event);
        if (group) {
          //we know the offset for all items, so the new group for all items
          //will be relative to this one.
          newGroupBase = this._getGroupIndex(group.groupId);
        }
      }
    }

    // move
    this.touchParams.itemProps.forEach((function (props) {
      var current = me.body.util.toTime(event.center.x - xOffset);
      var initial = me.body.util.toTime(props.initialX - xOffset);
      var offset = current - initial; // ms

      var itemData = this._cloneItemData(props.item.data); // clone the data
      if (props.item.editable === false) {
        return;
      }

      var updateTimeAllowed = me.options.editable.updateTime || props.item.editable === true;

      if (updateTimeAllowed) {
        if (props.dragLeft) {
          // drag left side of a range item
          if (itemData.start != undefined) {
            var initialStart = util.convert(props.data.start, 'Date');
            var start = new Date(initialStart.valueOf() + offset);
            // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
            itemData.start = snap ? snap(start, scale, step) : start;
          }
        } else if (props.dragRight) {
          // drag right side of a range item
          if (itemData.end != undefined) {
            var initialEnd = util.convert(props.data.end, 'Date');
            var end = new Date(initialEnd.valueOf() + offset);
            // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
            itemData.end = snap ? snap(end, scale, step) : end;
          }
        } else {
          // drag both start and end
          if (itemData.start != undefined) {
            var initialStart = util.convert(props.data.start, 'Date').valueOf();
            var start = new Date(initialStart + offset);

            if (itemData.end != undefined) {
              var initialEnd = util.convert(props.data.end, 'Date');
              var duration = initialEnd.valueOf() - initialStart.valueOf();

              // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
              itemData.start = snap ? snap(start, scale, step) : start;
              itemData.end = new Date(itemData.start.valueOf() + duration);
            } else {
              // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
              itemData.start = snap ? snap(start, scale, step) : start;
            }
          }
        }
      }

      var updateGroupAllowed = me.options.editable.updateGroup || props.item.editable === true;

      if (updateGroupAllowed && !props.dragLeft && !props.dragRight && newGroupBase != null) {
        if (itemData.group != undefined) {
          var newOffset = newGroupBase - props.groupOffset;

          //make sure we stay in bounds
          newOffset = Math.max(0, newOffset);
          newOffset = Math.min(me.groupIds.length - 1, newOffset);

          itemData.group = me.groupIds[newOffset];
        }
      }

      // confirm moving the item
      itemData = this._cloneItemData(itemData); // convert start and end to the correct type
      me.options.onMoving(itemData, (function (itemData) {
        if (itemData) {
          props.item.setData(this._cloneItemData(itemData, 'Date'));
        }
      }).bind(this));
    }).bind(this));

    this.stackDirty = true; // force re-stacking of all items next redraw
    this.body.emitter.emit('change');
  }
};

/**
 * Move an item to another group
 * @param {Item} item
 * @param {String | Number} groupId
 * @private
 */
ItemSet.prototype._moveToGroup = function (item, groupId) {
  var group = this.groups[groupId];
  if (group && group.groupId != item.data.group) {
    var oldGroup = item.parent;
    oldGroup.remove(item);
    oldGroup.order();
    group.add(item);
    group.order();

    item.data.group = group.groupId;
  }
};

/**
 * End of dragging selected items
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDragEnd = function (event) {
  if (this.touchParams.itemProps) {
    event.stopPropagation();

    var me = this;
    var dataset = this.itemsData.getDataSet();
    var itemProps = this.touchParams.itemProps;
    this.touchParams.itemProps = null;

    itemProps.forEach((function (props) {
      var id = props.item.id;
      var exists = me.itemsData.get(id, me.itemOptions) != null;

      if (!exists) {
        // add a new item
        me.options.onAdd(props.item.data, function (itemData) {
          me._removeItem(props.item); // remove temporary item
          if (itemData) {
            me.itemsData.getDataSet().add(itemData);
          }

          // force re-stacking of all items next redraw
          me.stackDirty = true;
          me.body.emitter.emit('change');
        });
      } else {
        // update existing item
        var itemData = this._cloneItemData(props.item.data); // convert start and end to the correct type
        me.options.onMove(itemData, function (itemData) {
          if (itemData) {
            // apply changes
            itemData[dataset._fieldId] = id; // ensure the item contains its id (can be undefined)
            dataset.update(itemData);
          } else {
            // restore original values
            props.item.setData(props.data);

            me.stackDirty = true; // force re-stacking of all items next redraw
            me.body.emitter.emit('change');
          }
        });
      }
    }).bind(this));
  }
};

ItemSet.prototype._onGroupDragStart = function (event) {
  if (this.options.groupEditable.order) {
    this.groupTouchParams.group = this.groupFromTarget(event);

    if (this.groupTouchParams.group) {
      event.stopPropagation();

      this.groupTouchParams.originalOrder = this.groupsData.getIds({
        order: this.options.groupOrder
      });
    }
  }
};

ItemSet.prototype._onGroupDrag = function (event) {
  if (this.options.groupEditable.order && this.groupTouchParams.group) {
    event.stopPropagation();

    // drag from one group to another
    var group = this.groupFromTarget(event);

    // try to avoid toggling when groups differ in height
    if (group && group.height != this.groupTouchParams.group.height) {
      var movingUp = group.top < this.groupTouchParams.group.top;
      var clientY = event.center ? event.center.y : event.clientY;
      var targetGroupTop = util.getAbsoluteTop(group.dom.foreground);
      var draggedGroupHeight = this.groupTouchParams.group.height;
      if (movingUp) {
        // skip swapping the groups when the dragged group is not below clientY afterwards
        if (targetGroupTop + draggedGroupHeight < clientY) {
          return;
        }
      } else {
        var targetGroupHeight = group.height;
        // skip swapping the groups when the dragged group is not below clientY afterwards
        if (targetGroupTop + targetGroupHeight - draggedGroupHeight > clientY) {
          return;
        }
      }
    }

    if (group && group != this.groupTouchParams.group) {
      var groupsData = this.groupsData;
      var targetGroup = groupsData.get(group.groupId);
      var draggedGroup = groupsData.get(this.groupTouchParams.group.groupId);

      // switch groups
      if (draggedGroup && targetGroup) {
        this.options.groupOrderSwap(draggedGroup, targetGroup, this.groupsData);
        this.groupsData.update(draggedGroup);
        this.groupsData.update(targetGroup);
      }

      // fetch current order of groups
      var newOrder = this.groupsData.getIds({
        order: this.options.groupOrder
      });

      // in case of changes since _onGroupDragStart
      if (!util.equalArray(newOrder, this.groupTouchParams.originalOrder)) {
        var groupsData = this.groupsData;
        var origOrder = this.groupTouchParams.originalOrder;
        var draggedId = this.groupTouchParams.group.groupId;
        var numGroups = Math.min(origOrder.length, newOrder.length);
        var curPos = 0;
        var newOffset = 0;
        var orgOffset = 0;
        while (curPos < numGroups) {
          // as long as the groups are where they should be step down along the groups order
          while (curPos + newOffset < numGroups && curPos + orgOffset < numGroups && newOrder[curPos + newOffset] == origOrder[curPos + orgOffset]) {
            curPos++;
          }

          // all ok
          if (curPos + newOffset >= numGroups) {
            break;
          }

          // not all ok
          // if dragged group was move upwards everything below should have an offset
          if (newOrder[curPos + newOffset] == draggedId) {
            newOffset = 1;
            continue;
          }
          // if dragged group was move downwards everything above should have an offset
          else if (origOrder[curPos + orgOffset] == draggedId) {
              orgOffset = 1;
              continue;
            }
            // found a group (apart from dragged group) that has the wrong position -> switch with the
            // group at the position where other one should be, fix index arrays and continue
            else {
                var slippedPosition = newOrder.indexOf(origOrder[curPos + orgOffset]);
                var switchGroup = groupsData.get(newOrder[curPos + newOffset]);
                var shouldBeGroup = groupsData.get(origOrder[curPos + orgOffset]);
                this.options.groupOrderSwap(switchGroup, shouldBeGroup, groupsData);
                groupsData.update(switchGroup);
                groupsData.update(shouldBeGroup);

                var switchGroupId = newOrder[curPos + newOffset];
                newOrder[curPos + newOffset] = origOrder[curPos + orgOffset];
                newOrder[slippedPosition] = switchGroupId;

                curPos++;
              }
        }
      }
    }
  }
};

ItemSet.prototype._onGroupDragEnd = function (event) {
  if (this.options.groupEditable.order && this.groupTouchParams.group) {
    event.stopPropagation();

    // update existing group
    var me = this;
    var id = me.groupTouchParams.group.groupId;
    var dataset = me.groupsData.getDataSet();
    var groupData = util.extend({}, dataset.get(id)); // clone the data
    me.options.onMoveGroup(groupData, function (groupData) {
      if (groupData) {
        // apply changes
        groupData[dataset._fieldId] = id; // ensure the group contains its id (can be undefined)
        dataset.update(groupData);
      } else {

        // fetch current order of groups
        var newOrder = dataset.getIds({
          order: me.options.groupOrder
        });

        // restore original order
        if (!util.equalArray(newOrder, me.groupTouchParams.originalOrder)) {
          var origOrder = me.groupTouchParams.originalOrder;
          var numGroups = Math.min(origOrder.length, newOrder.length);
          var curPos = 0;
          while (curPos < numGroups) {
            // as long as the groups are where they should be step down along the groups order
            while (curPos < numGroups && newOrder[curPos] == origOrder[curPos]) {
              curPos++;
            }

            // all ok
            if (curPos >= numGroups) {
              break;
            }

            // found a group that has the wrong position -> switch with the
            // group at the position where other one should be, fix index arrays and continue
            var slippedPosition = newOrder.indexOf(origOrder[curPos]);
            var switchGroup = dataset.get(newOrder[curPos]);
            var shouldBeGroup = dataset.get(origOrder[curPos]);
            me.options.groupOrderSwap(switchGroup, shouldBeGroup, dataset);
            groupsData.update(switchGroup);
            groupsData.update(shouldBeGroup);

            var switchGroupId = newOrder[curPos];
            newOrder[curPos] = origOrder[curPos];
            newOrder[slippedPosition] = switchGroupId;

            curPos++;
          }
        }
      }
    });

    me.body.emitter.emit('groupDragged', { groupId: id });
  }
};

/**
 * Handle selecting/deselecting an item when tapping it
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onSelectItem = function (event) {
  if (!this.options.selectable) return;

  var ctrlKey = event.srcEvent && (event.srcEvent.ctrlKey || event.srcEvent.metaKey);
  var shiftKey = event.srcEvent && event.srcEvent.shiftKey;
  if (ctrlKey || shiftKey) {
    this._onMultiSelectItem(event);
    return;
  }

  var oldSelection = this.getSelection();

  var item = this.itemFromTarget(event);
  var selection = item ? [item.id] : [];
  this.setSelection(selection);

  var newSelection = this.getSelection();

  // emit a select event,
  // except when old selection is empty and new selection is still empty
  if (newSelection.length > 0 || oldSelection.length > 0) {
    this.body.emitter.emit('select', {
      items: newSelection,
      event: event
    });
  }
};

/**
 * Handle creation and updates of an item on double tap
 * @param event
 * @private
 */
ItemSet.prototype._onAddItem = function (event) {
  if (!this.options.selectable) return;
  if (!this.options.editable.add) return;

  var me = this;
  var snap = this.options.snap || null;
  var item = this.itemFromTarget(event);

  event.stopPropagation();

  if (item) {
    // update item

    // execute async handler to update the item (or cancel it)
    var itemData = me.itemsData.get(item.id); // get a clone of the data from the dataset
    this.options.onUpdate(itemData, function (itemData) {
      if (itemData) {
        me.itemsData.getDataSet().update(itemData);
      }
    });
  } else {
    // add item
    var xAbs = util.getAbsoluteLeft(this.dom.frame);
    var x = event.center.x - xAbs;
    var start = this.body.util.toTime(x);
    var scale = this.body.util.getScale();
    var step = this.body.util.getStep();

    var newItemData = {
      start: snap ? snap(start, scale, step) : start,
      content: 'new item'
    };

    // when default type is a range, add a default end date to the new item
    if (this.options.type === 'range') {
      var end = this.body.util.toTime(x + this.props.width / 5);
      newItemData.end = snap ? snap(end, scale, step) : end;
    }

    newItemData[this.itemsData._fieldId] = util.randomUUID();

    var group = this.groupFromTarget(event);
    if (group) {
      newItemData.group = group.groupId;
    }

    // execute async handler to customize (or cancel) adding an item
    newItemData = this._cloneItemData(newItemData); // convert start and end to the correct type
    this.options.onAdd(newItemData, function (item) {
      if (item) {
        me.itemsData.getDataSet().add(item);
        // TODO: need to trigger a redraw?
      }
    });
  }
};

/**
 * Handle selecting/deselecting multiple items when holding an item
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onMultiSelectItem = function (event) {
  if (!this.options.selectable) return;

  var item = this.itemFromTarget(event);

  if (item) {
    // multi select items (if allowed)

    var selection = this.options.multiselect ? this.getSelection() // take current selection
    : []; // deselect current selection

    var shiftKey = event.srcEvent && event.srcEvent.shiftKey || false;

    if (shiftKey && this.options.multiselect) {
      // select all items between the old selection and the tapped item

      // determine the selection range
      selection.push(item.id);
      var range = ItemSet._getItemRange(this.itemsData.get(selection, this.itemOptions));

      // select all items within the selection range
      selection = [];
      for (var id in this.items) {
        if (this.items.hasOwnProperty(id)) {
          var _item = this.items[id];
          var start = _item.data.start;
          var end = _item.data.end !== undefined ? _item.data.end : start;

          if (start >= range.min && end <= range.max && !(_item instanceof BackgroundItem)) {
            selection.push(_item.id); // do not use id but item.id, id itself is stringified
          }
        }
      }
    } else {
        // add/remove this item from the current selection
        var index = selection.indexOf(item.id);
        if (index == -1) {
          // item is not yet selected -> select it
          selection.push(item.id);
        } else {
          // item is already selected -> deselect it
          selection.splice(index, 1);
        }
      }

    this.setSelection(selection);

    this.body.emitter.emit('select', {
      items: this.getSelection(),
      event: event
    });
  }
};

/**
 * Calculate the time range of a list of items
 * @param {Array.<Object>} itemsData
 * @return {{min: Date, max: Date}} Returns the range of the provided items
 * @private
 */
ItemSet._getItemRange = function (itemsData) {
  var max = null;
  var min = null;

  itemsData.forEach(function (data) {
    if (min == null || data.start < min) {
      min = data.start;
    }

    if (data.end != undefined) {
      if (max == null || data.end > max) {
        max = data.end;
      }
    } else {
      if (max == null || data.start > max) {
        max = data.start;
      }
    }
  });

  return {
    min: min,
    max: max
  };
};

/**
 * Find an item from an event target:
 * searches for the attribute 'timeline-item' in the event target's element tree
 * @param {Event} event
 * @return {Item | null} item
 */
ItemSet.prototype.itemFromTarget = function (event) {
  var target = event.target;
  while (target) {
    if (target.hasOwnProperty('timeline-item')) {
      return target['timeline-item'];
    }
    target = target.parentNode;
  }

  return null;
};

/**
 * Find the Group from an event target:
 * searches for the attribute 'timeline-group' in the event target's element tree
 * @param {Event} event
 * @return {Group | null} group
 */
ItemSet.prototype.groupFromTarget = function (event) {
  var clientY = event.center ? event.center.y : event.clientY;
  for (var i = 0; i < this.groupIds.length; i++) {
    var groupId = this.groupIds[i];
    var group = this.groups[groupId];
    var foreground = group.dom.foreground;
    var top = util.getAbsoluteTop(foreground);
    if (clientY > top && clientY < top + foreground.offsetHeight) {
      return group;
    }

    if (this.options.orientation.item === 'top') {
      if (i === this.groupIds.length - 1 && clientY > top) {
        return group;
      }
    } else {
      if (i === 0 && clientY < top + foreground.offset) {
        return group;
      }
    }
  }

  return null;
};

/**
 * Find the ItemSet from an event target:
 * searches for the attribute 'timeline-itemset' in the event target's element tree
 * @param {Event} event
 * @return {ItemSet | null} item
 */
ItemSet.itemSetFromTarget = function (event) {
  var target = event.target;
  while (target) {
    if (target.hasOwnProperty('timeline-itemset')) {
      return target['timeline-itemset'];
    }
    target = target.parentNode;
  }

  return null;
};

/**
 * Clone the data of an item, and "normalize" it: convert the start and end date
 * to the type (Date, Moment, ...) configured in the DataSet. If not configured,
 * start and end are converted to Date.
 * @param {Object} itemData, typically `item.data`
 * @param {string} [type]  Optional Date type. If not provided, the type from the DataSet is taken
 * @return {Object} The cloned object
 * @private
 */
ItemSet.prototype._cloneItemData = function (itemData, type) {
  var clone = util.extend({}, itemData);

  if (!type) {
    // convert start and end date to the type (Date, Moment, ...) configured in the DataSet
    type = this.itemsData.getDataSet()._options.type;
  }

  if (clone.start != undefined) {
    clone.start = util.convert(clone.start, type && type.start || 'Date');
  }
  if (clone.end != undefined) {
    clone.end = util.convert(clone.end, type && type.end || 'Date');
  }

  return clone;
};

module.exports = ItemSet;

},{"../../DataSet":28,"../../DataView":29,"../../module/hammer":32,"../../util":59,"../TimeStep":43,"./BackgroundGroup":45,"./Component":46,"./Group":49,"./item/BackgroundItem":52,"./item/BoxItem":53,"./item/PointItem":55,"./item/RangeItem":56}],51:[function(require,module,exports){
'use strict';

var util = require('../../util');
var Component = require('./Component');
var TimeStep = require('../TimeStep');
var DateUtil = require('../DateUtil');
var moment = require('../../module/moment');

/**
 * A horizontal time axis
 * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
 * @param {Object} [options]        See TimeAxis.setOptions for the available
 *                                  options.
 * @constructor TimeAxis
 * @extends Component
 */
function TimeAxis(body, options) {
  this.dom = {
    foreground: null,
    lines: [],
    majorTexts: [],
    minorTexts: [],
    redundant: {
      lines: [],
      majorTexts: [],
      minorTexts: []
    }
  };
  this.props = {
    range: {
      start: 0,
      end: 0,
      minimumStep: 0
    },
    lineTop: 0
  };

  this.defaultOptions = {
    orientation: {
      axis: 'bottom'
    }, // axis orientation: 'top' or 'bottom'
    showMinorLabels: true,
    showMajorLabels: true,
    format: TimeStep.FORMAT,
    moment: moment,
    timeAxis: null
  };
  this.options = util.extend({}, this.defaultOptions);

  this.body = body;

  // create the HTML DOM
  this._create();

  this.setOptions(options);
}

TimeAxis.prototype = new Component();

/**
 * Set options for the TimeAxis.
 * Parameters will be merged in current options.
 * @param {Object} options  Available options:
 *                          {string} [orientation.axis]
 *                          {boolean} [showMinorLabels]
 *                          {boolean} [showMajorLabels]
 */
TimeAxis.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    util.selectiveExtend(['showMinorLabels', 'showMajorLabels', 'hiddenDates', 'timeAxis', 'moment'], this.options, options);

    // deep copy the format options
    util.selectiveDeepExtend(['format'], this.options, options);

    if ('orientation' in options) {
      if (typeof options.orientation === 'string') {
        this.options.orientation.axis = options.orientation;
      } else if (typeof options.orientation === 'object' && 'axis' in options.orientation) {
        this.options.orientation.axis = options.orientation.axis;
      }
    }

    // apply locale to moment.js
    // TODO: not so nice, this is applied globally to moment.js
    if ('locale' in options) {
      if (typeof moment.locale === 'function') {
        // moment.js 2.8.1+
        moment.locale(options.locale);
      } else {
        moment.lang(options.locale);
      }
    }
  }
};

/**
 * Create the HTML DOM for the TimeAxis
 */
TimeAxis.prototype._create = function () {
  this.dom.foreground = document.createElement('div');
  this.dom.background = document.createElement('div');

  this.dom.foreground.className = 'vis-time-axis vis-foreground';
  this.dom.background.className = 'vis-time-axis vis-background';
};

/**
 * Destroy the TimeAxis
 */
TimeAxis.prototype.destroy = function () {
  // remove from DOM
  if (this.dom.foreground.parentNode) {
    this.dom.foreground.parentNode.removeChild(this.dom.foreground);
  }
  if (this.dom.background.parentNode) {
    this.dom.background.parentNode.removeChild(this.dom.background);
  }

  this.body = null;
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
TimeAxis.prototype.redraw = function () {
  var props = this.props;
  var foreground = this.dom.foreground;
  var background = this.dom.background;

  // determine the correct parent DOM element (depending on option orientation)
  var parent = this.options.orientation.axis == 'top' ? this.body.dom.top : this.body.dom.bottom;
  var parentChanged = foreground.parentNode !== parent;

  // calculate character width and height
  this._calculateCharSize();

  // TODO: recalculate sizes only needed when parent is resized or options is changed
  var showMinorLabels = this.options.showMinorLabels && this.options.orientation.axis !== 'none';
  var showMajorLabels = this.options.showMajorLabels && this.options.orientation.axis !== 'none';

  // determine the width and height of the elemens for the axis
  props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
  props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;
  props.height = props.minorLabelHeight + props.majorLabelHeight;
  props.width = foreground.offsetWidth;

  props.minorLineHeight = this.body.domProps.root.height - props.majorLabelHeight - (this.options.orientation.axis == 'top' ? this.body.domProps.bottom.height : this.body.domProps.top.height);
  props.minorLineWidth = 1; // TODO: really calculate width
  props.majorLineHeight = props.minorLineHeight + props.majorLabelHeight;
  props.majorLineWidth = 1; // TODO: really calculate width

  //  take foreground and background offline while updating (is almost twice as fast)
  var foregroundNextSibling = foreground.nextSibling;
  var backgroundNextSibling = background.nextSibling;
  foreground.parentNode && foreground.parentNode.removeChild(foreground);
  background.parentNode && background.parentNode.removeChild(background);

  foreground.style.height = this.props.height + 'px';

  this._repaintLabels();

  // put DOM online again (at the same place)
  if (foregroundNextSibling) {
    parent.insertBefore(foreground, foregroundNextSibling);
  } else {
    parent.appendChild(foreground);
  }
  if (backgroundNextSibling) {
    this.body.dom.backgroundVertical.insertBefore(background, backgroundNextSibling);
  } else {
    this.body.dom.backgroundVertical.appendChild(background);
  }

  return this._isResized() || parentChanged;
};

/**
 * Repaint major and minor text labels and vertical grid lines
 * @private
 */
TimeAxis.prototype._repaintLabels = function () {
  var orientation = this.options.orientation.axis;

  // calculate range and step (step such that we have space for 7 characters per label)
  var start = util.convert(this.body.range.start, 'Number');
  var end = util.convert(this.body.range.end, 'Number');
  var timeLabelsize = this.body.util.toTime((this.props.minorCharWidth || 10) * 7).valueOf();
  var minimumStep = timeLabelsize - DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this.body.range, timeLabelsize);
  minimumStep -= this.body.util.toTime(0).valueOf();

  var step = new TimeStep(new Date(start), new Date(end), minimumStep, this.body.hiddenDates);
  step.setMoment(this.options.moment);
  if (this.options.format) {
    step.setFormat(this.options.format);
  }
  if (this.options.timeAxis) {
    step.setScale(this.options.timeAxis);
  }
  this.step = step;

  // Move all DOM elements to a "redundant" list, where they
  // can be picked for re-use, and clear the lists with lines and texts.
  // At the end of the function _repaintLabels, left over elements will be cleaned up
  var dom = this.dom;
  dom.redundant.lines = dom.lines;
  dom.redundant.majorTexts = dom.majorTexts;
  dom.redundant.minorTexts = dom.minorTexts;
  dom.lines = [];
  dom.majorTexts = [];
  dom.minorTexts = [];

  var current;
  var next;
  var x;
  var xNext;
  var isMajor;
  var width;
  var line;
  var labelMinor;
  var xFirstMajorLabel = undefined;
  var max = 0;
  var className;

  step.start();
  next = step.getCurrent();
  xNext = this.body.util.toScreen(next);
  while (step.hasNext() && max < 1000) {
    max++;

    isMajor = step.isMajor();
    className = step.getClassName();
    labelMinor = step.getLabelMinor();

    current = next;
    x = xNext;

    step.next();
    next = step.getCurrent();
    xNext = this.body.util.toScreen(next);

    width = xNext - x;
    var labelFits = (labelMinor.length + 1) * this.props.minorCharWidth < width;

    if (this.options.showMinorLabels && labelFits) {
      this._repaintMinorText(x, labelMinor, orientation, className);
    }

    if (isMajor && this.options.showMajorLabels) {
      if (x > 0) {
        if (xFirstMajorLabel == undefined) {
          xFirstMajorLabel = x;
        }
        this._repaintMajorText(x, step.getLabelMajor(), orientation, className);
      }
      line = this._repaintMajorLine(x, width, orientation, className);
    } else {
      if (labelFits) {
        line = this._repaintMinorLine(x, width, orientation, className);
      } else {
        if (line) {
          line.style.width = parseInt(line.style.width) + width + 'px';
        }
      }
    }
  }

  // create a major label on the left when needed
  if (this.options.showMajorLabels) {
    var leftTime = this.body.util.toTime(0),
        leftText = step.getLabelMajor(leftTime),
        widthText = leftText.length * (this.props.majorCharWidth || 10) + 10; // upper bound estimation

    if (xFirstMajorLabel == undefined || widthText < xFirstMajorLabel) {
      this._repaintMajorText(0, leftText, orientation, className);
    }
  }

  // Cleanup leftover DOM elements from the redundant list
  util.forEach(this.dom.redundant, function (arr) {
    while (arr.length) {
      var elem = arr.pop();
      if (elem && elem.parentNode) {
        elem.parentNode.removeChild(elem);
      }
    }
  });
};

/**
 * Create a minor label for the axis at position x
 * @param {Number} x
 * @param {String} text
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the HTML element of the created label
 * @private
 */
TimeAxis.prototype._repaintMinorText = function (x, text, orientation, className) {
  // reuse redundant label
  var label = this.dom.redundant.minorTexts.shift();

  if (!label) {
    // create new label
    var content = document.createTextNode('');
    label = document.createElement('div');
    label.appendChild(content);
    this.dom.foreground.appendChild(label);
  }
  this.dom.minorTexts.push(label);

  label.childNodes[0].nodeValue = text;

  label.style.top = orientation == 'top' ? this.props.majorLabelHeight + 'px' : '0';
  label.style.left = x + 'px';
  label.className = 'vis-text vis-minor ' + className;
  //label.title = title;  // TODO: this is a heavy operation

  return label;
};

/**
 * Create a Major label for the axis at position x
 * @param {Number} x
 * @param {String} text
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the HTML element of the created label
 * @private
 */
TimeAxis.prototype._repaintMajorText = function (x, text, orientation, className) {
  // reuse redundant label
  var label = this.dom.redundant.majorTexts.shift();

  if (!label) {
    // create label
    var content = document.createTextNode(text);
    label = document.createElement('div');
    label.appendChild(content);
    this.dom.foreground.appendChild(label);
  }
  this.dom.majorTexts.push(label);

  label.childNodes[0].nodeValue = text;
  label.className = 'vis-text vis-major ' + className;
  //label.title = title; // TODO: this is a heavy operation

  label.style.top = orientation == 'top' ? '0' : this.props.minorLabelHeight + 'px';
  label.style.left = x + 'px';

  return label;
};

/**
 * Create a minor line for the axis at position x
 * @param {Number} x
 * @param {Number} width
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the created line
 * @private
 */
TimeAxis.prototype._repaintMinorLine = function (x, width, orientation, className) {
  // reuse redundant line
  var line = this.dom.redundant.lines.shift();
  if (!line) {
    // create vertical line
    line = document.createElement('div');
    this.dom.background.appendChild(line);
  }
  this.dom.lines.push(line);

  var props = this.props;
  if (orientation == 'top') {
    line.style.top = props.majorLabelHeight + 'px';
  } else {
    line.style.top = this.body.domProps.top.height + 'px';
  }
  line.style.height = props.minorLineHeight + 'px';
  line.style.left = x - props.minorLineWidth / 2 + 'px';
  line.style.width = width + 'px';

  line.className = 'vis-grid vis-vertical vis-minor ' + className;

  return line;
};

/**
 * Create a Major line for the axis at position x
 * @param {Number} x
 * @param {Number} width
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the created line
 * @private
 */
TimeAxis.prototype._repaintMajorLine = function (x, width, orientation, className) {
  // reuse redundant line
  var line = this.dom.redundant.lines.shift();
  if (!line) {
    // create vertical line
    line = document.createElement('div');
    this.dom.background.appendChild(line);
  }
  this.dom.lines.push(line);

  var props = this.props;
  if (orientation == 'top') {
    line.style.top = '0';
  } else {
    line.style.top = this.body.domProps.top.height + 'px';
  }
  line.style.left = x - props.majorLineWidth / 2 + 'px';
  line.style.height = props.majorLineHeight + 'px';
  line.style.width = width + 'px';

  line.className = 'vis-grid vis-vertical vis-major ' + className;

  return line;
};

/**
 * Determine the size of text on the axis (both major and minor axis).
 * The size is calculated only once and then cached in this.props.
 * @private
 */
TimeAxis.prototype._calculateCharSize = function () {
  // Note: We calculate char size with every redraw. Size may change, for
  // example when any of the timelines parents had display:none for example.

  // determine the char width and height on the minor axis
  if (!this.dom.measureCharMinor) {
    this.dom.measureCharMinor = document.createElement('DIV');
    this.dom.measureCharMinor.className = 'vis-text vis-minor vis-measure';
    this.dom.measureCharMinor.style.position = 'absolute';

    this.dom.measureCharMinor.appendChild(document.createTextNode('0'));
    this.dom.foreground.appendChild(this.dom.measureCharMinor);
  }
  this.props.minorCharHeight = this.dom.measureCharMinor.clientHeight;
  this.props.minorCharWidth = this.dom.measureCharMinor.clientWidth;

  // determine the char width and height on the major axis
  if (!this.dom.measureCharMajor) {
    this.dom.measureCharMajor = document.createElement('DIV');
    this.dom.measureCharMajor.className = 'vis-text vis-major vis-measure';
    this.dom.measureCharMajor.style.position = 'absolute';

    this.dom.measureCharMajor.appendChild(document.createTextNode('0'));
    this.dom.foreground.appendChild(this.dom.measureCharMajor);
  }
  this.props.majorCharHeight = this.dom.measureCharMajor.clientHeight;
  this.props.majorCharWidth = this.dom.measureCharMajor.clientWidth;
};

module.exports = TimeAxis;

},{"../../module/moment":33,"../../util":59,"../DateUtil":40,"../TimeStep":43,"./Component":46}],52:[function(require,module,exports){
'use strict';

var Hammer = require('../../../module/hammer');
var Item = require('./Item');
var BackgroundGroup = require('../BackgroundGroup');
var RangeItem = require('./RangeItem');

/**
 * @constructor BackgroundItem
 * @extends Item
 * @param {Object} data             Object containing parameters start, end
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe options
 */
// TODO: implement support for the BackgroundItem just having a start, then being displayed as a sort of an annotation
function BackgroundItem(data, conversion, options) {
  this.props = {
    content: {
      width: 0
    }
  };
  this.overflow = false; // if contents can overflow (css styling), this flag is set to true

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data.id);
    }
    if (data.end == undefined) {
      throw new Error('Property "end" missing in item ' + data.id);
    }
  }

  Item.call(this, data, conversion, options);
}

BackgroundItem.prototype = new Item(null, null, null);

BackgroundItem.prototype.baseClassName = 'vis-item vis-background';
BackgroundItem.prototype.stack = false;

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
BackgroundItem.prototype.isVisible = function (range) {
  // determine visibility
  return this.data.start < range.end && this.data.end > range.start;
};

/**
 * Repaint the item
 */
BackgroundItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // background box
    dom.box = document.createElement('div');
    // className is updated in redraw()

    // frame box (to prevent the item contents from overflowing
    dom.frame = document.createElement('div');
    dom.frame.className = 'vis-item-overflow';
    dom.box.appendChild(dom.frame);

    // contents box
    dom.content = document.createElement('div');
    dom.content.className = 'vis-item-content';
    dom.frame.appendChild(dom.content);

    // Note: we do NOT attach this item as attribute to the DOM,
    //       such that background items cannot be selected
    //dom.box['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.box.parentNode) {
    var background = this.parent.dom.background;
    if (!background) {
      throw new Error('Cannot redraw item: parent has no background container element');
    }
    background.appendChild(dom.box);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.content);
    this._updateDataAttributes(this.dom.content);
    this._updateStyle(this.dom.box);

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '');
    dom.box.className = this.baseClassName + className;

    // determine from css whether this box has overflow
    this.overflow = window.getComputedStyle(dom.content).overflow !== 'hidden';

    // recalculate size
    this.props.content.width = this.dom.content.offsetWidth;
    this.height = 0; // set height zero, so this item will be ignored when stacking items

    this.dirty = false;
  }
};

/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */
BackgroundItem.prototype.show = RangeItem.prototype.show;

/**
 * Hide the item from the DOM (when visible)
 * @return {Boolean} changed
 */
BackgroundItem.prototype.hide = RangeItem.prototype.hide;

/**
 * Reposition the item horizontally
 * @Override
 */
BackgroundItem.prototype.repositionX = RangeItem.prototype.repositionX;

/**
 * Reposition the item vertically
 * @Override
 */
BackgroundItem.prototype.repositionY = function (margin) {
  var onTop = this.options.orientation.item === 'top';
  this.dom.content.style.top = onTop ? '' : '0';
  this.dom.content.style.bottom = onTop ? '0' : '';
  var height;

  // special positioning for subgroups
  if (this.data.subgroup !== undefined) {
    // TODO: instead of calculating the top position of the subgroups here for every BackgroundItem, calculate the top of the subgroup once in Itemset

    var itemSubgroup = this.data.subgroup;
    var subgroups = this.parent.subgroups;
    var subgroupIndex = subgroups[itemSubgroup].index;
    // if the orientation is top, we need to take the difference in height into account.
    if (onTop == true) {
      // the first subgroup will have to account for the distance from the top to the first item.
      height = this.parent.subgroups[itemSubgroup].height + margin.item.vertical;
      height += subgroupIndex == 0 ? margin.axis - 0.5 * margin.item.vertical : 0;
      var newTop = this.parent.top;
      for (var subgroup in subgroups) {
        if (subgroups.hasOwnProperty(subgroup)) {
          if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroupIndex) {
            newTop += subgroups[subgroup].height + margin.item.vertical;
          }
        }
      }

      // the others will have to be offset downwards with this same distance.
      newTop += subgroupIndex != 0 ? margin.axis - 0.5 * margin.item.vertical : 0;
      this.dom.box.style.top = newTop + 'px';
      this.dom.box.style.bottom = '';
    }
    // and when the orientation is bottom:
    else {
        var newTop = this.parent.top;
        var totalHeight = 0;
        for (var subgroup in subgroups) {
          if (subgroups.hasOwnProperty(subgroup)) {
            if (subgroups[subgroup].visible == true) {
              var newHeight = subgroups[subgroup].height + margin.item.vertical;
              totalHeight += newHeight;
              if (subgroups[subgroup].index > subgroupIndex) {
                newTop += newHeight;
              }
            }
          }
        }
        height = this.parent.subgroups[itemSubgroup].height + margin.item.vertical;
        this.dom.box.style.top = this.parent.height - totalHeight + newTop + 'px';
        this.dom.box.style.bottom = '';
      }
  }
  // and in the case of no subgroups:
  else {
      // we want backgrounds with groups to only show in groups.
      if (this.parent instanceof BackgroundGroup) {
        // if the item is not in a group:
        height = Math.max(this.parent.height, this.parent.itemSet.body.domProps.center.height, this.parent.itemSet.body.domProps.centerContainer.height);
        this.dom.box.style.top = onTop ? '0' : '';
        this.dom.box.style.bottom = onTop ? '' : '0';
      } else {
        height = this.parent.height;
        // same alignment for items when orientation is top or bottom
        this.dom.box.style.top = this.parent.top + 'px';
        this.dom.box.style.bottom = '';
      }
    }
  this.dom.box.style.height = height + 'px';
};

module.exports = BackgroundItem;

},{"../../../module/hammer":32,"../BackgroundGroup":45,"./Item":54,"./RangeItem":56}],53:[function(require,module,exports){
'use strict';

var Item = require('./Item');
var util = require('../../../util');

/**
 * @constructor BoxItem
 * @extends Item
 * @param {Object} data             Object containing parameters start
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe available options
 */
function BoxItem(data, conversion, options) {
  this.props = {
    dot: {
      width: 0,
      height: 0
    },
    line: {
      width: 0,
      height: 0
    }
  };

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data);
    }
  }

  Item.call(this, data, conversion, options);
}

BoxItem.prototype = new Item(null, null, null);

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
BoxItem.prototype.isVisible = function (range) {
  // determine visibility
  // TODO: account for the real width of the item. Right now we just add 1/4 to the window
  var interval = (range.end - range.start) / 4;
  return this.data.start > range.start - interval && this.data.start < range.end + interval;
};

/**
 * Repaint the item
 */
BoxItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // create main box
    dom.box = document.createElement('DIV');

    // contents box (inside the background box). used for making margins
    dom.content = document.createElement('DIV');
    dom.content.className = 'vis-item-content';
    dom.box.appendChild(dom.content);

    // line to axis
    dom.line = document.createElement('DIV');
    dom.line.className = 'vis-line';

    // dot on axis
    dom.dot = document.createElement('DIV');
    dom.dot.className = 'vis-dot';

    // attach this item as attribute
    dom.box['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.box.parentNode) {
    var foreground = this.parent.dom.foreground;
    if (!foreground) throw new Error('Cannot redraw item: parent has no foreground container element');
    foreground.appendChild(dom.box);
  }
  if (!dom.line.parentNode) {
    var background = this.parent.dom.background;
    if (!background) throw new Error('Cannot redraw item: parent has no background container element');
    background.appendChild(dom.line);
  }
  if (!dom.dot.parentNode) {
    var axis = this.parent.dom.axis;
    if (!background) throw new Error('Cannot redraw item: parent has no axis container element');
    axis.appendChild(dom.dot);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.box);
    this._updateDataAttributes(this.dom.box);
    this._updateStyle(this.dom.box);

    var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
    dom.box.className = 'vis-item vis-box' + className;
    dom.line.className = 'vis-item vis-line' + className;
    dom.dot.className = 'vis-item vis-dot' + className;

    // recalculate size
    this.props.dot.height = dom.dot.offsetHeight;
    this.props.dot.width = dom.dot.offsetWidth;
    this.props.line.width = dom.line.offsetWidth;
    this.width = dom.box.offsetWidth;
    this.height = dom.box.offsetHeight;

    this.dirty = false;
  }

  this._repaintDeleteButton(dom.box);
};

/**
 * Show the item in the DOM (when not already displayed). The items DOM will
 * be created when needed.
 */
BoxItem.prototype.show = function () {
  if (!this.displayed) {
    this.redraw();
  }
};

/**
 * Hide the item from the DOM (when visible)
 */
BoxItem.prototype.hide = function () {
  if (this.displayed) {
    var dom = this.dom;

    if (dom.box.parentNode) dom.box.parentNode.removeChild(dom.box);
    if (dom.line.parentNode) dom.line.parentNode.removeChild(dom.line);
    if (dom.dot.parentNode) dom.dot.parentNode.removeChild(dom.dot);

    this.displayed = false;
  }
};

/**
 * Reposition the item horizontally
 * @Override
 */
BoxItem.prototype.repositionX = function () {
  var start = this.conversion.toScreen(this.data.start);
  var align = this.options.align;
  var left;

  // calculate left position of the box
  if (align == 'right') {
    this.left = start - this.width;
  } else if (align == 'left') {
    this.left = start;
  } else {
    // default or 'center'
    this.left = start - this.width / 2;
  }

  // reposition box
  this.dom.box.style.left = this.left + 'px';

  // reposition line
  this.dom.line.style.left = start - this.props.line.width / 2 + 'px';

  // reposition dot
  this.dom.dot.style.left = start - this.props.dot.width / 2 + 'px';
};

/**
 * Reposition the item vertically
 * @Override
 */
BoxItem.prototype.repositionY = function () {
  var orientation = this.options.orientation.item;
  var box = this.dom.box;
  var line = this.dom.line;
  var dot = this.dom.dot;

  if (orientation == 'top') {
    box.style.top = (this.top || 0) + 'px';

    line.style.top = '0';
    line.style.height = this.parent.top + this.top + 1 + 'px';
    line.style.bottom = '';
  } else {
    // orientation 'bottom'
    var itemSetHeight = this.parent.itemSet.props.height; // TODO: this is nasty
    var lineHeight = itemSetHeight - this.parent.top - this.parent.height + this.top;

    box.style.top = (this.parent.height - this.top - this.height || 0) + 'px';
    line.style.top = itemSetHeight - lineHeight + 'px';
    line.style.bottom = '0';
  }

  dot.style.top = -this.props.dot.height / 2 + 'px';
};

/**
 * Return the width of the item left from its start date
 * @return {number}
 */
BoxItem.prototype.getWidthLeft = function () {
  return this.width / 2;
};

/**
 * Return the width of the item right from its start date
 * @return {number}
 */
BoxItem.prototype.getWidthRight = function () {
  return this.width / 2;
};

module.exports = BoxItem;

},{"../../../util":59,"./Item":54}],54:[function(require,module,exports){
'use strict';

var Hammer = require('../../../module/hammer');
var util = require('../../../util');

/**
 * @constructor Item
 * @param {Object} data             Object containing (optional) parameters type,
 *                                  start, end, content, group, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} options          Configuration options
 *                                  // TODO: describe available options
 */
function Item(data, conversion, options) {
  this.id = null;
  this.parent = null;
  this.data = data;
  this.dom = null;
  this.conversion = conversion || {};
  this.options = options || {};

  this.selected = false;
  this.displayed = false;
  this.dirty = true;

  this.top = null;
  this.left = null;
  this.width = null;
  this.height = null;

  this.editable = null;
  if (this.data && this.data.hasOwnProperty('editable') && typeof this.data.editable === 'boolean') {
    this.editable = data.editable;
  }
}

Item.prototype.stack = true;

/**
 * Select current item
 */
Item.prototype.select = function () {
  this.selected = true;
  this.dirty = true;
  if (this.displayed) this.redraw();
};

/**
 * Unselect current item
 */
Item.prototype.unselect = function () {
  this.selected = false;
  this.dirty = true;
  if (this.displayed) this.redraw();
};

/**
 * Set data for the item. Existing data will be updated. The id should not
 * be changed. When the item is displayed, it will be redrawn immediately.
 * @param {Object} data
 */
Item.prototype.setData = function (data) {
  var groupChanged = data.group != undefined && this.data.group != data.group;
  if (groupChanged) {
    this.parent.itemSet._moveToGroup(this, data.group);
  }

  if (data.hasOwnProperty('editable') && typeof data.editable === 'boolean') {
    this.editable = data.editable;
  }

  this.data = data;
  this.dirty = true;
  if (this.displayed) this.redraw();
};

/**
 * Set a parent for the item
 * @param {ItemSet | Group} parent
 */
Item.prototype.setParent = function (parent) {
  if (this.displayed) {
    this.hide();
    this.parent = parent;
    if (this.parent) {
      this.show();
    }
  } else {
    this.parent = parent;
  }
};

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
Item.prototype.isVisible = function (range) {
  // Should be implemented by Item implementations
  return false;
};

/**
 * Show the Item in the DOM (when not already visible)
 * @return {Boolean} changed
 */
Item.prototype.show = function () {
  return false;
};

/**
 * Hide the Item from the DOM (when visible)
 * @return {Boolean} changed
 */
Item.prototype.hide = function () {
  return false;
};

/**
 * Repaint the item
 */
Item.prototype.redraw = function () {
  // should be implemented by the item
};

/**
 * Reposition the Item horizontally
 */
Item.prototype.repositionX = function () {
  // should be implemented by the item
};

/**
 * Reposition the Item vertically
 */
Item.prototype.repositionY = function () {
  // should be implemented by the item
};

/**
 * Repaint a delete button on the top right of the item when the item is selected
 * @param {HTMLElement} anchor
 * @protected
 */
Item.prototype._repaintDeleteButton = function (anchor) {
  var editable = (this.options.editable.remove || this.data.editable === true) && this.data.editable !== false;

  if (this.selected && editable && !this.dom.deleteButton) {
    // create and show button
    var me = this;

    var deleteButton = document.createElement('div');
    deleteButton.className = 'vis-delete';
    deleteButton.title = 'Delete this item';

    // TODO: be able to destroy the delete button
    new Hammer(deleteButton).on('tap', function (event) {
      event.stopPropagation();
      me.parent.removeFromDataSet(me);
    });

    anchor.appendChild(deleteButton);
    this.dom.deleteButton = deleteButton;
  } else if (!this.selected && this.dom.deleteButton) {
    // remove button
    if (this.dom.deleteButton.parentNode) {
      this.dom.deleteButton.parentNode.removeChild(this.dom.deleteButton);
    }
    this.dom.deleteButton = null;
  }
};

/**
 * Set HTML contents for the item
 * @param {Element} element   HTML element to fill with the contents
 * @private
 */
Item.prototype._updateContents = function (element) {
  var content;
  if (this.options.template) {
    var itemData = this.parent.itemSet.itemsData.get(this.id); // get a clone of the data from the dataset
    content = this.options.template(itemData);
  } else {
    content = this.data.content;
  }

  var changed = this._contentToString(this.content) !== this._contentToString(content);
  if (changed) {
    // only replace the content when changed
    if (content instanceof Element) {
      element.innerHTML = '';
      element.appendChild(content);
    } else if (content != undefined) {
      element.innerHTML = content;
    } else {
      if (!(this.data.type == 'background' && this.data.content === undefined)) {
        throw new Error('Property "content" missing in item ' + this.id);
      }
    }

    this.content = content;
  }
};

/**
 * Set HTML contents for the item
 * @param {Element} element   HTML element to fill with the contents
 * @private
 */
Item.prototype._updateTitle = function (element) {
  if (this.data.title != null) {
    element.title = this.data.title || '';
  } else {
    element.removeAttribute('vis-title');
  }
};

/**
 * Process dataAttributes timeline option and set as data- attributes on dom.content
 * @param {Element} element   HTML element to which the attributes will be attached
 * @private
 */
Item.prototype._updateDataAttributes = function (element) {
  if (this.options.dataAttributes && this.options.dataAttributes.length > 0) {
    var attributes = [];

    if (Array.isArray(this.options.dataAttributes)) {
      attributes = this.options.dataAttributes;
    } else if (this.options.dataAttributes == 'all') {
      attributes = Object.keys(this.data);
    } else {
      return;
    }

    for (var i = 0; i < attributes.length; i++) {
      var name = attributes[i];
      var value = this.data[name];

      if (value != null) {
        element.setAttribute('data-' + name, value);
      } else {
        element.removeAttribute('data-' + name);
      }
    }
  }
};

/**
 * Update custom styles of the element
 * @param element
 * @private
 */
Item.prototype._updateStyle = function (element) {
  // remove old styles
  if (this.style) {
    util.removeCssText(element, this.style);
    this.style = null;
  }

  // append new styles
  if (this.data.style) {
    util.addCssText(element, this.data.style);
    this.style = this.data.style;
  }
};

/**
 * Stringify the items contents
 * @param {string | Element | undefined} content
 * @returns {string | undefined}
 * @private
 */
Item.prototype._contentToString = function (content) {
  if (typeof content === 'string') return content;
  if (content && 'outerHTML' in content) return content.outerHTML;
  return content;
};

/**
 * Return the width of the item left from its start date
 * @return {number}
 */
Item.prototype.getWidthLeft = function () {
  return 0;
};

/**
 * Return the width of the item right from the max of its start and end date
 * @return {number}
 */
Item.prototype.getWidthRight = function () {
  return 0;
};

module.exports = Item;

},{"../../../module/hammer":32,"../../../util":59}],55:[function(require,module,exports){
'use strict';

var Item = require('./Item');

/**
 * @constructor PointItem
 * @extends Item
 * @param {Object} data             Object containing parameters start
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe available options
 */
function PointItem(data, conversion, options) {
  this.props = {
    dot: {
      top: 0,
      width: 0,
      height: 0
    },
    content: {
      height: 0,
      marginLeft: 0
    }
  };

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data);
    }
  }

  Item.call(this, data, conversion, options);
}

PointItem.prototype = new Item(null, null, null);

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
PointItem.prototype.isVisible = function (range) {
  // determine visibility
  // TODO: account for the real width of the item. Right now we just add 1/4 to the window
  var interval = (range.end - range.start) / 4;
  return this.data.start > range.start - interval && this.data.start < range.end + interval;
};

/**
 * Repaint the item
 */
PointItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // background box
    dom.point = document.createElement('div');
    // className is updated in redraw()

    // contents box, right from the dot
    dom.content = document.createElement('div');
    dom.content.className = 'vis-item-content';
    dom.point.appendChild(dom.content);

    // dot at start
    dom.dot = document.createElement('div');
    dom.point.appendChild(dom.dot);

    // attach this item as attribute
    dom.point['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.point.parentNode) {
    var foreground = this.parent.dom.foreground;
    if (!foreground) {
      throw new Error('Cannot redraw item: parent has no foreground container element');
    }
    foreground.appendChild(dom.point);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.point);
    this._updateDataAttributes(this.dom.point);
    this._updateStyle(this.dom.point);

    var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
    dom.point.className = 'vis-item vis-point' + className;
    dom.dot.className = 'vis-item vis-dot' + className;

    // recalculate size of dot and contents
    this.props.dot.width = dom.dot.offsetWidth;
    this.props.dot.height = dom.dot.offsetHeight;
    this.props.content.height = dom.content.offsetHeight;

    // resize contents
    dom.content.style.marginLeft = 2 * this.props.dot.width + 'px';
    //dom.content.style.marginRight = ... + 'px'; // TODO: margin right

    // recalculate size
    this.width = dom.point.offsetWidth;
    this.height = dom.point.offsetHeight;

    // reposition the dot
    dom.dot.style.top = (this.height - this.props.dot.height) / 2 + 'px';
    dom.dot.style.left = this.props.dot.width / 2 + 'px';

    this.dirty = false;
  }

  this._repaintDeleteButton(dom.point);
};

/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */
PointItem.prototype.show = function () {
  if (!this.displayed) {
    this.redraw();
  }
};

/**
 * Hide the item from the DOM (when visible)
 */
PointItem.prototype.hide = function () {
  if (this.displayed) {
    if (this.dom.point.parentNode) {
      this.dom.point.parentNode.removeChild(this.dom.point);
    }

    this.displayed = false;
  }
};

/**
 * Reposition the item horizontally
 * @Override
 */
PointItem.prototype.repositionX = function () {
  var start = this.conversion.toScreen(this.data.start);

  this.left = start - this.props.dot.width;

  // reposition point
  this.dom.point.style.left = this.left + 'px';
};

/**
 * Reposition the item vertically
 * @Override
 */
PointItem.prototype.repositionY = function () {
  var orientation = this.options.orientation.item;
  var point = this.dom.point;

  if (orientation == 'top') {
    point.style.top = this.top + 'px';
  } else {
    point.style.top = this.parent.height - this.top - this.height + 'px';
  }
};

/**
 * Return the width of the item left from its start date
 * @return {number}
 */
PointItem.prototype.getWidthLeft = function () {
  return this.props.dot.width;
};

/**
 * Return the width of the item right from  its start date
 * @return {number}
 */
PointItem.prototype.getWidthRight = function () {
  return this.width - this.props.dot.width;
};

module.exports = PointItem;

},{"./Item":54}],56:[function(require,module,exports){
'use strict';

var Hammer = require('../../../module/hammer');
var Item = require('./Item');

/**
 * @constructor RangeItem
 * @extends Item
 * @param {Object} data             Object containing parameters start, end
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe options
 */
function RangeItem(data, conversion, options) {
  this.props = {
    content: {
      width: 0
    }
  };
  this.overflow = false; // if contents can overflow (css styling), this flag is set to true

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data.id);
    }
    if (data.end == undefined) {
      throw new Error('Property "end" missing in item ' + data.id);
    }
  }

  Item.call(this, data, conversion, options);
}

RangeItem.prototype = new Item(null, null, null);

RangeItem.prototype.baseClassName = 'vis-item vis-range';

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
RangeItem.prototype.isVisible = function (range) {
  // determine visibility
  return this.data.start < range.end && this.data.end > range.start;
};

/**
 * Repaint the item
 */
RangeItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // background box
    dom.box = document.createElement('div');
    // className is updated in redraw()

    // frame box (to prevent the item contents from overflowing
    dom.frame = document.createElement('div');
    dom.frame.className = 'vis-item-overflow';
    dom.box.appendChild(dom.frame);

    // contents box
    dom.content = document.createElement('div');
    dom.content.className = 'vis-item-content';
    dom.frame.appendChild(dom.content);

    // attach this item as attribute
    dom.box['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.box.parentNode) {
    var foreground = this.parent.dom.foreground;
    if (!foreground) {
      throw new Error('Cannot redraw item: parent has no foreground container element');
    }
    foreground.appendChild(dom.box);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.box);
    this._updateDataAttributes(this.dom.box);
    this._updateStyle(this.dom.box);

    var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
    dom.box.className = this.baseClassName + className;

    // determine from css whether this box has overflow
    this.overflow = window.getComputedStyle(dom.frame).overflow !== 'hidden';

    // recalculate size
    // turn off max-width to be able to calculate the real width
    // this causes an extra browser repaint/reflow, but so be it
    this.dom.content.style.maxWidth = 'none';
    this.props.content.width = this.dom.content.offsetWidth;
    this.height = this.dom.box.offsetHeight;
    this.dom.content.style.maxWidth = '';

    this.dirty = false;
  }

  this._repaintDeleteButton(dom.box);
  this._repaintDragLeft();
  this._repaintDragRight();
};

/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */
RangeItem.prototype.show = function () {
  if (!this.displayed) {
    this.redraw();
  }
};

/**
 * Hide the item from the DOM (when visible)
 * @return {Boolean} changed
 */
RangeItem.prototype.hide = function () {
  if (this.displayed) {
    var box = this.dom.box;

    if (box.parentNode) {
      box.parentNode.removeChild(box);
    }

    this.displayed = false;
  }
};

/**
 * Reposition the item horizontally
 * @param {boolean} [limitSize=true] If true (default), the width of the range
 *                                   item will be limited, as the browser cannot
 *                                   display very wide divs. This means though
 *                                   that the applied left and width may
 *                                   not correspond to the ranges start and end
 * @Override
 */
RangeItem.prototype.repositionX = function (limitSize) {
  var parentWidth = this.parent.width;
  var start = this.conversion.toScreen(this.data.start);
  var end = this.conversion.toScreen(this.data.end);
  var contentLeft;
  var contentWidth;

  // limit the width of the range, as browsers cannot draw very wide divs
  if (limitSize === undefined || limitSize === true) {
    if (start < -parentWidth) {
      start = -parentWidth;
    }
    if (end > 2 * parentWidth) {
      end = 2 * parentWidth;
    }
  }
  var boxWidth = Math.max(end - start, 1);

  if (this.overflow) {
    this.left = start;
    this.width = boxWidth + this.props.content.width;
    contentWidth = this.props.content.width;

    // Note: The calculation of width is an optimistic calculation, giving
    //       a width which will not change when moving the Timeline
    //       So no re-stacking needed, which is nicer for the eye;
  } else {
      this.left = start;
      this.width = boxWidth;
      contentWidth = Math.min(end - start, this.props.content.width);
    }

  this.dom.box.style.left = this.left + 'px';
  this.dom.box.style.width = boxWidth + 'px';

  switch (this.options.align) {
    case 'left':
      this.dom.content.style.left = '0';
      break;

    case 'right':
      this.dom.content.style.left = Math.max(boxWidth - contentWidth, 0) + 'px';
      break;

    case 'center':
      this.dom.content.style.left = Math.max((boxWidth - contentWidth) / 2, 0) + 'px';
      break;

    default:
      // 'auto'
      // when range exceeds left of the window, position the contents at the left of the visible area
      if (this.overflow) {
        if (end > 0) {
          contentLeft = Math.max(-start, 0);
        } else {
          contentLeft = -contentWidth; // ensure it's not visible anymore
        }
      } else {
          if (start < 0) {
            contentLeft = -start;
          } else {
            contentLeft = 0;
          }
        }
      this.dom.content.style.left = contentLeft + 'px';
  }
};

/**
 * Reposition the item vertically
 * @Override
 */
RangeItem.prototype.repositionY = function () {
  var orientation = this.options.orientation.item;
  var box = this.dom.box;

  if (orientation == 'top') {
    box.style.top = this.top + 'px';
  } else {
    box.style.top = this.parent.height - this.top - this.height + 'px';
  }
};

/**
 * Repaint a drag area on the left side of the range when the range is selected
 * @protected
 */
RangeItem.prototype._repaintDragLeft = function () {
  if (this.selected && this.options.editable.updateTime && !this.dom.dragLeft) {
    // create and show drag area
    var dragLeft = document.createElement('div');
    dragLeft.className = 'vis-drag-left';
    dragLeft.dragLeftItem = this;

    this.dom.box.appendChild(dragLeft);
    this.dom.dragLeft = dragLeft;
  } else if (!this.selected && this.dom.dragLeft) {
    // delete drag area
    if (this.dom.dragLeft.parentNode) {
      this.dom.dragLeft.parentNode.removeChild(this.dom.dragLeft);
    }
    this.dom.dragLeft = null;
  }
};

/**
 * Repaint a drag area on the right side of the range when the range is selected
 * @protected
 */
RangeItem.prototype._repaintDragRight = function () {
  if (this.selected && this.options.editable.updateTime && !this.dom.dragRight) {
    // create and show drag area
    var dragRight = document.createElement('div');
    dragRight.className = 'vis-drag-right';
    dragRight.dragRightItem = this;

    this.dom.box.appendChild(dragRight);
    this.dom.dragRight = dragRight;
  } else if (!this.selected && this.dom.dragRight) {
    // delete drag area
    if (this.dom.dragRight.parentNode) {
      this.dom.dragRight.parentNode.removeChild(this.dom.dragRight);
    }
    this.dom.dragRight = null;
  }
};

module.exports = RangeItem;

},{"../../../module/hammer":32,"./Item":54}],57:[function(require,module,exports){
// English
'use strict';

exports['en'] = {
  current: 'current',
  time: 'time'
};
exports['en_EN'] = exports['en'];
exports['en_US'] = exports['en'];

// Dutch
exports['nl'] = {
  current: 'huidige',
  time: 'tijd'
};
exports['nl_NL'] = exports['nl'];
exports['nl_BE'] = exports['nl'];

},{}],58:[function(require,module,exports){
/**
 * This object contains all possible options. It will check if the types are correct, if required if the option is one
 * of the allowed values.
 *
 * __any__ means that the name of the property does not matter.
 * __type__ is a required field for all objects and contains the allowed types of all objects
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var string = 'string';
var boolean = 'boolean';
var number = 'number';
var array = 'array';
var date = 'date';
var object = 'object'; // should only be in a __type__ property
var dom = 'dom';
var moment = 'moment';
var any = 'any';

var allOptions = {
  configure: {
    enabled: { boolean: boolean },
    filter: { boolean: boolean, 'function': 'function' },
    container: { dom: dom },
    __type__: { object: object, boolean: boolean, 'function': 'function' }
  },

  //globals :
  align: { string: string },
  autoResize: { boolean: boolean },
  throttleRedraw: { number: number },
  clickToUse: { boolean: boolean },
  dataAttributes: { string: string, array: array },
  editable: {
    add: { boolean: boolean, 'undefined': 'undefined' },
    remove: { boolean: boolean, 'undefined': 'undefined' },
    updateGroup: { boolean: boolean, 'undefined': 'undefined' },
    updateTime: { boolean: boolean, 'undefined': 'undefined' },
    __type__: { boolean: boolean, object: object }
  },
  end: { number: number, date: date, string: string, moment: moment },
  format: {
    minorLabels: {
      millisecond: { string: string, 'undefined': 'undefined' },
      second: { string: string, 'undefined': 'undefined' },
      minute: { string: string, 'undefined': 'undefined' },
      hour: { string: string, 'undefined': 'undefined' },
      weekday: { string: string, 'undefined': 'undefined' },
      day: { string: string, 'undefined': 'undefined' },
      month: { string: string, 'undefined': 'undefined' },
      year: { string: string, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    majorLabels: {
      millisecond: { string: string, 'undefined': 'undefined' },
      second: { string: string, 'undefined': 'undefined' },
      minute: { string: string, 'undefined': 'undefined' },
      hour: { string: string, 'undefined': 'undefined' },
      weekday: { string: string, 'undefined': 'undefined' },
      day: { string: string, 'undefined': 'undefined' },
      month: { string: string, 'undefined': 'undefined' },
      year: { string: string, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    __type__: { object: object }
  },
  moment: { 'function': 'function' },
  groupOrder: { string: string, 'function': 'function' },
  groupEditable: {
    add: { boolean: boolean, 'undefined': 'undefined' },
    remove: { boolean: boolean, 'undefined': 'undefined' },
    order: { boolean: boolean, 'undefined': 'undefined' },
    __type__: { boolean: boolean, object: object }
  },
  groupOrderSwap: { 'function': 'function' },
  height: { string: string, number: number },
  hiddenDates: {
    start: { date: date, number: number, string: string, moment: moment },
    end: { date: date, number: number, string: string, moment: moment },
    repeat: { string: string },
    __type__: { object: object, array: array }
  },
  locale: { string: string },
  locales: {
    __type__: { object: object }
  },
  margin: {
    axis: { number: number },
    item: {
      horizontal: { number: number, 'undefined': 'undefined' },
      vertical: { number: number, 'undefined': 'undefined' },
      __type__: { object: object, number: number }
    },
    __type__: { object: object, number: number }
  },
  max: { date: date, number: number, string: string, moment: moment },
  maxHeight: { number: number, string: string },
  min: { date: date, number: number, string: string, moment: moment },
  minHeight: { number: number, string: string },
  moveable: { boolean: boolean },
  multiselect: { boolean: boolean },
  onAdd: { 'function': 'function' },
  onUpdate: { 'function': 'function' },
  onMove: { 'function': 'function' },
  onMoving: { 'function': 'function' },
  onRemove: { 'function': 'function' },
  onAddGroup: { 'function': 'function' },
  onMoveGroup: { 'function': 'function' },
  onRemoveGroup: { 'function': 'function' },
  order: { 'function': 'function' },
  orientation: {
    axis: { string: string, 'undefined': 'undefined' },
    item: { string: string, 'undefined': 'undefined' },
    __type__: { string: string, object: object }
  },
  selectable: { boolean: boolean },
  showCurrentTime: { boolean: boolean },
  showMajorLabels: { boolean: boolean },
  showMinorLabels: { boolean: boolean },
  stack: { boolean: boolean },
  snap: { 'function': 'function', 'null': 'null' },
  start: { date: date, number: number, string: string, moment: moment },
  template: { 'function': 'function' },
  groupTemplate: { 'function': 'function' },
  timeAxis: {
    scale: { string: string, 'undefined': 'undefined' },
    step: { number: number, 'undefined': 'undefined' },
    __type__: { object: object }
  },
  type: { string: string },
  width: { string: string, number: number },
  zoomable: { boolean: boolean },
  zoomKey: { string: ['ctrlKey', 'altKey', 'metaKey', ''] },
  zoomMax: { number: number },
  zoomMin: { number: number },

  __type__: { object: object }
};

var configureOptions = {
  global: {
    align: ['center', 'left', 'right'],
    autoResize: true,
    throttleRedraw: [10, 0, 1000, 10],
    clickToUse: false,
    // dataAttributes: ['all'], // FIXME: can be 'all' or string[]
    editable: {
      add: false,
      remove: false,
      updateGroup: false,
      updateTime: false
    },
    end: '',
    format: {
      minorLabels: {
        millisecond: 'SSS',
        second: 's',
        minute: 'HH:mm',
        hour: 'HH:mm',
        weekday: 'ddd D',
        day: 'D',
        month: 'MMM',
        year: 'YYYY'
      },
      majorLabels: {
        millisecond: 'HH:mm:ss',
        second: 'D MMMM HH:mm',
        minute: 'ddd D MMMM',
        hour: 'ddd D MMMM',
        weekday: 'MMMM YYYY',
        day: 'MMMM YYYY',
        month: 'YYYY',
        year: ''
      }
    },

    //groupOrder: {string, 'function': 'function'},
    groupsDraggable: false,
    height: '',
    //hiddenDates: {object, array},
    locale: '',
    margin: {
      axis: [20, 0, 100, 1],
      item: {
        horizontal: [10, 0, 100, 1],
        vertical: [10, 0, 100, 1]
      }
    },
    max: '',
    maxHeight: '',
    min: '',
    minHeight: '',
    moveable: false,
    multiselect: false,
    //onAdd: {'function': 'function'},
    //onUpdate: {'function': 'function'},
    //onMove: {'function': 'function'},
    //onMoving: {'function': 'function'},
    //onRename: {'function': 'function'},
    //order: {'function': 'function'},
    orientation: {
      axis: ['both', 'bottom', 'top'],
      item: ['bottom', 'top']
    },
    selectable: true,
    showCurrentTime: false,
    showMajorLabels: true,
    showMinorLabels: true,
    stack: true,
    //snap: {'function': 'function', nada},
    start: '',
    //template: {'function': 'function'},
    //timeAxis: {
    //  scale: ['millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'month', 'year'],
    //  step: [1, 1, 10, 1]
    //},
    type: ['box', 'point', 'range', 'background'],
    width: '100%',
    zoomable: true,
    zoomKey: ['ctrlKey', 'altKey', 'metaKey', ''],
    zoomMax: [315360000000000, 10, 315360000000000, 1],
    zoomMin: [10, 10, 315360000000000, 1]
  }
};

exports.allOptions = allOptions;
exports.configureOptions = configureOptions;

},{}],59:[function(require,module,exports){
// utility functions

// first check if moment.js is already loaded in the browser window, if so,
// use this instance. Else, load via commonjs.

'use strict';

var moment = require('./module/moment');
var uuid = require('./module/uuid');

/**
 * Test whether given object is a number
 * @param {*} object
 * @return {Boolean} isNumber
 */
exports.isNumber = function (object) {
  return object instanceof Number || typeof object == 'number';
};

/**
 * Remove everything in the DOM object
 * @param DOMobject
 */
exports.recursiveDOMDelete = function (DOMobject) {
  if (DOMobject) {
    while (DOMobject.hasChildNodes() === true) {
      exports.recursiveDOMDelete(DOMobject.firstChild);
      DOMobject.removeChild(DOMobject.firstChild);
    }
  }
};

/**
 * this function gives you a range between 0 and 1 based on the min and max values in the set, the total sum of all values and the current value.
 *
 * @param min
 * @param max
 * @param total
 * @param value
 * @returns {number}
 */
exports.giveRange = function (min, max, total, value) {
  if (max == min) {
    return 0.5;
  } else {
    var scale = 1 / (max - min);
    return Math.max(0, (value - min) * scale);
  }
};

/**
 * Test whether given object is a string
 * @param {*} object
 * @return {Boolean} isString
 */
exports.isString = function (object) {
  return object instanceof String || typeof object == 'string';
};

/**
 * Test whether given object is a Date, or a String containing a Date
 * @param {Date | String} object
 * @return {Boolean} isDate
 */
exports.isDate = function (object) {
  if (object instanceof Date) {
    return true;
  } else if (exports.isString(object)) {
    // test whether this string contains a date
    var match = ASPDateRegex.exec(object);
    if (match) {
      return true;
    } else if (!isNaN(Date.parse(object))) {
      return true;
    }
  }

  return false;
};

/**
 * Create a semi UUID
 * source: http://stackoverflow.com/a/105074/1262753
 * @return {String} uuid
 */
exports.randomUUID = function () {
  return uuid.v4();
};

/**
 * assign all keys of an object that are not nested objects to a certain value (used for color objects).
 * @param obj
 * @param value
 */
exports.assignAllKeys = function (obj, value) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      if (typeof obj[prop] !== 'object') {
        obj[prop] = value;
      }
    }
  }
};

/**
 * Fill an object with a possibly partially defined other object. Only copies values if the a object has an object requiring values.
 * That means an object is not created on a property if only the b object has it.
 * @param obj
 * @param value
 */
exports.fillIfDefined = function (a, b) {
  var allowDeletion = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

  for (var prop in a) {
    if (b[prop] !== undefined) {
      if (typeof b[prop] !== 'object') {
        if ((b[prop] === undefined || b[prop] === null) && a[prop] !== undefined && allowDeletion === true) {
          delete a[prop];
        } else {
          a[prop] = b[prop];
        }
      } else {
        if (typeof a[prop] === 'object') {
          exports.fillIfDefined(a[prop], b[prop], allowDeletion);
        }
      }
    }
  }
};

/**
 * Extend object a with the properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Object} a
 * @param {... Object} b
 * @return {Object} a
 */
exports.protoExtend = function (a, b) {
  for (var i = 1; i < arguments.length; i++) {
    var other = arguments[i];
    for (var prop in other) {
      a[prop] = other[prop];
    }
  }
  return a;
};

/**
 * Extend object a with the properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Object} a
 * @param {... Object} b
 * @return {Object} a
 */
exports.extend = function (a, b) {
  for (var i = 1; i < arguments.length; i++) {
    var other = arguments[i];
    for (var prop in other) {
      if (other.hasOwnProperty(prop)) {
        a[prop] = other[prop];
      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<String>} props
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.selectiveExtend = function (props, a, b) {
  if (!Array.isArray(props)) {
    throw new Error('Array with property names expected as first argument');
  }

  for (var i = 2; i < arguments.length; i++) {
    var other = arguments[i];

    for (var p = 0; p < props.length; p++) {
      var prop = props[p];
      if (other.hasOwnProperty(prop)) {
        a[prop] = other[prop];
      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<String>} props
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.selectiveDeepExtend = function (props, a, b) {
  var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }
  for (var i = 2; i < arguments.length; i++) {
    var other = arguments[i];
    for (var p = 0; p < props.length; p++) {
      var prop = props[p];
      if (other.hasOwnProperty(prop)) {
        if (b[prop] && b[prop].constructor === Object) {
          if (a[prop] === undefined) {
            a[prop] = {};
          }
          if (a[prop].constructor === Object) {
            exports.deepExtend(a[prop], b[prop], false, allowDeletion);
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        } else if (Array.isArray(b[prop])) {
          throw new TypeError('Arrays are not supported by deepExtend');
        } else {
          if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        }
      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<String>} props
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.selectiveNotDeepExtend = function (props, a, b) {
  var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }
  for (var prop in b) {
    if (b.hasOwnProperty(prop)) {
      if (props.indexOf(prop) == -1) {
        if (b[prop] && b[prop].constructor === Object) {
          if (a[prop] === undefined) {
            a[prop] = {};
          }
          if (a[prop].constructor === Object) {
            exports.deepExtend(a[prop], b[prop]);
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        } else if (Array.isArray(b[prop])) {
          a[prop] = [];
          for (var i = 0; i < b[prop].length; i++) {
            a[prop].push(b[prop][i]);
          }
        } else {
          if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        }
      }
    }
  }
  return a;
};

/**
 * Deep extend an object a with the properties of object b
 * @param {Object} a
 * @param {Object} b
 * @param [Boolean] protoExtend --> optional parameter. If true, the prototype values will also be extended.
 *                                  (ie. the options objects that inherit from others will also get the inherited options)
 * @param [Boolean] global      --> optional parameter. If true, the values of fields that are null will not deleted
 * @returns {Object}
 */
exports.deepExtend = function (a, b, protoExtend, allowDeletion) {
  for (var prop in b) {
    if (b.hasOwnProperty(prop) || protoExtend === true) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }
        if (a[prop].constructor === Object) {
          exports.deepExtend(a[prop], b[prop], protoExtend);
        } else {
          if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        }
      } else if (Array.isArray(b[prop])) {
        a[prop] = [];
        for (var i = 0; i < b[prop].length; i++) {
          a[prop].push(b[prop][i]);
        }
      } else {
        if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
          delete a[prop];
        } else {
          a[prop] = b[prop];
        }
      }
    }
  }
  return a;
};

/**
 * Test whether all elements in two arrays are equal.
 * @param {Array} a
 * @param {Array} b
 * @return {boolean} Returns true if both arrays have the same length and same
 *                   elements.
 */
exports.equalArray = function (a, b) {
  if (a.length != b.length) return false;

  for (var i = 0, len = a.length; i < len; i++) {
    if (a[i] != b[i]) return false;
  }

  return true;
};

/**
 * Convert an object to another type
 * @param {Boolean | Number | String | Date | Moment | Null | undefined} object
 * @param {String | undefined} type   Name of the type. Available types:
 *                                    'Boolean', 'Number', 'String',
 *                                    'Date', 'Moment', ISODate', 'ASPDate'.
 * @return {*} object
 * @throws Error
 */
exports.convert = function (object, type) {
  var match;

  if (object === undefined) {
    return undefined;
  }
  if (object === null) {
    return null;
  }

  if (!type) {
    return object;
  }
  if (!(typeof type === 'string') && !(type instanceof String)) {
    throw new Error('Type must be a string');
  }

  //noinspection FallthroughInSwitchStatementJS
  switch (type) {
    case 'boolean':
    case 'Boolean':
      return Boolean(object);

    case 'number':
    case 'Number':
      return Number(object.valueOf());

    case 'string':
    case 'String':
      return String(object);

    case 'Date':
      if (exports.isNumber(object)) {
        return new Date(object);
      }
      if (object instanceof Date) {
        return new Date(object.valueOf());
      } else if (moment.isMoment(object)) {
        return new Date(object.valueOf());
      }
      if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])); // parse number
        } else {
            return moment(object).toDate(); // parse string
          }
      } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
        }

    case 'Moment':
      if (exports.isNumber(object)) {
        return moment(object);
      }
      if (object instanceof Date) {
        return moment(object.valueOf());
      } else if (moment.isMoment(object)) {
        return moment(object);
      }
      if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return moment(Number(match[1])); // parse number
        } else {
            return moment(object); // parse string
          }
      } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
        }

    case 'ISODate':
      if (exports.isNumber(object)) {
        return new Date(object);
      } else if (object instanceof Date) {
        return object.toISOString();
      } else if (moment.isMoment(object)) {
        return object.toDate().toISOString();
      } else if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])).toISOString(); // parse number
        } else {
            return new Date(object).toISOString(); // parse string
          }
      } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ISODate');
        }

    case 'ASPDate':
      if (exports.isNumber(object)) {
        return '/Date(' + object + ')/';
      } else if (object instanceof Date) {
        return '/Date(' + object.valueOf() + ')/';
      } else if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        var value;
        if (match) {
          // object is an ASP date
          value = new Date(Number(match[1])).valueOf(); // parse number
        } else {
            value = new Date(object).valueOf(); // parse string
          }
        return '/Date(' + value + ')/';
      } else {
        throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ASPDate');
      }

    default:
      throw new Error('Unknown type "' + type + '"');
  }
};

// parse ASP.Net Date pattern,
// for example '/Date(1198908717056)/' or '/Date(1198908717056-0700)/'
// code from http://momentjs.com/
var ASPDateRegex = /^\/?Date\((\-?\d+)/i;

/**
 * Get the type of an object, for example exports.getType([]) returns 'Array'
 * @param {*} object
 * @return {String} type
 */
exports.getType = function (object) {
  var type = typeof object;

  if (type == 'object') {
    if (object === null) {
      return 'null';
    }
    if (object instanceof Boolean) {
      return 'Boolean';
    }
    if (object instanceof Number) {
      return 'Number';
    }
    if (object instanceof String) {
      return 'String';
    }
    if (Array.isArray(object)) {
      return 'Array';
    }
    if (object instanceof Date) {
      return 'Date';
    }
    return 'Object';
  } else if (type == 'number') {
    return 'Number';
  } else if (type == 'boolean') {
    return 'Boolean';
  } else if (type == 'string') {
    return 'String';
  } else if (type === undefined) {
    return 'undefined';
  }

  return type;
};

/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr
 * @param newValue
 * @returns {Array}
 */
exports.copyAndExtendArray = function (arr, newValue) {
  var newArr = [];
  for (var i = 0; i < arr.length; i++) {
    newArr.push(arr[i]);
  }
  newArr.push(newValue);
  return newArr;
};

/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr
 * @param newValue
 * @returns {Array}
 */
exports.copyArray = function (arr) {
  var newArr = [];
  for (var i = 0; i < arr.length; i++) {
    newArr.push(arr[i]);
  }
  return newArr;
};

/**
 * Retrieve the absolute left value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} left        The absolute left position of this element
 *                              in the browser page.
 */
exports.getAbsoluteLeft = function (elem) {
  return elem.getBoundingClientRect().left;
};

/**
 * Retrieve the absolute top value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} top        The absolute top position of this element
 *                              in the browser page.
 */
exports.getAbsoluteTop = function (elem) {
  return elem.getBoundingClientRect().top;
};

/**
 * add a className to the given elements style
 * @param {Element} elem
 * @param {String} className
 */
exports.addClassName = function (elem, className) {
  var classes = elem.className.split(' ');
  if (classes.indexOf(className) == -1) {
    classes.push(className); // add the class to the array
    elem.className = classes.join(' ');
  }
};

/**
 * add a className to the given elements style
 * @param {Element} elem
 * @param {String} className
 */
exports.removeClassName = function (elem, className) {
  var classes = elem.className.split(' ');
  var index = classes.indexOf(className);
  if (index != -1) {
    classes.splice(index, 1); // remove the class from the array
    elem.className = classes.join(' ');
  }
};

/**
 * For each method for both arrays and objects.
 * In case of an array, the built-in Array.forEach() is applied.
 * In case of an Object, the method loops over all properties of the object.
 * @param {Object | Array} object   An Object or Array
 * @param {function} callback       Callback method, called for each item in
 *                                  the object or array with three parameters:
 *                                  callback(value, index, object)
 */
exports.forEach = function (object, callback) {
  var i, len;
  if (Array.isArray(object)) {
    // array
    for (i = 0, len = object.length; i < len; i++) {
      callback(object[i], i, object);
    }
  } else {
    // object
    for (i in object) {
      if (object.hasOwnProperty(i)) {
        callback(object[i], i, object);
      }
    }
  }
};

/**
 * Convert an object into an array: all objects properties are put into the
 * array. The resulting array is unordered.
 * @param {Object} object
 * @param {Array} array
 */
exports.toArray = function (object) {
  var array = [];

  for (var prop in object) {
    if (object.hasOwnProperty(prop)) array.push(object[prop]);
  }

  return array;
};

/**
 * Update a property in an object
 * @param {Object} object
 * @param {String} key
 * @param {*} value
 * @return {Boolean} changed
 */
exports.updateProperty = function (object, key, value) {
  if (object[key] !== value) {
    object[key] = value;
    return true;
  } else {
    return false;
  }
};

/**
 * Throttle the given function to be only executed once every `wait` milliseconds
 * @param {function} fn
 * @param {number} wait    Time in milliseconds
 * @returns {function} Returns the throttled function
 */
exports.throttle = function (fn, wait) {
  var timeout = null;
  var needExecution = false;

  return function throttled() {
    if (!timeout) {
      needExecution = false;
      fn();

      timeout = setTimeout(function () {
        timeout = null;
        if (needExecution) {
          throttled();
        }
      }, wait);
    } else {
      needExecution = true;
    }
  };
};

/**
 * Add and event listener. Works for all browsers
 * @param {Element}     element    An html element
 * @param {string}      action     The action, for example "click",
 *                                 without the prefix "on"
 * @param {function}    listener   The callback function to be executed
 * @param {boolean}     [useCapture]
 */
exports.addEventListener = function (element, action, listener, useCapture) {
  if (element.addEventListener) {
    if (useCapture === undefined) useCapture = false;

    if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.addEventListener(action, listener, useCapture);
  } else {
    element.attachEvent("on" + action, listener); // IE browsers
  }
};

/**
 * Remove an event listener from an element
 * @param {Element}     element         An html dom element
 * @param {string}      action          The name of the event, for example "mousedown"
 * @param {function}    listener        The listener function
 * @param {boolean}     [useCapture]
 */
exports.removeEventListener = function (element, action, listener, useCapture) {
  if (element.removeEventListener) {
    // non-IE browsers
    if (useCapture === undefined) useCapture = false;

    if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.removeEventListener(action, listener, useCapture);
  } else {
    // IE browsers
    element.detachEvent("on" + action, listener);
  }
};

/**
 * Cancels the event if it is cancelable, without stopping further propagation of the event.
 */
exports.preventDefault = function (event) {
  if (!event) event = window.event;

  if (event.preventDefault) {
    event.preventDefault(); // non-IE browsers
  } else {
      event.returnValue = false; // IE browsers
    }
};

/**
 * Get HTML element which is the target of the event
 * @param {Event} event
 * @return {Element} target element
 */
exports.getTarget = function (event) {
  // code from http://www.quirksmode.org/js/events_properties.html
  if (!event) {
    event = window.event;
  }

  var target;

  if (event.target) {
    target = event.target;
  } else if (event.srcElement) {
    target = event.srcElement;
  }

  if (target.nodeType != undefined && target.nodeType == 3) {
    // defeat Safari bug
    target = target.parentNode;
  }

  return target;
};

/**
 * Check if given element contains given parent somewhere in the DOM tree
 * @param {Element} element
 * @param {Element} parent
 */
exports.hasParent = function (element, parent) {
  var e = element;

  while (e) {
    if (e === parent) {
      return true;
    }
    e = e.parentNode;
  }

  return false;
};

exports.option = {};

/**
 * Convert a value into a boolean
 * @param {Boolean | function | undefined} value
 * @param {Boolean} [defaultValue]
 * @returns {Boolean} bool
 */
exports.option.asBoolean = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return value != false;
  }

  return defaultValue || null;
};

/**
 * Convert a value into a number
 * @param {Boolean | function | undefined} value
 * @param {Number} [defaultValue]
 * @returns {Number} number
 */
exports.option.asNumber = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return Number(value) || defaultValue || null;
  }

  return defaultValue || null;
};

/**
 * Convert a value into a string
 * @param {String | function | undefined} value
 * @param {String} [defaultValue]
 * @returns {String} str
 */
exports.option.asString = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return String(value);
  }

  return defaultValue || null;
};

/**
 * Convert a size or location into a string with pixels or a percentage
 * @param {String | Number | function | undefined} value
 * @param {String} [defaultValue]
 * @returns {String} size
 */
exports.option.asSize = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (exports.isString(value)) {
    return value;
  } else if (exports.isNumber(value)) {
    return value + 'px';
  } else {
    return defaultValue || null;
  }
};

/**
 * Convert a value into a DOM element
 * @param {HTMLElement | function | undefined} value
 * @param {HTMLElement} [defaultValue]
 * @returns {HTMLElement | null} dom
 */
exports.option.asElement = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  return value || defaultValue || null;
};

/**
 * http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
 *
 * @param {String} hex
 * @returns {{r: *, g: *, b: *}} | 255 range
 */
exports.hexToRGB = function (hex) {
  // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
  var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  hex = hex.replace(shorthandRegex, function (m, r, g, b) {
    return r + r + g + g + b + b;
  });
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
};

/**
 * This function takes color in hex format or rgb() or rgba() format and overrides the opacity. Returns rgba() string.
 * @param color
 * @param opacity
 * @returns {*}
 */
exports.overrideOpacity = function (color, opacity) {
  if (color.indexOf("rgba") != -1) {
    return color;
  } else if (color.indexOf("rgb") != -1) {
    var rgb = color.substr(color.indexOf("(") + 1).replace(")", "").split(",");
    return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + opacity + ")";
  } else {
    var rgb = exports.hexToRGB(color);
    if (rgb == null) {
      return color;
    } else {
      return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + opacity + ")";
    }
  }
};

/**
 *
 * @param red     0 -- 255
 * @param green   0 -- 255
 * @param blue    0 -- 255
 * @returns {string}
 * @constructor
 */
exports.RGBToHex = function (red, green, blue) {
  return "#" + ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1);
};

/**
 * Parse a color property into an object with border, background, and
 * highlight colors
 * @param {Object | String} color
 * @return {Object} colorObject
 */
exports.parseColor = function (color) {
  var c;
  if (exports.isString(color) === true) {
    if (exports.isValidRGB(color) === true) {
      var rgb = color.substr(4).substr(0, color.length - 5).split(',').map(function (value) {
        return parseInt(value);
      });
      color = exports.RGBToHex(rgb[0], rgb[1], rgb[2]);
    }
    if (exports.isValidHex(color) === true) {
      var hsv = exports.hexToHSV(color);
      var lighterColorHSV = { h: hsv.h, s: hsv.s * 0.8, v: Math.min(1, hsv.v * 1.02) };
      var darkerColorHSV = { h: hsv.h, s: Math.min(1, hsv.s * 1.25), v: hsv.v * 0.8 };
      var darkerColorHex = exports.HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
      var lighterColorHex = exports.HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
      c = {
        background: color,
        border: darkerColorHex,
        highlight: {
          background: lighterColorHex,
          border: darkerColorHex
        },
        hover: {
          background: lighterColorHex,
          border: darkerColorHex
        }
      };
    } else {
      c = {
        background: color,
        border: color,
        highlight: {
          background: color,
          border: color
        },
        hover: {
          background: color,
          border: color
        }
      };
    }
  } else {
    c = {};
    c.background = color.background || undefined;
    c.border = color.border || undefined;

    if (exports.isString(color.highlight)) {
      c.highlight = {
        border: color.highlight,
        background: color.highlight
      };
    } else {
      c.highlight = {};
      c.highlight.background = color.highlight && color.highlight.background || undefined;
      c.highlight.border = color.highlight && color.highlight.border || undefined;
    }

    if (exports.isString(color.hover)) {
      c.hover = {
        border: color.hover,
        background: color.hover
      };
    } else {
      c.hover = {};
      c.hover.background = color.hover && color.hover.background || undefined;
      c.hover.border = color.hover && color.hover.border || undefined;
    }
  }

  return c;
};

/**
 * http://www.javascripter.net/faq/rgb2hsv.htm
 *
 * @param red
 * @param green
 * @param blue
 * @returns {*}
 * @constructor
 */
exports.RGBToHSV = function (red, green, blue) {
  red = red / 255;green = green / 255;blue = blue / 255;
  var minRGB = Math.min(red, Math.min(green, blue));
  var maxRGB = Math.max(red, Math.max(green, blue));

  // Black-gray-white
  if (minRGB == maxRGB) {
    return { h: 0, s: 0, v: minRGB };
  }

  // Colors other than black-gray-white:
  var d = red == minRGB ? green - blue : blue == minRGB ? red - green : blue - red;
  var h = red == minRGB ? 3 : blue == minRGB ? 1 : 5;
  var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
  var saturation = (maxRGB - minRGB) / maxRGB;
  var value = maxRGB;
  return { h: hue, s: saturation, v: value };
};

var cssUtil = {
  // split a string with css styles into an object with key/values
  split: function split(cssText) {
    var styles = {};

    cssText.split(';').forEach(function (style) {
      if (style.trim() != '') {
        var parts = style.split(':');
        var key = parts[0].trim();
        var value = parts[1].trim();
        styles[key] = value;
      }
    });

    return styles;
  },

  // build a css text string from an object with key/values
  join: function join(styles) {
    return Object.keys(styles).map(function (key) {
      return key + ': ' + styles[key];
    }).join('; ');
  }
};

/**
 * Append a string with css styles to an element
 * @param {Element} element
 * @param {String} cssText
 */
exports.addCssText = function (element, cssText) {
  var currentStyles = cssUtil.split(element.style.cssText);
  var newStyles = cssUtil.split(cssText);
  var styles = exports.extend(currentStyles, newStyles);

  element.style.cssText = cssUtil.join(styles);
};

/**
 * Remove a string with css styles from an element
 * @param {Element} element
 * @param {String} cssText
 */
exports.removeCssText = function (element, cssText) {
  var styles = cssUtil.split(element.style.cssText);
  var removeStyles = cssUtil.split(cssText);

  for (var key in removeStyles) {
    if (removeStyles.hasOwnProperty(key)) {
      delete styles[key];
    }
  }

  element.style.cssText = cssUtil.join(styles);
};

/**
 * https://gist.github.com/mjijackson/5311256
 * @param h
 * @param s
 * @param v
 * @returns {{r: number, g: number, b: number}}
 * @constructor
 */
exports.HSVToRGB = function (h, s, v) {
  var r, g, b;

  var i = Math.floor(h * 6);
  var f = h * 6 - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0:
      r = v, g = t, b = p;break;
    case 1:
      r = q, g = v, b = p;break;
    case 2:
      r = p, g = v, b = t;break;
    case 3:
      r = p, g = q, b = v;break;
    case 4:
      r = t, g = p, b = v;break;
    case 5:
      r = v, g = p, b = q;break;
  }

  return { r: Math.floor(r * 255), g: Math.floor(g * 255), b: Math.floor(b * 255) };
};

exports.HSVToHex = function (h, s, v) {
  var rgb = exports.HSVToRGB(h, s, v);
  return exports.RGBToHex(rgb.r, rgb.g, rgb.b);
};

exports.hexToHSV = function (hex) {
  var rgb = exports.hexToRGB(hex);
  return exports.RGBToHSV(rgb.r, rgb.g, rgb.b);
};

exports.isValidHex = function (hex) {
  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
  return isOk;
};

exports.isValidRGB = function (rgb) {
  rgb = rgb.replace(" ", "");
  var isOk = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/i.test(rgb);
  return isOk;
};
exports.isValidRGBA = function (rgba) {
  rgba = rgba.replace(" ", "");
  var isOk = /rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(.{1,3})\)/i.test(rgba);
  return isOk;
};

/**
 * This recursively redirects the prototype of JSON objects to the referenceObject
 * This is used for default options.
 *
 * @param referenceObject
 * @returns {*}
 */
exports.selectiveBridgeObject = function (fields, referenceObject) {
  if (typeof referenceObject == "object") {
    var objectTo = Object.create(referenceObject);
    for (var i = 0; i < fields.length; i++) {
      if (referenceObject.hasOwnProperty(fields[i])) {
        if (typeof referenceObject[fields[i]] == "object") {
          objectTo[fields[i]] = exports.bridgeObject(referenceObject[fields[i]]);
        }
      }
    }
    return objectTo;
  } else {
    return null;
  }
};

/**
 * This recursively redirects the prototype of JSON objects to the referenceObject
 * This is used for default options.
 *
 * @param referenceObject
 * @returns {*}
 */
exports.bridgeObject = function (referenceObject) {
  if (typeof referenceObject == "object") {
    var objectTo = Object.create(referenceObject);
    for (var i in referenceObject) {
      if (referenceObject.hasOwnProperty(i)) {
        if (typeof referenceObject[i] == "object") {
          objectTo[i] = exports.bridgeObject(referenceObject[i]);
        }
      }
    }
    return objectTo;
  } else {
    return null;
  }
};

/**
 * this is used to set the options of subobjects in the options object. A requirement of these subobjects
 * is that they have an 'enabled' element which is optional for the user but mandatory for the program.
 *
 * @param [object] mergeTarget | this is either this.options or the options used for the groups.
 * @param [object] options     | options
 * @param [String] option      | this is the option key in the options argument
 * @private
 */
exports.mergeOptions = function (mergeTarget, options, option) {
  var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
  var globalOptions = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];

  if (options[option] === null) {
    mergeTarget[option] = Object.create(globalOptions[option]);
  } else {
    if (options[option] !== undefined) {
      if (typeof options[option] === 'boolean') {
        mergeTarget[option].enabled = options[option];
      } else {
        if (options[option].enabled === undefined) {
          mergeTarget[option].enabled = true;
        }
        for (var prop in options[option]) {
          if (options[option].hasOwnProperty(prop)) {
            mergeTarget[option][prop] = options[option][prop];
          }
        }
      }
    }
  }
};

/**
 * This function does a binary search for a visible item in a sorted list. If we find a visible item, the code that uses
 * this function will then iterate in both directions over this sorted list to find all visible items.
 *
 * @param {Item[]} orderedItems       | Items ordered by start
 * @param {function} searchFunction   | -1 is lower, 0 is found, 1 is higher
 * @param {String} field
 * @param {String} field2
 * @returns {number}
 * @private
 */
exports.binarySearchCustom = function (orderedItems, searchFunction, field, field2) {
  var maxIterations = 10000;
  var iteration = 0;
  var low = 0;
  var high = orderedItems.length - 1;

  while (low <= high && iteration < maxIterations) {
    var middle = Math.floor((low + high) / 2);

    var item = orderedItems[middle];
    var value = field2 === undefined ? item[field] : item[field][field2];

    var searchResult = searchFunction(value);
    if (searchResult == 0) {
      // jihaa, found a visible item!
      return middle;
    } else if (searchResult == -1) {
      // it is too small --> increase low
      low = middle + 1;
    } else {
      // it is too big --> decrease high
      high = middle - 1;
    }

    iteration++;
  }

  return -1;
};

/**
 * This function does a binary search for a specific value in a sorted array. If it does not exist but is in between of
 * two values, we return either the one before or the one after, depending on user input
 * If it is found, we return the index, else -1.
 *
 * @param {Array} orderedItems
 * @param {{start: number, end: number}} target
 * @param {String} field
 * @param {String} sidePreference   'before' or 'after'
 * @returns {number}
 * @private
 */
exports.binarySearchValue = function (orderedItems, target, field, sidePreference) {
  var maxIterations = 10000;
  var iteration = 0;
  var low = 0;
  var high = orderedItems.length - 1;
  var prevValue, value, nextValue, middle;

  while (low <= high && iteration < maxIterations) {
    // get a new guess
    middle = Math.floor(0.5 * (high + low));
    prevValue = orderedItems[Math.max(0, middle - 1)][field];
    value = orderedItems[middle][field];
    nextValue = orderedItems[Math.min(orderedItems.length - 1, middle + 1)][field];

    if (value == target) {
      // we found the target
      return middle;
    } else if (prevValue < target && value > target) {
      // target is in between of the previous and the current
      return sidePreference == 'before' ? Math.max(0, middle - 1) : middle;
    } else if (value < target && nextValue > target) {
      // target is in between of the current and the next
      return sidePreference == 'before' ? middle : Math.min(orderedItems.length - 1, middle + 1);
    } else {
      // didnt find the target, we need to change our boundaries.
      if (value < target) {
        // it is too small --> increase low
        low = middle + 1;
      } else {
        // it is too big --> decrease high
        high = middle - 1;
      }
    }
    iteration++;
  }

  // didnt find anything. Return -1.
  return -1;
};

/*
 * Easing Functions - inspired from http://gizma.com/easing/
 * only considering the t value for the range [0, 1] => [0, 1]
 * https://gist.github.com/gre/1650294
 */
exports.easingFunctions = {
  // no easing, no acceleration
  linear: function linear(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function easeInQuad(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function easeOutQuad(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function easeInOutQuad(t) {
    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity
  easeInCubic: function easeInCubic(t) {
    return t * t * t;
  },
  // decelerating to zero velocity
  easeOutCubic: function easeOutCubic(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration
  easeInOutCubic: function easeInOutCubic(t) {
    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity
  easeInQuart: function easeInQuart(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuart: function easeOutQuart(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function easeInOutQuart(t) {
    return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function easeInQuint(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function easeOutQuint(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuint: function easeInOutQuint(t) {
    return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};

},{"./module/moment":33,"./module/uuid":34}],60:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],61:[function(require,module,exports){
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (typeof define === 'function' && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],62:[function(require,module,exports){
"use strict";
/**
 * Created by Alex on 11/6/2014.
 */

// https://github.com/umdjs/umd/blob/master/returnExports.js#L40-L60
// if the module has no dependencies, the above pattern can be simplified to
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.keycharm = factory();
  }
}(this, function () {

  function keycharm(options) {
    var preventDefault = options && options.preventDefault || false;

    var container = options && options.container || window;

    var _exportFunctions = {};
    var _bound = {keydown:{}, keyup:{}};
    var _keys = {};
    var i;

    // a - z
    for (i = 97; i <= 122; i++) {_keys[String.fromCharCode(i)] = {code:65 + (i - 97), shift: false};}
    // A - Z
    for (i = 65; i <= 90; i++) {_keys[String.fromCharCode(i)] = {code:i, shift: true};}
    // 0 - 9
    for (i = 0;  i <= 9;   i++) {_keys['' + i] = {code:48 + i, shift: false};}
    // F1 - F12
    for (i = 1;  i <= 12;   i++) {_keys['F' + i] = {code:111 + i, shift: false};}
    // num0 - num9
    for (i = 0;  i <= 9;   i++) {_keys['num' + i] = {code:96 + i, shift: false};}

    // numpad misc
    _keys['num*'] = {code:106, shift: false};
    _keys['num+'] = {code:107, shift: false};
    _keys['num-'] = {code:109, shift: false};
    _keys['num/'] = {code:111, shift: false};
    _keys['num.'] = {code:110, shift: false};
    // arrows
    _keys['left']  = {code:37, shift: false};
    _keys['up']    = {code:38, shift: false};
    _keys['right'] = {code:39, shift: false};
    _keys['down']  = {code:40, shift: false};
    // extra keys
    _keys['space'] = {code:32, shift: false};
    _keys['enter'] = {code:13, shift: false};
    _keys['shift'] = {code:16, shift: undefined};
    _keys['esc']   = {code:27, shift: false};
    _keys['backspace'] = {code:8, shift: false};
    _keys['tab']       = {code:9, shift: false};
    _keys['ctrl']      = {code:17, shift: false};
    _keys['alt']       = {code:18, shift: false};
    _keys['delete']    = {code:46, shift: false};
    _keys['pageup']    = {code:33, shift: false};
    _keys['pagedown']  = {code:34, shift: false};
    // symbols
    _keys['=']     = {code:187, shift: false};
    _keys['-']     = {code:189, shift: false};
    _keys[']']     = {code:221, shift: false};
    _keys['[']     = {code:219, shift: false};



    var down = function(event) {handleEvent(event,'keydown');};
    var up = function(event) {handleEvent(event,'keyup');};

    // handle the actualy bound key with the event
    var handleEvent = function(event,type) {
      if (_bound[type][event.keyCode] !== undefined) {
        var bound = _bound[type][event.keyCode];
        for (var i = 0; i < bound.length; i++) {
          if (bound[i].shift === undefined) {
            bound[i].fn(event);
          }
          else if (bound[i].shift == true && event.shiftKey == true) {
            bound[i].fn(event);
          }
          else if (bound[i].shift == false && event.shiftKey == false) {
            bound[i].fn(event);
          }
        }

        if (preventDefault == true) {
          event.preventDefault();
        }
      }
    };

    // bind a key to a callback
    _exportFunctions.bind = function(key, callback, type) {
      if (type === undefined) {
        type = 'keydown';
      }
      if (_keys[key] === undefined) {
        throw new Error("unsupported key: " + key);
      }
      if (_bound[type][_keys[key].code] === undefined) {
        _bound[type][_keys[key].code] = [];
      }
      _bound[type][_keys[key].code].push({fn:callback, shift:_keys[key].shift});
    };


    // bind all keys to a call back (demo purposes)
    _exportFunctions.bindAll = function(callback, type) {
      if (type === undefined) {
        type = 'keydown';
      }
      for (var key in _keys) {
        if (_keys.hasOwnProperty(key)) {
          _exportFunctions.bind(key,callback,type);
        }
      }
    };

    // get the key label from an event
    _exportFunctions.getKey = function(event) {
      for (var key in _keys) {
        if (_keys.hasOwnProperty(key)) {
          if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
            return key;
          }
          else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
            return key;
          }
          else if (event.keyCode == _keys[key].code && key == 'shift') {
            return key;
          }
        }
      }
      return "unknown key, currently not supported";
    };

    // unbind either a specific callback from a key or all of them (by leaving callback undefined)
    _exportFunctions.unbind = function(key, callback, type) {
      if (type === undefined) {
        type = 'keydown';
      }
      if (_keys[key] === undefined) {
        throw new Error("unsupported key: " + key);
      }
      if (callback !== undefined) {
        var newBindings = [];
        var bound = _bound[type][_keys[key].code];
        if (bound !== undefined) {
          for (var i = 0; i < bound.length; i++) {
            if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {
              newBindings.push(_bound[type][_keys[key].code][i]);
            }
          }
        }
        _bound[type][_keys[key].code] = newBindings;
      }
      else {
        _bound[type][_keys[key].code] = [];
      }
    };

    // reset all bound variables.
    _exportFunctions.reset = function() {
      _bound = {keydown:{}, keyup:{}};
    };

    // unbind all listeners and reset all variables.
    _exportFunctions.destroy = function() {
      _bound = {keydown:{}, keyup:{}};
      container.removeEventListener('keydown', down, true);
      container.removeEventListener('keyup', up, true);
    };

    // create listeners.
    container.addEventListener('keydown',down,true);
    container.addEventListener('keyup',up,true);

    // return the public functions.
    return _exportFunctions;
  }

  return keycharm;
}));



},{}],63:[function(require,module,exports){
//! moment.js
//! version : 2.14.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        return Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        var k;
        for (k in obj) {
            // even if its not own property I'd still call it non-empty
            return false;
        }
        return true;
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (utils_hooks__hooks.deprecationHandler != null) {
                utils_hooks__hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (utils_hooks__hooks.deprecationHandler != null) {
            utils_hooks__hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;
    utils_hooks__hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function get_set__set (mom, unit, value) {
        if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function units_month__handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = create_utc__createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return units_month__handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (typeof value !== 'number') {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        //the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function day_of_week__handleStrictParse(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = create_utc__createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = create_utc__createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        ordinalParse: defaultOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    // treat as if there is no base config
                    deprecateSimple('parentLocaleUndefined',
                            'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, parentConfig = baseConfig;
            // MERGE
            if (locales[name] != null) {
                parentConfig = locales[name]._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function locale_locales__listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (isDate(input)) {
            config._d = input;
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!valid__isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
            } else if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(matchOffset, this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            delta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIOROITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add               = add_subtract__add;
    momentPrototype__proto.calendar          = moment_calendar__calendar;
    momentPrototype__proto.clone             = clone;
    momentPrototype__proto.diff              = diff;
    momentPrototype__proto.endOf             = endOf;
    momentPrototype__proto.format            = format;
    momentPrototype__proto.from              = from;
    momentPrototype__proto.fromNow           = fromNow;
    momentPrototype__proto.to                = to;
    momentPrototype__proto.toNow             = toNow;
    momentPrototype__proto.get               = stringGet;
    momentPrototype__proto.invalidAt         = invalidAt;
    momentPrototype__proto.isAfter           = isAfter;
    momentPrototype__proto.isBefore          = isBefore;
    momentPrototype__proto.isBetween         = isBetween;
    momentPrototype__proto.isSame            = isSame;
    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
    momentPrototype__proto.isValid           = moment_valid__isValid;
    momentPrototype__proto.lang              = lang;
    momentPrototype__proto.locale            = locale;
    momentPrototype__proto.localeData        = localeData;
    momentPrototype__proto.max               = prototypeMax;
    momentPrototype__proto.min               = prototypeMin;
    momentPrototype__proto.parsingFlags      = parsingFlags;
    momentPrototype__proto.set               = stringSet;
    momentPrototype__proto.startOf           = startOf;
    momentPrototype__proto.subtract          = add_subtract__subtract;
    momentPrototype__proto.toArray           = toArray;
    momentPrototype__proto.toObject          = toObject;
    momentPrototype__proto.toDate            = toDate;
    momentPrototype__proto.toISOString       = moment_format__toISOString;
    momentPrototype__proto.toJSON            = toJSON;
    momentPrototype__proto.toString          = toString;
    momentPrototype__proto.unix              = unix;
    momentPrototype__proto.valueOf           = to_type__valueOf;
    momentPrototype__proto.creationData      = creationData;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var prototype__proto = Locale.prototype;

    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto.ordinal         = ordinal;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months            =        localeMonths;
    prototype__proto.monthsShort       =        localeMonthsShort;
    prototype__proto.monthsParse       =        localeMonthsParse;
    prototype__proto.monthsRegex       = monthsRegex;
    prototype__proto.monthsShortRegex  = monthsShortRegex;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    prototype__proto.weekdaysRegex       =        weekdaysRegex;
    prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
    prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = lists__get(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = locale_locales__getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return lists__get(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = lists__get(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function lists__listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function lists__listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function lists__listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function lists__listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes <= 1           && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   <= 1           && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    <= 1           && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  <= 1           && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   <= 1           && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function duration_humanize__getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.14.1';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.now                   = now;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.updateLocale          = updateLocale;
    utils_hooks__hooks.locales               = locale_locales__listLocales;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.calendarFormat        = getCalendarFormat;
    utils_hooks__hooks.prototype             = momentPrototype;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],64:[function(require,module,exports){
'use strict';

(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    window.propagating = factory();
  }
}(function () {
  var _firstTarget = null; // singleton, will contain the target element where the touch event started

  /**
   * Extend an Hammer.js instance with event propagation.
   *
   * Features:
   * - Events emitted by hammer will propagate in order from child to parent
   *   elements.
   * - Events are extended with a function `event.stopPropagation()` to stop
   *   propagation to parent elements.
   * - An option `preventDefault` to stop all default browser behavior.
   *
   * Usage:
   *   var hammer = propagatingHammer(new Hammer(element));
   *   var hammer = propagatingHammer(new Hammer(element), {preventDefault: true});
   *
   * @param {Hammer.Manager} hammer   An hammer instance.
   * @param {Object} [options]        Available options:
   *                                  - `preventDefault: true | false | 'mouse' | 'touch' | 'pen'`.
   *                                    Enforce preventing the default browser behavior.
   *                                    Cannot be set to `false`.
   * @return {Hammer.Manager} Returns the same hammer instance with extended
   *                          functionality
   */
  return function propagating(hammer, options) {
    var _options = options || {
      preventDefault: false
    };

    if (hammer.Manager) {
      // This looks like the Hammer constructor.
      // Overload the constructors with our own.
      var Hammer = hammer;

      var PropagatingHammer = function(element, options) {
        var o = Object.create(_options);
        if (options) Hammer.assign(o, options);
        return propagating(new Hammer(element, o), o);
      };
      Hammer.assign(PropagatingHammer, Hammer);

      PropagatingHammer.Manager = function (element, options) {
        var o = Object.create(_options);
        if (options) Hammer.assign(o, options);
        return propagating(new Hammer.Manager(element, o), o);
      };

      return PropagatingHammer;
    }

    // create a wrapper object which will override the functions
    // `on`, `off`, `destroy`, and `emit` of the hammer instance
    var wrapper = Object.create(hammer);

    // attach to DOM element
    var element = hammer.element;

    if(!element.hammer) element.hammer = [];
    element.hammer.push(wrapper);

    // register an event to catch the start of a gesture and store the
    // target in a singleton
    hammer.on('hammer.input', function (event) {
      if (_options.preventDefault === true || (_options.preventDefault === event.pointerType)) {
        event.preventDefault();
      }
      if (event.isFirst) {
        _firstTarget = event.target;
      }
    });

    /** @type {Object.<String, Array.<function>>} */
    wrapper._handlers = {};

    /**
     * Register a handler for one or multiple events
     * @param {String} events    A space separated string with events
     * @param {function} handler A callback function, called as handler(event)
     * @returns {Hammer.Manager} Returns the hammer instance
     */
    wrapper.on = function (events, handler) {
      // register the handler
      split(events).forEach(function (event) {
        var _handlers = wrapper._handlers[event];
        if (!_handlers) {
          wrapper._handlers[event] = _handlers = [];

          // register the static, propagated handler
          hammer.on(event, propagatedHandler);
        }
        _handlers.push(handler);
      });

      return wrapper;
    };

    /**
     * Unregister a handler for one or multiple events
     * @param {String} events      A space separated string with events
     * @param {function} [handler] Optional. The registered handler. If not
     *                             provided, all handlers for given events
     *                             are removed.
     * @returns {Hammer.Manager}   Returns the hammer instance
     */
    wrapper.off = function (events, handler) {
      // unregister the handler
      split(events).forEach(function (event) {
        var _handlers = wrapper._handlers[event];
        if (_handlers) {
          _handlers = handler ? _handlers.filter(function (h) {
            return h !== handler;
          }) : [];

          if (_handlers.length > 0) {
            wrapper._handlers[event] = _handlers;
          }
          else {
            // remove static, propagated handler
            hammer.off(event, propagatedHandler);
            delete wrapper._handlers[event];
          }
        }
      });

      return wrapper;
    };

    /**
     * Emit to the event listeners
     * @param {string} eventType
     * @param {Event} event
     */
    wrapper.emit = function(eventType, event) {
      _firstTarget = event.target;
      hammer.emit(eventType, event);
    };

    wrapper.destroy = function () {
      // Detach from DOM element
      var hammers = hammer.element.hammer;
      var idx = hammers.indexOf(wrapper);
      if(idx !== -1) hammers.splice(idx,1);
      if(!hammers.length) delete hammer.element.hammer;

      // clear all handlers
      wrapper._handlers = {};

      // call original hammer destroy
      hammer.destroy();
    };

    // split a string with space separated words
    function split(events) {
      return events.match(/[^ ]+/g);
    }

    /**
     * A static event handler, applying event propagation.
     * @param {Object} event
     */
    function propagatedHandler(event) {
      // let only a single hammer instance handle this event
      if (event.type !== 'hammer.input') {
        // it is possible that the same srcEvent is used with multiple hammer events,
        // we keep track on which events are handled in an object _handled
        if (!event.srcEvent._handled) {
          event.srcEvent._handled = {};
        }

        if (event.srcEvent._handled[event.type]) {
          return;
        }
        else {
          event.srcEvent._handled[event.type] = true;
        }
      }

      // attach a stopPropagation function to the event
      var stopped = false;
      event.stopPropagation = function () {
        stopped = true;
      };

      //wrap the srcEvent's stopPropagation to also stop hammer propagation:
      var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);
      if(typeof srcStop == "function") {
        event.srcEvent.stopPropagation = function(){
          srcStop();
          event.stopPropagation();
        }
      }

      // attach firstTarget property to the event
      event.firstTarget = _firstTarget;

      // propagate over all elements (until stopped)
      var elem = _firstTarget;
      while (elem && !stopped) {
        var elemHammer = elem.hammer;
        if(elemHammer){
          var _handlers;
          for(var k = 0; k < elemHammer.length; k++){
            _handlers = elemHammer[k]._handlers[event.type];
            if(_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {
              _handlers[i](event);
            }
          }
        }
        elem = elem.parentNode;
      }
    }

    return wrapper;
  };
}));

},{}],65:[function(require,module,exports){
$ = require('../bower_components/jquery/dist/jquery.js');

function setInputValue(el, val) {
    el.val(val);
    // tiggerHandler only works with angular element (not jquery)?
    angular.element(el).triggerHandler(sniffer.hasEvent('input') ? 'input' : 'change');
    return el;
}

function click(el) {
    angular.element(el).triggerHandler('click');
}

function compile(html, contents) {
    var scope = $rootScope.$new();
    var el = $compile(html)(scope);
    angular.extend(scope, contents);
    scope.$digest();
    return $(el);
}

function getScope(el) {
    return angular.element(el).scope();
}

exports.inject = function() {
    inject(function(_$compile_, _$rootScope_, $sniffer) {
        $compile = _$compile_;
        $rootScope = _$rootScope_;
        sniffer = $sniffer;
    });
};
exports.setInputValue = setInputValue;
exports.click = click;
exports.compile = compile;
exports.getScope = getScope;
},{"../bower_components/jquery/dist/jquery.js":2}],66:[function(require,module,exports){
var MapConfigTransformer = require('../lib/mapstory/MapConfigTransformer.js').MapConfigTransformer;

describe('MapConfigTransformer', function() {
    it('should transform map id 1193', function() {
        var data = JSON.parse('{"sources": {"1": {"hidden": true, "ptype": "gxp_mapquestsource", "id": "1"}, "0": {"ptype": "gx_olsource", "id": "0"}, "2": {"hidden": true, "ptype": "gxp_mapboxsource", "id": "2"}, "local": {"title": "My GeoServer WMS", "url": "/geoserver/geonode/Breweries0/wms", "baseParams": {"VERSION": "1.1.1", "REQUEST": "GetCapabilities", "TILED": true, "SERVICE": "WMS"}, "ptype": "gxp_wmscsource", "restUrl": "/gs/rest", "hidden": true, "id": "local"}}, "about": {"abstract": "This map shows the evolution and development of the  brewing industry in the United States. The information is obtained from the book American Breweries II by Dale P. Van Wieren. The same information could also be accessed at www.beerbooks.com", "title": "Chronology of the American Brewing Industry"}, "localGeoServerBaseUrl": "http://mapstory.org/geoserver/", "map": {"layers": [{"opacity": 1.0, "args": ["No background"], "group": "background", "name": "No background", "title": "No background", "selected": false, "visibility": false, "source": "0", "fixed": true, "type": "OpenLayers.Layer"}, {"opacity": 1.0, "args": ["OpenStreetMap"], "group": "background", "name": "OpenStreetMap", "title": "OpenStreetMap", "selected": false, "visibility": true, "source": "0", "fixed": true, "type": "OpenLayers.Layer.OSM"}, {"opacity": 1.0, "args": ["Humanitarian OpenStreetMap", ["http://a.tile.openstreetmap.fr/hot/${z}/${x}/${y}.png", "http://b.tile.openstreetmap.fr/hot/${z}/${x}/${y}.png", "http://c.tile.openstreetmap.fr/hot/${z}/${x}/${y}.png"], {"tileOptions": {"crossOriginKeyword": null}}], "group": "background", "name": "Humanitarian OpenStreetMap", "title": "Humanitarian OpenStreetMap", "selected": false, "visibility": false, "source": "0", "fixed": true, "type": "OpenLayers.Layer.OSM"}, {"opacity": 1.0, "args": ["Naked Earth", "http://maps.opengeo.org/geowebcache/service/wms", {"layers": ["Wayne"], "tiled": true, "tilesOrigin": [-20037508.34, -20037508.34], "format": "image/png"}, {"buffer": 0}], "group": "background", "name": "Naked Earth", "title": "Naked Earth", "selected": false, "visibility": false, "source": "0", "fixed": true, "type": "OpenLayers.Layer.WMS"}, {"opacity": 1.0, "group": "background", "name": "naip", "title": "Satellite Imagery", "selected": false, "visibility": false, "source": "1", "fixed": true}, {"opacity": 1.0, "group": "background", "name": "natural-earth-1", "title": "Natural Earth", "selected": false, "visibility": false, "source": "2", "fixed": false}, {"opacity": 1.0, "group": "background", "name": "natural-earth-2", "title": "Natural Earth 2", "selected": false, "visibility": false, "source": "2", "fixed": false}, {"opacity": 1.0, "group": "background", "name": "geography-class", "title": "Geography Class", "selected": false, "visibility": false, "source": "2", "fixed": false}, {"opacity": 1.0, "group": "background", "name": "world-light", "title": "World Light", "selected": false, "visibility": false, "source": "2", "fixed": false}, {"opacity": 1.0, "styles": "geonode_Breweries", "name": "Breweries0", "format": "image/png", "cached": true, "selected": true, "visibility": true, "capability": {"abstract": "", "nestedLayers": [], "cascaded": 0, "fixedHeight": 0, "prefix": "Breweries0", "keywords": [], "noSubsets": false, "dimensions": {"time": {"nearestVal": false, "multipleVal": false, "name": "time", "default": "current", "current": false, "units": "ISO8601", "values": ["1587-01-01T00:00:00.000Z", "1607-01-01T00:00:00.000Z", "1609-01-01T00:00:00.000Z", "1612-01-01T00:00:00.000Z", "1614-01-01T00:00:00.000Z", "1620-01-01T00:00:00.000Z", "1632-01-01T00:00:00.000Z", "1633-01-01T00:00:00.000Z", "1634-01-01T00:00:00.000Z", "1637-01-01T00:00:00.000Z", "1639-01-01T00:00:00.000Z", "1670-01-01T00:00:00.000Z", "1683-01-01T00:00:00.000Z", "1734-01-01T00:00:00.000Z", "1738-01-01T00:00:00.000Z", "1765-01-01T00:00:00.000Z", "1774-01-01T00:00:00.000Z", "1789-01-01T00:00:00.000Z", "1792-01-01T00:00:00.000Z", "1793-01-01T00:00:00.000Z", "1808-01-01T00:00:00.000Z", "1810-01-01T00:00:00.000Z", "1819-01-01T00:00:00.000Z", "1826-01-01T00:00:00.000Z", "1829-01-01T00:00:00.000Z", "1830-01-01T00:00:00.000Z", "1833-01-01T00:00:00.000Z", "1836-01-01T00:00:00.000Z", "1837-01-01T00:00:00.000Z", "1840-01-01T00:00:00.000Z", "1844-01-01T00:00:00.000Z", "1846-01-01T00:00:00.000Z", "1847-01-01T00:00:00.000Z", "1848-01-01T00:00:00.000Z", "1849-01-01T00:00:00.000Z", "1850-01-01T00:00:00.000Z", "1852-01-01T00:00:00.000Z", "1853-01-01T00:00:00.000Z", "1854-01-01T00:00:00.000Z", "1855-01-01T00:00:00.000Z", "1856-01-01T00:00:00.000Z", "1857-01-01T00:00:00.000Z", "1859-01-01T00:00:00.000Z", "1862-01-01T00:00:00.000Z", "1865-01-01T00:00:00.000Z", "1866-01-01T00:00:00.000Z", "1867-01-01T00:00:00.000Z", "1868-01-01T00:00:00.000Z", "1869-01-01T00:00:00.000Z", "1871-01-01T00:00:00.000Z", "1872-01-01T00:00:00.000Z", "1873-01-01T00:00:00.000Z", "1875-01-01T00:00:00.000Z", "1877-01-01T00:00:00.000Z", "1884-01-01T00:00:00.000Z", "1885-01-01T00:00:00.000Z", "1887-01-01T00:00:00.000Z", "1888-01-01T00:00:00.000Z", "1889-01-01T00:00:00.000Z", "1890-01-01T00:00:00.000Z", "1892-01-01T00:00:00.000Z", "1898-01-01T00:00:00.000Z", "1899-01-01T00:00:00.000Z", "1900-01-01T00:00:00.000Z", "1901-01-01T00:00:00.000Z", "1905-01-01T00:00:00.000Z", "1916-01-01T00:00:00.000Z", "1922-01-01T00:00:00.000Z", "1926-01-01T00:00:00.000Z", "1935-01-01T00:00:00.000Z", "1951-01-01T00:00:00.000Z", "1953-01-01T00:00:00.000Z", "1959-01-01T00:00:00.000Z", "1962-01-01T00:00:00.000Z", "1969-01-01T00:00:00.000Z", "1972-01-01T00:00:00.000Z", "1977-01-01T00:00:00.000Z", "1982-01-01T00:00:00.000Z", "1984-01-01T00:00:00.000Z", "1990-01-01T00:00:00.000Z"], "unitsymbol": null}}, "opaque": false, "tileSets": [{"layers": "Breweries0", "styles": "", "format": "image/png", "height": 256, "srs": {"EPSG:900913": true}, "bbox": {"EPSG:900913": {"srs": "EPSG:900913", "bbox": [-20037508.34, 0, 0, 20037508.34]}}, "resolutions": [156543.03390625, 78271.516953124999, 39135.7584765625, 19567.87923828125, 9783.9396191406249, 4891.9698095703125, 2445.9849047851562, 1222.9924523925781, 611.49622619628906, 305.74811309814453, 152.87405654907226, 76.437028274536132, 38.218514137268066, 19.109257068634033, 9.5546285343170165, 4.7773142671585083, 2.3886571335792541, 1.1943285667896271, 0.59716428339481353, 0.29858214169740677, 0.14929107084870338, 0.074645535424351692, 0.037322767712175846, 0.018661383856087923, 0.0093306919280439615, 0.0046653459640219807, 0.0023326729820109904, 0.0011663364910054952, 0.00058316824550274759, 0.0002915841227513738, 0.0001457920613756869], "width": 256}], "infoFormats": ["text/plain", "application/vnd.ogc.gml", "application/vnd.ogc.gml/3.1.1", "text/html", "application/json"], "styles": [{"abstract": "", "title": "azure square point style", "legend": {"height": "20", "width": "20", "href": "http://mapstory.org:80/geoserver/geonode/Breweries0/wms?request=GetLegendGraphic&format=image%2Fpng&width=20&height=20&layer=Breweries0", "format": "image/png"}, "name": "geonode_Breweries"}], "attribution": {"title": "admin"}, "authorityURLs": {}, "bbox": {"EPSG:4326": {"srs": "EPSG:4326", "bbox": [-157.816667, 21.300000000000001, -69.780000000000001, 46.601944000000003]}}, "fixedWidth": 0, "metadataURLs": [], "name": "Breweries0", "identifiers": {}, "srs": {"EPSG:900913": true}, "formats": ["image/png", "application/atom xml", "application/atom+xml", "application/openlayers", "application/pdf", "application/rss xml", "application/rss+xml", "application/vnd.google-earth.kml", "application/vnd.google-earth.kml xml", "application/vnd.google-earth.kml+xml", "application/vnd.google-earth.kml+xml;mode=networklink", "application/vnd.google-earth.kmz", "application/vnd.google-earth.kmz xml", "application/vnd.google-earth.kmz+xml", "application/vnd.google-earth.kmz;mode=networklink", "atom", "image/geotiff", "image/geotiff8", "image/gif", "image/gif;subtype=animated", "image/jpeg", "image/png8", "image/png; mode=8bit", "image/svg", "image/svg xml", "image/svg+xml", "image/tiff", "image/tiff8", "kml", "kmz", "openlayers", "rss"], "title": "Breweries0", "queryable": true, "llbbox": [-157.816667, 21.300000000000001, -69.780000000000001, 46.601944000000003]}, "source": "local", "tiled": false, "title": "Breweries0", "fixed": false, "transparent": true}], "wrapDateLine": false, "projection": "EPSG:900913", "center": [-12667972.53658, 4152514.0300837001], "zoom": 4, "units": "m", "maxResolution": 156543.03390625, "maxExtent": [-20037508.34, -20037508.34, 20037508.34, 20037508.34], "numZoomLevels": 22}, "defaultSourceType": "gxp_wmscsource", "apiKeys": {"google": "ABQIAAAAkofooZxTfcCv9Wi3zzGTVxTnme5EwnLVtEDGnh-lFVzRJhbdQhQgAhB1eT_2muZtc0dl-ZSWrtzmrw"}, "tools": [{"outputConfig": {"looped": true, "layout": "toolbar", "xtype": "app_playbacktoolbar", "hideParent": true, "controlConfig": {"timeStep": null, "animationRange": [-12086323200000, 631152000000], "snapToList": true, "model": {"range": [-12086323200000, 631152000000], "values": [-12086323200000, -11455171200000, -11392012800000, -11297404800000, -11234246400000, -11044944000000, -10666252800000, -10634630400000, -10603094400000, -10508400000000, -10445328000000, -9467020800000, -9056793600000, -7447420800000, -7321190400000, -6469113600000, -6185116800000, -5711731200000, -5617123200000, -5585500800000, -5112288000000, -5049129600000, -4765132800000, -4544208000000, -4449513600000, -4417977600000, -4323283200000, -4228675200000, -4197052800000, -4102444800000, -3976214400000, -3913056000000, -3881520000000, -3849984000000, -3818361600000, -3786825600000, -3723753600000, -3692131200000, -3660595200000, -3629059200000, -3597523200000, -3565900800000, -3502828800000, -3408134400000, -3313440000000, -3281904000000, -3250368000000, -3218832000000, -3187209600000, -3124137600000, -3092601600000, -3060979200000, -2997907200000, -2934748800000, -2713910400000, -2682288000000, -2619216000000, -2587680000000, -2556057600000, -2524521600000, -2461449600000, -2272060800000, -2240524800000, -2208988800000, -2177452800000, -2051222400000, -1704153600000, -1514764800000, -1388534400000, -1104537600000, -599616000000, -536457600000, -347155200000, -252460800000, -31536000000, 63072000000, 220924800000, 378691200000, 441763200000, 631152000000], "dimension": "time"}, "dimension": "time", "loop": true}, "listeners": {"single": true}, "removeMode": "container", "playbackMode": "cumulative", "defaults": {"scale": "medium"}, "autoPlay": false}, "looped": true, "outputTarget": "map-bbar", "ptype": "gxp_playback", "id": "playback-tool"}, {"bgColor": "#454238", "wrapDateLine": false, "ptype": "ms-tool-bar", "numZoomLevels": 22}, {"playbackTool": "playback-tool", "outputConfig": {"title": null}, "outputTarget": "timeline-container", "ptype": "gxp_timeline", "id": "timeline-tool"}], "authorizedRoles": ["ROLE_ANONYMOUS"], "id": 1193}');
        var config = MapConfigTransformer(data);
        expect(JSON.stringify(config)).toBe('{"id":1193,"playbackMode":"cumulative","map":{"center":[-12667972.53658,4152514.0300837],"projection":"EPSG:900913","zoom":4,"layers":[{"visibility":true,"group":"background","type":"OSM","title":"OpenStreetMap"},{"visibility":true,"type":"WMS","singleTile":true,"id":"Breweries0","name":"Breweries0","title":"Breweries0","url":"/geoserver/geonode/Breweries0/wms","params":{"LAYERS":"Breweries0","STYLES":"geonode_Breweries","TILED":"TRUE","FORMAT":"image/png","TRANSPARENT":true,"VERSION":"1.1.1"},"latlonBBOX":[-157.816667,21.3,-69.78,46.601944],"times":[-12086323200000,-11455171200000,-11392012800000,-11297404800000,-11234246400000,-11044944000000,-10666252800000,-10634630400000,-10603094400000,-10508486400000,-10445414400000,-9467107200000,-9056880000000,-7447420800000,-7321190400000,-6469113600000,-6185203200000,-5711817600000,-5617209600000,-5585587200000,-5112288000000,-5049129600000,-4765132800000,-4544208000000,-4449513600000,-4417977600000,-4323283200000,-4228675200000,-4197052800000,-4102444800000,-3976214400000,-3913056000000,-3881520000000,-3849984000000,-3818361600000,-3786825600000,-3723753600000,-3692131200000,-3660595200000,-3629059200000,-3597523200000,-3565900800000,-3502828800000,-3408134400000,-3313440000000,-3281904000000,-3250368000000,-3218832000000,-3187209600000,-3124137600000,-3092601600000,-3060979200000,-2997907200000,-2934748800000,-2713910400000,-2682288000000,-2619216000000,-2587680000000,-2556057600000,-2524521600000,-2461449600000,-2272060800000,-2240524800000,-2208988800000,-2177452800000,-2051222400000,-1704153600000,-1514764800000,-1388534400000,-1104537600000,-599616000000,-536457600000,-347155200000,-252460800000,-31536000000,63072000000,220924800000,378691200000,441763200000,631152000000],"bbox":[-20037508.34,0,0,20037508.34],"resolutions":[156543.03390625,78271.516953125,39135.7584765625,19567.87923828125,9783.939619140625,4891.9698095703125,2445.9849047851562,1222.9924523925781,611.4962261962891,305.74811309814453,152.87405654907226,76.43702827453613,38.218514137268066,19.109257068634033,9.554628534317017,4.777314267158508,2.388657133579254,1.194328566789627,0.5971642833948135,0.29858214169740677,0.14929107084870338,0.07464553542435169,0.037322767712175846,0.018661383856087923,0.009330691928043961,0.004665345964021981,0.0023326729820109904,0.0011663364910054952,0.0005831682455027476,0.0002915841227513738,0.0001457920613756869]}]}}');
    });
});

},{"../lib/mapstory/MapConfigTransformer.js":16}],67:[function(require,module,exports){
var SLDStyleConverter = require('../lib/edit/style/SLDStyleConverter.js').SLDStyleConverter;
var instance = new SLDStyleConverter();

describe('SLDStyleConverter', function() {

    beforeEach(function() {
        jasmine.addMatchers(customMatchers);
    });

    it('should convert simple types (point)', function() {
        var styleConfig = {
            "typeName": "simple",
            "symbol": {
                "size": 10,
                "shape": "circle",
                "graphic": null,
                "graphicType": null,
                "fillColor": "#ff0000",
                "fillOpacity": 80
            },
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "dotted",
                "strokeOpacity": 90
            },
            "geomType": "point"
        };
        var style = instance.generateStyle(styleConfig, 'simple');
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:Name>simple</sld:Name><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>circle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#ff0000</sld:CssParameter><sld:CssParameter name="fill-opacity">0.8</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width">3</sld:CssParameter><sld:CssParameter name="stroke-opacity">0.9</sld:CssParameter><sld:CssParameter name="stroke-dasharray">1 2</sld:CssParameter></sld:Stroke></sld:Mark><sld:Opacity>0.8</sld:Opacity><sld:Size>10</sld:Size></sld:Graphic></sld:PointSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
        // svg symbol (graphic)
        styleConfig = {
            "typeName": "simple",
            "symbol": {
                "size": 10,
                "shape": null,
                "graphic": "icon.svg",
                "graphicType": null,
                "fillColor": "#ff0000",
                "fillOpacity": 80
            },
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "solid",
                "strokeOpacity": 90
            },
            "geomType": "point"
        };
        style = instance.generateStyle(styleConfig, 'simple');
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:Name>simple</sld:Name><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><sld:PointSymbolizer><sld:Graphic><sld:ExternalGraphic><sld:OnlineResource xlink:href="http://localhost:9876/icon.svg?fill=%23ff0000&amp;stroke=%23ffff00"/><sld:Format>image/svg+xml</sld:Format></sld:ExternalGraphic><sld:Opacity>0.8</sld:Opacity><sld:Size>10</sld:Size></sld:Graphic></sld:PointSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
    });

    it('should convert simple types (line)', function() {
        var styleConfig = {
            "typeName": "simple line",
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "dashed",
                "strokeOpacity": 90
            },
            "geomType": "line"
        };
        var style = instance.generateStyle(styleConfig, 'simple line');
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:Name>simple line</sld:Name><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><sld:LineSymbolizer><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width">3</sld:CssParameter><sld:CssParameter name="stroke-opacity">0.9</sld:CssParameter><sld:CssParameter name="stroke-dasharray">5</sld:CssParameter></sld:Stroke></sld:LineSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
    });

    it('should convert simple types (polygon)', function() {
        var styleConfig = {
            "typeName": "simple polygon",
            "symbol": {
                "fillColor": "#ff0000",
                "fillOpacity": 80
            },
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "dashed",
                "strokeOpacity": 90
            },
            "geomType": "polygon"
        };
        var style = instance.generateStyle(styleConfig, 'simple polygon');
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:Name>simple polygon</sld:Name><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><sld:PolygonSymbolizer><sld:Fill><sld:CssParameter name="fill">#ff0000</sld:CssParameter><sld:CssParameter name="fill-opacity">0.8</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width">3</sld:CssParameter><sld:CssParameter name="stroke-opacity">0.9</sld:CssParameter><sld:CssParameter name="stroke-dasharray">5</sld:CssParameter></sld:Stroke></sld:PolygonSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
    });

    it('should convert labels', function() {
        var styleConfig = {
            "typeName": "simple",
            "symbol": {
                "size": 10,
                "shape": "circle",
                "graphic": null,
                "graphicType": null,
                "fillColor": "#ff0000",
                "fillOpacity": 80
            },
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "solid",
                "strokeOpacity": 90
            },
            "label": {
                "attribute": "foo",
                "fillColor": "#000000",
                "fontFamily": "serif",
                "fontSize": 10,
                "fontStyle": "normal",
                "fontWeight": "normal"
            },
            "geomType": "point"
        };
        var style = instance.generateStyle(styleConfig, 'simple');
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:Name>simple</sld:Name><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>circle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#ff0000</sld:CssParameter><sld:CssParameter name="fill-opacity">0.8</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width">3</sld:CssParameter><sld:CssParameter name="stroke-opacity">0.9</sld:CssParameter><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:Mark><sld:Opacity>0.8</sld:Opacity><sld:Size>10</sld:Size></sld:Graphic></sld:PointSymbolizer><sld:TextSymbolizer><sld:Label><ogc:PropertyName>foo</ogc:PropertyName></sld:Label><sld:Font><sld:CssParameter name="font-family">Serif</sld:CssParameter><sld:CssParameter name="font-size">10</sld:CssParameter><sld:CssParameter name="font-style">normal</sld:CssParameter><sld:CssParameter name="font-weight">normal</sld:CssParameter></sld:Font><sld:LabelPlacement><sld:LinePlacement/></sld:LabelPlacement><sld:Halo><sld:Radius>1</sld:Radius><sld:Fill><sld:CssParameter name="fill">#FFFFFF</sld:CssParameter></sld:Fill></sld:Halo><sld:Fill><sld:CssParameter name="fill">#000000</sld:CssParameter></sld:Fill><sld:VendorOption name="maxDisplacement">40</sld:VendorOption><sld:VendorOption name="autoWrap">40</sld:VendorOption><sld:VendorOption name="spaceAround">0</sld:VendorOption><sld:VendorOption name="followLine">false</sld:VendorOption><sld:VendorOption name="group">yes</sld:VendorOption><sld:VendorOption name="goodnessOfFit">0.2</sld:VendorOption><sld:VendorOption name="conflictResolution">true</sld:VendorOption></sld:TextSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
    });

    it('should convert unique classification', function() {
        var styleConfig = {
            "stroke": {
                "strokeColor": "#ffff00"
            },
            "geomType": "point",
            "classify": {
                "attribute": "foo"
            },
            "rules": [{
                "value": "bar",
                "style": {
                    "symbol": {
                        "fillColor": "#ff9900"
                    },
                    "stroke": {
                        "strokeColor": "#ff9900"
                    }
                }
            }, {
                "value": "baz",
                "style": {
                    "symbol": {
                        "fillColor": "#b36b00"
                    },
                    "stroke": {
                        "strokeColor": "#b36b00"
                    }
                }
            }]
        };
        var style = instance.generateStyle(styleConfig);
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><ogc:Filter><ogc:PropertyIsEqualTo><ogc:PropertyName>foo</ogc:PropertyName><ogc:Literal>bar</ogc:Literal></ogc:PropertyIsEqualTo></ogc:Filter><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>circle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#ff9900</sld:CssParameter><sld:CssParameter name="fill-opacity">1</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:Mark><sld:Opacity>1</sld:Opacity><sld:Size>10</sld:Size></sld:Graphic></sld:PointSymbolizer></sld:Rule><sld:Rule><ogc:Filter><ogc:PropertyIsEqualTo><ogc:PropertyName>foo</ogc:PropertyName><ogc:Literal>baz</ogc:Literal></ogc:PropertyIsEqualTo></ogc:Filter><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>circle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#b36b00</sld:CssParameter><sld:CssParameter name="fill-opacity">1</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:Mark><sld:Opacity>1</sld:Opacity><sld:Size>10</sld:Size></sld:Graphic></sld:PointSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
        styleConfig.geomType = "line";
        style = instance.generateStyle(styleConfig);
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><ogc:Filter><ogc:PropertyIsEqualTo><ogc:PropertyName>foo</ogc:PropertyName><ogc:Literal>bar</ogc:Literal></ogc:PropertyIsEqualTo></ogc:Filter><sld:LineSymbolizer><sld:Stroke><sld:CssParameter name="stroke">#ff9900</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:LineSymbolizer></sld:Rule><sld:Rule><ogc:Filter><ogc:PropertyIsEqualTo><ogc:PropertyName>foo</ogc:PropertyName><ogc:Literal>baz</ogc:Literal></ogc:PropertyIsEqualTo></ogc:Filter><sld:LineSymbolizer><sld:Stroke><sld:CssParameter name="stroke">#b36b00</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:LineSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
        styleConfig.geomType = "polygon";
        style = instance.generateStyle(styleConfig);
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><ogc:Filter><ogc:PropertyIsEqualTo><ogc:PropertyName>foo</ogc:PropertyName><ogc:Literal>bar</ogc:Literal></ogc:PropertyIsEqualTo></ogc:Filter><sld:PolygonSymbolizer><sld:Fill><sld:CssParameter name="fill">#ff9900</sld:CssParameter><sld:CssParameter name="fill-opacity">1</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:PolygonSymbolizer></sld:Rule><sld:Rule><ogc:Filter><ogc:PropertyIsEqualTo><ogc:PropertyName>foo</ogc:PropertyName><ogc:Literal>baz</ogc:Literal></ogc:PropertyIsEqualTo></ogc:Filter><sld:PolygonSymbolizer><sld:Fill><sld:CssParameter name="fill">#b36b00</sld:CssParameter><sld:CssParameter name="fill-opacity">1</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:PolygonSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
    });

    it('should convert ranges of a classification', function() {
        var styleConfig = {
            "stroke": {
                "strokeColor": "#ffff00"
            },  
            "geomType": "point",
            "classify": {
                "attribute": "foo"
            },      
            "rules": [{
                "range": {
                    "min": 0,
                    "max": 10
                },  
                "style": {
                    "symbol": {
                        "fillColor": "#ff9900"
                    }   
                }   
            }, {
                "range": {
                    "min": 10,
                    "max": 20
                },
                "style": {
                    "symbol": {
                        "fillColor": "#b36b00"
                    }
                }
            }]
        };  
        var style = instance.generateStyle(styleConfig);
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><ogc:Filter><ogc:PropertyIsBetween><ogc:PropertyName>foo</ogc:PropertyName><ogc:LowerBoundary><ogc:Literal>0</ogc:Literal></ogc:LowerBoundary><ogc:UpperBoundary><ogc:Literal>10</ogc:Literal></ogc:UpperBoundary></ogc:PropertyIsBetween></ogc:Filter><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>circle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#ff9900</sld:CssParameter><sld:CssParameter name="fill-opacity">1</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:Mark><sld:Opacity>1</sld:Opacity><sld:Size>10</sld:Size></sld:Graphic></sld:PointSymbolizer></sld:Rule><sld:Rule><ogc:Filter><ogc:PropertyIsBetween><ogc:PropertyName>foo</ogc:PropertyName><ogc:LowerBoundary><ogc:Literal>10</ogc:Literal></ogc:LowerBoundary><ogc:UpperBoundary><ogc:Literal>20</ogc:Literal></ogc:UpperBoundary></ogc:PropertyIsBetween></ogc:Filter><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>circle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#b36b00</sld:CssParameter><sld:CssParameter name="fill-opacity">1</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width"/><sld:CssParameter name="stroke-opacity"/><sld:CssParameter name="stroke-dasharray"/></sld:Stroke></sld:Mark><sld:Opacity>1</sld:Opacity><sld:Size>10</sld:Size></sld:Graphic></sld:PointSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
    });

    it('should convert rotation', function() {
        var styleConfig = {
            "typeName": "simple",
            "symbol": {
                "size": 10,
                "shape": "triangle",
                "graphic": null,
                "graphicType": null,
                "fillColor": "#ff0000",
                "fillOpacity": 80,
                "rotationAttribute": "rotation",
                "rotationUnits": "degrees"
            },
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "dotted",
                "strokeOpacity": 90
            },
            "geomType": "point"
        };
        var style = instance.generateStyle(styleConfig);
        expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>triangle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#ff0000</sld:CssParameter><sld:CssParameter name="fill-opacity">0.8</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width">3</sld:CssParameter><sld:CssParameter name="stroke-opacity">0.9</sld:CssParameter><sld:CssParameter name="stroke-dasharray">1 2</sld:CssParameter></sld:Stroke></sld:Mark><sld:Opacity>0.8</sld:Opacity><sld:Size>10</sld:Size><sld:Rotation><ogc:PropertyName>rotation</ogc:PropertyName></sld:Rotation></sld:Graphic></sld:PointSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');

         // now use radians
         styleConfig.symbol.rotationUnits = "radians";
         style = instance.generateStyle(styleConfig);
         expect(style).toBeXML('<sld:StyledLayerDescriptor xmlns:sld="http://www.opengis.net/sld" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0"><sld:NamedLayer><sld:UserStyle><sld:FeatureTypeStyle><sld:Rule><sld:PointSymbolizer><sld:Graphic><sld:Mark><sld:WellKnownName>triangle</sld:WellKnownName><sld:Fill><sld:CssParameter name="fill">#ff0000</sld:CssParameter><sld:CssParameter name="fill-opacity">0.8</sld:CssParameter></sld:Fill><sld:Stroke><sld:CssParameter name="stroke">#ffff00</sld:CssParameter><sld:CssParameter name="stroke-width">3</sld:CssParameter><sld:CssParameter name="stroke-opacity">0.9</sld:CssParameter><sld:CssParameter name="stroke-dasharray">1 2</sld:CssParameter></sld:Stroke></sld:Mark><sld:Opacity>0.8</sld:Opacity><sld:Size>10</sld:Size><sld:Rotation><ogc:Div><ogc:PropertyName>rotation</ogc:PropertyName><ogc:Div><ogc:Function name="pi"/><ogc:Literal>360</ogc:Literal></ogc:Div></ogc:Div></sld:Rotation></sld:Graphic></sld:PointSymbolizer></sld:Rule></sld:FeatureTypeStyle></sld:UserStyle></sld:NamedLayer></sld:StyledLayerDescriptor>');
    });

});

},{"../lib/edit/style/SLDStyleConverter.js":12}],68:[function(require,module,exports){
var StyleComplete = require('../lib/edit/style/StyleComplete.js').StyleComplete;
var instance = new StyleComplete();

describe('StyleComplete', function() {

    it('unique classification needs attribute, maxClasses and colorPalette', function() {
        var style = {
            "classify": {
                "method": "unique",
                "maxClasses": null,
                "attribute": null
            }
        };
        var result = instance.isComplete(style);
        expect(result).toBeFalsy();
        style.classify.attribute = 'foo';
        result = instance.isComplete(style);
        expect(result).toBeFalsy();
        style.classify.maxClasses = 10;
        expect(result).toBeFalsy();
        style.classify.colorPalette = true;
        result = instance.isComplete(style);
        expect(result).toBeTruthy();
    });

    it('other classifcation types need to have all info', function() {
        var style = {
            "classify": {
                "method": null,
                "attribute": null,
                "colorRamp": null
            },
            rules: []
        };
        var result = instance.isComplete(style);
        expect(result).toBeFalsy();
        style.classify.method = 'foo';
        result = instance.isComplete(style);
        expect(result).toBeFalsy();
        style.classify.attribute = 'bar';
        result = instance.isComplete(style);
        expect(result).toBeFalsy();
        style.classify.colorRamp = true;
        result = instance.isComplete(style);
        expect(result).toBeFalsy();
        style.rules.push({});
        result = instance.isComplete(style);
        expect(result).toBeTruthy();
    });

});


},{"../lib/edit/style/StyleComplete.js":13}],69:[function(require,module,exports){
var WFS_DFT = require('../lib/edit/style/WFSDescribeFeatureType.js').WFSDescribeFeatureType;
var instance = new WFS_DFT();

describe('WFSDescribeFeatureType', function() {
    it('should parse a WFS DescribeFeatureType response', function() {
        var xml = '<?xml version="1.0" encoding="UTF-8"?><xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:geonode="http://geonode.org/" xmlns:gml="http://www.opengis.net/gml" elementFormDefault="qualified" targetNamespace="http://geonode.org/">' +
'  <xsd:import namespace="http://www.opengis.net/gml" schemaLocation="http://mapstory.org:80/geoserver/schemas/gml/2.1.2/feature.xsd"/>' +
'  <xsd:complexType name="african_bees_2009Type">' +
'    <xsd:complexContent>' +
'      <xsd:extension base="gml:AbstractFeatureType">' +
'        <xsd:sequence>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="the_geom" nillable="true" type="gml:MultiPolygonPropertyType"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="AREA" nillable="true" type="xsd:double"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="PERIMETER" nillable="true" type="xsd:double"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="AFRBEEP020" nillable="true" type="xsd:long"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="STATE" nillable="true" type="xsd:string"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="COUNTY" nillable="true" type="xsd:string"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="FIPS" nillable="true" type="xsd:string"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="STATE_FIPS" nillable="true" type="xsd:string"/>' +
'          <xsd:element maxOccurs="1" minOccurs="0" name="FIRST_YR" nillable="true" type="xsd:dateTime"/>' +
'        </xsd:sequence>' +
'      </xsd:extension>' +
'    </xsd:complexContent>' +
'  </xsd:complexType>' +
'  <xsd:element name="african_bees_2009" substitutionGroup="gml:_Feature" type="geonode:african_bees_2009Type"/>' +
'</xsd:schema>';
        expect(JSON.stringify(instance.parseResult(xml))).toBe('{"timeAttribute":"FIRST_YR","featureNS":"http://geonode.org/","geomType":"polygon","attributes":[{"name":"the_geom","type":"MultiPolygonPropertyType","typeNS":"http://www.opengis.net/gml"},{"name":"AREA","type":"double","typeNS":"http://www.w3.org/2001/XMLSchema"},{"name":"PERIMETER","type":"double","typeNS":"http://www.w3.org/2001/XMLSchema"},{"name":"AFRBEEP020","type":"long","typeNS":"http://www.w3.org/2001/XMLSchema"},{"name":"STATE","type":"string","typeNS":"http://www.w3.org/2001/XMLSchema"},{"name":"COUNTY","type":"string","typeNS":"http://www.w3.org/2001/XMLSchema"},{"name":"FIPS","type":"string","typeNS":"http://www.w3.org/2001/XMLSchema"},{"name":"STATE_FIPS","type":"string","typeNS":"http://www.w3.org/2001/XMLSchema"},{"name":"FIRST_YR","type":"dateTime","typeNS":"http://www.w3.org/2001/XMLSchema"}]}');
    });
});

},{"../lib/edit/style/WFSDescribeFeatureType.js":14}],70:[function(require,module,exports){
var WPSClassify = require('../lib/edit/style/WPSClassify.js').WPSClassify;
var instance = new WPSClassify();

describe('WPSClassify', function() {

    beforeEach(function() {
        jasmine.addMatchers(customMatchers);
    });

    it('should create the correct WPS request', function() {
        var data = {
            typeName: 'cite:states',
            featureNS: 'http://www.opengeospatial.net/cite',
            featurePrefix: 'cite',
            attribute: 'POPULATION',
            numClasses: 10,
            method: 'EQUAL_INTERVAL'
        };
        var request = instance.classifyVector(data);
        expect(request).toBeXML('<wps:Execute xmlns:wps="http://www.opengis.net/wps/1.0.0" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ows="http://www.opengis.net/ows/1.1" xmlns:wfs="http://www.opengis.net/wfs" service="WPS" version="1.0.0"><ows:Identifier>vec:FeatureClassStats</ows:Identifier><wps:DataInputs><wps:Input><ows:Identifier>features</ows:Identifier><wps:Reference xlink:href="http://geoserver/wfs" method="POST" mimeType="text/xml"><wps:Body><wfs:GetFeature service="WFS" version="1.1.0" outputFormat="GML2"><wfs:Query xmlns:cite="http://www.opengeospatial.net/cite" typeName="cite:states"/></wfs:GetFeature></wps:Body></wps:Reference></wps:Input><wps:Input><ows:Identifier>attribute</ows:Identifier><wps:Data><wps:LiteralData>POPULATION</wps:LiteralData></wps:Data></wps:Input><wps:Input><ows:Identifier>classes</ows:Identifier><wps:Data><wps:LiteralData>10</wps:LiteralData></wps:Data></wps:Input><wps:Input><ows:Identifier>method</ows:Identifier><wps:Data><wps:LiteralData>EQUAL_INTERVAL</wps:LiteralData></wps:Data></wps:Input><wps:Input><ows:Identifier>stats</ows:Identifier><wps:Data><wps:LiteralData>mean</wps:LiteralData></wps:Data></wps:Input></wps:DataInputs><wps:ResponseForm><wps:RawDataOutput><ows:Identifier>results</ows:Identifier></wps:RawDataOutput></wps:ResponseForm></wps:Execute>');
    });

});

},{"../lib/edit/style/WPSClassify.js":15}],71:[function(require,module,exports){
var boxes = require('../lib/core/time/boxes.js');
var utils = require('../lib/core/time/utils.js');
var Box = boxes.Box;
var BoxModel = boxes.BoxModel;

describe("test boxes", function() {
    it("finds the right box by index", function() {
        function expectBoxOffset(data, idx) {
            return expect(boxes.findBox(data, idx)._offset);
        }
        ;
        var data = [{_offset: 0}];
        expectBoxOffset(data, 0).toBe(0);
        expectBoxOffset(data, 1).toBe(0);

        data = [{_offset: 0}, {_offset: 10}];
        expectBoxOffset(data, 0).toBe(0);
        expectBoxOffset(data, 5).toBe(0);
        expectBoxOffset(data, 10).toBe(10);
        expectBoxOffset(data, 11).toBe(10);
    });
    it("box steps works", function() {
        //expect(new Box({data: [1, 2, 3]}).getSteps()).toBe(3);
        expect(new Box({range: utils.createRange(10000, 20000), speed: {interval: 1000}}).getSteps()).toBe(11);
        expect(new Box({range: utils.createRange(10000, 11000), speed: {interval: 333}}).getSteps()).toBe(4);
    });
    it("box getIndex works", function() {
        var box = new Box({data: [1, 5, 10]});
        expect(box.getIndex(0)).toBe(0);
        expect(box.getIndex(1)).toBe(0);
        expect(box.getIndex(3)).toBe(0);
        expect(box.getIndex(10)).toBe(2);

        box = new Box({range: utils.createRange(10, 20), speed: {interval: 5}});
        expect(box.getIndex(5)).toBe(0);
        expect(box.getIndex(10)).toBe(0);
        expect(box.getIndex(12)).toBe(0);
        expect(box.getIndex(15)).toBe(1);
        expect(box.getIndex(18)).toBe(1);
        expect(box.getIndex(20)).toBe(2);
        expect(box.getIndex(25)).toBe(2);
    });
    it("box getDate works", function() {
        var box = new Box({data: [1, 5, 10]});
        box._offset = 0;
        expect(box.getDate(0)).toBe(1);
        box._offset = 10;
        expect(box.getDate(11)).toBe(5);

        box = new Box({range: utils.createRange(10, 20), speed: {interval: 5}});
        box._offset = 0;
        expect(box.getDate(0)).toBe(10);
        box._offset = 10;
        expect(box.getDate(11)).toBe(15);
    });
});

describe("test box model", function() {
    it("should work with a single box of list data", function() {
        var controller = new BoxModel([{data: [1, 2, 3]}]);
        var range = controller.getRange();
        expect(range.start).toBe(1);
        expect(range.end).toBe(3);
        //expect(controller.getSteps()).toBe(3);
        range = controller.getRangeAt(0, 1);
        expect(range.start).toBe(1);
        expect(range.end).toBe(2);
        expect(controller.getIndex(1)).toBe(0);
    });
    it("should work with two list boxes", function() {
        var controller = new BoxModel([{data: [1, 2, 3]}, {data: [4, 5, 6]}]);
        var range = controller.getRange();
        expect(range.start).toBe(1);
        expect(range.end).toBe(6);
        //expect(controller.getSteps()).toBe(6);
        range = controller.getRangeAt(2, 3);
        //expect(range.start).toBe(3);
        //expect(range.end).toBe(4);
        expect(controller.getIndex(0)).toBe(0);
        expect(controller.getIndex(3)).toBe(2);
        //expect(controller.getIndex(4)).toBe(3);
        //expect(controller.getIndex(7)).toBe(6);
    });
    it("should work with one range box", function() {
        var controller = new BoxModel([{range: utils.createRange(10, 20), speed: {interval: 5}}]);
        var range = controller.getRange();
        expect(range.start).toBe(10);
        expect(range.end).toBe(20);
        //expect(controller.getSteps()).toBe(3);
        range = controller.getRangeAt(0, 1);
        expect(range.start).toBe(10);
        expect(range.end).toBe(15);
        expect(controller.getIndex(1)).toBe(0);
        
    });
    it("should work with two range boxes", function() {
        var controller = new BoxModel([
            {range: utils.createRange(10, 20), speed: {interval: 5}},
            {range: utils.createRange(30, 50), speed: {interval: 10}}
        ]);
        var range = controller.getRange();
        expect(range.start).toBe(10);
        expect(range.end).toBe(50);
        expect(controller.getSteps()).toBe(6);
        range = controller.getRangeAt(2, 3);
        expect(range.start).toBe(20);
        expect(range.end).toBe(30);
        expect(controller.getIndex(40)).toBe(4);
    });
});

},{"../lib/core/time/boxes.js":4,"../lib/core/time/utils.js":11}],72:[function(require,module,exports){
var maps = require('../lib/core/time/maps.js');
require('../lib/ng/core/ogc/module.js');

describe("test maps", function() {
    it("readCapabilitiesTimeDimensions works", function() {
        function makeCaps(config) {
            return {
                value: {
                    capability: {
                        layer: {
                            layer: Object.getOwnPropertyNames(config).map(function(lyr) {
                                return {name: lyr, dimension: {}, extent: [{value: config[lyr]}]};
                            })
                        }
                    }
                }
            };
        }
        function expectData(args) {
            return expect(maps.readCapabilitiesTimeDimensions(makeCaps(args)));
        }
        function read(values) {
            return maps.readCapabilitiesTimeDimensions(makeCaps({data:values})).data;
        }
        function time(str) {
            return new Date(str).getTime();
        }
        var r = read('1990-01-01T00:00:00.000Z/2009-01-01T00:00:00.000Z/P1Y');
        expect(r.start).toBe(time('1990-01-01T00:00:00.000Z'));
        expect(r.end).toBe(time('2009-01-01T00:00:00.000Z'));
        expect(r.interval).toBe(31536000000);

        expectData({list: '1990'}).toEqual(
                {list: [time('1990')]}
        );
        expectData({list: '1990,1991,1992'}).toEqual(
                {list: [time('1990'),time('1991'),time('1992')]}
        );

        r = read('2000/2001');
        expect(r.start).toBe(time('2000'));
        expect(r.end).toBe(time('2001'));
    });
    it("readCapabilitiesTimeDimensions works for OpenLayers 2 config", function() {
        function makeCaps() {
            return {
                dimensions: {
                    'time': {
                        values: ["1989-01-01T00:00:00.000Z", "1990-01-01T00:00:00.000Z", "1991-01-01T00:00:00.000Z", "1992-01-01T00:00:00.000Z", "1993-01-01T00:00:00.000Z", "1994-01-01T00:00:00.000Z", "1995-01-01T00:00:00.000Z", "1996-01-01T00:00:00.000Z", "1997-01-01T00:00:00.000Z", "1998-01-01T00:00:00.000Z", "1999-01-01T00:00:00.000Z", "2000-01-01T00:00:00.000Z", "2001-01-01T00:00:00.000Z", "2002-01-01T00:00:00.000Z", "2003-01-01T00:00:00.000Z", "2004-01-01T00:00:00.000Z", "2005-01-01T00:00:00.000Z", "2006-01-01T00:00:00.000Z", "2007-01-01T00:00:00.000Z", "2008-01-01T00:00:00.000Z", "2009-01-01T00:00:00.000Z", "2010-01-01T00:00:00.000Z", "2011-01-01T00:00:00.000Z", "2012-01-01T00:00:00.000Z", "2013-01-01T00:00:00.000Z"]
                    }
                }
            };
        }
        var data = maps.readCapabilitiesTimeDimensions(makeCaps(), true);
        expect(data.length).toBe(25);
        expect(data[0]).toBe(599616000000);
        expect(data[24]).toBe(1356998400000);
    });
    describe('computeVectorRange works', function() {
        var storyLayer, features, range, StoryLayer;

        beforeEach(function() {
            // window.angular.mock.module is work around browserify conflict
            window.angular.mock.module('storytools.core.ogc');

            inject(function($injector) {
                StoryLayer = $injector.get('StoryLayer');
            });

            storyLayer = new StoryLayer({
                timeAttribute: "time",
                type: "VECTOR"
            });
            storyLayer.getLayer().setSource(new ol.source.Vector());

            features = [
                new ol.Feature({time: 1000})
            ];
            storyLayer.set('features', features);
        });

        it('using features as property', function() {
            range = maps.computeVectorRange(storyLayer);
            expect(range.start).toBe(1000);
            expect(range.end).toBe(1000);
        });
        it('using features from source', function() {
            storyLayer.set('features', null);
            storyLayer.getLayer().getSource().addFeatures(features);
            range = maps.computeVectorRange(storyLayer);
            expect(range.start).toBe(1000);
            expect(range.end).toBe(1000);
        });
        it('when empty endTimeAttribute', function() {
            storyLayer.set('endTimeAttribute', 'endTime');
            range = maps.computeVectorRange(storyLayer);
            expect(range.start).toBe(1000);
            expect(range.end).toBe(1000);
        });
        it('when unsorted mixed data', function() {
            storyLayer.set('endTimeAttribute', 'endTime');
            features.push(new ol.Feature({time: 500}));
            features.push(new ol.Feature({time: 100, endTime: 900}));
            range = maps.computeVectorRange(storyLayer);
            expect(range.start).toBe(100);
            expect(range.end).toBe(1000);
        });
        it('with single endAttribute', function() {
            storyLayer.set('endTimeAttribute', 'endTime');
            storyLayer.set('features', [new ol.Feature({endTime: 678})]);
            range = maps.computeVectorRange(storyLayer);
            expect(range.start).toBe(678);
            expect(range.end).toBe(678);
        });
        it('when text', function() {
            // works with text
            storyLayer.set('features', [new ol.Feature({time: '2001'})]);
            range = maps.computeVectorRange(storyLayer);
            expect(range.start).toBe(Date.parse('2001'));
            expect(range.end).toBe(Date.parse('2001'));
        });
    });
    describe('filterVectorLayer works', function() {
        var storyLayer, features, StoryLayer;

        function ids() {
            var layer = storyLayer.getLayer();
            var ids = layer.getSource().getFeatures().map(function(f) {
                return f.get('id');
            });
            ids.sort();
            return ids;
        }

        beforeEach(function() {
            // window.angular.mock.module is work around browserify conflict
            window.angular.mock.module('storytools.core.ogc');
                
            inject(function($injector) {
                StoryLayer = $injector.get('StoryLayer');
            });

            storyLayer = new StoryLayer({
              timeAttribute: "time",
              endTimeAttribute: "endTime",
              type: "VECTOR"
            });
            storyLayer.getLayer().setSource(new ol.source.Vector());
            var id = 1;
            features = [
                new ol.Feature({id:id++, time: 1000}),
                new ol.Feature({id:id++, time: 1000, endTime: 2000}),
                new ol.Feature({id:id++, time: 2000}),
                new ol.Feature({id:id++, time: 2000, endTime: 3000})
            ];
            storyLayer.set('features', features);
        });
        it('filters instants', function() {
            storyLayer.set('endTimeAttribute', null);
            // range before everything
            maps.filterVectorLayer(storyLayer, {start:500, end: 501});
            expect(ids()).toEqual([]);
            // range after everything
            maps.filterVectorLayer(storyLayer, {start:2500, end: 2600});
            expect(ids()).toEqual([]);
            // direct hit (ignores end exclusion)
            maps.filterVectorLayer(storyLayer, {start:2000, end: 2000});
            expect(ids()).toEqual([3,4]);
        });
        it('filters extents', function() {
            // range before everything
            maps.filterVectorLayer(storyLayer, {start:500, end: 501});
            expect(ids()).toEqual([]);
            // range before and after everything
            maps.filterVectorLayer(storyLayer, {start:500, end: 4000});
            expect(ids()).toEqual([1,2,3,4]);
            // excludes 3 due to intersection rules with end
            maps.filterVectorLayer(storyLayer, {start:1000, end:2000});
            expect(ids()).toEqual([1,2]);
            // 1 and 3 included as they are open ended and before
            maps.filterVectorLayer(storyLayer, {start:3000, end:4000});
            expect(ids()).toEqual([1,3,4]);
        });
    });

    describe('MapConfig', function() {

       beforeEach(function() {
              // window.angular.mock.module is work around browserify conflict
              window.angular.mock.module('storytools.core.ogc');
  
              inject(function($injector) {
                  StoryMap = $injector.get('StoryMap');
                  EditableStoryMap = $injector.get('EditableStoryMap');
                  stStoryMapBuilder = $injector.get('stStoryMapBuilder');
                  stStoryMapBaseBuilder = $injector.get('stStoryMapBaseBuilder');
                  stLayerBuilder = $injector.get('stLayerBuilder');
                  $timeout = $injector.get('$timeout');
              });
        });

        /*it('should transform to Interval object', function(done) {
            var data = JSON.parse('{"id":214,"map":{"center":[0,0],"projection":"EPSG:3857","zoom":3,"layers":[{"id":"foo","name":"foo","title":"My layer","geomType":"point","attributes": ["attr1", "attr2"],"timeAttribute":"attr1","resolutions":[0,10, 20],"bbox": [0,100,100,200],"latlonBBOX":[-10,-10,10,10],"times":{"start": 631152000000, "end": 1230768000000, "duration": "P1Y"},"singleTile":false,"type":"WMS","url":"http://myserver","params":{"LAYERS":"x"}}]}}');
            var storyMap = new StoryMap({target: 'foo'});
            storyMap.getStoryLayers().on('change:length', function() {
              expect(storyMap.getStoryLayers().item(0).get('times').interval).toBe(31536000000);
              done();
            });
            stStoryMapBuilder.modifyStoryMap(storyMap, data);
            $timeout.flush();
        });
        */

        it('should convert extent, zoom and projection', function() {
            var storyMap = new EditableStoryMap({target: 'foo'});
            storyMap.set('id', 215);
            storyMap.getMap().setView(new ol.View({center: [0,0], zoom: 3}));
            var config = storyMap.getState();
            var expected = '{"map":{"center":[0,0],"projection":"EPSG:3857","zoom":3,"layers":[]},"id":215}';
            expect(JSON.stringify(config)).toBe(expected);
        });

        it('should convert a tiled WMS layer', function(done) {
            var storyMap = new EditableStoryMap({target: 'foo'});
            storyMap.set('id', 216); 
            storyMap.getMap().setView(new ol.View({center: [0,0], zoom: 3}));
            stLayerBuilder.buildLayer({
              type: 'WMS',
              id: 'foo',
              name: 'x',
              title: 'My layer',
              geomType: 'point',
              timeAttribute: 'attr1',
              times: ['2001', '2002', '2003'],
              url: 'http://myserver',
              latlonBBOX: [-90,-180,90,180],
              bbox: [0,0,1,1],
              resolutions: [100,50,10],
              attributes: ['foo','bar']
            }, storyMap.getMap()).then(function(sl) {
              storyMap.addStoryLayer(sl);
              expect(sl.getLayer() instanceof ol.layer.Tile).toBe(true);
              expect(sl.getLayer().getSource() instanceof ol.source.TileWMS).toBe(true);
              var config = storyMap.getState();
              var expected = '{"map":{"center":[0,0],"projection":"EPSG:3857","zoom":3,"layers":[{"type":"WMS","id":"foo","name":"x","title":"My layer","geomType":"point","timeAttribute":"attr1","times":["2001","2002","2003"],"url":"http://myserver","latlonBBOX":[-90,-180,90,180],"bbox":[0,0,1,1],"resolutions":[100,50,10],"attributes":["foo","bar"]}]},"id":216}';
              expect(JSON.stringify(config)).toBe(expected);
              done();
            });
            $timeout.flush();
        });

        it('should convert an untiled WMS layer', function(done) {
            var storyMap = new EditableStoryMap({target: 'foo'});
            storyMap.set('id', 217);
            storyMap.getMap().setView(new ol.View({center: [0,0], zoom: 3}));
            stLayerBuilder.buildLayer({
                type: 'WMS',
                singleTile: true,
                title: 'My layer',
                id: 'foo',
                name: 'x',
                geomType: 'point',
                timeAttr: 'attr1',
                times: ['2001', '2002', '2003'],
                url: 'http://myserver',
                latlonBBOX: [-90,-180,90,180],
                bbox: [0,0,1,1],
                resolutions: [100,50,10],
                attributes: ['foo','bar']
            }, storyMap.getMap()).then(function(sl) {
                storyMap.addStoryLayer(sl);
                expect(sl.getLayer() instanceof ol.layer.Image).toBe(true);
                expect(sl.getLayer().getSource() instanceof ol.source.ImageWMS).toBe(true);
                var config = storyMap.getState();
                var expected = '{"map":{"center":[0,0],"projection":"EPSG:3857","zoom":3,"layers":[{"type":"WMS","singleTile":true,"title":"My layer","id":"foo","name":"x","geomType":"point","timeAttr":"attr1","times":["2001","2002","2003"],"url":"http://myserver","latlonBBOX":[-90,-180,90,180],"bbox":[0,0,1,1],"resolutions":[100,50,10],"attributes":["foo","bar"]}]},"id":217}';
                expect(JSON.stringify(config)).toBe(expected);
                done();
            });
            $timeout.flush();
        });

        it('should convert a vector layer', function(done) {
            var storyMap = new EditableStoryMap({target: 'foo'});
            storyMap.set('id', 227);
            storyMap.getMap().setView(new ol.View({center: [0,0], zoom: 3}));
            stLayerBuilder.buildLayer({
                type: 'VECTOR',
                id: 'foo',
                title: 'My layer',
                url: '/geoserver/wfs',
                geomType: 'point',
                timeAttr: 'attr1',
                typeName: 'foo',
                times: ['2001', '2002', '2003'],
                latlonBBOX: [-90,-180,90,180],
                bbox: [0,0,1,1],
                resolutions: [100,50,10],
                attributes: ['foo','bar']
            }, storyMap.getMap()).then(function(sl) {
                storyMap.addStoryLayer(sl);
                expect(sl.getLayer() instanceof ol.layer.Vector).toBe(true);
                var config = storyMap.getState();
                var expected = '{"map":{"center":[0,0],"projection":"EPSG:3857","zoom":3,"layers":[{"type":"VECTOR","id":"foo","title":"My layer","url":"/geoserver/wfs","geomType":"point","timeAttr":"attr1","typeName":"foo","times":["2001","2002","2003"],"latlonBBOX":[-90,-180,90,180],"bbox":[0,0,1,1],"resolutions":[100,50,10],"attributes":["foo","bar"]}]},"id":227}';
                expect(JSON.stringify(config)).toBe(expected);
                done();
            });
            $timeout.flush();
        });

        it('should convert an OSM layer', function() {
            var storyMap = new EditableStoryMap({target: 'foo'});
            storyMap.set('id', 218);
            storyMap.getMap().setView(new ol.View({center: [0,0], zoom: 3}));
            stStoryMapBaseBuilder.setBaseLayer(storyMap, {
                type: 'OSM'
            });
            var expected = '{"map":{"center":[0,0],"projection":"EPSG:3857","zoom":3,"layers":[{"type":"OSM","group":"background","visibility":true}]},"id":218}';
            expect(JSON.stringify(storyMap.getState())).toBe(expected);
        });

        it('should convert an MapQuest layer', function() {
            var storyMap = new EditableStoryMap({target: 'foo'});
            storyMap.set('id', 219);
            storyMap.getMap().setView(new ol.View({center: [0,0], zoom: 3}));
            stStoryMapBaseBuilder.setBaseLayer(storyMap, {
                type: 'MapQuest',
                layer: 'sat'
            });
            var expected = '{"map":{"center":[0,0],"projection":"EPSG:3857","zoom":3,"layers":[{"type":"MapQuest","layer":"sat","group":"background","visibility":true}]},"id":219}';
            expect(JSON.stringify(storyMap.getState())).toBe(expected);
        });

    });

});

},{"../lib/core/time/maps.js":7,"../lib/ng/core/ogc/module.js":17}],73:[function(require,module,exports){
require('../lib/ng/core/style/ol3StyleConverter.js');
require('../lib/ng/core/style/svgIcon.js');

describe('ol3StyleConverter', function() {

    beforeEach(function() {
        // window.angular.mock.module is work around browserify conflict
        window.angular.mock.module('storytools.core.style.ol3StyleConverter');
        window.angular.mock.module('storytools.core.style.svgIcon');

        inject(function(ol3StyleConverter) {
            this.ol3StyleConverter = ol3StyleConverter;
        });
    });

    it('should convert simple stypes', inject(function(ol3StyleConverter) {
        var styleConfig = {
            "symbol": {
                "size": 10,
                "shape": "circle",
                "graphic": null,
                "graphicType": null,
                "fillColor": "#ff0000",
                "fillOpacity": 80
            },
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "solid",
                "strokeOpacity": 90
            }
        };
        var style = ol3StyleConverter.generateStyle(styleConfig);
        expect(style.length).toBe(1);
        expect(style[0] instanceof ol.style.Style).toBeTruthy();
        var image = style[0].getImage();
        expect(image instanceof ol.style.Circle).toBeTruthy();
        expect(image.getRadius()).toBe(10/2);
        expect(image.getFill().getColor()).toBe('rgba(255,0,0,0.8)');
        expect(image.getStroke().getColor()).toBe('rgba(255,255,0,0.9)');
        expect(image.getStroke().getWidth()).toBe(3);
        var newStyle = ol3StyleConverter.generateStyle(styleConfig);
        expect(style === newStyle).toBeTruthy();
    }));

    it('should convert to square', inject(function(ol3StyleConverter) {
        var shapeConfig = ol3StyleConverter.generateShapeConfig({
            "symbol": {
                "size": 10,
                "shape": "square"
            }
        });
        expect(shapeConfig.points).toBe(4);
        expect(shapeConfig.radius).toBe(10/2);
        expect(shapeConfig.angle).toBe(Math.PI / 4);
    }));

    it('should convert to triangle', inject(function(ol3StyleConverter) {
        var shapeConfig = ol3StyleConverter.generateShapeConfig({
            "symbol": {
                "size": 10,
                "shape": "triangle"
            }
        });
        expect(shapeConfig.points).toBe(3);
        expect(shapeConfig.radius).toBe(10/2);
        expect(shapeConfig.angle).toBe(0);
    }));

    it('should convert to star', inject(function(ol3StyleConverter) {
        var shapeConfig = ol3StyleConverter.generateShapeConfig({
            "symbol": {
                "size": 10,
                "shape": "star"
            }
        });
        expect(shapeConfig.points).toBe(5);
        expect(shapeConfig.radius).toBe(10/2);
        expect(shapeConfig.radius2).toBe(10/4);
        expect(shapeConfig.angle).toBe(0);
    }));

    it('should convert to cross', inject(function(ol3StyleConverter) {
        var shapeConfig = ol3StyleConverter.generateShapeConfig({
            "symbol": {
                "size": 10,
                "shape": "cross"
            }
        });
        expect(shapeConfig.points).toBe(4);
        expect(shapeConfig.radius).toBe(10/2);
        expect(shapeConfig.radius2).toBe(0);
        expect(shapeConfig.angle).toBe(0);
    }));

    it('should convert to x', inject(function(ol3StyleConverter) {
        var shapeConfig = ol3StyleConverter.generateShapeConfig({
            "symbol": {
                "size": 10,
                "shape": "x"
            }
        });
        expect(shapeConfig.points).toBe(4);
        expect(shapeConfig.radius).toBe(10/2);
        expect(shapeConfig.radius2).toBe(0);
        expect(shapeConfig.angle).toBe(Math.PI / 4);
    }));

    it('should convert labels', inject(function(ol3StyleConverter) {
        var style = ol3StyleConverter.generateStyle({
            "symbol": {
                "size": 10,
                "shape": "circle",
                "graphic": null,
                "graphicType": null,
                "fillColor": "#ff0000",
                "fillOpacity": 80
            },
            "stroke": {
                "strokeColor": "#ffff00",
                "strokeWidth": 3,
                "strokeStyle": "solid",
                "strokeOpacity": 90
            },
            "label": {
                "attribute": "foo",
                "fontStyle": "italic",
                "fontWeight": "bold",
                "fontSize": 12,
                "fontFamily": "Serif",
                "fillColor": "#0000ff"
            }
        }, new ol.Feature({'foo': 'bar'}));
        expect(style.length).toBe(1);
        var text = style[0].getText();
        expect(text instanceof ol.style.Text).toBeTruthy();
        expect(text.getText()).toBe('bar');
        expect(text.getFont()).toBe('italic bold 12px Serif');
        expect(text.getFill().getColor()).toBe('#0000ff');
    }));

    it('should take rotation into account', inject(function(ol3StyleConverter) {
        var style = ol3StyleConverter.generateStyle({
            "symbol": {
                "size": 10,
                "shape": "triangle",
                "fillColor": "#ff0000",
                "rotationAttribute": 'rotation',
                "rotationUnits": 'radians'
            }
        }, new ol.Feature({'rotation': Math.PI/4}));
        expect(style[0].getImage().getRotation()).toBe(Math.PI/4);
        var newStyle = ol3StyleConverter.generateStyle({
            "symbol": {
                "size": 10,
                "shape": "triangle",
                "fillColor": "#ff0000",
                "rotationAttribute": 'rotation',
                "rotationUnits": 'radians'
            }
        }, new ol.Feature({'rotation': Math.PI/4}));
        // taken from style cache
        expect(newStyle === style).toBeTruthy();
        style = ol3StyleConverter.generateStyle({
            "symbol": {
                "size": 10,
                "shape": "triangle",
                "fillColor": "#ff0000",
                "rotationAttribute": 'rotation',
                "rotationUnits": 'degrees'
            }
        }, new ol.Feature({'rotation': 180}));
        expect(style[0].getImage().getRotation()).toBe(Math.PI/2);
    }));

    it('should convert unique classification', inject(function(ol3StyleConverter) {
        var styleConfig = {
            "stroke": {
                "strokeColor": "#ffff00"
            },
            "symbol": {
                "size": 10,
                "shape": "circle"
            },
            "geomType": "point",
            "classify": {
                "attribute": "foo"
            },
            "rules": [{
                "value": "bar",
                "style": {
                    "symbol": {
                        "fillColor": "#ff9900"
                    },
                    "stroke": {
                        "strokeColor": "#ff9900"
                    }
                }
            }, {
                "value": "baz",
                "style": {
                    "symbol": {
                        "fillColor": "#b36b00"
                    },
                    "stroke": {
                        "strokeColor": "#b36b00"
                    }
                }
            }]    
        };
        var style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'bar'}));
        expect(style[0].getImage().getFill().getColor()).toBe('#ff9900');
        expect(style[0].getImage().getStroke().getColor()).toBe('rgba(255,255,0,1)');
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'baz'}));
        expect(style[0].getImage().getFill().getColor()).toBe('#b36b00'); 

        styleConfig.geomType = "line";
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'bar'}));
        expect(style[0].getStroke().getColor()).toBe('#ff9900');
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'baz'}));
        expect(style[0].getStroke().getColor()).toBe('#b36b00');

        styleConfig.geomType = "polygon";
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'bar'}));
        expect(style[0].getFill().getColor()).toBe('#ff9900');
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'baz'}));
        expect(style[0].getFill().getColor()).toBe('#b36b00');
    }));

    it('should convert ranges of a classification', inject(function(ol3StyleConverter) {
        var styleConfig = {
            "stroke": {
                "strokeColor": "#ffff00"
            },
            "symbol": {
                "size": 10,
                "shape": "circle"
            },
            "geomType": "point",
            "classify": {
                "attribute": "foo"
            },
            "rules": [{
                "range": {
                    "min": 0,
                    "max": 10
                },
                "style": {
                    "symbol": {
                        "fillColor": "#ff9900"
                    },
                    "stroke": {
                        "strokeColor": "#ff9900"
                    }
                }
            }, {
                "range": {
                    "min": 10,
                    "max": 20
                },
                "style": {
                    "symbol": {
                        "fillColor": "#b36b00"
                    },
                    "stroke": {
                        "strokeColor": "#b36b00"
                    }
                }
            }]
        };
        // this tests for being inclusive on the lower boundary
        var style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 0}));
        expect(style[0].getImage().getFill().getColor()).toBe('#ff9900');
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 15}));
        expect(style[0].getImage().getFill().getColor()).toBe('#b36b00');

        styleConfig.geomType = "line";
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 5}));
        expect(style[0].getStroke().getColor()).toBe('#ff9900');
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 15}));
        expect(style[0].getStroke().getColor()).toBe('#b36b00');

        styleConfig.geomType = "polygon";
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 5}));
        expect(style[0].getFill().getColor()).toBe('#ff9900');
        // this tests for being inclusive on the upper bondary
        style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 20}));
        expect(style[0].getFill().getColor()).toBe('#b36b00');

    }));

    it('should convert unique classification with label', inject(function(ol3StyleConverter) {
        var styleConfig = {
            "stroke": {
                "strokeColor": "#ffff00"
            },
            "symbol": {
                "size": 10,
                "shape": "circle"
            },
            "geomType": "point",
            "classify": {
                "attribute": "foo"
            },
            "label": {
                "attribute": "foo",
                "fontWeight": "bold",
                "fontSize": 12,
                "fontFamily": "Serif",
                "fillColor": "#0000ff"
            },
            "rules": [{
                "value": "bar",
                "style": {
                    "symbol": {
                        "fillColor": "#ff9900"
                    }
                }
            }, {
                "value": "baz",
                "style": {
                    "symbol": {
                        "fillColor": "#b36b00"
                    }
                }
            }]
        };
        var style = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'baz'}));
        expect(style[0].getText().getText()).toBe('baz');
        var newStyle = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'baz'}));
        // taken from style cache
        expect(newStyle === style).toBeTruthy();
        newStyle = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'bar'}));
        // not taken from style cache
        expect(newStyle === style).toBeFalsy();
        styleConfig.stroke.strokeColor = "#ff0000";
        newStyle = ol3StyleConverter.generateStyle(styleConfig, new ol.Feature({'foo': 'baz'}));
        // not taken from style cache since strokeColor changed
        expect(newStyle === style).toBeFalsy();
    }));

});

},{"../lib/ng/core/style/ol3StyleConverter.js":19,"../lib/ng/core/style/svgIcon.js":20}],74:[function(require,module,exports){
pins = require('../lib/core/time/pins.js');

describe('test storyPins', function() {
    
    describe('StoryPin class', function() {
        it('constructor', function() {
            var sp = new pins.StoryPin({
                title: 'test',
                the_geom: '{"type":"Point","coordinates":[123,321]}',
                id: 22
            });
            expect(sp.get('title')).toBe('test');
            expect(sp.title).toBe('test');
            expect(sp.getId()).toBe(22);
            expect(sp.id).toBe(22);
            var coords = sp.getGeometry().getCoordinates();
            expect(coords[0]).toBe(123);
            expect(coords[1]).toBe(321);
        });
        it('update', function() {
            var sp = new pins.StoryPin({
                title: 'test',
                the_geom: '{"type":"Point","coordinates":[123,321]}'
            });
            expect(sp.content).toBe(null);
            expect(sp.title).toBe('test');
            sp.setProperties({
                title: null,
                content: 'content'
            });
            expect(sp.content).toBe('content');
            expect(sp.title).toBe(null);
            var coords = sp.getGeometry().getCoordinates();
            expect(coords[0]).toBe(123);
            expect(coords[1]).toBe(321);
        });
        it('empty', function() {
            var sp = new pins.StoryPin();
            expect(sp.content).toBe(null);
            expect(sp.title).toBe(null);
        });
    });

    geojson = {
        features: [
            {
                id: 24,
                geometry: { type:'Point', coordinates:[-90,45] },
                properties: {
                    title: 'test',
                    start_time: 1000000
                }
            }
        ]
    };
    describe('loadFromGeoJSON', function() {
        it('works', function() {
            var loaded = pins.loadFromGeoJSON(geojson);
            expect(loaded.length).toBe(1);
            var sp = loaded[0];
            expect(sp.id).toBe(24);
            expect(sp.getGeometry().getCoordinates()[0]).toBe(-90);
            expect(sp.getGeometry().getCoordinates()[1]).toBe(45);
            expect(sp.start_time).toBe(1000000000);
            expect(sp.end_time).toBe(null);
        });
        it('works with projection', function() {
            var loaded = pins.loadFromGeoJSON(geojson, ol.proj.get('EPSG:3857'));
            var sp = loaded[0];
            expect(sp.getGeometry().getCoordinates()[0]).toBe(-10018754.171394622);
            expect(sp.getGeometry().getCoordinates()[1]).toBe(5621521.486192066);
        });
    });
    describe('toGeoJSON', function() {
        it('works', function() {
            // to do this correctly, we need to understand the current projection
            // this test just verifies the ol3 format works properly
            var format = new ol.format.GeoJSON({
                defaultDataProjection: 'EPSG:4326'
            });
            var sp = new pins.StoryPin({
                title: 'test',
                the_geom: '{"type":"Point","coordinates":[123,321]}',
                id: 22
            });
            var sp = format.readFeature(format.writeFeature(sp));
            expect(sp.get('title')).toBe('test');
            expect(sp.getId()).toBe(22);
            var coords = sp.getGeometry().getCoordinates();
            expect(coords[0]).toBe(123);
            expect(coords[1]).toBe(321);
        });
    });
});

},{"../lib/core/time/pins.js":9}],75:[function(require,module,exports){
storytools = {
    core: require('../lib/core/index.js')
};
require('../lib/ng/core/pins/module.js');

describe('test storyPins', function() {
    var StoryPin;
    beforeEach(function() {
        // window.angular.mock.module is work around browserify conflict
        window.angular.mock.module('storytools.core.pins');

        inject(function($injector) {
            StoryPin = $injector.get('StoryPin');
        });
    });

    describe('StoryPinLayerManager', function() {

    });

});
},{"../lib/core/index.js":3,"../lib/ng/core/pins/module.js":18}],76:[function(require,module,exports){
require('../lib/ng/edit/style/services/styleChoices.js');

describe('test styleChoices', function() {

    beforeEach(function() {
        window.angular.mock.module('storytools.edit.style.styleChoices');
    });

    describe('stRecentChoices works', function() {
        beforeEach(function() {

            inject(function($injector) {
                stRecentChoices = $injector.get('stRecentChoices');
            });
        });
        it('should store recent icons', function() {
            var icons = stRecentChoices.icons;
            icons.clear();
            icons.add('a');
            expect(icons.recent).toEqual(['a']);
            icons.add('b');
            expect(icons.recent).toEqual(['a', 'b']);
            icons.add('b');
            expect(icons.recent).toEqual(['a', 'b']);
            var others = 'cdefghijklmonpqrstuvxyz';
            for (var i=0; i<others.length;i++) {
                icons.add(others[i]);
            }
            expect(icons.recent.length).toBe(icons._max);
            // this assertion is based on the assumption of _max=24...
            expect(icons.recent[0]).toBe('b');
        });
    });
});
},{"../lib/ng/edit/style/services/styleChoices.js":24}],77:[function(require,module,exports){
require('../lib/ng/edit/style/directives/directives.js');
require('../lib/ng/edit/style/services/iconCommons.js');
require('../lib/ng/edit/style/services/styleChoices.js');
require('../lib/ng/core/style/ol3StyleConverter.js');
require('../lib/ng/core/style/svgIcon.js');
helpers = require('./helpers.js');
$ = require('../bower_components/jquery/dist/jquery.js');

describe('test style directives', function() {

    beforeEach(function() {
        // @todo mock dependency for now - used by graphicEditor
        window.angular.mock.module(function($provide) {
            $provide.value('$modal', {open: new Function()});
        });

        // window.angular.mock.module is work around browserify conflict
        window.angular.mock.module('storytools.edit.style.directives');
        window.angular.mock.module('storytools.allTemplates');
        window.angular.mock.module('storytools.edit.style.styleChoices');
        window.angular.mock.module('storytools.edit.style.iconCommons');
        window.angular.mock.module('storytools.core.style.ol3StyleConverter');
        window.angular.mock.module('storytools.core.style.svgIcon');

        inject(helpers.inject);
    });

    describe('attribute-combo', function() {
        it('should filter attributes', function() {
            var attributes = [
                {name: 's', type: 'string'},
                {name: 'i', type: 'integer'},
                {name: 'd', type: 'double'},
                {name: 't', type: 'dateTime'},
                {name: 'g', type: 'geom', typeNS:'http://www.opengis.net/gml'}
            ];
            var scope = {
                layer: {
                    get: function() {
                        return attributes;
                    }
                }
            };
            function attributeText(el) {
                // extract attribute text from elements disregarding the first
                return angular.element(el.find('li').splice(1)).text();
            }
            // expecting all attributes
            var el = helpers.compile("<attribute-combo layer=layer></attribute-combo>", scope);
            expect(attributeText(el)).toBe('dgist');
            // exclude geom
            el = helpers.compile("<attribute-combo filter=nogeom layer=layer></attribute-combo>", scope);
            expect(attributeText(el)).toBe('dist');
            // include string and integer
            el = helpers.compile("<attribute-combo include='string,integer' layer=layer></attribute-combo>", scope);
            expect(attributeText(el)).toBe('is');
        });
    });

    describe('number editor', function() {
        it('should bind and edit', function() {
            var el = helpers.compile("<number-editor st-model='thing' property='value'></number-editor>", {thing: {value: 42}});
            expect(el.find('button').text().trim()).toBe('42');
            helpers.setInputValue(el.find('input'), '13');
            expect(helpers.getScope(el).thing.value).toBe(13);
        });
    });

    describe('color editor', function() {
        it('should bind and edit', function() {
            var el = helpers.compile("<color-editor st-model='thing' property='value'></color-editor>", {thing: {value: '#faa'}});
            expect(el.find('i').css('backgroundColor')).toBe('rgb(255, 170, 170)');
            helpers.setInputValue(el.find('input'), '#aaa');
            expect(helpers.getScope(el).thing.value).toBe('#aaa');
            expect(el.find('i').css('backgroundColor')).toBe('rgb(170, 170, 170)');
        });
    });

    describe('graphic-editor', function() {
        beforeEach(inject(function($injector) {
            stRecentChoices = $injector.get('stRecentChoices');
            // clear these as they may trigger http requests
            stRecentChoices.icons.clear();
        }));
        it('should bind and edit marks', function() {
            var el = helpers.compile("<graphic-editor symbol='thing'></graphic-editor>", {thing: {shape: 'circle'}});
            // @todo not a great test - instead of using a canvas, this could be an image w/ data URI
            expect(el.find('span canvas').attr('mark')).toBe('circle');
            angular.forEach(el.find('canvas'), function(e) {
                e = angular.element(e);
                if (e.attr('mark') == 'square') {
                    e.triggerHandler('click');
                }
            });
            expect(el.find('span canvas').attr('mark')).toBe('square');
        });
        describe('works with icon commons', function() {
            // extra gnarl - rendering of the recent-icons requires some
            // mock http to talk to the iconCommons and wait until the
            // directive updates itself - see whenReady
            beforeEach(inject(function($injector) {
                $httpBackend = $injector.get('$httpBackend');
                stRecentChoices = $injector.get('stRecentChoices');
                $q = $injector.get('$q');
                $timeout = $injector.get('$timeout');

                stRecentChoices.icons.add('/item1.svg');
                stRecentChoices.icons.add('/item2.svg');
                // mock requests for the icons
                $httpBackend.when('GET', '/item1.svg').respond('<svg></svg>', {'Content-Type': 'text/xml'});
                $httpBackend.when('GET', '/item2.svg').respond('<svg></svg>', {'Content-Type': 'text/xml'});
            }));
            // return a promise that will resolve once the http requests have
            // completed and the recent icons have been set in the scope
            function whenReady(el, $httpBackend) {
                // grab the directive scope and watch for svg icons to resolve before running tests
                var scope = helpers.getScope(el.children());
                var loaded = $q.defer();
                scope.$watch('recent', function() {
                    loaded.resolve(true);
                });
                // flush pending requests
                $httpBackend.flush();
                return loaded.promise;
            }
            // IMPORTANT : for all tests here, if `done` is not called, jasmine will timeout -
            // this will cover the failure case. see: http://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support
            // IMPORTANT: $timeout.flush() is required to trigger promise resolution
            it('should bind to recent choices', function(done) {
                var el = helpers.compile("<graphic-editor symbol='thing'></graphic-editor>", {thing: {}});
                whenReady(el, $httpBackend).then(function() {
                    var img = el.find('.recent-icons img');
                    expect(img.length).toBe(2);
                    done();
                });
                $timeout.flush();
            });
            it('should update with change in recent choices', function(done) {
                var el = helpers.compile("<graphic-editor symbol='thing'></graphic-editor>", {thing: {}});

                whenReady(el, $httpBackend).then(function() {
                    var img = el.find('.recent-icons img');
                    expect(img.length).toBe(2);
                    expect(img.attr('src').indexOf('data:image/svg+xml;base64,')).toBe(0);

                    // because we're already in the digest, call this with a timeout
                    $timeout(function() {
                        // queue up expected request
                        $httpBackend.when('GET', '/item3.svg').respond('<svg></svg>', {'Content-Type': 'text/xml'});
                        // and add this recent choice (normally would be from user selecting from icon-commons dialog
                        stRecentChoices.icons.add('/item3.svg');
                        // this triggers an update as if user used the dialog
                        helpers.getScope(el.children())._updateRecent();
                        // there should be 3 icons now
                        whenReady(el, $httpBackend).then(function() {
                            var img = el.find('.recent-icons img');
                            expect(img.length).toBe(3);
                            done();
                        });
                    });
                });
                $timeout.flush();
            });
            it('should bind and edit svg', function(done) {
                var el = helpers.compile("<graphic-editor symbol='thing'></graphic-editor>", {thing: {graphic: '/item1.svg'}});
                whenReady(el, $httpBackend).then(function() {
                    var img = el.find('.recent-icons img');
                    expect(img.length).toBe(2);
                    expect(img.attr('src').indexOf('data:image/svg+xml;base64,')).toBe(0);
                    done();
                });
                $timeout.flush();
            });

        });
    });

    describe('label-editor', function() {
        it('should bind and edit attribute', function() {
            var label = {
                "attribute": null,
                "fillColor": "#000000",
                "fontFamily": "Serif",
                "fontSize": 10,
                "fontStyle": "normal",
                "fontWeight": "normal"
            };
            var attributes = [
                {name: 'a', type: 'string'},
                {name: 'b', type: 'integer'}
            ];
            var el = helpers.compile("<label-editor layer=layer st-model='thing'></graphic-editor>", {
                thing: {label: label},
                layer: {
                    get: function() {
                        // mock attributes
                        return attributes;
                    }
                }
            });
            expect(el.find('.dropdown-toggle').eq(0).text().trim()).toBe('Select Attribute');
            helpers.click(el.find('.dropdown-menu').eq(0).find('li').eq(1));
            expect(label.attribute).toBe('a');
        });
    });

    describe('classify-editor', function() {
        var classify, el;
        beforeEach(function() {
            classify = {
                method: null,
                attribute: null,
                maxClasses: 5,
                range: {
                    min: 0,
                    max: 16
                }
            };
            var attributes = [
                {name: 'a', type: 'string'},
                {name: 'b', type: 'integer'}
            ];
            el = helpers.compile("<classify-editor show-max-classes=true show-fixed-classes></classify-editor>", {
                layer: {
                    get: function() {
                        return attributes;
                    }
                },
                activeStyle: {classify: classify},
                changeClassifyProperty: function(prop, val) {
                    classify[prop] = val;
                },
                showMaxClasses: true,
                showFixedClasses: true
            });
        });
        it('should bind and edit attribute', function() {
            helpers.click(el.find('ul.dropdown-menu li').get(1));
            expect(classify.attribute).toBe('a');
        });
        it('should bind and edit maxClasses', function() {
            helpers.setInputValue(el.find('[ng-if=showMaxClasses] input').eq(0), '7');
            expect(classify.maxClasses).toBe(7);
        });
    });

    describe('stroke-editor', function() {
        it('has a smoke test', function() {
            var el = helpers.compile("<stroke-editor st-model='thing'></stroke-editor>", {thing: {stroke: {}}});
            expect(el.children().length).toBe(1);
        });
    });

    describe('rules-editor', function() {
        it('has a smoke test', function() {
            var el = helpers.compile("<rules-editor></rules-editor>", {});
            expect(el.children().length).toBe(1);
        });
    });

    describe('symbol-editor', function() {
        it('has a smoke test', function() {
            var el = helpers.compile("<symbol-editor st-model='thing'></symbol-editor>", {thing: {symbol: {}}});
            expect(el.children().length).toBe(1);
        });
    });
});

},{"../bower_components/jquery/dist/jquery.js":2,"../lib/ng/core/style/ol3StyleConverter.js":19,"../lib/ng/core/style/svgIcon.js":20,"../lib/ng/edit/style/directives/directives.js":22,"../lib/ng/edit/style/services/iconCommons.js":23,"../lib/ng/edit/style/services/styleChoices.js":24,"./helpers.js":65}],78:[function(require,module,exports){
require('../lib/ng/edit/style/services/styleRuleBuilder.js');
require('../lib/ng/edit/style/services/styleChoices.js');
require('../lib/ng/edit/style/services/styleTypes.js');

describe('styleRuleBuilder', function() {

    beforeEach(function() {
        // window.angular.mock.module is work around browserify conflict
        window.angular.mock.module('storytools.edit.style.styleRuleBuilder');
        window.angular.mock.module('storytools.edit.style.styleChoices');
        window.angular.mock.module('storytools.edit.style.styleTypes');

        inject(function(stStyleRuleBuilder) {
            this.stStyleRuleBuilder = stStyleRuleBuilder;
        });
    });

    it('should pick values from a 2-stop color ramp', inject(function(stStyleRuleBuilder) {
        vals = stStyleRuleBuilder._colorRampValues({0:'#ff0000',1:'#0000ff'},2);
        expect(vals.length).toBe(2);
        expect(vals).toEqual(['#ff0000','#0000ff']);
    }));

    it('should pick values from a 3-stop color ramp', inject(function(stStyleRuleBuilder) {
        vals = stStyleRuleBuilder._colorRampValues({0:'#ff0000',1:'#0000ff'},3);
        expect(vals.length).toBe(3);
        expect(vals).toEqual(['#ff0000', '#7f007f', '#0000ff']);
    }));
});
},{"../lib/ng/edit/style/services/styleChoices.js":24,"../lib/ng/edit/style/services/styleRuleBuilder.js":25,"../lib/ng/edit/style/services/styleTypes.js":26}],79:[function(require,module,exports){
require('../lib/ng/edit/time/directives.js');
helpers = require('./helpers.js');

describe('test time directives', function() {

    beforeEach(function() {
        // window.angular.mock.module is work around browserify conflict
        window.angular.mock.module('storytools.edit.time.directives');
        window.angular.mock.module('storytools.allTemplates');

        inject(helpers.inject);
    });

    describe('st-date-time-field directive', function() {
        it('should handle epoch properly', function() {
            var el = helpers.compile('<st-date-time-field date-time="value"></st-date-time-field>', {
                value: 0
            });
            input = el.find('input');
            expect(input.val()).toBe('1970-01-01T00:00:00.000Z');
        });
    });
});
},{"../lib/ng/edit/time/directives.js":27,"./helpers.js":65}],80:[function(require,module,exports){
storytools = {
    core: require('../lib/core/index.js')
};
require('../lib/ng/core/time/services.js');

describe('test time services', function() {

    beforeEach(function() {
        window.angular.mock.module('storytools.core.time.services');
    });

    describe('TimeMachine works', function() {
        function timeLayers() {
            var layers = [];
            Array.prototype.slice.call(arguments).forEach(function(data) {
                layers.push({
                    get: function() {
                        return data;
                    }
                });
            });
            return layers;
        }
        beforeEach(function() {

            inject(function($injector) {
                TimeMachine = $injector.get('TimeMachine');
            });
        });
        it('should compute ticks', function() {
            layers = timeLayers(
                [1, 10, 1000],
                [10000, 10, 10]
            );
            expect(TimeMachine.computeTicks(layers)).toEqual([ 1, 10, 1000, 10000 ]);

            layers = timeLayers(
                [10000, 40000],
                [20000, 30000],
                new storytools.core.time.utils.Interval({start: 5000, end: 50000, duration:'P5S'})
            );
            var results = [];
            for (var i = 5000; i <= 50000; i+= 5000 ) {
                results.push(i);
            }
            expect(TimeMachine.computeTicks(layers)).toEqual(results);
        });
    });
});

},{"../lib/core/index.js":3,"../lib/ng/core/time/services.js":21}],81:[function(require,module,exports){
var utils = require('../lib/core/time/utils.js');
var moment = require('vis/node_modules/moment');

/*
NOTE - numeric values in these tests (and the API) are all milliseconds
       despite looking like years - party like it's "1970-01-01T00:00:01.999Z"!
*/
describe("test utils", function() {
    it("tests finding", function() {
        var data = [1,5,10];
        expect(utils.find(data, 0)).toBe(0);
        expect(utils.find(data, 1)).toBe(0);
        expect(utils.find(data, 2)).toBe(0);
        expect(utils.find(data, 5)).toBe(1);
        expect(utils.find(data, 6)).toBe(1);
        expect(utils.find(data, 10)).toBe(2);
        expect(utils.find(data, 11)).toBe(2);
    });
    describe("range", function() {
        it("createRange works", function() {
            var r;
            // text
            r = utils.createRange('2000', '2001');
            expect(r.start).toBe(Date.parse('2000'));
            expect(r.end).toBe(Date.parse('2001'));
            // numbers (millis)
            r = utils.createRange(2000, 2003);
            expect(r.start).toBe(2000);
            expect(r.end).toBe(2003);
            // copy
            r = utils.createRange(r);
            expect(r.start).toBe(2000);
            expect(r.end).toBe(2003);
            // single arg
            r = utils.createRange(1999);
            expect(r.start).toBe(1999);
            expect(r.end).toBe(1999);
            // null 1st arg (open range)
            r = utils.createRange(1999, null);
            expect(r.start).toBe(1999);
            expect(r.end).toBe(null);
            // null 2nd arg (open range)
            r = utils.createRange(null, 6789);
            expect(r.start).toBe(null);
            expect(r.end).toBe(6789);
        });
        it("basics work", function() {
            var r = utils.createRange(2000, 2003);
            expect(r.center()).toBe(2001);
            expect(r.width()).toBe(3);
        });
        it("extend works", function() {
            var r = utils.createRange(2000, 2003);
            // idempotent
            r.extend(r);
            expect(r.start).toBe(2000);
            expect(r.end).toBe(2003);
            // single left
            r.extend(1995);
            expect(r.start).toBe(1995);
            expect(r.end).toBe(2003);
            // single right
            r.extend(2004);
            expect(r.start).toBe(1995);
            expect(r.end).toBe(2004);
            // both sides
            r.extend(utils.createRange(1900, 2010));
            expect(r.start).toBe(1900);
            expect(r.end).toBe(2010);
            // start with nothing, extend w/ nothing
            r = utils.createRange(null, null);
            r.extend(r = utils.createRange(null, null));
            expect(r.isEmpty()).toBe(true);
            // starting with nothing, extend open-ended start
            r = utils.createRange(null, null);
            r.extend(utils.createRange(1234, null));
            expect(r.start).toBe(1234);
            expect(r.end).toBe(1234);
            // starting with nothing, extend open-ended end
            r = utils.createRange(null, null);
            r.extend(utils.createRange(null, 5678));
            expect(r.start).toBe(5678);
            expect(r.end).toBe(5678);
        });
        it("intersects works with instants", function() {
            var r = utils.createRange(2000, 2003);
            expect(r.intersects(1999)).toBe(false);
            expect(r.intersects(2000)).toBe(true);
            expect(r.intersects(2001)).toBe(true);
            expect(r.intersects(2003)).toBe(false);
            // instant range, too
            r = utils.createRange(2000, 2000);
            expect(r.intersects(2000)).toBe(true);
        });
        it("intersects works on open range with instants", function() {
            var r = utils.createRange(null, 2003);
            expect(r.intersects(1999)).toBe(true);
            expect(r.intersects(2004)).toBe(false);
            r = utils.createRange(2003, null);
            expect(r.intersects(1999)).toBe(false);
            expect(r.intersects(2004)).toBe(true);
        });
        it("intersects works on instant range with open ranges", function() {
            var r = utils.createRange(2003, 2003);
            expect(r.intersects(utils.createRange(1999, null))).toBe(true);
            expect(r.intersects(utils.createRange(null, 2004))).toBe(true);
            expect(r.intersects(utils.createRange(2004, null))).toBe(false);
            expect(r.intersects(utils.createRange(null, 2002))).toBe(false);
        });
        it("intersects works with extents", function() {
            var r = utils.createRange(2000, 2003);
            expect(r.intersects(utils.createRange(1999, 2000))).toBe(true);
            expect(r.intersects(utils.createRange(2000, 2001))).toBe(true);
            expect(r.intersects(utils.createRange(2002, 2003))).toBe(true);
            expect(r.intersects(utils.createRange(1999, 2003))).toBe(true);
            expect(r.intersects(utils.createRange(1999, 2004))).toBe(true);
            expect(r.intersects(utils.createRange(2004, 2005))).toBe(false);
            expect(r.intersects(utils.createRange(1998, 1999))).toBe(false);
        });
        it("isRangeLike works", function() {
            expect(utils.isRangeLike(null)).toBe(false);
            expect(utils.isRangeLike(undefined)).toBe(false);
            expect(utils.isRangeLike('x')).toBe(false);
            expect(utils.isRangeLike(22)).toBe(false);
            expect(utils.isRangeLike({start:1})).toBe(true);
            expect(utils.isRangeLike({end:1})).toBe(true);
            expect(utils.isRangeLike({start:1, end:1})).toBe(true);
        });
    });
    it("tests interval picking", function() {
        expect(utils.pickInterval(utils.createRange('2000','2001'))).toBe(
            moment.duration(1, 'months').asMilliseconds()
        );
        expect(utils.pickInterval(utils.createRange('2000-01-01','2000-02-01'))).toBe(
            moment.duration(1, 'weeks').asMilliseconds()
        );
    });
    it("tests compute range works", function() {
        var r = utils.computeRange([utils.createRange(100,200)]);
        expect(r.start).toBe(100);
        expect(r.end).toBe(200);
        r = utils.computeRange([utils.createRange(100,400), utils.createRange(100,300)]);
        expect(r.start).toBe(100);
        expect(r.end).toBe(400);
        r = utils.computeRange([20,10,50]);
        expect(r.start).toBe(10);
        expect(r.end).toBe(50);
    });
    it("tests createOffsetter works", function() {
        function offsetAsISO(timestamp, duration) {
            return new Date(utils.createOffsetter(duration)(timestamp)).toISOString();
        }
        expect(offsetAsISO('1970', 'P1Y')).toBe('1971-01-01T00:00:00.000Z');
        expect(offsetAsISO('1970-06-01', 'P1Y1M')).toBe('1971-07-01T00:00:00.000Z');
        expect(offsetAsISO('1974-02-28T12:24', 'P2Y2M')).toBe('1976-04-28T12:24:00.000Z');
        expect(offsetAsISO('1974-02-28T12:24', 'P2Y2M')).toBe('1976-04-28T12:24:00.000Z');
        // verify current algorithm fails - jan 31st + 1month wraps into march
        expect(offsetAsISO('1974-01-31T12:24', 'P2Y1M')).toBe('1976-03-02T12:24:00.000Z');
    });
        it("parseISODuration should throw sometimes", function() {
        expect(function() {
            utils.parseISODuration('TP1M');
        }).toThrowError('expected P as starting duration : TP1M');
        expect(function() {
            utils.parseISODuration('P1X');
        }).toThrowError('unknown duration specifier : X');
    });
    it("parseISODuration should parse correctly", function() {
        expect(utils.parseISODuration('PT1S')).toBe(1000);
        expect(utils.parseISODuration('PT1M')).toBe(60000);
        expect(utils.parseISODuration('PT1H')).toBe(3600000);
        expect(utils.parseISODuration('P1D')).toBe(86400000);
        expect(utils.parseISODuration('P1W')).toBe(604800000);
        expect(utils.parseISODuration('P1M')).toBe(2592000000);
        expect(utils.parseISODuration('P1Y')).toBe(31536000000);
        expect(utils.parseISODuration('P1MT1M')).toBe(2592000000 + 60000);
    });
});

},{"../lib/core/time/utils.js":11,"vis/node_modules/moment":63}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJ0ZXN0L3Rlc3RzLmpzIiwiYm93ZXJfY29tcG9uZW50cy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJsaWIvY29yZS9pbmRleC5qcyIsImxpYi9jb3JlL3RpbWUvYm94ZXMuanMiLCJsaWIvY29yZS90aW1lL2NvbnRyb2xzLmpzIiwibGliL2NvcmUvdGltZS9saW5lLmpzIiwibGliL2NvcmUvdGltZS9tYXBzLmpzIiwibGliL2NvcmUvdGltZS9tb2RlbHMuanMiLCJsaWIvY29yZS90aW1lL3BpbnMuanMiLCJsaWIvY29yZS90aW1lL3NsaWRlci5qcyIsImxpYi9jb3JlL3RpbWUvdXRpbHMuanMiLCJsaWIvZWRpdC9zdHlsZS9TTERTdHlsZUNvbnZlcnRlci5qcyIsImxpYi9lZGl0L3N0eWxlL1N0eWxlQ29tcGxldGUuanMiLCJsaWIvZWRpdC9zdHlsZS9XRlNEZXNjcmliZUZlYXR1cmVUeXBlLmpzIiwibGliL2VkaXQvc3R5bGUvV1BTQ2xhc3NpZnkuanMiLCJsaWIvbWFwc3RvcnkvTWFwQ29uZmlnVHJhbnNmb3JtZXIuanMiLCJsaWIvbmcvY29yZS9vZ2MvbW9kdWxlLmpzIiwibGliL25nL2NvcmUvcGlucy9tb2R1bGUuanMiLCJsaWIvbmcvY29yZS9zdHlsZS9vbDNTdHlsZUNvbnZlcnRlci5qcyIsImxpYi9uZy9jb3JlL3N0eWxlL3N2Z0ljb24uanMiLCJsaWIvbmcvY29yZS90aW1lL3NlcnZpY2VzLmpzIiwibGliL25nL2VkaXQvc3R5bGUvZGlyZWN0aXZlcy9kaXJlY3RpdmVzLmpzIiwibGliL25nL2VkaXQvc3R5bGUvc2VydmljZXMvaWNvbkNvbW1vbnMuanMiLCJsaWIvbmcvZWRpdC9zdHlsZS9zZXJ2aWNlcy9zdHlsZUNob2ljZXMuanMiLCJsaWIvbmcvZWRpdC9zdHlsZS9zZXJ2aWNlcy9zdHlsZVJ1bGVCdWlsZGVyLmpzIiwibGliL25nL2VkaXQvc3R5bGUvc2VydmljZXMvc3R5bGVUeXBlcy5qcyIsImxpYi9uZy9lZGl0L3RpbWUvZGlyZWN0aXZlcy5qcyIsIi9Vc2Vycy9BY29zdGEvRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvRGF0YVNldC5qcyIsIi9Vc2Vycy9BY29zdGEvRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvRGF0YVZpZXcuanMiLCIvVXNlcnMvQWNvc3RhL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL1F1ZXVlLmpzIiwiL1VzZXJzL0Fjb3N0YS9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi9oYW1tZXJVdGlsLmpzIiwiL1VzZXJzL0Fjb3N0YS9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi9tb2R1bGUvaGFtbWVyLmpzIiwiL1VzZXJzL0Fjb3N0YS9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi9tb2R1bGUvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Zpcy9saWIvbW9kdWxlL3V1aWQuanMiLCIvVXNlcnMvQWNvc3RhL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3NoYXJlZC9BY3RpdmF0b3IuanMiLCIvVXNlcnMvQWNvc3RhL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3NoYXJlZC9Db2xvclBpY2tlci5qcyIsIi9Vc2Vycy9BY29zdGEvRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvc2hhcmVkL0NvbmZpZ3VyYXRvci5qcyIsIi9Vc2Vycy9BY29zdGEvRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvc2hhcmVkL1ZhbGlkYXRvci5qcyIsIi9Vc2Vycy9BY29zdGEvRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvQ29yZS5qcyIsIi9Vc2Vycy9BY29zdGEvRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvRGF0ZVV0aWwuanMiLCIvVXNlcnMvQWNvc3RhL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL1JhbmdlLmpzIiwiL1VzZXJzL0Fjb3N0YS9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9TdGFjay5qcyIsIi9Vc2Vycy9BY29zdGEvRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvVGltZVN0ZXAuanMiLCIvVXNlcnMvQWNvc3RhL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL1RpbWVsaW5lLmpzIiwiL1VzZXJzL0Fjb3N0YS9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvQmFja2dyb3VuZEdyb3VwLmpzIiwiL1VzZXJzL0Fjb3N0YS9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvQ29tcG9uZW50LmpzIiwiL1VzZXJzL0Fjb3N0YS9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvQ3VycmVudFRpbWUuanMiLCIvVXNlcnMvQWNvc3RhL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9DdXN0b21UaW1lLmpzIiwiL1VzZXJzL0Fjb3N0YS9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvR3JvdXAuanMiLCIvVXNlcnMvQWNvc3RhL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9JdGVtU2V0LmpzIiwiL1VzZXJzL0Fjb3N0YS9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvVGltZUF4aXMuanMiLCIvVXNlcnMvQWNvc3RhL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9pdGVtL0JhY2tncm91bmRJdGVtLmpzIiwiL1VzZXJzL0Fjb3N0YS9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvaXRlbS9Cb3hJdGVtLmpzIiwiL1VzZXJzL0Fjb3N0YS9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvaXRlbS9JdGVtLmpzIiwiL1VzZXJzL0Fjb3N0YS9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvaXRlbS9Qb2ludEl0ZW0uanMiLCIvVXNlcnMvQWNvc3RhL0RldmVsb3BtZW50L21hcHN0b3J5L3N0b3J5LXRvb2xzL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9pdGVtL1JhbmdlSXRlbS5qcyIsIi9Vc2Vycy9BY29zdGEvRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvbG9jYWxlcy5qcyIsIi9Vc2Vycy9BY29zdGEvRGV2ZWxvcG1lbnQvbWFwc3Rvcnkvc3RvcnktdG9vbHMvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvb3B0aW9uc1RpbWVsaW5lLmpzIiwiL1VzZXJzL0Fjb3N0YS9EZXZlbG9wbWVudC9tYXBzdG9yeS9zdG9yeS10b29scy9ub2RlX21vZHVsZXMvdmlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3Zpcy9ub2RlX21vZHVsZXMvZW1pdHRlci1jb21wb25lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlzL25vZGVfbW9kdWxlcy9oYW1tZXJqcy9oYW1tZXIuanMiLCJub2RlX21vZHVsZXMvdmlzL25vZGVfbW9kdWxlcy9rZXljaGFybS9rZXljaGFybS5qcyIsIm5vZGVfbW9kdWxlcy92aXMvbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCJub2RlX21vZHVsZXMvdmlzL25vZGVfbW9kdWxlcy9wcm9wYWdhdGluZy1oYW1tZXJqcy9wcm9wYWdhdGluZy5qcyIsInRlc3QvaGVscGVycy5qcyIsInRlc3QvdGVzdC1NYXBDb25maWdUcmFuc2Zvcm1lci5qcyIsInRlc3QvdGVzdC1TTERTdHlsZUNvbnZlcnRlci5qcyIsInRlc3QvdGVzdC1TdHlsZUNvbXBsZXRlLmpzIiwidGVzdC90ZXN0LVdGU0Rlc2NyaWJlRmVhdHVyZVR5cGUuanMiLCJ0ZXN0L3Rlc3QtV1BTQ2xhc3NpZnkuanMiLCJ0ZXN0L3Rlc3QtYm94ZXMuanMiLCJ0ZXN0L3Rlc3QtbWFwcy5qcyIsInRlc3QvdGVzdC1vbDNTdHlsZUNvbnZlcnRlci5qcyIsInRlc3QvdGVzdC1waW5zLmpzIiwidGVzdC90ZXN0LXN0b3J5UGlucy5qcyIsInRlc3QvdGVzdC1zdHlsZUNob2ljZXMuanMiLCJ0ZXN0L3Rlc3Qtc3R5bGVEaXJlY3RpdmVzLmpzIiwidGVzdC90ZXN0LXN0eWxlUnVsZUJ1aWxkZXIuanMiLCJ0ZXN0L3Rlc3QtdGltZURpcmVjdGl2ZXMuanMiLCJ0ZXN0L3Rlc3QtdGltZVNlcnZpY2VzLmpzIiwidGVzdC90ZXN0LXV0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMTFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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RUFBRSxPQUFPO0dBQ3hCLENBQUMsQ0FBQztDQUNKLE1BQ0k7QUFDSCxRQUFNLENBQUMsT0FBTyxHQUFHLFlBQVk7QUFDM0IsVUFBTSxLQUFLLENBQUMsMkRBQTJELENBQUMsQ0FBQztHQUMxRSxDQUFBO0NBQ0Y7Ozs7Ozs7QUNYRCxNQUFNLENBQUMsT0FBTyxHQUFHLEFBQUMsT0FBTyxNQUFNLEtBQUssV0FBVyxJQUFLLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7OztBQ0YxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QVMsRUFBQyxhQUFhLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsY0FBYyxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxhQUFhLEVBQUUsU0FBUyxFQUFDLGVBQWUsRUFBRSxTQUFTLEVBQUMsTUFBTSxFQUFFLFNBQVMsRUFBQyxjQUFjLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsY0FBYyxFQUFFLFNBQVMsRUFBQyxnQkFBZ0IsRUFBRSxTQUFTLEVBQUMsT0FBTyxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxjQUFjLEVBQUUsU0FBUyxFQUFDLGVBQWUsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsTUFBTSxFQUFFLFNBQVMsRUFBQyxNQUFNLEVBQUUsU0FBUyxFQUFDLEtBQUssRUFBRSxTQUFTLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFDLFlBQVksRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUMsV0FBVyxFQUFFLFNBQVMsRUFBQyxZQUFZLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsWUFBWSxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxXQUFXLEVBQUUsU0FBUyxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQyxRQUFRLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsV0FBVyxFQUFFLFNBQVMsRUFBQyxhQUFhLEVBQUUsU0FBUyxFQUFDLGNBQWMsRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLGFBQWEsRUFBRSxTQUFTLEVBQUMsWUFBWSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsTUFBTSxFQUFFLFNBQVMsRUFBQyxlQUFlLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxhQUFhLEVBQUUsU0FBUyxFQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUMsTUFBTSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxRQUFRLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsTUFBTSxFQUFFLFNBQVMsRUFBQyxhQUFhLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLEtBQUssRUFBRSxTQUFTLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxNQUFNLEVBQUUsU0FBUyxFQUFDLFlBQVksRUFBRSxTQUFTLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQyxvQkFBb0IsRUFBRSxTQUFTLEVBQUMsT0FBTyxFQUFFLFNBQVMsRUFBQyxHQUFHLEVBQUUsU0FBUyxFQUFDLE9BQU8sRUFB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QVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDakQsVUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEdBQUcsc0JBQXNCLENBQUM7QUFDcEQsVUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDO0FBQ3JDLFVBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDOztBQUVsRCxVQUFJLENBQUMsVUFBVSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDaEQsVUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEdBQUcscUJBQXFCLENBQUM7QUFDbEQsVUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDO0FBQ25DLFVBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDOztBQUVoRCxVQUFJLENBQUMsVUFBVSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDaEQsVUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEdBQUcscUJBQXFCLENBQUM7QUFDbEQsVUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEdBQUcsV0FBVyxDQUFDO0FBQ3hDLFVBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDOztBQUVwRCxVQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDNUMsVUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3RDLFVBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUM3QyxVQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FB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QUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN0QixVQUFJLENBQUMsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUN4QixVQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEUsU0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDVixTQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNWLFVBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5QyxVQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDekIsVUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7OztBQUdsQixVQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsT0FBTyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUNySyxVQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FB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QUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDOzs7QUFHckYsTUFBSSxPQUFPLENBQUMsV0FBVyxJQUFJLEtBQUssRUFBRTtBQUNoQyxRQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDdkMsUUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDO0dBQzlDLE1BQ0k7QUFDSCxRQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDMUMsUUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDO0dBQzNDOzs7QUFHRCxLQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNyRSxLQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNyRSxLQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQzs7O0FBRzdELE9BQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFLLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxXQUFXLEdBQUcsR0FBRyxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUEsR0FBSSxDQUFDLENBQUM7QUFDOUYsT0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7QUFDeEMsT0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQU0sQ0FBQyxHQUFH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QUFLLEtBQUssQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDOzs7QUFHM0QsT0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUM7QUFDeEMsT0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsZUFBZSxDQUFDO0FBQzVELE9BQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxhQUFhLENBQUMsV0FBVyxJQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7QUFDekUsT0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7QUFDN0MsT0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLGNBQWMsQ0FBQyxXQUFXLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztBQUMxRSxPQUFLLENBQUMsY0FBYyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztBQUMvQyxNQUFJLFdBQVcsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxlQUFlLENBQUM7QUFDNUYsT0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQVksV0FBVyxDQUFDO0FBQzFDLE9BQUssQ0FBQyxlQUFlLENBQUMsS0FBSyxHQUFHLFdBQVcsQ0FBQztBQUMxQyxPQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBZSxXQUFXLENBQUM7QUFDMUMsT0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQVksV0FBVyxDQUFDOzs7QUFHMUMsS0FBRyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFhLEtBQUssQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLElBQUks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QUFJLEdBQUcsV0FBVyxFQUFTO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsQUFBUSxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztHQUFDO0FBQ3ZGLE1BQUksUUFBUSxHQUFDLEdBQUcsR0FBRyxXQUFXLEVBQVU7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxBQUFRLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO0dBQUM7QUFDdEYsTUFBSSxRQUFRLEdBQUMsR0FBRyxHQUFHLFdBQVcsRUFBVTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLEFBQVEsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7R0FBQztBQUN0RixNQUFJLFFBQVEsR0FBQyxFQUFFLEdBQUcsV0FBVyxFQUFXO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsQUFBUSxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztHQUFDO0FBQ3JGLE1BQUksUUFBUSxHQUFDLEVBQUUsR0FBRyxXQUFXLEVBQVc7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxBQUFRLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0dBQUM7QUFDckYsTUFBSSxRQUFRLEdBQUMsQ0FBQyxHQUFHLFdBQVcsRUFBWTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLEFBQVEsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLFFBQVEsR0FBRyxXQUFXLEVBQWM7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxBQUFRLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxTQUFTLEdBQUMsQ0FBQyxHQUFHLFdBQVcsRUFBVztBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLEFBQU8sSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLFNBQVMsR0FBRyxXQUFXLEVBQWE7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxBQUFPLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxPQUFPLEdBQUMsQ0FBQyxHQUFHLFdBQVcsRUFBYTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEFBQVMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLE9BQU8sR0FBQyxDQUFDLEdBQUcsV0FBVyxFQUFhO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsQUFBUyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztHQUFDO0FBQ3BGLE1BQUksT0FBTyxHQUFHLFdBQVcsRUFBZTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEFBQVMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLE9BQU8sR0FBQyxDQUFDLEdBQUcsV0FBVyxFQUFhO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUMsQUFBSyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztHQUFDO0FBQ3BGLE1BQUksUUFBUSxHQUFDLENBQUMsR0FBRyxXQUFXLEVBQVk7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxBQUFRLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxRQUFRLEdBQUcsV0FBVyxFQUFjO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsQUFBUSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztHQUFDO0FBQ3BGLE1BQUksVUFBVSxHQUFDLEVBQUUsR0FBRyxXQUFXLEVBQVM7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxBQUFNLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0dBQUM7QUFDckYsTUFBSSxVQUFVLEdBQUMsRUFBRSxHQUFHLFdBQVcsRUFBUztBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEFBQU0sSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7R0FBQztBQUNyRixNQUFJLFVBQVUsR0FBQyxDQUFDLEdBQUcsV0FBVyxFQUFVO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsQUFBTSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztHQUFDO0FBQ3BGLE1BQUksVUFBVSxHQUFHLFdBQVcsRUFBWTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEFBQU0sSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLFVBQVUsR0FBQyxFQUFFLEdBQUcsV0FBVyxFQUFTO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsQUFBTSxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztHQUFDO0FBQ3JGLE1BQUksVUFBVSxHQUFDLEVBQUUsR0FBRyxXQUFXLEVBQVM7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxBQUFNLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0dBQUM7QUFDckYsTUFBSSxVQUFVLEdBQUMsQ0FBQyxHQUFHLFdBQVcsRUFBVTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEFBQU0sSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLFVBQVUsR0FBRyxXQUFXLEVBQVk7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxBQUFNLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxlQUFlLEdBQUMsR0FBRyxHQUFHLFdBQVcsRUFBRztBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsYUFBYSxDQUFDLEFBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7R0FB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QUFDL0IsUUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO0FBQ2xCLFVBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ3JELFVBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzFELFVBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzFELFVBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQ3JEO0FBQ0QsUUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQztBQUM3QyxRQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ2xELFFBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDbEQsUUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztBQUM1QyxRQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztHQUM1Qjs7O0FBR0QsTUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO0FBQ2QsUUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDL0MsUUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7R0FDbkI7QUFDRCxNQUFJLElBQUksSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO0FBQ3RCLFFBQUksQ0FBQyxVQUFV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QUFDLElBQUksR0FBRyxZQUFXOztBQUVsQyxNQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFO0FBQzlCLFFBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztHQUNsRDs7O0FBR0QsTUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRTtBQUM3QixRQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUM3RDs7O0FBR0QsTUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRTtBQUNqQyxRQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7R0FDbkQ7Q0FDRixDQUFDOzs7Ozs7Ozs7QUFTRixPQUFPLENBQUMsU0FBUyxDQUFDLFlBQVksR0FBRyxVQUFTLEdBQUcsRUFBRTtBQUM3QyxNQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQzs7QUFFcEIsTUFBSSxHQUFHLElBQUksU0FBUyxFQUFFLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDL0IsTUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7OztBQUdyQyxPQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDbkQsTUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkIs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SSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3BFLFFBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7R0FDNUQ7QUFDRCxNQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQztBQUNwRSxNQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQzs7O0FBR2xFLE1BQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFnQixFQUFFO0FBQzlCLFFBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxRCxRQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLFNBQVMsR0FBRyxnQ0FBZ0MsQ0FBQztBQUN2RSxRQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDOztBQUV0RCxRQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDcEUsUUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztHQUM1RDtBQUNELE1BQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxDQUFDO0FBQ3BFLE1BQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsV0FB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Q0FBQztBQUNsRCxNQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDOztBQUUxQyxPQUFLLElBQUksR0FBRyxJQUFJLFlBQVksRUFBRTtBQUM1QixRQUFJLFlBQVksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDcEMsYUFBTyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDcEI7R0FDRjs7QUFFRCxTQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0NBQzlDLENBQUM7Ozs7Ozs7Ozs7QUFVRixPQUFPLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDcEMsTUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7QUFFWixNQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUMxQixNQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNsQixNQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQSxBQUFDLENBQUM7QUFDcEIsTUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFBLEFBQUMsQ0FBQztBQUN4QixNQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQSxHQUFJLENBQUMsQ0FBQSxBQUFDLENBQUM7O0FBRTlCLFVBQVEsQ0FBQyxHQUFHLENBQUM7QUFDWCxTQUFLLENBQUM7QUFBRSxPQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUFDLE1BQU07QUFBQSxBQUNuQyxTQUFLLENBQUM7QUFBRSxPQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUFDLE1BQU07QUFBQSxBQUNuQyxTQUFLLENBQUM7QUFBRSxPQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUFDLE1BQU07QUFBQSxBQUNuQyxTQUFLLENBQUM7QUFBRSxPQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUFDLE1BQU07QUFBQSxBQUNuQyxTQUFLLENBQUM7QUFBRSxPQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUFDLE1BQU07QUFBQSxBQUNuQyxTQUFLLENBQUM7QUFBRSxPQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUFDLE1BQU07QUFBQSxHQUNwQzs7QUFFRCxTQUFPLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQztDQUNuRixDQUFDOztBQUVGLE9BQU8sQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUNwQyxNQUFJLEdBQUcsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDcEMsU0FBTyxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDOUMsQ0FBQzs7QUFFRixPQUFPLENBQUMsUUFBUSxHQUFHLFVBQVUsR0FBRyxFQUFFO0FBQ2hDLE1BQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDaEMsU0FBTyxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDOUMsQ0FBQzs7QUFFRixPQUFPLENBQUMsVUFBVSxHQUFHLFVBQVUsR0FBRyxFQUFFO0FBQ2xDLE1BQUksSUFBSSxHQUFHLG9DQUFvQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUMxRCxTQUFPLElBQUksQ0FBQztDQUNiLENBQUM7O0FBRUYsT0FBTyxDQUFDLFVBQVUsR0FBRyxVQUFVLEdBQUcsRUFBRTtBQUNsQyxLQUFHLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDM0IsTUFBSSxJQUFJLEdBQUcsdUNBQXVDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzdELFNBQU8sSUFBSSxDQUFDO0NBQ2IsQ0FBQTtBQUNELE9BQU8sQ0FBQyxXQUFXLEdBQUcsVUFBVSxJQUFJLEVBQUU7QUFDcEMsTUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQzdCLE1BQUksSUFBSSxHQUFHLGlEQUFpRCxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN4RSxTQUFPLElBQUksQ0FBQztDQUNiLENBQUE7Ozs7Ozs7OztBQVNELE9BQU8sQ0FBQyxxQkFBcUIsR0FBRyxVQUFVLE1BQU0sRUFBRSxlQUFlLEVBQUU7QUFDakUsTUFBSSxPQUFPLGVBQWUsSUFBSSxRQUFRLEVBQUU7QUFDdEMsUUFBSSxRQUFRLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUM5QyxTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN0QyxVQUFJLGVBQWUsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7QUFDN0MsWUFBSSxPQUFPLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxRQUFRLEVBQUU7QUFDakQsa0JBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3hFO09BQ0Y7S0FDRjtBQUNELFdBQU8sUUFBUSxDQUFDO0dBQ2pCLE1BQ0k7QUFDSCxXQUFPLElBQUksQ0FBQztHQUNiO0NBQ0YsQ0FBQzs7Ozs7Ozs7O0FBU0YsT0FBTyxDQUFDLFlBQVksR0FBRyxVQUFVLGVBQWUsRUFBRTtBQUNoRCxNQUFJLE9BQU8sZUFBZSxJQUFJLFFBQVEsRUFBRTtBQUN0QyxRQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQzlDLFNBQUssSUFBSSxDQUFDLElBQUksZUFBZSxFQUFFO0FBQzdCLFVBQUksZUFBZSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRTtBQUNyQyxZQUFJLE9BQU8sZUFBZSxDQUFDLENBQUMsQ0FBQyxJQUFJLFFBQVEsRUFBRTtBQUN6QyxrQkFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDeEQ7T0FDRjtLQUNGO0FBQ0QsV0FBTyxRQUFRLENBQUM7R0FDakIsTUFDSTtBQUNILFdBQU8sSUFBSSxDQUFDO0dBQ2I7Q0FDRixDQUFDOzs7Ozs7Ozs7OztBQVlGLE9BQU8sQ0FBQyxZQUFZLEdBQUcsVUFBVSxXQUFXLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBNkM7TUFBM0MsYUFBYSx5REFBRyxLQUFLO01BQUUsYUFBYSx5REFBRyxFQUFFOztBQUN0RyxNQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxJQUFJLEVBQUU7QUFDNUIsZUFBVyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7R0FDNUQsTUFDSTtBQUNILFFBQUksT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLFNBQVMsRUFBRTtBQUNqQyxVQUFJLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLFNBQVMsRUFBRTtBQUN4QyxtQkFBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7T0FDL0MsTUFDSTtBQUNILFlBQUksT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sS0FBSyxTQUFTLEVBQUU7QUFDekMscUJBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1NBQ3BDO0FBQ0QsYUFBSyxJQUFJLElBQUksSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUU7QUFDaEMsY0FBSSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ3hDLHVCQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1dBQ25EO1NBQ0Y7T0FDRjtLQUNGO0dBQ0Y7Q0FDRixDQUFBOzs7Ozs7Ozs7Ozs7O0FBY0QsT0FBTyxDQUFDLGtCQUFrQixHQUFHLFVBQVUsWUFBWSxFQUFFLGNBQWMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFO0FBQ2xGLE1BQUksYUFBYSxHQUFHLEtBQUssQ0FBQztBQUMxQixNQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7QUFDbEIsTUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ1osTUFBSSxJQUFJLEdBQUcsWUFBWSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7O0FBRW5DLFNBQU8sR0FBRyxJQUFJLElBQUksSUFBSSxTQUFTLEdBQUcsYUFBYSxFQUFFO0FBQy9DLFFBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFBLEdBQUksQ0FBQyxDQUFDLENBQUM7O0FBRTFDLFFBQUksSUFBSSxHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNoQyxRQUFJLEtBQUssR0FBRyxBQUFDLE1BQU0sS0FBSyxTQUFTLEdBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQzs7QUFFdkUsUUFBSSxZQUFZLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3pDLFFBQUksWUFBWSxJQUFJLENBQUMsRUFBRTs7QUFDckIsYUFBTyxNQUFNLENBQUM7S0FDZixNQUNJLElBQUksWUFBWSxJQUFJLENBQUMsQ0FBQyxFQUFFOztBQUMzQixTQUFHLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQztLQUNsQixNQUNJOztBQUNILFVBQUksR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0tBQ25COztBQUVELGFBQVMsRUFBRSxDQUFDO0dBQ2I7O0FBRUQsU0FBTyxDQUFDLENBQUMsQ0FBQztDQUNYLENBQUM7Ozs7Ozs7Ozs7Ozs7O0FBY0YsT0FBTyxDQUFDLGlCQUFpQixHQUFHLFVBQVUsWUFBWSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsY0FBYyxFQUFFO0FBQ2pGLE1BQUksYUFBYSxHQUFHLEtBQUssQ0FBQztBQUMxQixNQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7QUFDbEIsTUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ1osTUFBSSxJQUFJLEdBQUcsWUFBWSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDbkMsTUFBSSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUM7O0FBRXhDLFNBQU8sR0FBRyxJQUFJLElBQUksSUFBSSxTQUFTLEdBQUcsYUFBYSxFQUFFOztBQUUvQyxVQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxHQUFHLEdBQUcsQ0FBQSxBQUFDLENBQUMsQ0FBQztBQUN4QyxhQUFTLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3pELFNBQUssR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDcEMsYUFBUyxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDOztBQUUvRSxRQUFJLEtBQUssSUFBSSxNQUFNLEVBQUU7O0FBQ25CLGFBQU8sTUFBTSxDQUFDO0tBQ2YsTUFDSSxJQUFJLFNBQVMsR0FBRyxNQUFNLElBQUksS0FBSyxHQUFHLE1BQU0sRUFBRTs7QUFDN0MsYUFBTyxjQUFjLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7S0FDdEUsTUFDSSxJQUFJLEtBQUssR0FBRyxNQUFNLElBQUksU0FBUyxHQUFHLE1BQU0sRUFBRTs7QUFDN0MsYUFBTyxjQUFjLElBQUksUUFBUSxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztLQUM1RixNQUNJOztBQUNILFVBQUksS0FBSyxHQUFHLE1BQU0sRUFBRTs7QUFDbEIsV0FBRyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUM7T0FDbEIsTUFDSTs7QUFDSCxZQUFJLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQztPQUNuQjtLQUNGO0FBQ0QsYUFBUyxFQUFFLENBQUM7R0FDYjs7O0FBR0QsU0FBTyxDQUFDLENBQUMsQ0FBQztDQUNYLENBQUM7Ozs7Ozs7QUFPRixPQUFPLENBQUMsZUFBZSxHQUFHOztBQUV4QixRQUFNLEVBQUUsZ0JBQVUsQ0FBQyxFQUFFO0FBQ25CLFdBQU8sQ0FBQyxDQUFBO0dBQ1Q7O0FBRUQsWUFBVSxFQUFFLG9CQUFVLENBQUMsRUFBRTtBQUN2QixXQUFPLENBQUMsR0FBRyxDQUFDLENBQUE7R0FDYjs7QUFFRCxhQUFXLEVBQUUscUJBQVUsQ0FBQyxFQUFFO0FBQ3hCLFdBQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUEsQUFBQyxDQUFBO0dBQ25COztBQUVELGVBQWEsRUFBRSx1QkFBVSxDQUFDLEVBQUU7QUFDMUIsV0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUEsR0FBSSxDQUFDLENBQUE7R0FDakQ7O0FBRUQsYUFBVyxFQUFFLHFCQUFVLENBQUMsRUFBRTtBQUN4QixXQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFBO0dBQ2pCOztBQUVELGNBQVksRUFBRSxzQkFBVSxDQUFDLEVBQUU7QUFDekIsV0FBTyxBQUFDLEVBQUUsQ0FBQyxHQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFBO0dBQ3pCOztBQUVELGdCQUFjLEVBQUUsd0JBQVUsQ0FBQyxFQUFFO0FBQzNCLFdBQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFBLElBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUEsQUFBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFBLEFBQUMsR0FBRyxDQUFDLENBQUE7R0FDeEU7O0FBRUQsYUFBVyxFQUFFLHFCQUFVLENBQUMsRUFBRTtBQUN4QixXQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQTtHQUNyQjs7QUFFRCxjQUFZLEVBQUUsc0JBQVUsQ0FBQyxFQUFFO0FBQ3pCLFdBQU8sQ0FBQyxHQUFHLEFBQUMsRUFBRSxDQUFDLEdBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUE7R0FDN0I7O0FBRUQsZ0JBQWMsRUFBRSx3QkFBVSxDQUFDLEVBQUU7QUFDM0IsV0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBSSxFQUFFLENBQUMsQUFBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFBO0dBQzlEOztBQUVELGFBQVcsRUFBRSxxQkFBVSxDQUFDLEVBQUU7QUFDeEIsV0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFBO0dBQ3pCOztBQUVELGNBQVksRUFBRSxzQkFBVSxDQUFDLEVBQUU7QUFDekIsV0FBTyxDQUFDLEdBQUcsQUFBQyxFQUFFLENBQUMsR0FBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUE7R0FDakM7O0FBRUQsZ0JBQWMsRUFBRSx3QkFBVSxDQUFDLEVBQUU7QUFDM0IsV0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUksRUFBRSxDQUFDLEFBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUE7R0FDeEU7Q0FDRixDQUFDOzs7QUM3NUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmxGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsbUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJyZXF1aXJlKCcuL3Rlc3QtdXRpbHMnKTtcbnJlcXVpcmUoJy4vdGVzdC1tYXBzJyk7XG5yZXF1aXJlKCcuL3Rlc3QtYm94ZXMnKTtcbnJlcXVpcmUoJy4vdGVzdC1zdHlsZVJ1bGVCdWlsZGVyJyk7XG5yZXF1aXJlKCcuL3Rlc3Qtb2wzU3R5bGVDb252ZXJ0ZXInKTtcbnJlcXVpcmUoJy4vdGVzdC1TTERTdHlsZUNvbnZlcnRlcicpO1xucmVxdWlyZSgnLi90ZXN0LVdQU0NsYXNzaWZ5Jyk7XG5yZXF1aXJlKCcuL3Rlc3Qtc3R5bGVEaXJlY3RpdmVzLmpzJyk7XG5yZXF1aXJlKCcuL3Rlc3QtdGltZURpcmVjdGl2ZXMuanMnKTtcbnJlcXVpcmUoJy4vdGVzdC1zdHlsZUNob2ljZXMuanMnKTtcbnJlcXVpcmUoJy4vdGVzdC1TdHlsZUNvbXBsZXRlLmpzJyk7XG5yZXF1aXJlKCcuL3Rlc3Qtc3RvcnlQaW5zLmpzJyk7XG5yZXF1aXJlKCcuL3Rlc3QtdGltZVNlcnZpY2VzLmpzJyk7XG5yZXF1aXJlKCcuL3Rlc3QtTWFwQ29uZmlnVHJhbnNmb3JtZXIuanMnKTtcbnJlcXVpcmUoJy4vdGVzdC1XRlNEZXNjcmliZUZlYXR1cmVUeXBlLmpzJyk7XG5yZXF1aXJlKCcuL3Rlc3QtcGlucy5qcycpO1xuIiwiLyplc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyovXG4vKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuMS4wXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDctMDdUMjE6NDRaXG4gKi9cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG5cblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMgd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy4xLjBcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0cmV0dXJuIG51bSAhPSBudWxsID9cblxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdFx0KCBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdICkgOlxuXG5cdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0XHRzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNBcnJheSggc3JjICkgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0XHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdFx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0XHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xuXHR9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy82MTI1XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdERPTUV2YWwoIGNvZGUgKTtcblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0bm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRcdHJldHVybiBwcm94eTtcblx0fSxcblxuXHRub3c6IERhdGUubm93LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXG5cdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuMFxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDEtMDRcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFx4ODAtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0ZGlzYWJsZWRBbmNlc3RvciA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOlxuXHQvLyBJRTogKltkaXNhYmxlZF06bm90KGJ1dHRvbiwgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIG9wdGdyb3VwLCBvcHRpb24sIG1lbnVpdGVtLCBmaWVsZHNldClcblx0Ly8gbm90IElFOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9ybSBlbGVtZW50cyBhbmQgb3B0aW9uIGVsZW1lbnRzIGZvciBleHBsaWNpdCBkaXNhYmxpbmdcblx0XHRyZXR1cm4gXCJsYWJlbFwiIGluIGVsZW0gJiYgZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblx0XHRcdFwiZm9ybVwiIGluIGVsZW0gJiYgZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0Ly8gQ2hlY2sgbm9uLWRpc2FibGVkIGZvcm0gZWxlbWVudHMgZm9yIGZpZWxkc2V0W2Rpc2FibGVkXSBhbmNlc3RvcnNcblx0XHRcdFwiZm9ybVwiIGluIGVsZW0gJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgJiYgKFxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTYtMTErXG5cdFx0XHRcdC8vIEFuY2VzdHJ5IGlzIGNvdmVyZWQgZm9yIHVzXG5cdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGFzc3VtZSBhbnkgbm9uLTxvcHRpb24+IHVuZGVyIGZpZWxkc2V0W2Rpc2FibGVkXSBpcyBkaXNhYmxlZFxuXHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHQoXCJsYWJlbFwiIGluIGVsZW0gfHwgIWRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSkgIT09IGRpc2FibGVkXG5cdFx0XHQpO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbmQgYW5kIGZpbHRlclxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIG0gPyBbIG0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdC8vIFN1cHBvcnQ6IElFNi83XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdGRlbGV0ZSBFeHByLmZpbmRbXCJJRFwiXTtcblxuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRzdXBwb3J0LmdldEJ5SWQgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdFx0XHRFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdFx0fVxuXG5cdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdCAmJiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRyZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXSA6XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHRcdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgalF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdHdoaXRlID0gKCAvXFxTKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIGpRdWVyeS50eXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0XHRyZXNvbHZlLmNhbGwoIHVuZGVmaW5lZCwgdmFsdWUgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuY2FsbCggdW5kZWZpbmVkLCB2YWx1ZSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0ICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWFzdGVyLnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG5cdFx0aWYgKCBob2xkICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2hhaW5hYmxlID9cblx0XHRlbGVtcyA6XG5cblx0XHQvLyBHZXRzXG5cdFx0YnVsayA/XG5cdFx0XHRmbi5jYWxsKCBlbGVtcyApIDpcblx0XHRcdGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGpRdWVyeS5jYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcImZhbHNlXCIgPyBmYWxzZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcblxuXHRcdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBKU09OLnBhcnNlKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCxcblx0XHRzY2FsZSA9IDEsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cblx0XHRcdC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0Ly8gQnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaC5cblx0XHR9IHdoaWxlIChcblx0XHRcdHNjYWxlICE9PSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsICkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zXG5cdFx0KTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICksXG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKykvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldCA9IHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdFtdO1xuXG5cdHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG5cdFx0alF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICkgOlxuXHRcdHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBtYXRjaGVzLCBzZWwsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKCMxMzE4MClcblx0XHQvL1xuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGluIEZGIGJ1dCBkb24ndCBibG9jayBJRSByYWRpbyBldmVudHMgKCMzODYxLCBnaC0yMzQzKVxuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJiBjdXIubm9kZVR5cGUgJiZcblx0XHRcdCggZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiIHx8IGlzTmFOKCBldmVudC5idXR0b24gKSB8fCBldmVudC5idXR0b24gPCAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgKCBjdXIuZGlzYWJsZWQgIT09IHRydWUgfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogdGhpcywgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGpRdWVyeS5pc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblxuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gKCBidXR0b24gJiAxID8gMSA6ICggYnV0dG9uICYgMiA/IDMgOiAoIGJ1dHRvbiAmIDQgPyAyIDogMCApICkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuXHQvKiBlc2xpbnQtZW5hYmxlICovXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTNcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdGpRdWVyeS5ub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyggZWxlbS50eXBlICk7XG5cblx0aWYgKCBtYXRjaCApIHtcblx0XHRlbGVtLnR5cGUgPSBtYXRjaFsgMSBdO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKCBzcmMgKTtcblx0XHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIGlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgZG9jICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm1hcmdpbiA9ICggL15tYXJnaW4vICk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcImJveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwidG9wOjElO3dpZHRoOjUwJVwiO1xuXHRcdGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IGRpdlN0eWxlLm1hcmdpbkxlZnQgPT09IFwiMnB4XCI7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSBkaXZTdHlsZS53aWR0aCA9PT0gXCI0cHhcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjUwJVwiO1xuXHRcdHBpeGVsTWFyZ2luUmlnaHRWYWwgPSBkaXZTdHlsZS5tYXJnaW5SaWdodCA9PT0gXCI0cHhcIjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHBpeGVsTWFyZ2luUmlnaHRWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDo4cHg7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O1wiICtcblx0XHRcInBhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbE1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxNYXJnaW5SaWdodFZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBvbmx5IG5lZWRlZCBmb3IgLmNzcygnZmlsdGVyJykgKCMxMjUzNylcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbE1hcmdpblJpZ2h0KCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGU7XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHtcblx0dmFyIGkgPSBleHRyYSA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApID9cblxuXHRcdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRcdDQgOlxuXG5cdFx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHRcdG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXG5cdFx0dmFsID0gMDtcblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG5cdFx0aWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcblx0dmFyIHZhbCxcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRpZiAoIGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0dmFsID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVsgbmFtZSBdO1xuXHR9XG5cblx0Ly8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblxuXHRcdC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0aWYgKCB2YWwgPCAwIHx8IHZhbCA9PSBudWxsICkge1xuXHRcdFx0dmFsID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHtcblx0XHRcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuXHRcdFx0KCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggb3JpZ05hbWUgKSB8fCBvcmlnTmFtZSApO1xuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHxcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgdGltZXJJZCxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiByYWYoKSB7XG5cdGlmICggdGltZXJJZCApIHtcblx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByYWYgKTtcblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1lcblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdGpRdWVyeS5wcm94eSggcmVzdWx0LnN0b3AsIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmIG9yIGlmIGRvY3VtZW50IGlzIGhpZGRlblxuXHRpZiAoIGpRdWVyeS5meC5vZmYgfHwgZG9jdW1lbnQuaGlkZGVuICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRvcHQuZHVyYXRpb24gPSB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSBcIm51bWJlclwiID9cblx0XHRcdG9wdC5kdXJhdGlvbiA6IG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzID9cblx0XHRcdFx0alF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0galF1ZXJ5Lm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggIXRpbWVySWQgKSB7XG5cdFx0dGltZXJJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgP1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggcmFmICkgOlxuXHRcdFx0d2luZG93LnNldEludGVydmFsKCBqUXVlcnkuZngudGljaywgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGlmICggd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSggdGltZXJJZCApO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGVhckludGVydmFsKCB0aW1lcklkICk7XG5cdH1cblxuXHR0aW1lcklkID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGFiaW5kZXggP1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKSA6XG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmIGVsZW0uaHJlZiA/XG5cdFx0XHRcdFx0XHRcdDAgOlxuXHRcdFx0XHRcdFx0XHQtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG52YXIgcmNsYXNzID0gL1tcXHRcXHJcXG5cXGZdL2c7XG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIFwiIFwiICsgY3VyVmFsdWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBnZXRDbGFzcyggZWxlbSApICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZyxcblx0cnNwYWNlcyA9IC9bXFx4MjBcXHRcXHJcXG5cXGZdKy9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApIDpcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRcdHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0alF1ZXJ5LnRyaW0oIGpRdWVyeS50ZXh0KCBlbGVtICkgKS5yZXBsYWNlKCByc3BhY2VzLCBcIiBcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRcdGkgPSBpbmRleCA8IDAgP1xuXHRcdFx0XHRcdFx0bWF4IDpcblx0XHRcdFx0XHRcdG9uZSA/IGluZGV4IDogMDtcblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0cmV0dXJuIHZhbCA9PSBudWxsID9cblx0XHRcdFx0bnVsbCA6XG5cdFx0XHRcdGpRdWVyeS5pc0FycmF5KCB2YWwgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cnRzID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTNcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBhbnRpLWNhY2hlIGluIHVuY2FjaGVkIHVybCBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIlwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0galF1ZXJ5LnRyaW0oIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG4vKipcbiAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0Vmlldztcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvY0VsZW0sIHdpbiwgcmVjdCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSBlbGVtZW50IGlzIG5vdCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpXG5cdFx0aWYgKCByZWN0LndpZHRoIHx8IHJlY3QuaGVpZ2h0ICkge1xuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0d2luID0gZ2V0V2luZG93KCBkb2MgKTtcblx0XHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXG5cdFx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdHJldHVybiByZWN0O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LFxuXHRcdC8vIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyB0aGVyZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcImh0bWxcIiApICkge1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdFx0cGFyZW50T2Zmc2V0ID0ge1xuXHRcdFx0XHR0b3A6IHBhcmVudE9mZnNldC50b3AgKyBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICksXG5cdFx0XHRcdGxlZnQ6IHBhcmVudE9mZnNldC5sZWZ0ICsgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblx0XHRcdHZhciB3aW4gPSBnZXRXaW5kb3coIGVsZW0gKTtcblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiIsImV4cG9ydHMudGltZSA9IHJlcXVpcmUoJy4vdGltZS9jb250cm9scycpO1xuZXhwb3J0cy5tYXBzID0gcmVxdWlyZSgnLi90aW1lL21hcHMnKTtcbmV4cG9ydHMubWFwcy5waW5zID0gcmVxdWlyZSgnLi90aW1lL3BpbnMnKTtcbmV4cG9ydHMubWFwcy5ib3hlcyA9IHJlcXVpcmUoJy4vdGltZS9ib3hlcycpO1xuZXhwb3J0cy51dGlscyA9IHJlcXVpcmUoJy4vdGltZS91dGlscycpO1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5mdW5jdGlvbiBCb3gob3B0aW9ucykge1xuICAgIHRoaXMucmFuZ2UgPSBvcHRpb25zLnJhbmdlIHx8IG51bGw7XG4gICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhIHx8IG51bGw7XG4gICAgdGhpcy5sYXllcklkcyA9IG9wdGlvbnMubGF5ZXJJZHMgfHwgbnVsbDtcbiAgICB0aGlzLmNlbnRlciA9IG9wdGlvbnMuY2VudGVyIHx8IG51bGw7IC8vIG9sLkNvb3JkaW5hdGVcbiAgICB0aGlzLnJlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb24gfHwgbnVsbDtcbiAgICB0aGlzLmFsbG93UGFuID0gb3B0aW9ucy5hbGxvd1BhbjtcbiAgICB0aGlzLmFsbG93Wm9vbSA9IG9wdGlvbnMuYWxsb3dab29tO1xuICAgIHRoaXMuc3BlZWQgPSBvcHRpb25zLnNwZWVkOyAgLy8gaW50ZXJ2YWwsIHNlY29uZHNcbiAgICB0aGlzLnRpdGxlID0gb3B0aW9ucy50aXRsZSB8fCAnJztcbiAgICB0aGlzLmlkID0gb3B0aW9ucy5pZCB8fCBuZXcgRGF0ZSgpLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgIHRoaXMuem9vbSA9IG9wdGlvbnMuem9vbSB8fCBudWxsO1xuICAgIHRoaXMuX29mZnNldCA9IDA7XG4gICAgaWYgKHRoaXMucmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgaWYodGhpcy5kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gdXRpbHMuY3JlYXRlUmFuZ2UodGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbdGhpcy5kYXRhLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gdXRpbHMuY3JlYXRlUmFuZ2Uob3B0aW9ucy5zdGFydF90aW1lLCBvcHRpb25zLmVuZF90aW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBAdG9kbyBwb3NzaWJsZSBkaXZpZGUgYnkgemVybyBpZiBzcGVlZC5pbnRlcnZhbCBub3Qgc2V0IVxuICAgIHRoaXMuX3N0ZXBzID0gdGhpcy5kYXRhID09PSBudWxsID8gTWF0aC5mbG9vcih0aGlzLnJhbmdlLndpZHRoKCkgLyB0aGlzLnNwZWVkLmludGVydmFsKSArIDE6IHRoaXMuZGF0YS5sZW5ndGg7XG59XG5Cb3gucHJvdG90eXBlLmdldFN0ZXBzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZXBzO1xufTtcbkJveC5wcm90b3R5cGUuZ2V0UmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZTtcbn07XG5Cb3gucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24oaW5zdGFudCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEgPyB1dGlscy5maW5kKHRoaXMuZGF0YSwgaW5zdGFudCkgOlxuICAgICAgICBNYXRoLmZsb29yKE1hdGgubWluKHRoaXMucmFuZ2Uud2lkdGgoKSwgTWF0aC5tYXgoMCwgaW5zdGFudCAtIHRoaXMucmFuZ2Uuc3RhcnQpKSAvIHRoaXMuc3BlZWQuaW50ZXJ2YWwpO1xufTtcbkJveC5wcm90b3R5cGUuZ2V0RGF0ZSA9IGZ1bmN0aW9uKGlkeCkge1xuICAgIGlkeCA9IGlkeCAtIHRoaXMuX29mZnNldDtcbiAgICByZXR1cm4gdGhpcy5kYXRhID8gdGhpcy5kYXRhW2lkeF0gOiB0aGlzLnJhbmdlLnN0YXJ0ICsgKGlkeCAqIHRoaXMuc3BlZWQuaW50ZXJ2YWwpO1xufTtcblxuXG5mdW5jdGlvbiBnZXRUaW1lKHByb3BzLCBwcm9wKSB7XG4gICAgdmFyIHZhbCA9IHByb3BzW3Byb3BdO1xuICAgIGlmICh0eXBlb2YgdmFsICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB2YWwgKj0gMTAwMDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogTG9hZCBCb3ggZnJvbSBnZW9qc29uLCByZXByb2plY3RpbmcgZnJvbSA0MzI2IHRvIHRoZSBwcm92aWRlZFxuICogcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBnZW9qc29uXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvamVjdGlvblxuICogQHJldHVybnMgYXJyYXkgb2YgQm94IGZlYXR1cmVzXG4gKi9cbmV4cG9ydHMubG9hZEZyb21HZW9KU09OID0gZnVuY3Rpb24oZ2VvanNvbiwgcHJvamVjdGlvbikge1xuICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAgIHByb2plY3Rpb24gPSBvbC5wcm9qLmdldChwcm9qZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlb2pzb24uZmVhdHVyZXMubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdmFyIHByb3BzID0gZi5wcm9wZXJ0aWVzO1xuICAgICAgICAvL3Byb3BzLnRoZV9nZW9tID0gZi5nZW9tZXRyeTtcbiAgICAgICAgcHJvcHMuaWQgPSBmLmlkO1xuICAgICAgICBwcm9wcy5zdGFydF90aW1lID0gZ2V0VGltZShwcm9wcywgJ3N0YXJ0X3RpbWUnKTtcbiAgICAgICAgcHJvcHMuZW5kX3RpbWUgPSBnZXRUaW1lKHByb3BzLCAnZW5kX3RpbWUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCb3gocHJvcHMsIHByb2plY3Rpb24pO1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gZmluZEJveChib3hlcywgaWR4KSB7XG4gICAgdmFyIGksIGlpO1xuICAgIHZhciBib3g7XG4gICAgZm9yIChpID0gMCwgaWkgPSBib3hlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGJveCA9IGJveGVzW2ldO1xuICAgICAgICBpZiAoaWR4ID49IGJveC5fb2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAoaSArIDEgPCBpaSkge1xuICAgICAgICAgICAgICAgIGlmIChpZHggPCBib3hlc1tpICsgMV0uX29mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3g7XG59XG5cbmV4cG9ydHMuQm94TW9kZWwgPSBmdW5jdGlvbihib3hBcnJheSkge1xuICAgIHZhciBib3hlcyxcbiAgICAgICAgcmFuZ2UsXG4gICAgICAgIHN0ZXBzO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUJveGVzKG5ldSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgYm94ZXMgPSBuZXUubWFwKGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgIHZhciBib3ggPSBuZXcgQm94KGIpO1xuICAgICAgICAgICAgYm94Ll9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBvZmZzZXQgKz0gYm94LmdldFN0ZXBzKCk7XG4gICAgICAgICAgICByZXR1cm4gYm94O1xuICAgICAgICB9KTtcbiAgICAgICAgcmFuZ2UgPSB1dGlscy5jb21wdXRlUmFuZ2UoYm94ZXMsICdyYW5nZScpO1xuICAgICAgICBzdGVwcyA9IG9mZnNldDtcbiAgICB9XG4gICAgdXBkYXRlQm94ZXMoYm94QXJyYXkpO1xuICAgIHRoaXMuZ2V0UmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG4gICAgdGhpcy5nZXRTdGVwcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RlcHM7XG4gICAgfTtcbiAgICB0aGlzLmdldFJhbmdlQXQgPSBmdW5jdGlvbihzLCBlKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGZpbmRCb3goYm94ZXMsIHMpO1xuICAgICAgICB2YXIgZW5kID0gZmluZEJveChib3hlcywgZSk7XG4gICAgICAgIHJldHVybiB1dGlscy5jcmVhdGVSYW5nZShzdGFydC5nZXREYXRlKHMpLCBlbmQuZ2V0RGF0ZShlKSk7XG4gICAgfTtcbiAgICB0aGlzLmdldEluZGV4ID0gZnVuY3Rpb24oaW5zdGFudCkge1xuICAgICAgICB2YXIgaWR4ID0gMCwgaTtcbiAgICAgICAgaWYgKGluc3RhbnQgPCBib3hlc1swXS5nZXRSYW5nZSgpLnN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGJveC5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKGluc3RhbnQgPj0gcmFuZ2Uuc3RhcnQgJiYgaW5zdGFudCA8PSByYW5nZS5lbmQpIHtcbiAgICAgICAgICAgICAgICBpZHggKz0gYm94LmdldEluZGV4KGluc3RhbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZHggKz0gYm94LmdldFN0ZXBzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9O1xuICAgIHRoaXMuc2V0UmFuZ2UgPSBmdW5jdGlvbihuZXdSYW5nZSkge1xuICAgICAgICBpZiAoYm94ZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIC8vIEB0b2RvIHN1cHBvcnQgZm9yIHJhbmdlXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNSYW5nZUxpa2UobmV3UmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgc3VwcG9ydGVkIHlldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm94ZXNbMF0uZGF0YSA9IG5ld1JhbmdlO1xuICAgICAgICAgICAgLy8gQHRvZG8gbXVzdCBzZXQgaGVyZSBvciBjb25zdHJ1Y3RvciBpcyBkdW1iIGFuZCBkb2Vzbid0IHJlY29tcHV0ZVxuICAgICAgICAgICAgYm94ZXNbMF0ucmFuZ2UgPSB1dGlscy5jb21wdXRlUmFuZ2UobmV3UmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQHRvZG8gZmluaXNoXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbW9yZSB0aGFuIG9uZSBzdG9yeSBib3ggdG8gdXBkYXRlIHJhbmdlIHdpdGghJyk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlQm94ZXMoYm94ZXMpO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICB9O1xufTtcblxuZXhwb3J0cy5maW5kQm94ID0gZmluZEJveDtcbmV4cG9ydHMuQm94ID0gQm94O1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG1vZGVscyA9IHJlcXVpcmUoJy4vbW9kZWxzJyk7XG52YXIgdGltZXNsaWRlciA9IHJlcXVpcmUoJy4vc2xpZGVyJyk7XG52YXIgbGluZSA9IHJlcXVpcmUoJy4vbGluZScpO1xudmFyIG1hcHMgPSByZXF1aXJlKCcuL21hcHMnKTtcblxuLyoqXG4gKiBGYWNhZGUgb2JqZWN0IGFuZCBndXRzIG9mIHNsaWRlci90aW1lbGluZS9wbGF5YmFjayBsb2dpYy5cbiAqXG4gKiBTaW5jZSBwbGF5YmFjayBpcyBkcml2ZW4gYnkgYSB0aW1lb3V0LCBhbGwgb3RoZXIgcG90ZW50aWFsIGV2ZW50c1xuICogYXJlIGZpcmVkIGluIGFuIGFzeW5jIG1hbm5lciB0byBlbnN1cmUgYSB1bmlmb3JtIEFQSS5cbiAqL1xuZnVuY3Rpb24gVGltZUNvbnRyb2xsZXIobW9kZWwsIHNsaWRlciwgdGltZWxpbmUsIGNvbnRyb2xzLCBjaGFwdGVyQ291bnQpIHtcbiAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgdGhpcy5zbGlkZXIgPSBzbGlkZXI7XG4gICAgdGhpcy50aW1lbGluZSA9IHRpbWVsaW5lO1xuICAgIHRoaXMubG9vcCA9ICdub25lJztcblxuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgY3VycmVudFRpbWVsaW5lV2luZG93ID0gZ2V0VGltZWxpbmVXaW5kb3coKSxcbiAgICAgICAgaXNBZGp1c3RpbmcgPSBmYWxzZSxcbiAgICAgICAgc3RhcnRlZCA9IGZhbHNlLFxuICAgICAgICB0aW1lb3V0ID0gbnVsbCxcbiAgICAgICAgZXZlbnRzID0gbmV3IHV0aWxzLkV2ZW50cygpLFxuICAgICAgICBkZWZlcnJlZCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gZ2V0VGltZWxpbmVXaW5kb3coKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5jcmVhdGVSYW5nZSh0aW1lbGluZS5nZXRXaW5kb3coKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRqdXN0KGZ1biwgYSwgYikge1xuICAgICAgICBpZiAoaXNBZGp1c3RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpc0FkanVzdGluZyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmdW4oYSwgYik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpc0FkanVzdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2VudGVyVGltZWxpbmUocmFuZ2UpIHtcbiAgICAgICAgdmFyIGMgPSBtb2RlbC5tb2RlID09PSAnY3VtdWxhdGl2ZScgPyByYW5nZS5lbmQgOiByYW5nZS5jZW50ZXIoKTtcbiAgICAgICAgdGltZWxpbmUubW92ZVRvKGMpO1xuICAgICAgICBwdWJsaXNoUmFuZ2VDaGFuZ2UocmFuZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkanVzdFNsaWRlcihyYW5nZSkge1xuICAgICAgICBpZiAodGltZWxpbmUuaXNXaW5kb3dNYXgoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNlbnRlciA9IHJhbmdlLmNlbnRlcigpO1xuICAgICAgICB2YXIgaWR4ID0gbW9kZWwuZ2V0SW5kZXgoY2VudGVyKTtcbiAgICAgICAgaWYgKG1vZGVsLm1vZGUgPT09ICdjdW11bGF0aXZlJykge1xuICAgICAgICAgICAgc2xpZGVyLmdyb3dUbyhpZHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2xpZGVyLmNlbnRlcihpZHgpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVsaW5lLnNldFRpbWUoY2VudGVyKTtcbiAgICAgICAgcHVibGlzaFJhbmdlQ2hhbmdlKHNsaWRlci5nZXRSYW5nZSgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTbGlkZXIocmFuZ2UpIHtcbiAgICAgICAgaWYgKHV0aWxzLnJhbmdlc0VxdWFsKHJhbmdlLCBjdXJyZW50VGltZWxpbmVXaW5kb3cpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2UgPSB1dGlscy5jcmVhdGVSYW5nZShyYW5nZSk7XG4gICAgICAgIC8vIHpvb20gb3Igc2Nyb2xsIGV2ZW50P1xuICAgICAgICBpZiAocmFuZ2Uud2lkdGgoKSAhPT0gY3VycmVudFRpbWVsaW5lV2luZG93LndpZHRoKCkpIHtcbiAgICAgICAgICAgIHRpbWVsaW5lLm1vdmVUb0N1cnJlbnRUaW1lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGp1c3RTbGlkZXIocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRUaW1lbGluZVdpbmRvdyA9IHJhbmdlO1xuICAgIH1cblxuICAgIHNsaWRlci5vbigncmFuZ2VDaGFuZ2VkJywgZnVuY3Rpb24oZXYsIHJhbmdlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCgpO1xuICAgICAgICBhZGp1c3QoY2VudGVyVGltZWxpbmUsIHJhbmdlKTtcbiAgICAgICAgc2NoZWR1bGUoKTtcbiAgICB9KTtcbiAgICB0aW1lbGluZS5vbigncmFuZ2VjaGFuZ2VkJywgZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgYWRqdXN0KHVwZGF0ZVNsaWRlciwgcmFuZ2UpO1xuICAgIH0pO1xuICAgIHRpbWVsaW5lLm9uKCdzZWxlY3QnLCBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2VsZWN0ZWQgaXRlbXM6IFwiLCBwcm9wZXJ0aWVzLml0ZW1zKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjbGVhclRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdmUoYW10KSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB2YXIgYXRFbmQ7XG4gICAgICAgIGlmIChtb2RlbC5tb2RlID09PSAnY3VtdWxhdGl2ZScpIHtcbiAgICAgICAgICAgIGF0RW5kID0gc2xpZGVyLmdyb3coYW10KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0RW5kID0gc2xpZGVyLm1vdmUoYW10KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRFbmQpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmxvb3AgPT09ICdjaGFwdGVyJykge1xuICAgICAgICAgICAgICAgIHNsaWRlci5qdW1wKDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmxvb3AgPT09ICdzdG9yeScpIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFwdGVyID0gd2luZG93LmxvY2F0aW9uLmhhc2guc3BsaXQoXCIvXCIpWzJdO1xuICAgICAgICAgICAgICB2YXIgbmV4dENoYXB0ZXIgPSBjdXJyZW50Q2hhcHRlciA9PT0gdW5kZWZpbmVkIHx8IGN1cnJlbnRDaGFwdGVyID09PSBudWxsID8gMiA6IHBhcnNlSW50KGN1cnJlbnRDaGFwdGVyKSArIDE7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNoYXB0ZXJDb3VudCk7XG4gICAgICAgICAgICAgIGlmKG5leHRDaGFwdGVyIDw9IGNoYXB0ZXJDb3VudCkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJHb2luZyB0byBDaGFwdGVyIFwiLCBuZXh0Q2hhcHRlcik7XG4gICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcjL2NoYXB0ZXIvJyArIG5leHRDaGFwdGVyO1xuICAgICAgICAgICAgICAgICAgc2xpZGVyLmp1bXAoMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJHb2luZyB0byBDaGFwdGVyIDFcIik7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAnIy9jaGFwdGVyLzEnO1xuICAgICAgICAgICAgICAgIHNsaWRlci5qdW1wKDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjZW50ZXJUaW1lbGluZShzbGlkZXIuZ2V0UmFuZ2UoKSk7XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICBzY2hlZHVsZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAvLyBAdG9kbyByZXNwZWN0IHBsYXliYWNrIGludGVydmFsIG9wdGlvbnMuLi5cbiAgICAgICAgICAgIHZhciB3YWl0ID0gbW9kZWwuaW50ZXJ2YWw7XG4gICAgICAgICAgICAkLndoZW4uYXBwbHkoJCwgZGVmZXJyZWQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KG1vdmUsIHdhaXQsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBkZWZlcnJlZCB3YXMgcmVqZWN0ZWQsIGlmIGFyZ3VtZW50cyBwcm92aWRlZCwgdGhpc1xuICAgICAgICAgICAgICAgIC8vIHJlcHJlc2VudHMgYW4gZXJyb3Igc3RhdGUgc28gZG9uJ3QgY29udGludWUgcGxheWluZ1xuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwICYmIHN0YXJ0ZWQgJiYgdGltZW91dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQobW92ZSwgd2FpdCwgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWZlcnJlZCA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKCkge1xuICAgICAgICBwdWJsaXNoU3RhdGVDaGFuZ2UoXCJydW5uaW5nXCIpO1xuICAgICAgICBtb3ZlKDEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1Ymxpc2hSYW5nZUNoYW5nZShkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRhdGEgPSBzbGlkZXIuZ2V0UmFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBwdWJsaXNoKFwicmFuZ2VDaGFuZ2VcIiwgZGF0YSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVibGlzaFN0YXRlQ2hhbmdlKHN0YXRlKSB7XG4gICAgICAgIHB1Ymxpc2goXCJzdGF0ZUNoYW5nZVwiLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVibGlzaChldmVudCwgZGF0YSkge1xuICAgICAgICBldmVudHMuZXZlbnQoZXZlbnQpLnB1Ymxpc2goZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5kZWZlciA9IGZ1bmN0aW9uKGRlZmVyKSB7XG4gICAgICAgIGRlZmVycmVkLnB1c2goZGVmZXIpO1xuICAgIH07XG4gICAgdGhpcy5nZXRDdXJyZW50UmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNsaWRlci5nZXRSYW5nZSgpO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG1vZGVsLnVwZGF0ZShvcHRpb25zKTtcbiAgICAgICAgc2xpZGVyLnVwZGF0ZShtb2RlbCk7XG4gICAgICAgIHRpbWVsaW5lLnVwZGF0ZShtb2RlbCk7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHB1Ymxpc2hSYW5nZUNoYW5nZSwgMCk7XG4gICAgfTtcbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVmZXJyZWQgPSBbXTtcbiAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHJ1biwgMCk7XG4gICAgfTtcbiAgICB0aGlzLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVmZXJyZWQgPSBbXTtcbiAgICAgICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBjbGVhclRpbWVvdXQoKTtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQocHVibGlzaFN0YXRlQ2hhbmdlLCAwLCAnc3RvcHBlZCcpO1xuICAgIH07XG4gICAgdGhpcy5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCgpO1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChtb3ZlLCAwLCAxKTtcbiAgICB9O1xuICAgIHRoaXMucHJldiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoKTtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQobW92ZSwgMCwgLTEpO1xuICAgIH07XG4gICAgdGhpcy5pc1N0YXJ0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ZWQ7XG4gICAgfTtcbiAgICB0aGlzLm9uID0gZnVuY3Rpb24oZXZlbnQsIGYpIHtcbiAgICAgICAgZXZlbnRzLmV2ZW50KGV2ZW50KS5zdWJzY3JpYmUoZik7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBhbm5vdGF0aW9uIG1vZGVsOlxuICogdGl0bGVcbiAqIGNvbnRlbnRcbiAqIHRoZV9nZW9tXG4gKiBzdGFydF90aW1lXG4gKiBlbmRfdGltZVxuICogaW5fdGltZWxpbmVcbiAqIGluX21hcFxuICogYXBwZWFyYW5jZVxuICovXG5mdW5jdGlvbiBBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucykge1xuICAgIHZhciBhbm4gPSBhbm5vdGF0aW9ucyB8fCBbXTtcbiAgICBmdW5jdGlvbiBpblRpbWVsaW5lKCkge1xuICAgICAgICByZXR1cm4gYW5uLmZpbHRlcihmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5pbl90aW1lbGluZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuZ2V0VGltZUxpbmVBbm5vdGF0b25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpblRpbWVsaW5lKHRydWUpO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihhbm5vdGF0aW9ucykge1xuICAgICAgICB0aGlzLmFubiA9IGFubm90YXRpb25zO1xuICAgIH07XG59XG5cbi8qKlxuICogYm94IG1vZGVsOlxuICogdGl0bGVcbiAqIGNvbnRlbnRcbiAqIHRoZV9nZW9tXG4gKiBzdGFydF90aW1lXG4gKiBlbmRfdGltZVxuICogaW5fdGltZWxpbmVcbiAqIGluX21hcFxuICogYXBwZWFyYW5jZVxuICovXG5mdW5jdGlvbiBCb3hlcyhib3hlcykge1xuICAgIHZhciBib3ggPSBib3hlcyB8fCBbXTtcbiAgICBmdW5jdGlvbiBpblRpbWVsaW5lKCkge1xuICAgICAgICByZXR1cm4gYm94LmZpbHRlcihmdW5jdGlvbihiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsvL2IuaW5fdGltZWxpbmU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmdldFRpbWVMaW5lQm94ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGluVGltZWxpbmUodHJ1ZSk7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKGJveGVzKSB7XG4gICAgICAgIHRoaXMuYm94ID0gYm94ZXM7XG4gICAgfTtcbn1cblxuXG4vKipcbiAqIGNvbW1vbiBsaW5nbzpcbiAqIGluc3RhbnQ6IGEgc2luZ2xlIHBvaW50IGluIHRpbWVcbiAqIGV4dGVudCwgcmFuZ2U6IGhhcyBwcm9wZXJ0eSBzdGFydCBhbmQgZW5kXG4gKiBzdGFydCwgZW5kOiBsb25nIHZhbHVlcyByZXByZXNlbnRpbmcgVVRDIChpbnRlcm5hbCkgYnV0IGdlbmVyYWxseSxcbiAqICAgICAgICAgICAgIGEgZGF0ZVxuICogaW50ZXJ2YWw6IG11bHRpcGllciAqIHByZWNpc2lvblxuICogcHJlY2lzaW9uOiB0aWNrLCBzZWNvbmQsIG1pbnV0ZSwgaG91ciwgZGF5LCB3ZWVrLCBtb250aCwgeWVhclxuICogICAgICAgICAgICBub3RlOiB0aWNrIGltcGxpZXMgYSBtdWx0aXBpZXIgb2YgMVxuICogc3BlZWQ6IG9iamVjdCB3aXRoIHByb3BlcnR5IHNlY29uZHMgKGZyYW1lcmF0ZSkgYW5kIG9wdGlvbmFsIGludGVydmFsXG4gKlxuICogb3B0aW9ucyA9IHtcbiAqICAgYW5ub3RhdGlvbnM6IFsge1xuICogICAgICB0aXRsZSxcbiAqICAgICAgY29udGVudCxcbiAqICAgICAgdGhlX2dlb20sXG4gKiAgICAgIHN0YXJ0X3RpbWUsXG4gKiAgICAgIGVuZF90aW1lLFxuICogICAgICBpbl90aW1lbGluZSxcbiAqICAgICAgaW5fbWFwLFxuICogICAgICBhcHBlYXJhbmNlXG4gKiAgICAgIH0gLi4uIF0sXG4gKiAgIG1hcDogb2wuTWFwLFxuICogICBib3hlcyA6IFsge1xuICogICAgICByYW5nZSA6IHtcbiAqICAgICAgICAgIHN0YXJ0LCBlbmRcbiAqICAgICAgfSxcbiAqICAgICAgY2VudGVyOiBvbC5Db29yZGluYXRlLFxuICogICAgICByZXNvbHV0aW9uOiBmbG9hdCxcbiAqICAgICAgc3RhdGljOiBib29sZWFuLFxuICogICAgICBzcGVlZDogeyBpbnRlcnZhbCwgc2Vjb25kcyB9XG4gKiAgICAgIH0gLi4uIF0sXG4gKiAgIGRhdGEgOiBbIGRhdGUgLi4uXSB8IHJhbmdlV2l0aEludGVydmFsLFxuICogICBwbGF5YmFjayA6IHtcbiAqICAgICAgbW9kZTogaW5zdGFudCB8IHJhbmdlIHwgY3VtdWxhdGl2ZSxcbiAqICAgICAgZml4ZWQ6IGJvb2xlYW5cbiAqICAgfSxcbiAqICAgdGltZUxpbmVJZCA6IGVsZW1lbnQgaWQsXG4gKiAgIHRpbWVTbGlkZXJJZCA6IGVsZW1lbnQgaWQsXG4gKiAgIGNvbnRyb2xzSWQ6IGVsZW1lbnQgaWRcbiAqXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgLy8gQHRvZG8gZm9yIGxheWVycywgYW5ub3RhdGlvbnMgd29uJ3QgZXhpc3QgYW5kLCBpbnRpYWxseSwgd2Ugd29uJ3RcbiAgICAvLyAgICAgICBoYXZlIHBsYXliYWNrIHNldHRpbmdzIGZvciBsYXllcnMuLi5cbiAgICB2YXIgbW9kZWwsXG4gICAgICAgIGFubm90YXRpb25zID0gbmV3IEFubm90YXRpb25zKG9wdGlvbnMuYW5ub3RhdGlvbnMpLFxuICAgICAgICBib3hlcyA9IG9wdGlvbnMuYm94ZXMsXG4gICAgICAgIGNoYXB0ZXJDb3VudCA9IG9wdGlvbnMuY2hhcHRlckNvdW50LFxuICAgICAgICB0b3RhbFJhbmdlLFxuICAgICAgICBzbGlkZXIsXG4gICAgICAgIHRpbWVsaW5lLFxuICAgICAgICBtYXBDb250cm9sbGVyLFxuICAgICAgICBjb250cm9scztcbiAgICBvcHRpb25zLmJveHkgPSBuZXcgQm94ZXMob3B0aW9ucy5ib3hlcyk7XG4gICAgLy8gbWFrZSBhIGRlZmF1bHQgYm94IGlmIG5vbmUgcHJvdmlkZWRcbiAgICBpZiAodHlwZW9mIGJveGVzID09ICd1bmRlZmluZWQnIHx8IGJveGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSAwLCBkYXRhID0gbnVsbDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5kYXRhKSkge1xuICAgICAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgICAgICAgIHRvdGFsUmFuZ2UgPSB1dGlscy5jb21wdXRlUmFuZ2Uob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludGVydmFsID0gb3B0aW9ucy5kYXRhLmludGVydmFsIHx8IHV0aWxzLnBpY2tJbnRlcnZhbChvcHRpb25zLmRhdGEpO1xuICAgICAgICAgICAgdG90YWxSYW5nZSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBib3hlcyA9IFt7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICByYW5nZTogdG90YWxSYW5nZSxcbiAgICAgICAgICAgICAgICBzcGVlZDoge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbDogaW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHM6IDNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XTtcbiAgICB9XG5cbiAgICBtb2RlbCA9IG5ldyBtb2RlbHMuVGltZU1vZGVsKG9wdGlvbnMsIGJveGVzLCBhbm5vdGF0aW9ucyk7XG4gICAgc2xpZGVyID0gbmV3IHRpbWVzbGlkZXIuVGltZVNsaWRlcihvcHRpb25zLnRpbWVTbGlkZXJJZCB8fCAnc2xpZGVyJywgbW9kZWwpO1xuICAgIHRpbWVsaW5lID0gbmV3IGxpbmUuVGltZUxpbmUob3B0aW9ucy50aW1lTGluZUlkIHx8ICd0aW1lbGluZScsIG1vZGVsKTtcblxuICAgIHZhciB0aW1lQ29udHJvbHMgPSBuZXcgVGltZUNvbnRyb2xsZXIobW9kZWwsIHNsaWRlciwgdGltZWxpbmUsIGNvbnRyb2xzLCBjaGFwdGVyQ291bnQpO1xuICAgIG1hcENvbnRyb2xsZXIgPSBuZXcgbWFwcy5NYXBDb250cm9sbGVyKG9wdGlvbnMsIHRpbWVDb250cm9scyk7XG4gICAgcmV0dXJuIHRpbWVDb250cm9scztcbn1cblxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLm1hcHMgPSBtYXBzO1xuZXhwb3J0cy51dGlscyA9IHV0aWxzO1xuIiwidmFyIFRpbWVsaW5lID0gcmVxdWlyZSgndmlzL2xpYi90aW1lbGluZS9UaW1lbGluZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIERpc3BsYXkgYW5ub3RhdGlvbnMgb3Igb3RoZXIgdGVtcG9yYWwgaW5zdGFudC9leHRlbnQuIEFsbG93IGFkanVzdGluZ1xuICogdGltZSAoZWl0aGVyIGluc3RhbnQgb3IgZXh0ZW50KSBieSBkcmFnZ2luZy5cbiAqIEBwYXJhbSB7dHlwZX0gaWRcbiAqIEBwYXJhbSB7dHlwZX0gbW9kZWxcbiAqIEByZXR1cm5zIHtfTDEuVGltZUxpbmV9XG4gKi9cbmV4cG9ydHMuVGltZUxpbmUgPSBmdW5jdGlvbihpZCwgbW9kZWwpIHtcbiAgICB2YXIgZG9tID0gJChcIiNcIiArIGlkKTtcbiAgICB2YXIgdGltZWxpbmUgPSBudWxsO1xuICAgIC8vIEByZXZpc2l0IC0gaW50ZXJuYWxseSB0aGUgdGltZWxpbmUgc2VlbXMgdG8gYXBwbHkgdGhlIG9mZnNldCB3aGVuXG4gICAgLy8gICAgICAgICAgICBjcmVhdGluZyBhIHRvb2wgdGlwLCBkb2VzIHRoaXMgY2F1c2UgcHJvYmxlbXMgZWxzZXdoZXJlP1xuICAgIHZhciBvZmZzZXQgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCAqIDEwMDA7XG5cbiAgICBmdW5jdGlvbiBpbml0KG1vZGVsKSB7XG4gICAgICAgIHZhciBzdG9yeV9waW5fbGFiZWwgPSAnU3RvcnkgUGluJztcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW10sIGxheWVyX2dyb3VwcyA9IFtdLCBncm91cHMgPSBbe2lkOiBzdG9yeV9waW5fbGFiZWwsIHRpdGxlOiBzdG9yeV9waW5fbGFiZWwsIHRpbWU6IFtdfV0sIG9wdGlvbnM7XG4gICAgICAgIHZhciByYW5nZSA9IG1vZGVsLmdldFJhbmdlKCk7XG4gICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJhbmdlID0gdXRpbHMuY3JlYXRlUmFuZ2UoRGF0ZS5ub3coKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudHMgPSBtb2RlbC5hbm5vdGF0aW9ucy5nZXRUaW1lTGluZUFubm90YXRvbnMoKS5tYXAoZnVuY3Rpb24oYW5uLCBpKSB7XG4gICAgICAgICAgICAvKmpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYW5uLnN0YXJ0X3RpbWUgIT0gbnVsbCA/IGFubi5zdGFydF90aW1lIDogcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICB2YXIgZW5kID0gYW5uLmVuZF90aW1lICE9IG51bGwgPyBhbm4uZW5kX3RpbWUgOiByYW5nZS5lbmQ7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHN0YXJ0ID09PSBlbmQgPyAnYm94JyA6ICdyYW5nZSc7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBhbm4uaWQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGFubi5jb250ZW50IHx8IGFubi50aXRsZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogYW5uLnRpdGxlLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgZ3JvdXA6IHN0b3J5X3Bpbl9sYWJlbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtb2RlbC5ib3h5LmJveCkge1xuICAgICAgICAgICAgZWxlbWVudHNzID0gbW9kZWwuYm94eS5ib3gubWFwKGZ1bmN0aW9uKGJveCwgaSkge1xuICAgICAgICAgICAgICAgIC8qanNoaW50IGVxbnVsbDp0cnVlICovXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYm94LnJhbmdlICE9IG51bGwgPyBib3gucmFuZ2Uuc3RhcnQgOiByYW5nZS5zdGFydDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gYm94LnJhbmdlICE9IG51bGwgPyBib3gucmFuZ2UuZW5kIDogcmFuZ2UuZW5kO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gJ2JhY2tncm91bmQnO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnc2InICsgYm94LmlkLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBib3guY29udGVudCB8fCBib3gudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbGVtZW50cyA9IGVsZW1lbnRzLmNvbmNhdChlbGVtZW50c3MpO1xuICAgICAgICB9XG4gICAgICAgIGxheWVyX2dyb3VwcyA9ICQubWFwKG1vZGVsLnN0b3J5TGF5ZXJzLCBmdW5jdGlvbihseXIsIGkpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IGx5ci5nZXQoJ2lkJyk7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBseXIuZ2V0KCd0aXRsZScpO1xuICAgICAgICAgICAgdmFyIHRpbWVzID0gbHlyLmdldCgndGltZXMnKSB8fCBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQgKyAnOicgKyBpICsgJzonICsgaixcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IGlkLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdGltZXNbal0sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib3gnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRpdGxlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBncm91cHMgPSBncm91cHMuY29uY2F0KGxheWVyX2dyb3Vwcyk7XG5cbiAgICAgICAgdmFyIGhlaWdodCA9ICQoIGRvY3VtZW50ICkuaGVpZ2h0KCkgKiAwLjM1O1xuXG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtaW46IHJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgbWF4OiByYW5nZS5lbmQsXG4gICAgICAgICAgICBzdGFydDogcmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHJhbmdlLmVuZCxcbiAgICAgICAgICAgIGhlaWdodDogKGhlaWdodCA8IDMwMCk/IDEzODogaGVpZ2h0LFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiA0MDAsXG4gICAgICAgICAgICBzaG93Q3VycmVudFRpbWU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aW1lbGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGltZWxpbmUgPSBuZXcgVGltZWxpbmUoZG9tLmdldCgwKSwgZWxlbWVudHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGltZWxpbmUuc2V0R3JvdXBzKGdyb3Vwcyk7XG4gICAgICAgICAgICB0aW1lbGluZS5zZXRDdXJyZW50VGltZShyYW5nZS5zdGFydCk7XG4gICAgICAgICAgICB0aW1lbGluZS5hZGRDdXN0b21UaW1lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lbGluZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgdGltZWxpbmUuc2V0SXRlbXMoZWxlbWVudHMpO1xuICAgICAgICAgICAgdGltZWxpbmUuc2V0R3JvdXBzKGdyb3Vwcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdChtb2RlbCk7XG5cbiAgICAvLyB1cGRhdGVzIGZyb20gdXNlciBkcmFnZ2luZyBjdXN0b210aW1lIGJhclxuICAgIC8vIEB0b2RvIHdpbGwgbm90IHVwZGF0ZSBzbGlkZXIgY3VycmVudGx5IGF0IG1pbiB0aW1lbGluZSB6b29tIGFzIGl0XG4gICAgLy8gaXMgZGlmZmljdWx0IHRvIGRldGVybWluZSB3aGV0aGVyIGFuIGV2ZW50IGlzIGZyb20gem9vbWluZyBvciBkcmFnZ2luZ1xuICAgIC8vIG5lZWQgdG8gd3JhcCBldmVudCBoYW5kbGluZyB0byBiZXR0ZXIgZGlmZmVyZW50aWF0ZVxuICAgIHRpbWVsaW5lLm9uKCd0aW1lY2hhbmdlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aW1lbGluZS5tb3ZlVG8odGltZWxpbmUuZ2V0Q3VzdG9tVGltZSgpLCB7YW5pbWF0ZTogZmFsc2V9KTtcbiAgICB9KTtcblxuICAgIHRoaXMubW92ZVRvID0gZnVuY3Rpb24odGltZSkge1xuICAgICAgICB0aW1lbGluZS5tb3ZlVG8odGltZSwge2FuaW1hdGU6IGZhbHNlfSk7XG4gICAgICAgIHRoaXMuc2V0VGltZSh0aW1lKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0VGltZSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgdGltZWxpbmUuc2V0Q3VzdG9tVGltZSh0aW1lICsgb2Zmc2V0KTtcbiAgICB9O1xuICAgIHRoaXMuaXNXaW5kb3dNYXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnJhbmdlc0VxdWFsKHRpbWVsaW5lLmdldFdpbmRvdygpLCBtb2RlbC5nZXRSYW5nZSgpKTtcbiAgICB9O1xuICAgIHRoaXMubW92ZVRvQ3VycmVudFRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aW1lbGluZS5nZXRDdXN0b21UaW1lKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgd2lkdGggPSB1dGlscy5jcmVhdGVSYW5nZSh0aW1lbGluZS5nZXRXaW5kb3coKSkud2lkdGgoKTtcbiAgICAgICAgdmFyIHJhbmdlID0gbW9kZWwuZ2V0UmFuZ2UoKTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aW1lbGluZS5zZXRXaW5kb3cocmFuZ2Uuc3RhcnQsIHJhbmdlLnN0YXJ0ICsgd2lkdGgsIHthbmltYXRlOiBmYWxzZX0pO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQgPT09IHJhbmdlLmVuZCkge1xuICAgICAgICAgICAgdGltZWxpbmUuc2V0V2luZG93KHJhbmdlLmVuZCAtIHdpZHRoLCByYW5nZS5lbmQsIHthbmltYXRlOiBmYWxzZX0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGltZWxpbmUubW92ZVRvKGN1cnJlbnQsIHthbmltYXRlOiBmYWxzZX0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldFdpbmRvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGltZWxpbmUuZ2V0V2luZG93KCk7XG4gICAgfTtcbiAgICB0aGlzLm9uID0gZnVuY3Rpb24oZXYsIGNiKSB7XG4gICAgICAgIHRpbWVsaW5lLm9uKGV2LCBjYik7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZSA9IGluaXQ7XG4gICAgLy8gQHRvZG8gZGV0ZWN0IGNsaWNrIG9yIGRibGNsaWNrIGV2ZW50IGFuZCBwb3NpdGlvbiBiYXNlZCBvbiAlIG9mIHRvdGFsIHdpZHRoXG59O1xuIiwiLypqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCd2aXMvbm9kZV9tb2R1bGVzL21vbWVudCcpO1xuXG4vKipcbiAqIFJlYWQgdGhlIHByb3ZpZGUgb2wzIFdNUyBjYXBhYmlsaXRpZXMgZG9jdW1lbnRcbiAqIEBwYXJhbSB7dHlwZX0gY2Fwc1xuICogQHJldHVybnMgYW4gb2JqZWN0IG9mIG5hbWUtPltkYXRlfGludGVydmFsXXxpbnRlcnZhbC1yYW5nZSBtYXBwaW5nc1xuICovXG5leHBvcnRzLnJlYWRDYXBhYmlsaXRpZXNUaW1lRGltZW5zaW9ucyA9IGZ1bmN0aW9uKGNhcHMsIG9wZW5sYXllcnMyKSB7XG4gICAgdmFyIGRpbWVuc2lvbnMgPSB7fTtcbiAgICBmdW5jdGlvbiByZWFkUmFuZ2Uoc3VicGFydHMpIHtcbiAgICAgICAgaWYgKHN1YnBhcnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgMiBwYXJ0cyBmb3IgcmFuZ2UgOiAnICsgc3VicGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5nZSA9IHV0aWxzLmNyZWF0ZVJhbmdlKHN1YnBhcnRzWzBdLCBzdWJwYXJ0c1sxXSk7XG4gICAgICAgIGlmIChzdWJwYXJ0cy5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgcmFuZ2UuZHVyYXRpb24gPSBzdWJwYXJ0c1syXTtcbiAgICAgICAgICAgIHJhbmdlID0gbmV3IHV0aWxzLkludGVydmFsKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRQYXJ0KHBhcnQpIHtcbiAgICAgICAgdmFyIHN1YnBhcnRzID0gcGFydC5zcGxpdCgnLycpO1xuICAgICAgICBpZiAoc3VicGFydHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLnBhcnNlKHN1YnBhcnRzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkUmFuZ2Uoc3VicGFydHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlKGRpbWVuc2lvbikge1xuICAgICAgICB2YXIgZGltcyA9IG9wZW5sYXllcnMyID8gZGltZW5zaW9uIDogZGltZW5zaW9uLnNwbGl0KCcsJyk7XG4gICAgICAgIGlmIChkaW1zLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICB2YXIgcmVhZCA9IHJlYWRQYXJ0KGRpbXNbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiByZWFkID09PSAnbnVtYmVyJyA/IFtyZWFkXSA6IHJlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpbXMubWFwKHJlYWRQYXJ0KTtcbiAgICB9XG4gICAgaWYgKG9wZW5sYXllcnMyID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChjYXBzLmRpbWVuc2lvbnMgJiYgY2Fwcy5kaW1lbnNpb25zLnRpbWUpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSBwYXJzZShjYXBzLmRpbWVuc2lvbnMudGltZS52YWx1ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEB0b2RvIG5lZWQgdG8gbWFrZSBsYXllciBzY2FubmluZyByZWN1cnNpdmU/XG4gICAgICAgIGNhcHMudmFsdWUuY2FwYWJpbGl0eS5sYXllci5sYXllci5mb3JFYWNoKGZ1bmN0aW9uKGx5cikge1xuICAgICAgICAgICAgaWYgKGx5ci5kaW1lbnNpb24pIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zW2x5ci5uYW1lXSA9IHBhcnNlKGx5ci5leHRlbnRbMF0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRpbWVuc2lvbnM7XG59O1xuXG5mdW5jdGlvbiBUaWxlTG9hZExpc3RlbmVyKHRpbGVTdGF0dXNDYWxsYmFjaykge1xuICAgIHZhciB0aWxlc0xvYWRpbmcgPSB7fTtcbiAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCksXG4gICAgICAgICAgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gcmVtYWluaW5nVGlsZXMoKSB7XG4gICAgICAgIHZhciB0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aWxlc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIHQgKz0gdGlsZXNMb2FkaW5nW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICB2YXIgbGlzdGVuZXIgPSB7XG4gICAgICAgIGRlZmVycmVkOiBkZWZlcnJlZCxcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBzIGluIHRpbGVzTG9hZGluZykge1xuICAgICAgICAgICAgICAgIHRpbGVzTG9hZGluZ1tzXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmZXJyZWQpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTsgLy8gbm90aWZ5IHdlJ3ZlIGFib3J0ZWQgYnV0IHcvb3V0IGVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGlsZVN0YXR1c0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGlsZVN0YXR1c0NhbGxiYWNrKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0aWxlUXVldWVkOiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIG9sLnNvdXJjZS5UaWxlV01TKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gc291cmNlLmdldFVybHMoKVswXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2Ygb2wuc291cmNlLkltYWdlV01TKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gc291cmNlLmdldFVybCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGlsZXNMb2FkaW5nW2tleV0gPSAodGlsZXNMb2FkaW5nW2tleV0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgaWYgKHRpbGVTdGF0dXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRpbGVTdGF0dXNDYWxsYmFjayhyZW1haW5pbmdUaWxlcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGlsZUxvYWRlZDogZnVuY3Rpb24oZXZlbnQsIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2Ygb2wuc291cmNlLlRpbGVXTVMpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBzb3VyY2UuZ2V0VXJscygpWzBdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBvbC5zb3VyY2UuSW1hZ2VXTVMpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBzb3VyY2UuZ2V0VXJsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aWxlc0xvYWRpbmdba2V5XSAtPSAxO1xuICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHJlbWFpbmluZ1RpbGVzKCk7XG4gICAgICAgICAgICBpZiAodGlsZVN0YXR1c0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGlsZVN0YXR1c0NhbGxiYWNrKHJlbWFpbmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nID09PSAwICYmIGRlZmVycmVkKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyB3b3JrYXJvdW5kIGZvciB3aGVuIHRoZSB0aWxlcyBhcmUgY2FjaGVkIGFuZCBubyBldmVudHMgYXJlIHRyaWdnZXJlZFxuICAgIC8vIHRoaXMgYWRkcyBhIGNvbnN0YW50IChzbWFsbCkgYWRkaXRpb25hbCBkZWxheSB0byB0aGUgY3VycmVudCBwbGF5IHJhdGVcbiAgICAvLyB1bmRlciBvcHRpbWFsIChjYWNoZWQpIGNvbmRpdGlvbnNcbiAgICAvLyBAdG9kbyBjYW4gdGhpcyBzYWZlbHkgYmUgc2hvcnRlbmVkP1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGlsZXNMb2FkaW5nKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfSwxMDApO1xuICAgIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuZnVuY3Rpb24gZmlsdGVyVmVjdG9yTGF5ZXIoc3RvcnlMYXllciwgcmFuZ2UpIHtcbiAgICB2YXIgdGltZUF0dHIgPSBzdG9yeUxheWVyLmdldCgndGltZUF0dHJpYnV0ZScpLCBsX2ZlYXR1cmVzID0gc3RvcnlMYXllci5nZXQoJ2ZlYXR1cmVzJyk7XG4gICAgaWYgKHRpbWVBdHRyID09PSB1bmRlZmluZWQgfHwgbF9mZWF0dXJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmFuZ2UgPSB1dGlscy5jcmVhdGVSYW5nZShyYW5nZSk7XG4gICAgLy8gbG9vcCBvdmVyIGFsbCBvcmlnaW5hbCBmZWF0dXJlcyBhbmQgZmlsdGVyIHRoZW1cbiAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICB2YXIgbGF5ZXIgPSBzdG9yeUxheWVyLmdldExheWVyKCk7XG4gICAgdmlzaXRBbGxMYXllckZlYXR1cmVUaW1lcyhzdG9yeUxheWVyLCBmdW5jdGlvbihmLHIpIHtcbiAgICAgICAgaWYgKHJhbmdlLmludGVyc2VjdHMocikpIHtcbiAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goZik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsYXllci5nZXRTb3VyY2UoKS5jbGVhcih0cnVlKTtcbiAgICBsYXllci5nZXRTb3VyY2UoKS5hZGRGZWF0dXJlcyhmZWF0dXJlcyk7XG59XG5cblxuZnVuY3Rpb24gZmlsdGVyVmVjdG9yQm94TGF5ZXIoc3RvcnlMYXllciwgcmFuZ2UpIHtcbiAgICB2YXIgdGltZUF0dHIgPSBzdG9yeUxheWVyLmdldCgndGltZUF0dHJpYnV0ZScpLCBsX2ZlYXR1cmVzID0gc3RvcnlMYXllci5nZXQoJ2ZlYXR1cmVzJyk7XG4gICAgaWYgKHRpbWVBdHRyID09PSB1bmRlZmluZWQgfHwgbF9mZWF0dXJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmFuZ2UgPSB1dGlscy5jcmVhdGVSYW5nZShyYW5nZSk7XG4gICAgLy8gbG9vcCBvdmVyIGFsbCBvcmlnaW5hbCBmZWF0dXJlcyBhbmQgZmlsdGVyIHRoZW1cbiAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICB2aXNpdEFsbExheWVyRmVhdHVyZVRpbWVzKHN0b3J5TGF5ZXIsIGZ1bmN0aW9uKGYscikge1xuICAgICAgICBpZiAocmFuZ2UuaW50ZXJzZWN0cyhyKSkge1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChmKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZlYXR1cmVzO1xufVxuLyoqXG4gKiBDYWxsIHRoZSBwcm92aWRlZCB2aXNpdG9yIGZ1bmN0aW9uIG9uIHRoZSBzcGVjaWZpZWQgZmVhdHVyZXMgdXNpbmcgdGhlXG4gKiBjb25maWd1cmF0aW9uIHByb3ZpZGVkIGluIHRoZSBsYXllci4gVGhlIHZpc2l0b3IgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWRcbiAqIHdpdGggdGhlIGZlYXR1cmUsIGFuZCBzdGFydCBhbmQgZW5kIHRpbWUsIGlmIGFueS4gVGhlIGZlYXR1cmVzIHZpc2l0ZWQgd2lsbFxuICogYmUsIGluIG9yZGVyIG9mIHByaW9yaXR5OiB0aGUgcHJvdmlkZWQgKG9wdGlvbmFsKSBmZWF0dXJlcyBhcmd1bWVudCwgdGhlXG4gKiBsYXllciBwcm9wZXJ0eSAnZmVhdHVyZXMnLCB0aGUgbGF5ZXIncyBzb3VyY2UgZmVhdHVyZXMuXG4gKiBAcGFyYW0ge1N0b3J5TGF5ZXJ9IHN0b3J5IGxheWVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB2aXNpdG9yIGZ1bmN0aW9uKGZlYXR1cmUsIHN0YXJ0LCBlbmQpXG4gKiBAcGFyYW0ge2FycmF5fSBmZWF0dXJlcyAob3BpdG9uYWwpXG4gKi9cbmZ1bmN0aW9uIHZpc2l0QWxsTGF5ZXJGZWF0dXJlVGltZXMoc3RvcnlMYXllciwgdmlzaXRvciwgZmVhdHVyZXMpIHtcbiAgICB2YXIgc3RhcnRBdHQgPSBzdG9yeUxheWVyLmdldCgndGltZUF0dHJpYnV0ZScpO1xuICAgIHZhciBlbmRBdHQgPSBzdG9yeUxheWVyLmdldCgnZW5kVGltZUF0dHJpYnV0ZScpO1xuICAgIHZhciByYW5nZUdldHRlcjtcbiAgICB2YXIgbGF5ZXIgPSBzdG9yeUxheWVyLmdldExheWVyKCk7XG4gICAgZmVhdHVyZXMgPSBmZWF0dXJlcyB8fCBzdG9yeUxheWVyLmdldCgnZmVhdHVyZXMnKSB8fCBsYXllci5nZXRTb3VyY2UoKS5nZXRGZWF0dXJlcygpO1xuICAgIGlmIChlbmRBdHQpIHtcbiAgICAgICAgcmFuZ2VHZXR0ZXIgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICBpZihmLnJhbmdlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZi5yYW5nZTtcbiAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBmLmdldChzdGFydEF0dCk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGYuZ2V0KGVuZEF0dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmNyZWF0ZVJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlR2V0dGVyID0gZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgaWYoZi5yYW5nZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYucmFuZ2U7XG4gICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZi5nZXQoc3RhcnRBdHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5jcmVhdGVSYW5nZShzdGFydCwgc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB1dGlscy52aXNpdFJhbmdlcyhmZWF0dXJlcywgcmFuZ2VHZXR0ZXIsIHZpc2l0b3IpO1xufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIHJhbmdlIG9mIHRoZSBwcm92aWRlZCBmZWF0dXJlcyB1c2luZyB0aGUgbGF5ZXIncyBjb25maWd1cmVkXG4gKiB0aW1lYXR0cmlidXRlcy4gSWYgdGhlIG9wdGlvbmFsIGZlYXR1cmVzIGFycmF5IGlzIG9taXR0ZWQsIHRoZSBmZWF0dXJlc1xuICogd2lsbCBjb21lIGZyb20gdGhlIGxheWVyLlxuICogQHBhcmFtIHtTdG9yeUxheWVyfSBzdG9yeUxheWVyXG4gKiBAcGFyYW0ge2FycmF5fSBmZWF0dXJlcyAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyB7c3Rvcnl0b29scy5jb3JlLnRpbWUuUmFuZ2V9IHJhbmdlIG9mIGZlYXR1cmVzXG4gKi9cbmV4cG9ydHMuY29tcHV0ZVZlY3RvclJhbmdlID0gZnVuY3Rpb24oc3RvcnlMYXllciwgZmVhdHVyZXMpIHtcbiAgICB2YXIgc3RhcnRBdHQgPSBzdG9yeUxheWVyLmdldCgndGltZUF0dHJpYnV0ZScpO1xuICAgIHZhciBlbmRBdHQgPSBzdG9yeUxheWVyLmdldCgnZW5kVGltZUF0dHJpYnV0ZScpO1xuICAgIHZhciBsYXllciA9IHN0b3J5TGF5ZXIuZ2V0TGF5ZXIoKTtcbiAgICBmZWF0dXJlcyA9IGZlYXR1cmVzIHx8IHN0b3J5TGF5ZXIuZ2V0KCdmZWF0dXJlcycpIHx8IGxheWVyLmdldFNvdXJjZSgpLmdldEZlYXR1cmVzKCk7XG4gICAgcmV0dXJuIHV0aWxzLmNvbXB1dGVSYW5nZShmZWF0dXJlcywgZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gdXRpbHMuY3JlYXRlUmFuZ2UoZi5nZXQoc3RhcnRBdHQpLCBmLmdldChlbmRBdHQpKTtcbiAgICB9KTtcbn07XG5cbmV4cG9ydHMuZmlsdGVyVmVjdG9yTGF5ZXIgPSBmaWx0ZXJWZWN0b3JMYXllcjtcbmV4cG9ydHMuZmlsdGVyVmVjdG9yQm94TGF5ZXIgPSBmaWx0ZXJWZWN0b3JCb3hMYXllcjtcblxuZXhwb3J0cy5NYXBDb250cm9sbGVyID0gZnVuY3Rpb24ob3B0aW9ucywgdGltZUNvbnRyb2xzKSB7XG4gICAgdmFyIGxvYWRMaXN0ZW5lciA9IG51bGwsXG4gICAgICAgICAgdGlsZVN0YXR1c0NhbGxiYWNrID0gb3B0aW9ucy50aWxlU3RhdHVzQ2FsbGJhY2ssXG4gICAgICAgICAgc3RvcnlNYXAgPSBvcHRpb25zLnN0b3J5TWFwO1xuICAgIGZ1bmN0aW9uIGxheWVyQWRkZWQobGF5ZXIpIHtcbiAgICAgICAgdmFyIHNvdXJjZSwgaW1hZ2U7XG4gICAgICAgIHZhciBsb2FkZWQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgLy8gZ3JhYiB0aGUgYWN0aXZlIGxvYWRMaXN0ZW5lciB0byBhdm9pZCBwaGFudG9tIG9ubG9hZHNcbiAgICAgICAgICAgIC8vIHdoZW4gbGlzdGVuZXIgaXMgY2FuY2VsbGVkXG4gICAgICAgICAgICB2YXIgY3VycmVudExpc3RlbmVyID0gbG9hZExpc3RlbmVyO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaXN0ZW5lci50aWxlTG9hZGVkKGV2ZW50LCBzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgbG9hZHN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBncmFiIHRoZSBhY3RpdmUgbG9hZExpc3RlbmVyIHRvIGF2b2lkIHBoYW50b20gb25sb2Fkc1xuICAgICAgICAgICAgLy8gd2hlbiBsaXN0ZW5lciBpcyBjYW5jZWxsZWRcbiAgICAgICAgICAgIHZhciBjdXJyZW50TGlzdGVuZXIgPSBsb2FkTGlzdGVuZXI7XG4gICAgICAgICAgICBpZiAoY3VycmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExpc3RlbmVyLnRpbGVRdWV1ZWQoc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxheWVyIGluc3RhbmNlb2Ygb2wubGF5ZXIuVGlsZSAmJiBsYXllci5nZXRTb3VyY2UoKSBpbnN0YW5jZW9mIG9sLnNvdXJjZS5UaWxlV01TKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBsYXllci5nZXRTb3VyY2UoKTtcbiAgICAgICAgICAgIHNvdXJjZS5vbigndGlsZWxvYWRzdGFydCcsIGxvYWRzdGFydCk7XG4gICAgICAgICAgICBzb3VyY2Uub24oJ3RpbGVsb2FkZW5kJywgbG9hZGVkKTtcbiAgICAgICAgICAgIC8vIEB0b2RvIGhhbmRsZSBvbmVycm9yIGFuZCBjYW5jZWwgZGVmZXJyZWQgd2l0aCBhbiBleGFtcGxlXG4gICAgICAgICAgICAvLyB0byBzdG9wIGF1dG9tYXRpYyBwbGF5YmFja1xuICAgICAgICAgICAgc291cmNlLm9uKCd0aWxlbG9hZGVycm9yJywgbG9hZGVkKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXllciBpbnN0YW5jZW9mIG9sLmxheWVyLkltYWdlICYmIGxheWVyLmdldFNvdXJjZSgpIGluc3RhbmNlb2Ygb2wuc291cmNlLkltYWdlV01TKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBsYXllci5nZXRTb3VyY2UoKTtcbiAgICAgICAgICAgIHNvdXJjZS5vbignaW1hZ2Vsb2Fkc3RhcnQnLCBsb2Fkc3RhcnQpO1xuICAgICAgICAgICAgc291cmNlLm9uKCdpbWFnZWxvYWRlbmQnLCBsb2FkZWQpO1xuICAgICAgICAgICAgc291cmNlLm9uKCdpbWFnZWxvYWRlcnJvcicsIGxvYWRlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTG9hZExpc3RlbmVyKCkge1xuICAgICAgICBpZiAobG9hZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2FkTGlzdGVuZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9hZExpc3RlbmVyID0gbmV3IFRpbGVMb2FkTGlzdGVuZXIodGlsZVN0YXR1c0NhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGxvYWRMaXN0ZW5lcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVDZW50ZXJBbmRab29tKHJhbmdlKXtcbiAgICAgICAgdmFyIGN1cnJlbnRCb3hlcyA9IGZpbHRlclZlY3RvckJveExheWVyKHN0b3J5TWFwLnN0b3J5Qm94ZXNMYXllciwgcmFuZ2UpO1xuXG4gICAgICAgIGlmKGN1cnJlbnRCb3hlcyAmJiBjdXJyZW50Qm94ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRCb3ggPSBjdXJyZW50Qm94ZXNbMF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChjdXJyZW50Qm94LmNlbnRlcikge1xuICAgICAgICAgICAgICAgIHN0b3J5TWFwLmFuaW1hdGVDZW50ZXJBbmRab29tKGN1cnJlbnRCb3guY2VudGVyLCBjdXJyZW50Qm94Lnpvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGlmIChzdG9yeU1hcC5yZXR1cm5Ub0V4dGVudCkge1xuICAgICAgICAgICAgICAgIHN0b3J5TWFwLmFuaW1hdGVDZW50ZXJBbmRab29tKHN0b3J5TWFwLmdldENlbnRlcigpLCBzdG9yeU1hcC5nZXRab29tKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTGF5ZXJzKHJhbmdlKSB7XG4gICAgICAgIHZhciBzdG9yeUxheWVycyA9IHN0b3J5TWFwLmdldFN0b3J5TGF5ZXJzKCk7XG4gICAgICAgIHZhciB0aW1lID0gbmV3IERhdGUocmFuZ2Uuc3RhcnQpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIGlmIChyYW5nZS5zdGFydCAhPSByYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHRpbWUgKz0gXCIvXCIgKyBuZXcgRGF0ZShyYW5nZS5lbmQpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yeUxheWVycy5nZXRMZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RvcnlMYXllciA9IHN0b3J5TGF5ZXJzLml0ZW0oaSksIGxheWVyID0gc3RvcnlMYXllci5nZXRMYXllcigpO1xuICAgICAgICAgICAgaWYgKChsYXllciBpbnN0YW5jZW9mIG9sLmxheWVyLlRpbGUgJiYgbGF5ZXIuZ2V0U291cmNlKCkgaW5zdGFuY2VvZiBvbC5zb3VyY2UuVGlsZVdNUykgfHxcbiAgICAgICAgICAgICAgICAgIChsYXllciBpbnN0YW5jZW9mIG9sLmxheWVyLkltYWdlICYmIGxheWVyLmdldFNvdXJjZSgpIGluc3RhbmNlb2Ygb2wuc291cmNlLkltYWdlV01TKSkge1xuICAgICAgICAgICAgICAgIGlmIChzdG9yeUxheWVyLmdldCgndGltZXMnKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5nZXRTb3VyY2UoKS51cGRhdGVQYXJhbXMoe1RJTUU6IHRpbWV9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxheWVyIGluc3RhbmNlb2Ygb2wubGF5ZXIuVmVjdG9yKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyVmVjdG9yTGF5ZXIoc3RvcnlMYXllciwgcmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgaXMgYSBub24tc3RvcnkgbGF5ZXIgLSBub3QgcGFydCBvZiB0aGUgbWFpbiBjb2xsZWN0aW9uXG4gICAgICAgIGZpbHRlclZlY3RvckxheWVyKHN0b3J5TWFwLnN0b3J5UGluc0xheWVyLCByYW5nZSk7XG4gICAgICAgIGlmIChzdG9yeUxheWVycy5nZXRMZW5ndGgoKSA+PSAxKSB7XG4gICAgICAgICAgICB0aW1lQ29udHJvbHMuZGVmZXIoY3JlYXRlTG9hZExpc3RlbmVyKCkuZGVmZXJyZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgbWUubGF5ZXJzID0ge307XG4gICAgc3RvcnlNYXAuZ2V0U3RvcnlMYXllcnMoKS5vbignYWRkJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdmFyIGx5ciA9IGV2LmVsZW1lbnQsIGlkID0gbHlyLmdldCgnaWQnKTtcbiAgICAgICAgaWYgKG1lLmxheWVyc1tpZF0gIT09IHRydWUpIHtcbiAgICAgICAgICAgIGxheWVyQWRkZWQobHlyLmdldExheWVyKCkpO1xuICAgICAgICAgICAgbWUubGF5ZXJzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBzdG9yeU1hcC5nZXRTdG9yeUxheWVycygpLmZvckVhY2goZnVuY3Rpb24obHlyKSB7XG4gICAgICAgIHZhciBpZCA9IGx5ci5nZXQoJ2lkJyk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkICYmIG1lLmxheWVyc1tpZF0gIT09IHRydWUpIHtcbiAgICAgICAgICAgIGxheWVyQWRkZWQobHlyLmdldExheWVyKCkpO1xuICAgICAgICAgICAgbWUubGF5ZXJzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aW1lQ29udHJvbHMub24oJ3JhbmdlQ2hhbmdlJywgdXBkYXRlQ2VudGVyQW5kWm9vbSk7XG4gICAgdGltZUNvbnRyb2xzLm9uKCdyYW5nZUNoYW5nZScsIHVwZGF0ZUxheWVycyk7XG59O1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIEJveE1vZGVsID0gcmVxdWlyZSgnLi9ib3hlcycpLkJveE1vZGVsO1xuXG4vKipcbiAqIEB0b2RvIGRvY3VtZW50IG1lXG4gKi9cbmV4cG9ydHMuVGltZU1vZGVsID0gZnVuY3Rpb24ob3B0aW9ucywgYm94ZXMsIGFubm90YXRpb25zKSB7XG4gICAgXG4gICAgdmFyIGV2ZW50cyA9IG5ldyB1dGlscy5FdmVudHMoKSxcbiAgICAgICAgYm94TW9kZWwgPSBuZXcgQm94TW9kZWwoYm94ZXMpO1xuXG4gICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zO1xuICAgIHRoaXMuYm94ZXMgPSBib3hlcztcbiAgICB0aGlzLmJveHkgPSBvcHRpb25zLmJveHk7XG4gICAgdGhpcy5zdG9yeUxheWVycyA9IFtdO1xuICAgIHRoaXMuZml4ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm1vZGUgPSAnaW5zdGFudCc7XG4gICAgdGhpcy5pbnRlcnZhbCA9IDEwMDA7XG5cbiAgICBmdW5jdGlvbiBpbml0KG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoJ2ZpeGVkJykpIHtcbiAgICAgICAgICAgIHRoaXMuZml4ZWQgPSBvcHRzLmZpeGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoJ3NwZWVkJykgJiYgb3B0cy5zcGVlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gb3B0cy5zcGVlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KCdtb2RlJykgJiYgb3B0cy5tb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IG9wdHMubW9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eSgnYW5ub3RhdGlvbnMnKSkge1xuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9ucy51cGRhdGUob3B0cy5hbm5vdGF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoJ2JveGVzJykpIHtcbiAgICAgICAgICAgIHRoaXMuYm94eS51cGRhdGUob3B0cy5ib3hlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eSgnc3RvcnlMYXllcnMnKSkge1xuICAgICAgICAgICAgdGhpcy5zdG9yeUxheWVycyA9IG9wdHMuc3RvcnlMYXllcnM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdG9kbyBpcyB0aGUgYmVzdCBuYW1lIGZvciB0aGlzXG4gICAgICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KCdkYXRhJykpIHtcbiAgICAgICAgICAgIGJveE1vZGVsLnNldFJhbmdlKG9wdHMuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5nZXRSYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYm94TW9kZWwuZ2V0UmFuZ2UoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VG90YWxSYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBAdG9kbyBuZWVkIHRvIGFjY2VzcyBsYXllcnMgYW5kIGNhY2hlZCBkaW1lbnNpb24gZGF0YVxuICAgICAgICAvLyAgICAgICBhbmQgY29uc2lkZXIgYW5ub3RhdGlvbnM/XG4gICAgICAgIHRocm93IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9O1xuICAgIHRoaXMudXBkYXRlID0gaW5pdDtcbiAgICB0aGlzLmdldFN0ZXBzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBib3hNb2RlbC5nZXRTdGVwcygpO1xuICAgIH07XG4gICAgdGhpcy5nZXRJbmRleCA9IGZ1bmN0aW9uKGluc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIGJveE1vZGVsLmdldEluZGV4KGluc3RhbnQpO1xuICAgIH07XG4gICAgdGhpcy5nZXRSYW5nZUF0ID0gZnVuY3Rpb24oaSwgaikge1xuICAgICAgICByZXR1cm4gYm94TW9kZWwuZ2V0UmFuZ2VBdChpLCBqKTtcbiAgICB9O1xufTtcbiIsInZhciBmb3JtYXQgPSBuZXcgb2wuZm9ybWF0Lkdlb0pTT04oKTtcblxuXG52YXIgU3RvcnlQaW4gPSBmdW5jdGlvbihkYXRhLCBwcm9qZWN0aW9uKSB7XG4gICAgb2wuRmVhdHVyZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLnRoZV9nZW9tKSB7XG4gICAgICAgICAgICB2YXIgZ2VvbSA9IGRhdGEudGhlX2dlb207XG4gICAgICAgICAgICBpZiAodHlwZW9mIGdlb20gPT09ICdzdHJpbmcnIHx8ICd0eXBlJyBpbiBnZW9tKSB7XG4gICAgICAgICAgICAgICAgZ2VvbSA9IGZvcm1hdC5yZWFkR2VvbWV0cnkoZ2VvbSwge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlUHJvamVjdGlvbjogcHJvamVjdGlvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRHZW9tZXRyeShnZW9tKTtcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLnRoZV9nZW9tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0SWQoZGF0YS5pZCk7XG4gICAgfVxufTtcblN0b3J5UGluLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUob2wuRmVhdHVyZS5wcm90b3R5cGUpO1xuU3RvcnlQaW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RvcnlQaW47XG4vLyBleHBvc2UgdGhlc2Ugc2ltcGx5IGZvciB0aGUgdGltZWxpbmUgLSBpdCBkb2Vzbid0IGtub3cgdGhleSdyZSBmZWF0dXJlc1xuWydpZCcsJ3N0YXJ0X3RpbWUnLCdlbmRfdGltZScsJ2NvbnRlbnQnLCd0aXRsZScsJ2luX3RpbWVsaW5lJywnaW5fbWFwJ10uZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0b3J5UGluLnByb3RvdHlwZSwgcHJvcCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMuZ2V0KHByb3ApO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KHByb3AsIHZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG4vKlxuIHZhciBzdGFydCA9IGFubi5zdGFydF90aW1lICE9IG51bGwgPyBhbm4uc3RhcnRfdGltZSA6IHJhbmdlLnN0YXJ0O1xuIHZhciBlbmQgPSBhbm4uZW5kX3RpbWUgIT0gbnVsbCA/IGFubi5lbmRfdGltZSA6IHJhbmdlLmVuZDtcbiB2YXIgdHlwZSA9IHN0YXJ0ID09PSBlbmQgPyAnYm94JyA6ICdyYW5nZSc7XG4gcmV0dXJuIHtcbiBpZDogYW5uLmlkLFxuIHN0YXJ0OiBzdGFydCxcbiBlbmQ6IGVuZCxcbiBjb250ZW50OiBhbm4uY29udGVudCB8fCBhbm4udGl0bGUsXG4gdGl0bGU6IGFubi50aXRsZSxcbiB0eXBlOiB0eXBlXG4gfTtcbiAqL1xuXG5mdW5jdGlvbiBnZXRUaW1lKHByb3BzLCBwcm9wKSB7XG4gICAgdmFyIHZhbCA9IHByb3BzW3Byb3BdO1xuICAgIGlmICh0eXBlb2YgdmFsICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB2YWwgKj0gMTAwMDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogTG9hZCBTdG9yeVBpbnMgZnJvbSBnZW9qc29uLCByZXByb2plY3RpbmcgZnJvbSA0MzI2IHRvIHRoZSBwcm92aWRlZFxuICogcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBnZW9qc29uXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvamVjdGlvblxuICogQHJldHVybnMgYXJyYXkgb2YgU3RvcnlQaW4gZmVhdHVyZXNcbiAqL1xuZXhwb3J0cy5sb2FkRnJvbUdlb0pTT04gPSBmdW5jdGlvbihnZW9qc29uLCBwcm9qZWN0aW9uKSB7XG4gICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgICAgcHJvamVjdGlvbiA9IG9sLnByb2ouZ2V0KHByb2plY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvanNvbi5mZWF0dXJlcy5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICB2YXIgcHJvcHMgPSBmLnByb3BlcnRpZXM7XG4gICAgICAgIHByb3BzLnRoZV9nZW9tID0gZi5nZW9tZXRyeTtcbiAgICAgICAgcHJvcHMuaWQgPSBmLmlkO1xuICAgICAgICBwcm9wcy5zdGFydF90aW1lID0gZ2V0VGltZShwcm9wcywgJ3N0YXJ0X3RpbWUnKTtcbiAgICAgICAgcHJvcHMuZW5kX3RpbWUgPSBnZXRUaW1lKHByb3BzLCAnZW5kX3RpbWUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdG9yeVBpbihwcm9wcywgcHJvamVjdGlvbik7XG4gICAgfSk7XG59O1xuXG5leHBvcnRzLlN0b3J5UGluID0gU3RvcnlQaW47XG4iLCIvKipcbiAqIFZpc3VhbCBmZWVkYmFjayBvZiBjb21wbGV0ZSBzdG9yeSBsaW5lLiBBbGxvdyBkcmFnZ2luZyBvZiByYW5nZSwgY2xpY2tcbiAqIHRvIHBvc2l0aW9uLlxuICpcbiAqIFBsYXliYWNrIE1vZGVzXG4gKiAtIGZpeGVkIGN1bXVsYXRpdmUgKG1pbiBmaXhlZCBhdCAwLCBtYXggYWRqdXN0cyB3aXRoIHRpY2spXG4gKiAtIGZpeGVkIHJhbmdlIHBsYXliYWNrIChyYW5nZSBmaXhlZCwgd2luZG93IGFkanVzdHMgd2l0aCB0aWNrKVxuICogLSBmaXhlZCBpbnN0YW50IChsaWtlIGZpeGVkIHJhbmdlIGJ1dCByYW5nZSBvZiAwKVxuICogLSBvcGVuIHJhbmdlIHBsYXliYWNrIChmdWxseSBhZGp1c3RhYmxlIG1pbi9tYXgsIHdpbmRvdyBhZGp1c3RzIHdpdGggdGljaylcbiAqXG4gKiBJbnRlcm5hbCBtb2RlbFxuICogLSAwLU4gd2hlcmUgTiBpcyBlaXRoZXIgdGhlIG51bWJlciBvZiBpbnN0YW50cyBvciB0aGUgdG90YWwgbnVtYmVyIG9mIGV4dGVudHNcbiAqXG4gKiBAcGFyYW0ge3R5cGV9IGlkXG4gKiBAcGFyYW0ge3R5cGV9IG1vZGVsXG4gKiBAcmV0dXJucyB7VGltZVNsaWRlcn1cbiAqL1xuZXhwb3J0cy5UaW1lU2xpZGVyID0gZnVuY3Rpb24oaWQsIG1vZGVsKSB7XG4gICAgdmFyIHNsaWRlciA9ICQoXCIjXCIgKyBpZCk7XG4gICAgdmFyIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdmFyIHNpbmdsZVNsaWRlcjtcblxuICAgIGZ1bmN0aW9uIGluaXQobW9kZWwpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzdGVwOiAxLFxuICAgICAgICAgICAgc3RhcnQ6IFswLCAwXSxcbiAgICAgICAgICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgICAgICAgICAgY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgICAgIG1heDogbW9kZWwuZ2V0U3RlcHMoKSAtIDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiZWhhdmlvdXI6ICdkcmFnLXNuYXAnXG4gICAgICAgIH07XG4gICAgICAgIHNpbmdsZVNsaWRlciA9IGZhbHNlO1xuXG4gICAgICAgIC8qaWYgKG1vZGVsLmZpeGVkKSB7XG4gICAgICAgICAgICAvLyBAdG9kbyBuZWVkIG1vZGVsIGludGVydmFsXG4gICAgICAgIH0qL1xuXG4gICAgICAgIGlmIChtb2RlbC5tb2RlID09PSAnY3VtdWxhdGl2ZScpIHtcbiAgICAgICAgICAgIHNpbmdsZVNsaWRlciA9IHRydWU7XG4gICAgICAgICAgICBvcHRpb25zLmNvbm5lY3QgPSAnbG93ZXInO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGVsLm1vZGUgPT09ICdpbnN0YW50Jykge1xuICAgICAgICAgICAgc2luZ2xlU2xpZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIG9wdGlvbnMuY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGVsLm1vZGUgPT09ICdyYW5nZScpIHtcbiAgICAgICAgICAgIGlmIChtb2RlbC5maXhlZCkge1xuICAgICAgICAgICAgICAgIC8vIGlkZWFsbHkgd2UnZCBzdXBwb3J0IHNuYXAgYnV0IGl0IGJyZWFrcyBmaXhlZFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYmVoYXZpb3VyID0gJ2RyYWctZml4ZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJpbnZhbGlkIG1vZGVsIG1vZGUgOiBcIiArIG1vZGVsLm1vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIC8vIGhhdmUgdG8gdXBkYXRlIHZhbHVlcyBiYXNlZCBvbiBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBnZXRTbGlkZXJSYW5nZUludGVybmFsKCk7XG4gICAgICAgICAgICBpZiAoc2luZ2xlU2xpZGVyKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdGFydCA9IHJhbmdlWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VbMF0gPT09IHJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlWzFdICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhcnQgPSByYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaW5nbGVTbGlkZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHNsaWRlci5ub1VpU2xpZGVyKG9wdGlvbnMsIGluaXRpYWxpemVkKTtcbiAgICAgICAgaWYgKCFpbml0aWFsaXplZCkge1xuICAgICAgICAgICAgc2xpZGVyLmJpbmQoJ3NsaWRlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBnZXRSYW5nZSgpO1xuICAgICAgICAgICAgICAgIHNsaWRlci50cmlnZ2VyKCdyYW5nZUNoYW5nZWQnLCByYW5nZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaW5pdChtb2RlbCk7XG5cbiAgICBmdW5jdGlvbiBnZXRTbGlkZXJSYW5nZUludGVybmFsKCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBzbGlkZXIudmFsKCk7XG4gICAgICAgIGlmICghIEFycmF5LmlzQXJyYXkocmFuZ2UpKSB7XG4gICAgICAgICAgICByYW5nZSA9IHBhcnNlSW50KHJhbmdlLCAxMCk7XG4gICAgICAgICAgICByYW5nZSA9IFttb2RlbC5tb2RlID09PSAnY3VtdWxhdGl2ZScgPyAwIDogcmFuZ2UsIHJhbmdlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlID0gcmFuZ2UubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIHBhcnNlSW50KGksIDEwKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJhbmdlKCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBnZXRTbGlkZXJSYW5nZUludGVybmFsKCk7XG4gICAgICAgIHJldHVybiBtb2RlbC5nZXRSYW5nZUF0KHJhbmdlWzBdLCByYW5nZVsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGdldFNsaWRlclJhbmdlSW50ZXJuYWwoKTtcbiAgICAgICAgcmV0dXJuIHJhbmdlWzFdIC0gcmFuZ2VbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBdEVuZChsZWZ0KSB7XG4gICAgICAgIHZhciByYW5nZSA9IGdldFNsaWRlclJhbmdlSW50ZXJuYWwoKTtcbiAgICAgICAgaWYgKGxlZnQpIHtcbiAgICAgICAgICAgIHJldHVybiByYW5nZVswXSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VbMV0gPT09IG1vZGVsLmdldFN0ZXBzKCktMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZSh2YWwpIHtcbiAgICAgICAgLy8gbm9ybWFsaXplIG5vdWlzbGlkZXIudmFsIHRvIGhhbmRsZSBhcnJheVxuICAgICAgICBpZiAoc2luZ2xlU2xpZGVyKSB7XG4gICAgICAgICAgICBzbGlkZXIudmFsKHZhbFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbGlkZXIudmFsKHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNsaWRlciA9IHNsaWRlcjtcbiAgICB0aGlzLm9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNsaWRlci5vbi5hcHBseShzbGlkZXIsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICB0aGlzLmdldFNsaWRlclJhbmdlSW50ZXJuYWwgPSBnZXRTbGlkZXJSYW5nZUludGVybmFsO1xuICAgIHRoaXMuY2VudGVyID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIGhhbGYgPSBNYXRoLmZsb29yKHdpZHRoKCkgLyAyKTtcbiAgICAgICAgc2V0VmFsdWUoW2luZGV4IC0gaGFsZiwgaW5kZXggKyBoYWxmXSk7XG4gICAgfTtcbiAgICB0aGlzLm1vdmUgPSBmdW5jdGlvbihhbXQpIHtcbiAgICAgICAgdmFyIHZhbHMgID0gZ2V0U2xpZGVyUmFuZ2VJbnRlcm5hbCgpO1xuICAgICAgICB2YWxzWzBdICs9IGFtdDtcbiAgICAgICAgdmFsc1sxXSArPSBhbXQ7XG4gICAgICAgIHNldFZhbHVlKHZhbHMpO1xuICAgICAgICByZXR1cm4gaXNBdEVuZChhbXQgPCAwKTtcbiAgICB9O1xuICAgIHRoaXMuZ3JvdyA9IGZ1bmN0aW9uKGFtdCkge1xuICAgICAgICB2YXIgdmFscyA9IGdldFNsaWRlclJhbmdlSW50ZXJuYWwoKTtcbiAgICAgICAgdmFsc1sxXSArPSBhbXQ7XG4gICAgICAgIHNldFZhbHVlKHZhbHMpO1xuICAgICAgICByZXR1cm4gaXNBdEVuZChmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLmdyb3dUbyA9IGZ1bmN0aW9uKHdoZXJlKSB7XG4gICAgICAgIHZhciB2YWxzID0gZ2V0U2xpZGVyUmFuZ2VJbnRlcm5hbCgpO1xuICAgICAgICB2YWxzWzFdID0gd2hlcmU7XG4gICAgICAgIHNldFZhbHVlKHZhbHMpO1xuICAgICAgICByZXR1cm4gaXNBdEVuZChmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLmp1bXAgPSBmdW5jdGlvbih0bykge1xuICAgICAgICBzZXRWYWx1ZShbdG8sIHRvICsgd2lkdGgoKV0pO1xuICAgIH07XG4gICAgdGhpcy5nZXRSYW5nZSA9IGdldFJhbmdlO1xuICAgIHRoaXMudXBkYXRlID0gaW5pdDtcbn07XG4iLCJ2YXIgbW9tZW50ID0gcmVxdWlyZSgndmlzL25vZGVfbW9kdWxlcy9tb21lbnQnKTtcblxuLyoqXG4gKiBHZXQgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZnJvbSB0aGUgcHJvdmlkZWQgYXJnLlxuICogQHBhcmFtIGFyZyAtIGVpdGhlciBEYXRlLCByYW5nZSAocmV0dXJucyBzdGFydCksIHN0cmluZyBvciBudW1iZXJcbiAqIEByZXR1cm5zIG1pbGxpc2Vjb25kcyBvciBudWxsIGlmIG5vdGhpbmcgcHJvdmlkZWRcbiAqL1xuZ2V0VGltZSA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGFyZztcbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG4gICAgaWYgKGFyZyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGFyZy5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gRGF0ZS5wYXJzZShhcmcpO1xuICAgIH1cbiAgICAvKmpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICAgIGlmIChhcmcgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlzUmFuZ2VMaWtlKGFyZykpIHtcbiAgICAgICAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIGdldFRpbWUoYXJnLnN0YXJ0ICE9IG51bGwgPyBhcmcuc3RhcnQgOiBhcmcuZW5kKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY2FsbCBnZXRUaW1lIHdpdGggJyArIHR5cGUgKyBcIiwgOiBcIiArIGFyZyk7XG59O1xuXG5pc1JhbmdlTGlrZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIC8qanNoaW50IGVxbnVsbDp0cnVlICovXG4gICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIChvYmplY3QuaGFzT3duUHJvcGVydHkoJ3N0YXJ0JykgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KCdlbmQnKSk7XG59O1xuXG5leHBvcnRzLmlzUmFuZ2VMaWtlID0gaXNSYW5nZUxpa2U7XG5cbmV4cG9ydHMuY3JlYXRlUmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIG90aGVyID0gc3RhcnQ7XG4gICAgICAgIGlmIChpc1JhbmdlTGlrZShvdGhlcikpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gb3RoZXIuc3RhcnQ7XG4gICAgICAgICAgICBlbmQgPSBvdGhlci5lbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKmpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICAgIGlmIChzdGFydCAhPSBudWxsICYmIGVuZCAhPSBudWxsICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgPiBlbmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSYW5nZShnZXRUaW1lKHN0YXJ0KSwgZ2V0VGltZShlbmQpKTtcbn07XG5cbmV4cG9ydHMucmFuZ2VzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGdldFRpbWUoYS5zdGFydCkgPT09IGdldFRpbWUoYi5zdGFydCkgJiZcbiAgICAgICAgZ2V0VGltZShhLmVuZCkgPT09IGdldFRpbWUoYi5lbmQpO1xufTtcblxuZnVuY3Rpb24gcmFuZ2VDb250YWlucyhyYW5nZSwgdGltZSkge1xuICAgIC8qanNoaW50IGVxbnVsbDp0cnVlICovXG4gICAgaWYgKHRpbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdGltZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICAvKmpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICAgIHJldHVybiAoKHJhbmdlLnN0YXJ0ICE9IG51bGwgPyB0aW1lID49IHJhbmdlLnN0YXJ0IDogdHJ1ZSkgJiZcbiAgICAgICAgICAgKHJhbmdlLmVuZCAhPSBudWxsID8gdGltZSA8IHJhbmdlLmVuZCA6IHRydWUpKSB8fFxuICAgICAgICAgICByYW5nZS5zdGFydCA9PT0gcmFuZ2UuZW5kICYmIHRpbWUgPT09IHJhbmdlLnN0YXJ0O1xufVxuXG5leHBvcnRzLnBhcnNlSVNPRHVyYXRpb24gPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICAgIHZhciB2YWx1ZXMgPSBleHBvcnRzLmlzb0R1cmF0aW9uVG9Nb21lbnQoZHVyYXRpb24pO1xuICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24odmFsdWVzKS5hc01pbGxpc2Vjb25kcygpO1xufTtcblxuZXhwb3J0cy5JbnRlcnZhbCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIGR1cmF0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIG9wdHMgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSBvcHRzLnN0YXJ0O1xuICAgICAgICBlbmQgPSBvcHRzLmVuZDtcbiAgICAgICAgZHVyYXRpb24gPSBvcHRzLmR1cmF0aW9uO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludGVydmFsIHNob3VsZCBoYXZlIHdpZHRoJyk7XG4gICAgfVxuICAgIFJhbmdlLmNhbGwodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSBleHBvcnRzLnBhcnNlSVNPRHVyYXRpb24odGhpcy5kdXJhdGlvbik7XG4gICAgdGhpcy5vZmZzZXQgPSBleHBvcnRzLmNyZWF0ZU9mZnNldHRlcih0aGlzKTtcbn07XG5cbmZ1bmN0aW9uIFJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoaXNOYU4oc3RhcnQpIHx8IGlzTmFOKGVuZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXJ0IGFuZC9vciBlbmQnKTtcbiAgICB9XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xufVxuLyoqXG4gKiBleHRlbmQgdGhpcyBSYW5nZSBieSBhbm90aGVyLiBUaGlzIGFsZ29yaXRobSB3aWxsIGNvbnNpZGVyIGFuIG9wZW4tZW5kZWRcbiAqIHJhbmdlIHRvIHJlcHJlc2VudCBhIG1pbmltdW0gb2Ygc3RhcnQgYW5kIG1heGltdW0gb2YgZW5kLlxuICogQHBhcmFtIHt0eXBlfSBvdGhlclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuUmFuZ2UucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICBpZiAoIWlzUmFuZ2VMaWtlKG90aGVyKSkge1xuICAgICAgICBvdGhlciA9IGV4cG9ydHMuY3JlYXRlUmFuZ2Uob3RoZXIpO1xuICAgIH1cbiAgICB2YXIgc3RhcnQgPSBnZXRUaW1lKG90aGVyLnN0YXJ0KTtcbiAgICB2YXIgZW5kID0gZ2V0VGltZShvdGhlci5lbmQpO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgIH1cbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBNYXRoLm1pbih0aGlzLnN0YXJ0LCBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gTWF0aC5tYXgodGhpcy5lbmQsIGVuZCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIGlmIChpc1JhbmdlTGlrZShvdGhlcikpIHtcbiAgICAgICAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgdmFyIGVzID0gb3RoZXIuc3RhcnQgPT0gbnVsbCA/IE51bWJlci5NSU5fVkFMVUUgOiBvdGhlci5zdGFydDtcbiAgICAgICAgdmFyIGVlID0gb3RoZXIuZW5kID09IG51bGwgPyBOdW1iZXIuTUFYX1ZBTFVFIDogb3RoZXIuZW5kO1xuICAgICAgICAvLyBpbnRlcnNlY3Rpb24gaWYgKGFueSlcbiAgICAgICAgLy8gZWZmZWN0aXZlIGVuZCBpbiB0aGlzIHJhbmdlXG4gICAgICAgIC8vIGVmZmVjdGl2ZSBzdGFydCBpbiB0aGlzIHJhbmdlXG4gICAgICAgIC8vIGVmZmVjdGl2ZSBzdGFydCBiZWZvcmUgYW5kIGVmZmVjdGl2ZSBlbmQgYWZ0ZXJcbiAgICAgICAgcmV0dXJuIHJhbmdlQ29udGFpbnModGhpcywgZXMpIHx8XG4gICAgICAgICAgICByYW5nZUNvbnRhaW5zKHRoaXMsIGVlKSB8fFxuICAgICAgICAgICAgZXMgPD0gdGhpcy5zdGFydCAmJiBlZSA+PSB0aGlzLmVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmFuZ2VDb250YWlucyh0aGlzLCBnZXRUaW1lKG90aGVyKSk7XG4gICAgfVxufTtcblJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnN0YXJ0KS50b1VUQ1N0cmluZygpICsgXCIgOiBcIiArIG5ldyBEYXRlKHRoaXMuZW5kKS50b1VUQ1N0cmluZygpO1xufTtcblJhbmdlLnByb3RvdHlwZS5jZW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnN0YXJ0ICsgKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgLyAyKTtcbn07XG5SYW5nZS5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lbmQgLSB0aGlzLnN0YXJ0O1xufTtcblJhbmdlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICByZXR1cm4gdGhpcy5lbmQgPT0gbnVsbCAmJiB0aGlzLnN0YXJ0ID09IG51bGw7XG59O1xuZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuXG5cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBvdmVyYWxsIHJhbmdlIG9mIHByb3ZpZGVkIGFyZ3MuIEFyZ3MgbWF5IGJlIGFuIGFycmF5IG9mOlxuICogZGF0ZSBvciBsb25nLCByYW5nZSwgb2JqZWN0IHdpdGggcHJvcGVydHkvZnVuY3Rpb24geWllbGRpbmcgcmFuZ2UgZm9yIHRoZVxuICogb2JqZWN0LlxuICogQHBhcmFtIHt0eXBlfSBhcmdzXG4gKiBAcmV0dXJucyByYW5nZSB3aWxsIGhhdmUgc3RhcnQvZW5kIGV2ZW4gaWYgdGhlIHNhbWUgdGltZS5cbiAqL1xuZXhwb3J0cy5jb21wdXRlUmFuZ2UgPSBmdW5jdGlvbihhcmdzLCByYW5nZUdldHRlcikge1xuICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShudWxsLCBudWxsKTtcbiAgICBleHBvcnRzLnZpc2l0UmFuZ2VzKGFyZ3MsIHJhbmdlR2V0dGVyLCBmdW5jdGlvbihhcmcsIHIpIHtcbiAgICAgICAgcmFuZ2UuZXh0ZW5kKHIpO1xuICAgIH0pO1xuICAgIC8qanNoaW50IGVxbnVsbDp0cnVlICovXG4gICAgaWYgKHJhbmdlLnN0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgcmFuZ2Uuc3RhcnQgPSByYW5nZS5lbmQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5lbmQgPT0gbnVsbCkge1xuICAgICAgICByYW5nZS5lbmQgPSByYW5nZS5zdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xufTtcblxuZXhwb3J0cy52aXNpdFJhbmdlcyA9IGZ1bmN0aW9uKG9iamVjdHMsIHJhbmdlR2V0dGVyLCB2aXNpdG9yKSB7XG4gICAgdmFyIGdldFJhbmdlO1xuICAgIGlmICh0eXBlb2YgcmFuZ2VHZXR0ZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZ2V0UmFuZ2UgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RbcmFuZ2VHZXR0ZXJdO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJhbmdlR2V0dGVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZ2V0UmFuZ2UgPSByYW5nZUdldHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXRSYW5nZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzUmFuZ2VMaWtlKG9iamVjdCkgPyBvYmplY3QgOiBleHBvcnRzLmNyZWF0ZVJhbmdlKG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG9iamVjdHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gb2JqZWN0c1tpXTtcbiAgICAgICAgdmlzaXRvcihvYmplY3QsIGdldFJhbmdlKG9iamVjdCkpO1xuICAgIH1cbn07XG5cbi8qKiBmb3IgdGhlIGdpdmVuIHdoYXQsIGZpbmQgdGhlIGluZGV4IGluIHRoZSBpdGVtcyB0aGF0IHdoYXQgaXMgY2xvc2VzdFxuICogdG8uIGl0ZW1zIG11c3QgYmUgc29ydGVkLiBUaGUgbG93ZXN0IGNsb3Nlc3QgdmFsdWUgcG9zc2libGUgaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydHMuYmluYXJ5U2VhcmNoID0gZnVuY3Rpb24oaXRlbXMsIHdoYXQpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIHZhciBzdG9wID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgbWlkID0gc3RvcCArIHN0YXJ0IC8gMiB8IDA7XG4gICAgdmFyIHZhbDtcbiAgICBpZiAod2hhdCA8IGl0ZW1zWzBdKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAod2hhdCA+IGl0ZW1zW3N0b3BdKSB7XG4gICAgICAgIHJldHVybiBpdGVtcy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICB3aGlsZSAoKHZhbCA9IGl0ZW1zW21pZF0pICE9PSB3aGF0ICYmIHN0YXJ0IDwgc3RvcCkge1xuICAgICAgICBpZiAod2hhdCA+IHZhbCkge1xuICAgICAgICAgICAgaWYgKHdoYXQgPCBpdGVtc1ttaWQgKyAxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod2hhdCA8IHZhbCkge1xuICAgICAgICAgICAgaWYgKHdoYXQgPiBpdGVtc1ttaWQgLSAxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaWQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcCA9IG1pZCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgbWlkID0gc3RvcCArIHN0YXJ0IC8gMiB8IDA7XG4gICAgfVxuICAgIHJldHVybiBtaWQ7XG59O1xuXG5leHBvcnRzLmZpbmQgPSBmdW5jdGlvbihpdGVtcywgd2hhdCkge1xuICAgIGlmICh3aGF0IDwgaXRlbXNbMF0pIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGlmICh3aGF0ID49IGl0ZW1zW2ldICYmIHdoYXQgPCBpdGVtc1tpICsgMV0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtcy5sZW5ndGggLSAxO1xufTtcblxuZXhwb3J0cy5FdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdG9waWNzID0ge307XG5cbiAgICAvLyBAdG9kbyBpbnRyb2R1Y2Ugc2V0dGluZyB0b3BpY3Mgd2l0aCBhcmd1bWVudHMgYW5kIGxvZ2dpbmcvZXhjZXB0aW9uXG4gICAgLy8gb24gdW4tZmlyZWQgZXZlbnRcblxuICAgIGZ1bmN0aW9uIGV2ZW50KGlkKSB7XG4gICAgICAgIHZhciBjYWxsYmFja3MsIG1ldGhvZCxcbiAgICAgICAgICAgICAgICB0b3BpYyA9IGlkICYmIHRvcGljc1sgaWQgXTtcbiAgICAgICAgaWYgKCF0b3BpYykge1xuICAgICAgICAgICAgY2FsbGJhY2tzID0galF1ZXJ5LkNhbGxiYWNrcygpO1xuICAgICAgICAgICAgdG9waWMgPSB7XG4gICAgICAgICAgICAgICAgcHVibGlzaDogY2FsbGJhY2tzLmZpcmUsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlOiBjYWxsYmFja3MuYWRkLFxuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBjYWxsYmFja3MucmVtb3ZlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzWyBpZCBdID0gdG9waWM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGljO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50OiBldmVudFxuICAgIH07XG59O1xuXG5leHBvcnRzLnBpY2tJbnRlcnZhbCA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgdmFyIGludGVydmFscyA9IFtcbiAgICAgICAgbW9tZW50LmR1cmF0aW9uKDEsICdzZWNvbmRzJykuYXNNaWxsaXNlY29uZHMoKSxcbiAgICAgICAgbW9tZW50LmR1cmF0aW9uKDEsICdtaW51dGVzJykuYXNNaWxsaXNlY29uZHMoKSxcbiAgICAgICAgbW9tZW50LmR1cmF0aW9uKDEsICdob3VycycpLmFzTWlsbGlzZWNvbmRzKCksXG4gICAgICAgIG1vbWVudC5kdXJhdGlvbigxLCAnZGF5cycpLmFzTWlsbGlzZWNvbmRzKCksXG4gICAgICAgIG1vbWVudC5kdXJhdGlvbigxLCAnd2Vla3MnKS5hc01pbGxpc2Vjb25kcygpLFxuICAgICAgICBtb21lbnQuZHVyYXRpb24oMSwgJ21vbnRocycpLmFzTWlsbGlzZWNvbmRzKCksXG4gICAgICAgIG1vbWVudC5kdXJhdGlvbigxLCAneWVhcnMnKS5hc01pbGxpc2Vjb25kcygpXG4gICAgXTtcbiAgICByZXR1cm4gaW50ZXJ2YWxzW01hdGgubWF4KGV4cG9ydHMuZmluZChpbnRlcnZhbHMsIHJhbmdlLndpZHRoKCkpIC0gMSwgMCldO1xufTtcblxuZXhwb3J0cy5nZXRUaW1lID0gZ2V0VGltZTtcblxuLyoqXG4gKiBSZWFkIGFuIGlzbyBkdXJhdGlvbiBpbnRvIGEgbW9tZW50LmpzIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkdXJhdGlvblxuICogQHJldHVybnMge29iamVjdH0gd2l0aCBtb21lbnQuanMgaW5mb1xuICovXG5leHBvcnRzLmlzb0R1cmF0aW9uVG9Nb21lbnQgPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbi5jaGFyQXQoMCkgIT0gJ1AnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgUCBhcyBzdGFydGluZyBkdXJhdGlvbiA6ICcgKyBkdXJhdGlvbik7XG4gICAgfVxuICAgIHZhciBwYXR0ZXJuID0gLyhcXGQrKShcXHcpL2c7XG4gICAgdmFyIGRhdGUgPSBudWxsLCB0aW1lID0gbnVsbCwgdmFsdWVzID0ge307XG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbi5zdWJzdHJpbmcoMSk7XG4gICAgaWYgKGR1cmF0aW9uLmluZGV4T2YoJ1QnKSA+PSAwKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGR1cmF0aW9uLnNwbGl0KCdUJyk7XG4gICAgICAgIGRhdGUgPSBwYXJ0c1swXTtcbiAgICAgICAgdGltZSA9IHBhcnRzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGUgPSBkdXJhdGlvbjtcbiAgICB9XG4gICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgICdZJzogJ3llYXJzJyxcbiAgICAgICAgJ00nOiAnbW9udGhzJyxcbiAgICAgICAgJ1cnOiAnd2Vla3MnLFxuICAgICAgICAnRCc6ICdkYXlzJyxcbiAgICAgICAgJ0gnOiAnaG91cnMnLFxuICAgICAgICAnbSc6ICdtaW51dGVzJyxcbiAgICAgICAgJ1MnOiAnc2Vjb25kcydcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBhcnNlKGNodW5rLCB0aW1lKSB7XG4gICAgICAgIGZ1bmN0aW9uIHJlYWQoYW1vdW50LCBwYXJ0KSB7XG4gICAgICAgICAgICBpZiAodGltZSAmJiBwYXJ0ID09ICdNJykge1xuICAgICAgICAgICAgICAgIHBhcnQgPSAnbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWFwcGVkVG8gPSBtYXBwaW5nW3BhcnRdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXBwZWRUbyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCd1bmtub3duIGR1cmF0aW9uIHNwZWNpZmllciA6ICcgKyBwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlc1ttYXBwZWRUb10gPSBwYXJzZUZsb2F0KGFtb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHdoaWxlICgobmV4dCA9IHBhdHRlcm4uZXhlYyhjaHVuaykpICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZWFkKG5leHRbMV0sIG5leHRbMl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRlICE9PSBudWxsKSB7XG4gICAgICAgIHBhcnNlKGRhdGUsIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKHRpbWUgIT09IG51bGwpIHtcbiAgICAgICAgcGFyc2UodGltZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59O1xuXG4vKipcbiAqIEdldCBhIGZ1bmN0aW9uIGZvciB0aGUgcHJvdmlkZWQgZHVyYXRpb24gdGhhdCBjb21wdXRlcyBhIG5ldyB0aW1lc3RhbXAgYmFzZWQgb24gYVxuICogcHJvdmlkZWQgZGF0ZSBhbmQgb3B0aW9uYWwgbXVsdGlwbGllciAobmVnYXRpdmUgZm9yIHJldmVyc2UpLlxuICogQHBhcmFtIHtzdHJpbmd9IGlzbyBkdXJhdGlvblxuICogQHJldHVybnMge2Z1bmN0aW9ufSBvZmZzZXR0ZXIodGltZXN0YW1wLCBtdWx0aXBsaWVyPTEpXG4gKi9cbmV4cG9ydHMuY3JlYXRlT2Zmc2V0dGVyID0gZnVuY3Rpb24oaW50ZXJ2YWxPckR1cmF0aW9uKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gdHlwZW9mIGludGVydmFsT3JEdXJhdGlvbiA9PT0gJ3N0cmluZycgPyBpbnRlcnZhbE9yRHVyYXRpb246IGludGVydmFsT3JEdXJhdGlvbi5kdXJhdGlvbjtcbiAgICB2YXIgdmFsdWVzID0gZXhwb3J0cy5pc29EdXJhdGlvblRvTW9tZW50KGR1cmF0aW9uKTtcbiAgICAvLyBhcyBvZiB3cml0aW5nLCBtb21lbnQgYXNzdW1lcyB5PTM2NWQgYW5kIG09MzBkIHJlc3VsdGluZyBpbiBzbG93XG4gICAgLy8gZGF5IG9mIG1vbnRoIHNoaWZ0cyB0aGF0IGJyZWFrIHRpY2tzIGZyb20gbWF0Y2hpbmdcbiAgICAvLyBzbyB3ZSB0YWtlIGNhcmUgb2YgdGhpcyB1c2luZyBhIG1vcmUgYWNjdXJhdGUgYXBwcm9hY2hcbiAgICAvLyAqKiB0aGUgY3VycmVudCBhcHByb2FjaCBicmVha3MgZG93biBpZiB0aGUgZGF5IG9mIG1vbnRoIGlzIGdyZWF0ZXIgdGhhblxuICAgIC8vIDI4IGFuZCBkYXkgb2YgbW9udGggd2lsbCBubyBsb25nZXIgYmUgcmV0YWluZWQgKHdpbGwgc2hpZnQpXG4gICAgaWYgKCd5ZWFycycgaW4gdmFsdWVzIHx8ICdtb250aHMnIGluIHZhbHVlcykge1xuICAgICAgICB2YXIgeWVhcnMgPSB2YWx1ZXMueWVhcnM7XG4gICAgICAgIHZhciBtb250aHMgPSB2YWx1ZXMubW9udGhzO1xuICAgICAgICB2YWx1ZXMueWVhcnMgPSAwO1xuICAgICAgICB2YWx1ZXMubW9udGhzID0gMDtcbiAgICAgICAgdmFyIG1pbGxpcyA9IG1vbWVudC5kdXJhdGlvbih2YWx1ZXMpLmFzTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0cywgbXVsdCkge1xuICAgICAgICAgICAgbXVsdCA9IG11bHQgfHwgMTtcbiAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUodHMpO1xuICAgICAgICAgICAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgICAgIHZhciB5ID0gZC5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgaWYgKHllYXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB5ICs9IG11bHQgKiB5ZWFycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtID0gZC5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgaWYgKG1vbnRocyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbSArPSBtdWx0ICogbW9udGhzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZC5zZXRVVENGdWxsWWVhcih5LCBtKTtcbiAgICAgICAgICAgIHJldHVybiBkLmdldFRpbWUoKSArIChtdWx0ICogbWlsbGlzKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gbW9tZW50LmR1cmF0aW9uKHZhbHVlcykuYXNNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRzLCBtdWx0KSB7XG4gICAgICAgICAgICBtdWx0ID0gbXVsdCB8fCAxO1xuICAgICAgICAgICAgcmV0dXJuIHRzICsgKG11bHQgKiBvZmZzZXQpO1xuICAgICAgICB9O1xuICAgIH1cbn07XG4iLCIvLyd1c2Ugc3RyaWN0JztcbmV4cG9ydHMuU0xEU3R5bGVDb252ZXJ0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZW5lcmF0ZVN0eWxlOiBmdW5jdGlvbihzdHlsZSwgbGF5ZXJOYW1lLCBhc1N0cmluZykge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29udmVydEpTT04oc3R5bGUsIGxheWVyTmFtZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IG5ldyBvd3Nqcy5Kc29uaXguQ29udGV4dChbb3dzanMubWFwcGluZ3MuWExpbmtfMV8wLCBvd3Nqcy5tYXBwaW5ncy5GaWx0ZXJfMV8wXzAsIG93c2pzLm1hcHBpbmdzLkdNTF8yXzFfMiwgb3dzanMubWFwcGluZ3MuU0xEXzFfMF8wXSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VQcmVmaXhlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnOiAneGxpbmsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvc2xkJzogJ3NsZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2MnOiAnb2djJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJzaGFsbGVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1hcnNoYWxsZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc1N0cmluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcnNoYWxsZXIubWFyc2hhbFN0cmluZyhjb25maWcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXJzaGFsbGVyLm1hcnNoYWxEb2N1bWVudChjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVGaWxsOiBmdW5jdGlvbihzdHlsZSwgc3R5bGVSdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNzc1BhcmFtZXRlcjogW3tcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2ZpbGwnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbKHN0eWxlUnVsZSAmJiBzdHlsZVJ1bGUuc3R5bGUuc3ltYm9sLmZpbGxDb2xvcikgPyBzdHlsZVJ1bGUuc3R5bGUuc3ltYm9sLmZpbGxDb2xvciA6IHN0eWxlLnN5bWJvbC5maWxsQ29sb3JdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZmlsbC1vcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogW1N0cmluZyhzdHlsZVJ1bGUgPyAoc3R5bGVSdWxlLnN0eWxlLnN5bWJvbC5maWxsT3BhY2l0eSB8fCAxMDApIC8gMTAwIDogKHN0eWxlLnN5bWJvbC5maWxsT3BhY2l0eSB8fCAxMDApIC8gMTAwKV1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlU3Ryb2tlOiBmdW5jdGlvbihzdHlsZSwgc3R5bGVSdWxlKSB7XG4gICAgICAgICAgICB2YXIgZGFzaEFycmF5O1xuICAgICAgICAgICAgaWYgKHN0eWxlLnN0cm9rZS5zdHJva2VTdHlsZSA9PT0gJ2Rhc2hlZCcpIHtcbiAgICAgICAgICAgICAgICBkYXNoQXJyYXkgPSAnNSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLnN0cm9rZS5zdHJva2VTdHlsZSA9PT0nZG90dGVkJykge1xuICAgICAgICAgICAgICAgIGRhc2hBcnJheSA9ICcxIDInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjc3NQYXJhbWV0ZXI6IFt7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzdHJva2UnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbKHN0eWxlUnVsZSAmJiBzdHlsZVJ1bGUuc3R5bGUuc3Ryb2tlLnN0cm9rZUNvbG9yKSA/IHN0eWxlUnVsZS5zdHlsZS5zdHJva2Uuc3Ryb2tlQ29sb3IgOiBzdHlsZS5zdHJva2Uuc3Ryb2tlQ29sb3JdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc3Ryb2tlLXdpZHRoJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogc3R5bGUuc3Ryb2tlLnN0cm9rZVdpZHRoID8gW1N0cmluZyhzdHlsZS5zdHJva2Uuc3Ryb2tlV2lkdGgpXSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogc3R5bGUuc3Ryb2tlLnN0cm9rZU9wYWNpdHkgPyBbU3RyaW5nKHN0eWxlLnN0cm9rZS5zdHJva2VPcGFjaXR5IC8gMTAwKV0gOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzdHJva2UtZGFzaGFycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogZGFzaEFycmF5ID8gW2Rhc2hBcnJheV0gOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlUG9seWdvblN5bWJvbGl6ZXI6IGZ1bmN0aW9uKHN0eWxlLCBzdHlsZVJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBmaWxsID0gdGhpcy5jcmVhdGVGaWxsKHN0eWxlLCBzdHlsZVJ1bGUpO1xuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IHRoaXMuY3JlYXRlU3Ryb2tlKHN0eWxlKTtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJ0OiAnUG9seWdvblN5bWJvbGl6ZXInLFxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9zbGRcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb247XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVBvaW50U3ltYm9saXplcjogZnVuY3Rpb24oc3R5bGUsIHN0eWxlUnVsZSkge1xuICAgICAgICAgICAgdmFyIGZpbGwgPSB0aGlzLmNyZWF0ZUZpbGwoc3R5bGUsIHN0eWxlUnVsZSk7IFxuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IHRoaXMuY3JlYXRlU3Ryb2tlKHN0eWxlKTtcbiAgICAgICAgICAgIHZhciBncmFwaGljT3JNYXJrO1xuICAgICAgICAgICAgaWYgKHN0eWxlLnN5bWJvbCAmJiBzdHlsZS5zeW1ib2wuZ3JhcGhpYykge1xuICAgICAgICAgICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgICAgICAgICAgLy8gQHRvZG8gYXBwZW5kaW5nIGljb24gY29tbW9ucyBhdHRyaWJ1dGVzIHNob3VsZCBnbyBlbHNld2hlcmVcbiAgICAgICAgICAgICAgICBhLmhyZWYgPSBzdHlsZS5zeW1ib2wuZ3JhcGhpYyArICc/JyArXG4gICAgICAgICAgICAgICAgICAgICdmaWxsPScgKyBlbmNvZGVVUklDb21wb25lbnQoKHN0eWxlUnVsZSAmJiBzdHlsZVJ1bGUuc3R5bGUuc3ltYm9sLmZpbGxDb2xvcikgPyBzdHlsZVJ1bGUuc3R5bGUuc3ltYm9sLmZpbGxDb2xvciA6IHN0eWxlLnN5bWJvbC5maWxsQ29sb3IpICtcbiAgICAgICAgICAgICAgICAgICAgXCImc3Ryb2tlPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0eWxlLnN0cm9rZS5zdHJva2VDb2xvcik7XG4gICAgICAgICAgICAgICAgZ3JhcGhpY09yTWFyayA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBUWVBFX05BTUU6IFwiU0xEXzFfMF8wLkV4dGVybmFsR3JhcGhpY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBcImltYWdlL3N2Zyt4bWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ubGluZVJlc291cmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogYS5ocmVmXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncmFwaGljT3JNYXJrID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIFRZUEVfTkFNRTogXCJTTERfMV8wXzAuTWFya1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2VsbEtub3duTmFtZTogc3R5bGUuc3ltYm9sICYmIHN0eWxlLnN5bWJvbC5zaGFwZSB8fCAnY2lyY2xlJ1xuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIGlmIChzdHlsZS5zeW1ib2wgJiYgYW5ndWxhci5pc0RlZmluZWQoc3R5bGUuc3ltYm9sLmZpbGxPcGFjaXR5KSkge1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBNYXRoLm1heCgwLjAxLCBzdHlsZS5zeW1ib2wuZmlsbE9wYWNpdHkpIC8gMTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogJ1BvaW50U3ltYm9saXplcicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3NsZFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBncmFwaGljOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlcm5hbEdyYXBoaWNPck1hcms6IGdyYXBoaWNPck1hcmssXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW1N0cmluZyhvcGFjaXR5KV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW1N0cmluZyhzdHlsZVJ1bGUgJiYgc3R5bGVSdWxlLnN0eWxlLnN5bWJvbCAmJiBzdHlsZVJ1bGUuc3R5bGUuc3ltYm9sLnNpemUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5zeW1ib2wgJiYgc3R5bGUuc3ltYm9sLnNpemUgfHwgMTApXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBzdHlsZS5zeW1ib2wgJiYgc3R5bGUuc3ltYm9sLnJvdGF0aW9uQXR0cmlidXRlID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtzdHlsZS5zeW1ib2wucm90YXRpb25Vbml0cyA9PT0gJ2RlZ3JlZXMnID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcnQ6IFwiUHJvcGVydHlOYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW3N0eWxlLnN5bWJvbC5yb3RhdGlvbkF0dHJpYnV0ZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJEaXZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJ0OiBcIlByb3BlcnR5TmFtZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW3N0eWxlLnN5bWJvbC5yb3RhdGlvbkF0dHJpYnV0ZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcnQ6IFwiRGl2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJGdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInBpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJMaXRlcmFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtcIjM2MFwiXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlTGluZVN5bWJvbGl6ZXI6IGZ1bmN0aW9uKHN0eWxlLCBzdHlsZVJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcnQ6ICdMaW5lU3ltYm9saXplcicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3NsZFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHRoaXMuY3JlYXRlU3Ryb2tlKHN0eWxlLCBzdHlsZVJ1bGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlVGV4dFN5bWJvbGl6ZXI6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgZm9udEZhbWlseTtcbiAgICAgICAgICAgIHZhciBzdHlsZUZvbnRGYW1pbHkgPSBzdHlsZS5sYWJlbC5mb250RmFtaWx5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoc3R5bGVGb250RmFtaWx5ID09PSAnc2VyaWYnKSB7XG4gICAgICAgICAgICAgICAgZm9udEZhbWlseSAgPSAnU2VyaWYnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZUZvbnRGYW1pbHkgPT09ICdzYW5zLXNlcmlmJykge1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgPSAnU2Fuc1NlcmlmJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGVGb250RmFtaWx5ID09PSAnY3Vyc2l2ZScpIHtcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5ID0gJ0NvbWljIFNhbnMgTVMnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZUZvbnRGYW1pbHkgPT09ICdtb25vc3BhY2UnKSB7XG4gICAgICAgICAgICAgICAgZm9udEZhbWlseSA9ICdDb3VyaWVyIE5ldyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJ0OiAnVGV4dFN5bWJvbGl6ZXInLFxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9zbGRcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3NzUGFyYW1ldGVyOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZmlsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtzdHlsZS5sYWJlbC5maWxsQ29sb3JdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGFsbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1BhcmFtZXRlcjogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2ZpbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbJyNGRkZGRkYnXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogWycxJ11cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxQbGFjZW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVQbGFjZW1lbnQ6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1BhcmFtZXRlcjogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2ZvbnQtZmFtaWx5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogZm9udEZhbWlseSA/IFtmb250RmFtaWx5XTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZm9udC1zaXplJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW1N0cmluZyhzdHlsZS5sYWJlbC5mb250U2l6ZSldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZm9udC1zdHlsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtzdHlsZS5sYWJlbC5mb250U3R5bGVdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZm9udC13ZWlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbc3R5bGUubGFiZWwuZm9udFdlaWdodF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJ0OiBcIlByb3BlcnR5TmFtZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtzdHlsZS5sYWJlbC5hdHRyaWJ1dGVdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB2ZW5kb3JPcHRpb246IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbWF4RGlzcGxhY2VtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICc0MCdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2F1dG9XcmFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICc0MCdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3NwYWNlQXJvdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcwJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZm9sbG93TGluZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnZmFsc2UnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdncm91cCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAneWVzJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZ29vZG5lc3NPZkZpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnMC4yJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY29uZmxpY3RSZXNvbHV0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnZlcnRKU09OOiBmdW5jdGlvbihzdHlsZSwgbGF5ZXJOYW1lKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9zbGQnLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcnQ6ICdTdHlsZWRMYXllckRlc2NyaXB0b3InXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBcIjEuMC4wXCIsXG4gICAgICAgICAgICAgICAgbmFtZWRMYXllck9yVXNlckxheWVyOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgVFlQRV9OQU1FOiBcIlNMRF8xXzBfMC5OYW1lZExheWVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBsYXllck5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lZFN0eWxlT3JVc2VyU3R5bGU6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRZUEVfTkFNRTogXCJTTERfMV8wXzAuVXNlclN0eWxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVUeXBlU3R5bGU6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcnVsZSwgcnVsZUNvbnRhaW5lciA9IHJlc3VsdC52YWx1ZS5uYW1lZExheWVyT3JVc2VyTGF5ZXJbMF0ubmFtZWRTdHlsZU9yVXNlclN0eWxlWzBdLmZlYXR1cmVUeXBlU3R5bGVbMF0ucnVsZTtcbiAgICAgICAgICAgIGlmIChzdHlsZS5ydWxlcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHN0eWxlLnJ1bGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlUnVsZSA9IHN0eWxlLnJ1bGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVSdWxlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyaXNvbk9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJQcm9wZXJ0eUlzRXF1YWxUb1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJQcm9wZXJ0eU5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW3N0eWxlLmNsYXNzaWZ5LmF0dHJpYnV0ZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcnQ6IFwiTGl0ZXJhbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbU3RyaW5nKHN0eWxlUnVsZS52YWx1ZSldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVJ1bGUucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJpc29uT3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJ0OiBcIlByb3BlcnR5SXNCZXR3ZWVuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcnQ6IFwiUHJvcGVydHlOYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtzdHlsZS5jbGFzc2lmeS5hdHRyaWJ1dGVdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyQm91bmRhcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJ0OiBcIkxpdGVyYWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW1N0cmluZyhzdHlsZVJ1bGUucmFuZ2UubWluKV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckJvdW5kYXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJMaXRlcmFsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtTdHJpbmcoc3R5bGVSdWxlLnJhbmdlLm1heCldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogc3R5bGVSdWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdHlsZVJ1bGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9saXplcjogW11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLmdlb21UeXBlID09PSBcInBvaW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuc3ltYm9saXplci5wdXNoKHRoaXMuY3JlYXRlUG9pbnRTeW1ib2xpemVyKHN0eWxlLCBzdHlsZVJ1bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5nZW9tVHlwZSA9PT0gXCJsaW5lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuc3ltYm9saXplci5wdXNoKHRoaXMuY3JlYXRlTGluZVN5bWJvbGl6ZXIoc3R5bGUsIHN0eWxlUnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLmdlb21UeXBlID09PSBcInBvbHlnb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5zeW1ib2xpemVyLnB1c2godGhpcy5jcmVhdGVQb2x5Z29uU3ltYm9saXplcihzdHlsZSwgc3R5bGVSdWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLmxhYmVsICYmIHN0eWxlLmxhYmVsLmF0dHJpYnV0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5zeW1ib2xpemVyLnB1c2godGhpcy5jcmVhdGVUZXh0U3ltYm9saXplcihzdHlsZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVDb250YWluZXIucHVzaChydWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBydWxlLCBtdWx0aXBsZSBzeW1ib2xpemVyc1xuICAgICAgICAgICAgICAgIHJ1bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbGl6ZXI6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBydWxlQ29udGFpbmVyLnB1c2gocnVsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmdlb21UeXBlID09PSAncG9pbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuc3ltYm9saXplci5wdXNoKHRoaXMuY3JlYXRlUG9pbnRTeW1ib2xpemVyKHN0eWxlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5nZW9tVHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuc3ltYm9saXplci5wdXNoKHRoaXMuY3JlYXRlTGluZVN5bWJvbGl6ZXIoc3R5bGUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLmdlb21UeXBlID09PSAncG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5zeW1ib2xpemVyLnB1c2godGhpcy5jcmVhdGVQb2x5Z29uU3ltYm9saXplcihzdHlsZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUubGFiZWwgJiYgc3R5bGUubGFiZWwuYXR0cmlidXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuc3ltYm9saXplci5wdXNoKHRoaXMuY3JlYXRlVGV4dFN5bWJvbGl6ZXIoc3R5bGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iLCJleHBvcnRzLlN0eWxlQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0NvbXBsZXRlOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICAgICAgaWYgKHN0eWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5jbGFzc2lmeSkge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5jbGFzc2lmeS5tZXRob2QgPT09IFwidW5pcXVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLmNsYXNzaWZ5LmF0dHJpYnV0ZSA9PT0gbnVsbCB8fCBzdHlsZS5jbGFzc2lmeS5tYXhDbGFzc2VzID09PSBudWxsIHx8ICFzdHlsZS5jbGFzc2lmeS5jb2xvclBhbGV0dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGUuY2xhc3NpZnkubWV0aG9kID09PSBudWxsIHx8IHN0eWxlLmNsYXNzaWZ5LmF0dHJpYnV0ZSA9PT0gbnVsbCB8fCBzdHlsZS5jbGFzc2lmeS5jb2xvclJhbXAgPT09IG51bGwgfHwgc3R5bGUucnVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuIiwiLy8ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuV0ZTRGVzY3JpYmVGZWF0dXJlVHlwZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5wYXJzZVJlc3VsdCA9IGZ1bmN0aW9uKHhtbCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IG93c2pzLkpzb25peC5Db250ZXh0KFtcbiAgICAgICAgICAgICAgICBvd3Nqcy5tYXBwaW5ncy5YU0RfMV8wXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHRoaXMudW5tYXJzaGFsbGVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVVubWFyc2hhbGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2hlbWEgPSB0aGlzLnVubWFyc2hhbGxlci51bm1hcnNoYWxTdHJpbmcoeG1sKS52YWx1ZTtcbiAgICAgICAgdmFyIGZlYXR1cmVOUyA9IHNjaGVtYS50YXJnZXROYW1lc3BhY2U7XG4gICAgICAgIHZhciBlbGVtZW50ID0gc2NoZW1hLmNvbXBsZXhUeXBlWzBdLmNvbXBsZXhDb250ZW50LmV4dGVuc2lvbi5zZXF1ZW5jZS5lbGVtZW50O1xuICAgICAgICB2YXIgZmllbGRzID0gW107XG4gICAgICAgIHZhciBnZW9tZXRyeVR5cGUsIHRpbWVBdHRyO1xuICAgICAgICBmb3IgKHZhciBpPTAsIGlpPWVsZW1lbnQubGVuZ3RoOyBpPGlpOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGVsZW1lbnRbaV07XG4gICAgICAgICAgICBpZiAoZWwudHlwZS5uYW1lc3BhY2VVUkkgPT09ICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbHAgPSBlbC50eXBlLmxvY2FsUGFydDtcbiAgICAgICAgICAgICAgICBpZiAobHAuaW5kZXhPZignUG9seWdvbicpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeVR5cGUgPSAncG9seWdvbic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChscC5pbmRleE9mKCdMaW5lU3RyaW5nJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5VHlwZSA9ICdsaW5lJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxwLmluZGV4T2YoJ1BvaW50JykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5VHlwZSA9ICdwb2ludCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlbC50eXBlLmxvY2FsUGFydCA9PT0gJ2RhdGVUaW1lJykge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lQXR0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVBdHRyID0gZWwubmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aW1lQXR0ciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmllbGRzLnB1c2goe25hbWU6IGVsLm5hbWUsIHR5cGU6IGVsLnR5cGUubG9jYWxQYXJ0LCB0eXBlTlM6IGVsLnR5cGUubmFtZXNwYWNlVVJJfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpbWVBdHRyaWJ1dGU6IHRpbWVBdHRyLFxuICAgICAgICAgICAgZmVhdHVyZU5TOiBmZWF0dXJlTlMsXG4gICAgICAgICAgICBnZW9tVHlwZTogZ2VvbWV0cnlUeXBlLFxuICAgICAgICAgICAgYXR0cmlidXRlczogZmllbGRzXG4gICAgICAgIH07XG4gICAgfTtcblxufTtcbiIsIi8vJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLldQU0NsYXNzaWZ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLnBhcnNlUmVzdWx0ID0gZnVuY3Rpb24oeG1sKSB7XG4gICAgICAgIHZhciBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgICAgICB2YXIgZXhjZXB0aW9ucyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZU5TKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L293cy8xLjEnLCAnRXhjZXB0aW9uVGV4dCcpO1xuICAgICAgICBpZiAoZXhjZXB0aW9ucy5sZW5ndGggPT09MCkge1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0NsYXNzJyk7XG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaWk9Y2xhc3Nlcy5sZW5ndGg7IGk8aWk7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBtaW4gPSBjbGFzc2VzW2ldLmdldEF0dHJpYnV0ZSgnbG93ZXJCb3VuZCcpO1xuICAgICAgICAgICAgICAgIHZhciBtYXggPSBjbGFzc2VzW2ldLmdldEF0dHJpYnV0ZSgndXBwZXJCb3VuZCcpO1xuICAgICAgICAgICAgICAgIHJ1bGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBtaW4gKyAnLScgKyBtYXgsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW46IG1pbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDogbWF4XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBydWxlczogcnVsZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1zZzogZXhjZXB0aW9uc1swXS50ZXh0Q29udGVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IG93c2pzLkpzb25peC5Db250ZXh0KFtcbiAgICAgICAgICAgIG93c2pzLm1hcHBpbmdzLlhMaW5rXzFfMCxcbiAgICAgICAgICAgIG93c2pzLm1hcHBpbmdzLk9XU18xXzFfMCxcbiAgICAgICAgICAgIG93c2pzLm1hcHBpbmdzLkZpbHRlcl8xXzFfMCxcbiAgICAgICAgICAgIG93c2pzLm1hcHBpbmdzLk9XU18xXzBfMCxcbiAgICAgICAgICAgIG93c2pzLm1hcHBpbmdzLlNNSUxfMl8wLFxuICAgICAgICAgICAgb3dzanMubWFwcGluZ3MuU01JTF8yXzBfTGFuZ3VhZ2UsXG4gICAgICAgICAgICBvd3Nqcy5tYXBwaW5ncy5HTUxfM18xXzEsXG4gICAgICAgICAgICBvd3Nqcy5tYXBwaW5ncy5XRlNfMV8xXzAsXG4gICAgICAgICAgICBvd3Nqcy5tYXBwaW5ncy5XUFNfMV8wXzBcbiAgICAgICAgXSwge1xuICAgICAgICAgICAgbmFtZXNwYWNlUHJlZml4ZXM6IHtcbiAgICAgICAgICAgICAgICAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc6ICd4bGluaycsXG4gICAgICAgICAgICAgICAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvd3BzLzEuMC4wJzogJ3dwcycsXG4gICAgICAgICAgICAgICAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvb3dzLzEuMSc6ICdvd3MnLFxuICAgICAgICAgICAgICAgICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dmcyc6ICd3ZnMnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcnNoYWxsZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlTWFyc2hhbGxlcigpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFVuaXF1ZVZhbHVlcyA9IGZ1bmN0aW9uKGRhdGEsIGFzU3RyaW5nKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUNvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5nZW5lcmF0ZU1haW5Db25maWcoJ2dzOlVuaXF1ZScsIFwiYXBwbGljYXRpb24vanNvblwiLCBkYXRhKTtcbiAgICAgICAgY29uZmlnLnZhbHVlLmRhdGFJbnB1dHMuaW5wdXQucHVzaCh7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICdhdHRyaWJ1dGUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGxpdGVyYWxEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhLmF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhc1N0cmluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFyc2hhbGxlci5tYXJzaGFsU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXJzaGFsbGVyLm1hcnNoYWxEb2N1bWVudChjb25maWcpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZ2VuZXJhdGVNYWluQ29uZmlnID0gZnVuY3Rpb24ocHJvY2Vzc0lkLCBtaW1lVHlwZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJFeGVjdXRlXCIsXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvd3BzLzEuMC4wXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHNlcnZpY2U6IFwiV1BTXCIsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogXCIxLjAuMFwiLFxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByb2Nlc3NJZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VGb3JtOiB7XG4gICAgICAgICAgICAgICAgICAgIHJhd0RhdGFPdXRwdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJyZXN1bHRzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGF0YUlucHV0czoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnZmVhdHVyZXMnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiAndGV4dC94bWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAnaHR0cDovL2dlb3NlcnZlci93ZnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VVUkk6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC93ZnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGFydDogXCJHZXRGZWF0dXJlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEZvcm1hdDogXCJHTUwyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlOiBcIldGU1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogXCIxLjEuMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVOYW1lOiBbe25zOiBkYXRhLmZlYXR1cmVOUywgbHA6IGRhdGEudHlwZU5hbWUuc3BsaXQoJzonKVsxXSB8fCBkYXRhLnR5cGVOYW1lLCBwOiBkYXRhLmZlYXR1cmVQcmVmaXh9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB0aGlzLmNsYXNzaWZ5VmVjdG9yID0gZnVuY3Rpb24oZGF0YSwgYXNTdHJpbmcpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmdlbmVyYXRlTWFpbkNvbmZpZygndmVjOkZlYXR1cmVDbGFzc1N0YXRzJywgdW5kZWZpbmVkLCBkYXRhKTtcbiAgICAgICAgY29uZmlnLnZhbHVlLmRhdGFJbnB1dHMuaW5wdXQucHVzaCh7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICdhdHRyaWJ1dGUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGxpdGVyYWxEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhLmF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgaWRlbnRpZmllcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnY2xhc3NlcydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbGl0ZXJhbERhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZyhkYXRhLm51bUNsYXNzZXMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICdtZXRob2QnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGxpdGVyYWxEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhLm1ldGhvZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgaWRlbnRpZmllcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnc3RhdHMnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGxpdGVyYWxEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnbWVhbicgLyogVE9ETyBjdXJyZW50bHkgd2UgbmVlZCB0byBzZW5kIGF0IGxlYXN0IDEgc3RhdHMgaW5wdXQgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYXNTdHJpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcnNoYWxsZXIubWFyc2hhbFN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFyc2hhbGxlci5tYXJzaGFsRG9jdW1lbnQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuIiwiZXhwb3J0cy5NYXBDb25maWdUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgbGF5ZXJzID0gW10sIGksIGlpLCBtb2RlID0gJ2luc3RhbnQnO1xuICAgIC8vIGxvb2sgZm9yIHBsYXliYWNrIG1vZGUgaW4gdG9vbHNcbiAgICBpZiAoZGF0YS50b29scykge1xuICAgICAgICBmb3IgKGk9MCwgaWk9ZGF0YS50b29scy5sZW5ndGg7IGk8aWk7ICsraSkge1xuICAgICAgICAgICAgdmFyIHRvb2wgPSBkYXRhLnRvb2xzW2ldO1xuICAgICAgICAgICAgaWYgKHRvb2wucHR5cGUgPT09IFwiZ3hwX3BsYXliYWNrXCIgJiYgdG9vbC5vdXRwdXRDb25maWcpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbC5vdXRwdXRDb25maWcucGxheWJhY2tNb2RlID09PSAnY3VtdWxhdGl2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9ICdjdW11bGF0aXZlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBvdGhlciBtb2Rlc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoaT0wLCBpaT1kYXRhLm1hcC5sYXllcnMubGVuZ3RoOyBpPGlpOyArK2kpIHtcbiAgICAgICAgIHZhciBsYXllciA9IGRhdGEubWFwLmxheWVyc1tpXTtcbiAgICAgICAgIC8vIFRPRE8gZm9yIHRoZSBlZGl0b3Igd2UgYWxzbyBuZWVkIHRoZSBpbnZpc2libGUgbGF5ZXJzXG4gICAgICAgICBpZiAobGF5ZXIudmlzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBkYXRhLnNvdXJjZXNbbGF5ZXIuc291cmNlXTtcbiAgICAgICAgICAgICB2YXIgbGF5ZXJDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IGxheWVyLnZpc2liaWxpdHksXG4gICAgICAgICAgICAgICAgIGdyb3VwOiBsYXllci5ncm91cFxuICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgaWYgKHNvdXJjZS5wdHlwZSA9PT0gXCJneHBfbWFwcXVlc3Rzb3VyY2VcIikge1xuICAgICAgICAgICAgICAgICBsYXllckNvbmZpZy50eXBlID0gJ01hcFF1ZXN0JztcbiAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcubGF5ZXIgPSBsYXllci5uYW1lID09PSAnbmFpcCcgPyAnc2F0JyA6ICdvc20nO1xuICAgICAgICAgICAgICAgICBsYXllckNvbmZpZy50aXRsZSA9IGxheWVyLnRpdGxlO1xuICAgICAgICAgICAgICAgICBsYXllcnMucHVzaChsYXllckNvbmZpZyk7XG4gICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UucHR5cGUgPT09IFwiZ3hwX21hcGJveHNvdXJjZVwiKSB7XG4gICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnR5cGUgPSAnTWFwQm94JztcbiAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcubmFtZSA9IGxheWVyLm5hbWU7XG4gICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnRpdGxlID0gbGF5ZXIudGl0bGU7XG4gICAgICAgICAgICAgICAgIGxheWVycy5wdXNoKGxheWVyQ29uZmlnKTtcbiAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5wdHlwZSA9PT0gXCJneF9vbHNvdXJjZVwiIHx8IHNvdXJjZS5wdHlwZSA9PT0gXCJneHBfd21zY3NvdXJjZVwiKSB7XG4gICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnR5cGUgPSAoc291cmNlLnB0eXBlID09PSBcImd4X29sc291cmNlXCIpID8gbGF5ZXIudHlwZS5yZXBsYWNlKCdPcGVuTGF5ZXJzLkxheWVyLicsICcnKSA6IFwiV01TXCI7XG4gICAgICAgICAgICAgICAgIGlmIChsYXllckNvbmZpZy50eXBlID09PSAnT1NNJykge1xuICAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyQ29uZmlnLmFyZ3MgJiYgbGF5ZXJDb25maWcuYXJnc1swXSA9PT0gJ0h1bWFuaXRhcmlhbiBPcGVuU3RyZWV0TWFwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnR5cGUgPSAnSE9UJztcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnRpdGxlID0gbGF5ZXIudGl0bGU7XG4gICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXJDb25maWcudHlwZSA9PT0gJ1dNUycpIHtcbiAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLnB0eXBlID09PSBcImd4X29sc291cmNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBsYXllci5hcmdzWzJdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtc1trZXldLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW2tleS50b1VwcGVyQ2FzZSgpXSA9IHBhcmFtc1trZXldLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICBsYXllckNvbmZpZy51cmwgPSBsYXllci5hcmdzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIExBWUVSUzogbGF5ZXIubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU1RZTEVTOiBsYXllci5zdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRJTEVEOiAnVFJVRScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZPUk1BVDogbGF5ZXIuZm9ybWF0IHx8ICdpbWFnZS9wbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUUkFOU1BBUkVOVDogbGF5ZXIudHJhbnNwYXJlbnQgfHwgJ1RSVUUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIudGlsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnNpbmdsZVRpbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICBsYXllckNvbmZpZy5pZCA9IGxheWVyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcubmFtZSA9IGxheWVyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcudGl0bGUgPSBsYXllci50aXRsZUFsaWFzIHx8IGxheWVyLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLm1hc2tpbmdzID0gbGF5ZXIubWFza2luZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBub3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBiZXN0IHBsYWNlIHRvIGRvIHRoaXM/XG4gICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcudXJsID0gc291cmNlLnVybC5yZXBsYWNlKCdodHRwOi8vbWFwc3Rvcnkub3JnL2dlb3NlcnZlci8nLCAnL2dlb3NlcnZlci8nKTtcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLnBhcmFtcy5WRVJTSU9OID0gJzEuMS4xJztcbiAgICAgICAgICAgICAgICAgICAgIGlmIChsYXllci5jYXBhYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcubGF0bG9uQkJPWCA9IGxheWVyLmNhcGFiaWxpdHkubGxiYm94O1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVxdWlyZSBkZXBlbmRlbmN5IGV4cGxpY2l0bHk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVzID0gc3Rvcnl0b29scy5jb3JlLnRpbWUubWFwcy5yZWFkQ2FwYWJpbGl0aWVzVGltZURpbWVuc2lvbnMobGF5ZXIuY2FwYWJpbGl0eSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcudGltZXMgPSB0aW1lcztcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5mbyBmb3IgY3VzdG9tIHRpbGVHcmlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyLmNhcGFiaWxpdHkudGlsZVNldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc3JzIGluIGxheWVyLmNhcGFiaWxpdHkudGlsZVNldHNbMF0uYmJveCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJib3ggPSBsYXllci5jYXBhYmlsaXR5LnRpbGVTZXRzWzBdLmJib3hbc3JzXS5iYm94O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcuYmJveCA9IGJib3g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWcucmVzb2x1dGlvbnMgPSBsYXllci5jYXBhYmlsaXR5LnRpbGVTZXRzWzBdLnJlc29sdXRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICBsYXllcnMucHVzaChsYXllckNvbmZpZyk7XG4gICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS53YXJuKCdVbmtub3duIHNvdXJjZSB0eXBlIGluIG1hcCBjb25maWc6ICcgKyBzb3VyY2UucHR5cGUpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgfVxuICAgICByZXR1cm4ge1xuICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICBwbGF5YmFja01vZGU6IG1vZGUsXG4gICAgICAgICBtYXA6IHtcbiAgICAgICAgICAgICBjZW50ZXI6IGRhdGEubWFwLmNlbnRlcixcbiAgICAgICAgICAgICBwcm9qZWN0aW9uOiBkYXRhLm1hcC5wcm9qZWN0aW9uLFxuICAgICAgICAgICAgIHpvb206IGRhdGEubWFwLnpvb20sXG4gICAgICAgICAgICAgbGF5ZXJzOiBsYXllcnNcbiAgICAgICAgIH1cbiAgICAgfTtcbn07XG4iLCIoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgbW9kdWxlID0gYW5ndWxhci5tb2R1bGUoJ3N0b3J5dG9vbHMuY29yZS5vZ2MnLCBbXG4gIF0pO1xuXG4gIC8vIEB0b2RvIC0gcHJvdmlzaW9uYWwgZGVmYXVsdCBzdG9yeSBwaW5zIHN0eWxlXG4gIHZhciBkZWZhdWx0U3R5bGUgPSBbbmV3IG9sLnN0eWxlLlN0eWxlKHtcbiAgICBmaWxsOiBuZXcgb2wuc3R5bGUuRmlsbCh7Y29sb3I6ICdyZ2JhKDI1NSwgMCwgMCwgMC4xKSd9KSxcbiAgICBzdHJva2U6IG5ldyBvbC5zdHlsZS5TdHJva2Uoe2NvbG9yOiAncmVkJywgd2lkdGg6IDF9KSxcbiAgICBpbWFnZTogbmV3IG9sLnN0eWxlLkNpcmNsZSh7XG4gICAgICByYWRpdXM6IDEwLFxuICAgICAgZmlsbDogbmV3IG9sLnN0eWxlLkZpbGwoe2NvbG9yOiAncmdiYSgyNTUsIDAsIDAsIDAuMSknfSksXG4gICAgICBzdHJva2U6IG5ldyBvbC5zdHlsZS5TdHJva2Uoe2NvbG9yOiAncmVkJywgd2lkdGg6IDF9KVxuICAgIH0pXG4gIH0pXTtcblxuICBmdW5jdGlvbiBTdG9yeU1hcChkYXRhKSB7XG4gICAgb2wuT2JqZWN0LmNhbGwodGhpcywgZGF0YSk7XG4gICAgdGhpcy5tYXBfID0gbmV3IG9sLk1hcCh7dGFyZ2V0OiBkYXRhLnRhcmdldCwgcGl4ZWxSYXRpbzogMX0pO1xuICAgIHRoaXMub3ZlcmxheSA9IG5ldyBvbC5GZWF0dXJlT3ZlcmxheSh7XG4gICAgICBtYXA6IHRoaXMubWFwXyxcbiAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICB9KTtcbiAgICB0aGlzLnRpdGxlID0gXCJEZWZhdWx0IE1hcHN0b3J5XCI7XG4gICAgdGhpcy5hYnN0cmFjdCA9IFwiTm8gSW5mb3JtYXRpb24gU3VwcGxpZWQuXCI7XG4gICAgdGhpcy5vd25lciA9IFwiXCI7XG4gICAgdGhpcy5tb2RlID0gXCJpbnN0YW50XCI7XG4gICAgdGhpcy5yZXR1cm5Ub0V4dGVudCA9IGRhdGEucmV0dXJuVG9FeHRlbnQgfHwgZmFsc2U7XG4gICAgdGhpcy5jZW50ZXIgPSBbMCwwXTtcbiAgICB0aGlzLnpvb20gPSAyO1xuICAgIHRoaXMuc3RvcnlMYXllcnNfID0gbmV3IG9sLkNvbGxlY3Rpb24oKTtcbiAgICB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uXyA9IGRhdGEuYW5pbWF0aW9uRHVyYXRpb24gfHwgNTAwO1xuICAgIHRoaXMuc3RvcnlCb3hlc0xheWVyID0gbmV3IFN0b3J5TGF5ZXIoe1xuICAgICAgdGltZUF0dHJpYnV0ZTogJ3N0YXJ0X3RpbWUnLFxuICAgICAgZW5kVGltZUF0dHJpYnV0ZTogJ2VuZF90aW1lJyxcbiAgICAgIGxheWVyOiBuZXcgb2wubGF5ZXIuVmVjdG9yKHtcbiAgICAgICAgc291cmNlOiBuZXcgb2wuc291cmNlLlZlY3RvcigpLFxuICAgICAgICBzdHlsZTogZGVmYXVsdFN0eWxlXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHRoaXMuc3RvcnlQaW5zTGF5ZXIgPSBuZXcgU3RvcnlMYXllcih7XG4gICAgICB0aW1lQXR0cmlidXRlOiAnc3RhcnRfdGltZScsXG4gICAgICBlbmRUaW1lQXR0cmlidXRlOiAnZW5kX3RpbWUnLFxuICAgICAgbGF5ZXI6IG5ldyBvbC5sYXllci5WZWN0b3Ioe1xuICAgICAgICBzb3VyY2U6IG5ldyBvbC5zb3VyY2UuVmVjdG9yKCksXG4gICAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgdGhpcy5hZGRTdG9yeVBpbnNMYXllcigpO1xuICAgIHRoaXMuYWRkU3RvcnlCb3hlc0xheWVyKCk7XG4gIH1cblxuICBTdG9yeU1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG9sLk9iamVjdC5wcm90b3R5cGUpO1xuICBTdG9yeU1hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdG9yeU1hcDtcblxuICBTdG9yeU1hcC5wcm90b3R5cGUuYWRkU3RvcnlQaW5zTGF5ZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1hcF8uYWRkTGF5ZXIodGhpcy5zdG9yeVBpbnNMYXllci5nZXRMYXllcigpKTtcbiAgfTtcblxuICBTdG9yeU1hcC5wcm90b3R5cGUuYWRkU3RvcnlCb3hlc0xheWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tYXBfLmFkZExheWVyKHRoaXMuc3RvcnlCb3hlc0xheWVyLmdldExheWVyKCkpO1xuICB9O1xuXG4gIFN0b3J5TWFwLnByb3RvdHlwZS5zZXRTdG9yeU93bmVyID0gZnVuY3Rpb24oc3RvcnlPd25lcikge1xuICAgIHRoaXMub3duZXIgPSAgc3RvcnlPd25lcjtcbiAgfTtcblxuICBTdG9yeU1hcC5wcm90b3R5cGUuZ2V0U3RvcnlPd25lciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm93bmVyO1xuICB9O1xuXG4gIFN0b3J5TWFwLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jZW50ZXI7XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLmdldFpvb20gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy56b29tO1xuICB9O1xuXG4gIFN0b3J5TWFwLnByb3RvdHlwZS5zZXRTdG9yeVRpdGxlID0gZnVuY3Rpb24oc3RvcnlUaXRsZSkge1xuICAgIHRoaXMudGl0bGUgPSAgc3RvcnlUaXRsZTtcbiAgfTtcblxuICBTdG9yeU1hcC5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24oY2VudGVyKSB7XG4gICAgdGhpcy5jZW50ZXIgPSAgY2VudGVyO1xuICB9O1xuXG4gIFN0b3J5TWFwLnByb3RvdHlwZS5zZXRab29tID0gZnVuY3Rpb24oem9vbSkge1xuICAgIHRoaXMuem9vbSA9ICB6b29tO1xuICB9O1xuXG4gIFN0b3J5TWFwLnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24ocGxheWJhY2tNb2RlKSB7XG4gICAgdGhpcy5tb2RlID0gIHBsYXliYWNrTW9kZTtcbiAgfTtcblxuICBTdG9yeU1hcC5wcm90b3R5cGUuc2V0U3RvcnlBYnN0cmFjdCA9IGZ1bmN0aW9uKHN0b3J5QWJzdHJhY3QpIHtcbiAgICB0aGlzLmFic3RyYWN0ID0gIHN0b3J5QWJzdHJhY3Q7XG4gIH07XG5cblxuICBTdG9yeU1hcC5wcm90b3R5cGUuZ2V0U3RvcnlUaXRsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICB9O1xuXG4gIFN0b3J5TWFwLnByb3RvdHlwZS5nZXRTdG9yeUFic3RyYWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWJzdHJhY3Q7XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLnNldEJhc2VMYXllciA9IGZ1bmN0aW9uKGJhc2VMYXllcikge1xuICAgIHRoaXMuc2V0KCdiYXNlbGF5ZXInLCBiYXNlTGF5ZXIpO1xuICAgIHRoaXMubWFwXy5nZXRMYXllcnMoKS5mb3JFYWNoKGZ1bmN0aW9uKGx5cikge1xuICAgICAgaWYgKGx5ci5nZXQoJ2dyb3VwJykgPT09ICdiYWNrZ3JvdW5kJykge1xuICAgICAgICB0aGlzLm1hcF8ucmVtb3ZlTGF5ZXIobHlyKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLm1hcF8uZ2V0TGF5ZXJzKCkuaW5zZXJ0QXQoMCwgdGhpcy5nZXQoJ2Jhc2VsYXllcicpKTtcbiAgfTtcblxuICBTdG9yeU1hcC5wcm90b3R5cGUuYWRkU3RvcnlMYXllciA9IGZ1bmN0aW9uKHN0b3J5TGF5ZXIpIHtcbiAgICBzdG9yeUxheWVyLnN0b3J5TWFwXyA9IHRoaXM7XG4gICAgdGhpcy5zdG9yeUxheWVyc18ucHVzaChzdG9yeUxheWVyKTtcbiAgICAvLyBrZWVwIHBpbnMgbGF5ZXIgb24gdG9wXG4gICAgdmFyIGlkeCA9IHRoaXMubWFwXy5nZXRMYXllcnMoKS5nZXRMZW5ndGgoKSwgbWUgPSB0aGlzO1xuICAgIHRoaXMubWFwXy5nZXRMYXllcnMoKS5mb3JFYWNoKGZ1bmN0aW9uKHNsKSB7XG4gICAgICBpZiAoc2wgPT09IG1lLnN0b3J5UGluc0xheWVyKSB7XG4gICAgICAgIGlkeCAtPSAxO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMubWFwXy5nZXRMYXllcnMoKS5pbnNlcnRBdChcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgc3RvcnlMYXllci5nZXRMYXllcigpXG4gICAgKTtcbiAgfTtcblxuICBTdG9yeU1hcC5wcm90b3R5cGUuZ2V0U3RvcnlMYXllcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yeUxheWVyc187XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLmdldE1hcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hcF87XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tYXBfLmdldExheWVycygpLmNsZWFyKCk7XG4gICAgdGhpcy5zdG9yeUxheWVyc18uY2xlYXIoKTtcbiAgICB0aGlzLmFkZFN0b3J5UGluc0xheWVyKCk7XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLmFuaW1hdGVQYW5BbmRCb3VuY2UgPSBmdW5jdGlvbihjZW50ZXIsIHpvb20pe1xuXG4gICAgdmFyIGR1cmF0aW9uID0gMjAwMDtcbiAgICB2YXIgc3RhcnQgPSArbmV3IERhdGUoKTtcblxuICAgIHZhciB2aWV3ID0gdGhpcy5tYXBfLmdldFZpZXcoKTtcblxuICAgIGlmKHZpZXcuZ2V0Q2VudGVyKCkgIT0gY2VudGVyKXtcblxuICAgICAgdmFyIHBhbiA9IG9sLmFuaW1hdGlvbi5wYW4oe1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5hbmltYXRpb25EdXJhdGlvbl8sXG4gICAgICAgIHNvdXJjZTogdmlldy5nZXRDZW50ZXIoKSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0XG4gICAgICB9KTtcblxuXG4gICAgICB2YXIgYm91bmNlID0gb2wuYW5pbWF0aW9uLmJvdW5jZSh7XG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgcmVzb2x1dGlvbjogMiAqIHZpZXcuZ2V0UmVzb2x1dGlvbigpLFxuICAgICAgICBzdGFydDogc3RhcnRcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm1hcF8uYmVmb3JlUmVuZGVyKHBhbiwgYm91bmNlKTtcblxuICAgICAgdmlldy5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICAgIHZpZXcuc2V0Wm9vbSh6b29tKTtcbiAgICB9XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLmFuaW1hdGVDZW50ZXJBbmRab29tID0gZnVuY3Rpb24oY2VudGVyLCB6b29tKSB7XG4gICAgdmFyIHZpZXcgPSB0aGlzLm1hcF8uZ2V0VmlldygpO1xuICAgIGlmICh2aWV3LmdldENlbnRlcigpICE9PSBjZW50ZXIgfHwgdmlldy5nZXRab29tKCkgIT09IHpvb20pIHtcbiAgICAgIHRoaXMubWFwXy5iZWZvcmVSZW5kZXIob2wuYW5pbWF0aW9uLnBhbih7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uXyxcbiAgICAgICAgc291cmNlOiB2aWV3LmdldENlbnRlcigpXG4gICAgICB9KSk7XG4gICAgICB2aWV3LnNldENlbnRlcihjZW50ZXIpO1xuICAgICAgdGhpcy5tYXBfLmJlZm9yZVJlbmRlcihvbC5hbmltYXRpb24uem9vbSh7XG4gICAgICAgIHJlc29sdXRpb246IHZpZXcuZ2V0UmVzb2x1dGlvbigpLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5hbmltYXRpb25EdXJhdGlvbl9cbiAgICAgIH0pKTtcbiAgICAgIHZpZXcuc2V0Wm9vbSh6b29tKTtcbiAgICB9XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLnNldEFsbG93UGFuID0gZnVuY3Rpb24oYWxsb3dQYW4pIHtcbiAgICB0aGlzLm1hcF8uZ2V0SW50ZXJhY3Rpb25zKCkuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICBpZiAoaSBpbnN0YW5jZW9mIG9sLmludGVyYWN0aW9uLktleWJvYXJkUGFuIHx8XG4gICAgICAgICAgICBpIGluc3RhbmNlb2Ygb2wuaW50ZXJhY3Rpb24uRHJhZ1Bhbikge1xuICAgICAgICBpLnNldEFjdGl2ZShhbGxvd1Bhbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgU3RvcnlNYXAucHJvdG90eXBlLnNldEFsbG93Wm9vbSA9IGZ1bmN0aW9uKGFsbG93Wm9vbSkge1xuICAgIHZhciB6b29tQ3RybDtcbiAgICB0aGlzLm1hcF8uZ2V0Q29udHJvbHMoKS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgIGlmIChjIGluc3RhbmNlb2Ygb2wuY29udHJvbC5ab29tKSB7XG4gICAgICAgIHpvb21DdHJsID0gYztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWFsbG93Wm9vbSkge1xuICAgICAgdGhpcy5tYXBfLnJlbW92ZUNvbnRyb2woem9vbUN0cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1hcF8uYWRkQ29udHJvbChuZXcgb2wuY29udHJvbC5ab29tKCkpO1xuICAgIH1cbiAgICB0aGlzLm1hcF8uZ2V0SW50ZXJhY3Rpb25zKCkuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICBpZiAoaSBpbnN0YW5jZW9mIG9sLmludGVyYWN0aW9uLkRvdWJsZUNsaWNrWm9vbSB8fFxuICAgICAgICAgICAgaSBpbnN0YW5jZW9mIG9sLmludGVyYWN0aW9uLlBpbmNoWm9vbSB8fFxuICAgICAgICAgICAgaSBpbnN0YW5jZW9mIG9sLmludGVyYWN0aW9uLkRyYWdab29tIHx8XG4gICAgICAgICAgICBpIGluc3RhbmNlb2Ygb2wuaW50ZXJhY3Rpb24uTW91c2VXaGVlbFpvb20pIHtcbiAgICAgICAgaS5zZXRBY3RpdmUoYWxsb3dab29tKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBtb2R1bGUuY29uc3RhbnQoJ1N0b3J5TWFwJywgU3RvcnlNYXApO1xuXG4gIGZ1bmN0aW9uIEVkaXRhYmxlU3RvcnlNYXAoZGF0YSkge1xuICAgIFN0b3J5TWFwLmNhbGwodGhpcywgZGF0YSk7XG4gIH1cblxuICBFZGl0YWJsZVN0b3J5TWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RvcnlNYXAucHJvdG90eXBlKTtcbiAgRWRpdGFibGVTdG9yeU1hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFZGl0YWJsZVN0b3J5TWFwO1xuXG4gIG1vZHVsZS5jb25zdGFudCgnRWRpdGFibGVTdG9yeU1hcCcsIEVkaXRhYmxlU3RvcnlNYXApO1xuXG4gIEVkaXRhYmxlU3RvcnlNYXAucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbmZpZyA9IHt9O1xuICAgIGNvbmZpZy5tYXAgPSB7XG4gICAgICBjZW50ZXI6IHRoaXMubWFwXy5nZXRWaWV3KCkuZ2V0Q2VudGVyKCksXG4gICAgICBwcm9qZWN0aW9uOiB0aGlzLm1hcF8uZ2V0VmlldygpLmdldFByb2plY3Rpb24oKS5nZXRDb2RlKCksXG4gICAgICB6b29tOiB0aGlzLm1hcF8uZ2V0VmlldygpLmdldFpvb20oKSxcbiAgICAgIGxheWVyczogW11cbiAgICB9O1xuICAgIHZhciBtYXBJZCA9IHRoaXMuZ2V0KCdpZCcpO1xuICAgIGlmIChtYXBJZCA+PSAwKSB7XG4gICAgICBjb25maWcuaWQgPSBtYXBJZDtcbiAgICB9XG4gICAgdmFyIGJhc2VMYXllciA9IHRoaXMuZ2V0KCdiYXNlbGF5ZXInKTtcbiAgICBpZiAoYmFzZUxheWVyKSB7XG4gICAgICB2YXIgYmFzZUxheWVyU3RhdGUgPSB0aGlzLmdldCgnYmFzZWxheWVyJykuZ2V0KCdzdGF0ZScpO1xuICAgICAgYmFzZUxheWVyU3RhdGUuZ3JvdXAgPSAnYmFja2dyb3VuZCc7XG4gICAgICBiYXNlTGF5ZXJTdGF0ZS52aXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgIGNvbmZpZy5tYXAubGF5ZXJzLnB1c2goYmFzZUxheWVyU3RhdGUpO1xuICAgIH1cbiAgICB0aGlzLnN0b3J5TGF5ZXJzXy5mb3JFYWNoKGZ1bmN0aW9uKHN0b3J5TGF5ZXIpIHtcbiAgICAgIGNvbmZpZy5tYXAubGF5ZXJzLnB1c2goc3RvcnlMYXllci5nZXRTdGF0ZSgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9O1xuXG4gIEVkaXRhYmxlU3RvcnlNYXAucHJvdG90eXBlLnJlbW92ZVN0b3J5TGF5ZXIgPSBmdW5jdGlvbihzdG9yeUxheWVyKSB7XG4gICAgdGhpcy5zdG9yeUxheWVyc18ucmVtb3ZlKHN0b3J5TGF5ZXIpO1xuICAgIHRoaXMubWFwXy5yZW1vdmVMYXllcihzdG9yeUxheWVyLmdldExheWVyKCkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFN0b3J5TGF5ZXIoZGF0YSkge1xuICAgIGlmIChkYXRhLnRpbWVzICYmIHN0b3J5dG9vbHMuY29yZS50aW1lLnV0aWxzLmlzUmFuZ2VMaWtlKGRhdGEudGltZXMpKSB7XG4gICAgICBkYXRhLnRpbWVzID0gbmV3IHN0b3J5dG9vbHMuY29yZS50aW1lLnV0aWxzLkludGVydmFsKGRhdGEudGltZXMpO1xuICAgIH1cbiAgICBvbC5PYmplY3QuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICB2YXIgbGF5ZXI7XG4gICAgaWYgKHRoaXMuZ2V0KCd0eXBlJykgPT09ICdWRUNUT1InKSB7XG4gICAgICBsYXllciA9IG5ldyBvbC5sYXllci5WZWN0b3Ioe3NvdXJjZTogbmV3IG9sLnNvdXJjZS5WZWN0b3IoKX0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5nZXQoJ3R5cGUnKSA9PT0gJ0hFQVRNQVAnKSB7XG4gICAgICBsYXllciA9IG5ldyBvbC5sYXllci5IZWF0bWFwKHtcbiAgICAgICAgcmFkaXVzOiBkYXRhLnN0eWxlLnJhZGl1cyxcbiAgICAgICAgb3BhY2l0eTogZGF0YS5zdHlsZS5vcGFjaXR5LFxuICAgICAgICBzb3VyY2U6IG5ldyBvbC5zb3VyY2UuVmVjdG9yKClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5nZXQoJ3R5cGUnKSA9PT0gJ1dNUycpIHtcbiAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIHVzZU9sZEFzSW50ZXJpbVRpbGVzOiB0cnVlXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZ2V0KCdzaW5nbGVUaWxlJykgPT09IHRydWUpIHtcbiAgICAgICAgbGF5ZXIgPSBuZXcgb2wubGF5ZXIuSW1hZ2UoY29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxheWVyID0gbmV3IG9sLmxheWVyLlRpbGUoY29uZmlnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXIgPSBkYXRhLmxheWVyO1xuICAgIH1cbiAgICB0aGlzLmxheWVyXyA9IGxheWVyO1xuICB9XG5cbiAgU3RvcnlMYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG9sLk9iamVjdC5wcm90b3R5cGUpO1xuICBTdG9yeUxheWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0b3J5TGF5ZXI7XG5cbiAgU3RvcnlMYXllci5wcm90b3R5cGUuZ2V0U3RvcnlNYXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yeU1hcF87XG4gIH07XG5cbiAgU3RvcnlMYXllci5wcm90b3R5cGUuc2V0V01TU291cmNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIHZhciBuYW1lID0gdGhpcy5nZXQoJ25hbWUnKTtcbiAgICB2YXIgdGltZXMgPSB0aGlzLmdldCgndGltZXMnKTtcbiAgICB2YXIgc2luZ2xlVGlsZSA9IHRoaXMuZ2V0KCdzaW5nbGVUaWxlJyk7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZ2V0KCdwYXJhbXMnKSB8fCB7XG4gICAgICAnTEFZRVJTJzogbmFtZSxcbiAgICAgICdWRVJTSU9OJzogJzEuMS4wJyxcbiAgICAgICdUSUxFRCc6IHRydWVcbiAgICB9O1xuICAgIGlmICh0aW1lcykge1xuICAgICAgcGFyYW1zLlRJTUUgPSBuZXcgRGF0ZSh0aW1lcy5zdGFydCB8fCB0aW1lc1swXSkudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHNpbmdsZVRpbGUpIHtcbiAgICAgIGxheWVyLnNldFNvdXJjZShuZXcgb2wuc291cmNlLkltYWdlV01TKHtcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIHVybDogdGhpcy5nZXQoJ3VybCcpLFxuICAgICAgICBzZXJ2ZXJUeXBlOiAnZ2Vvc2VydmVyJ1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGlsZUdyaWQsIHJlc29sdXRpb25zID0gdGhpcy5nZXQoJ3Jlc29sdXRpb25zJyksXG4gICAgICAgICAgICBiYm94ID0gdGhpcy5nZXQoJ2Jib3gnKTtcbiAgICAgIGlmIChyZXNvbHV0aW9ucyAmJiBiYm94KSB7XG4gICAgICAgIHRpbGVHcmlkID0gbmV3IG9sLnRpbGVncmlkLlRpbGVHcmlkKHtcbiAgICAgICAgICBleHRlbnQ6IGJib3gsXG4gICAgICAgICAgcmVzb2x1dGlvbnM6IHJlc29sdXRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gQHRvZG8gdXNlIHVybHMgZm9yIHN1YmRvbWFpbiBsb2FkaW5nXG4gICAgICBsYXllci5zZXRTb3VyY2UobmV3IG9sLnNvdXJjZS5UaWxlV01TKHtcbiAgICAgICAgdXJsOiB0aGlzLmdldCgndXJsJyksXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICB0aWxlR3JpZDogdGlsZUdyaWQsXG4gICAgICAgIHNlcnZlclR5cGU6ICdnZW9zZXJ2ZXInXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4gIFN0b3J5TGF5ZXIucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5nZXRQcm9wZXJ0aWVzKCk7XG4gICAgZGVsZXRlIHN0YXRlLmZlYXR1cmVzO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcblxuICBTdG9yeUxheWVyLnByb3RvdHlwZS5nZXRMYXllciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmxheWVyXztcbiAgfTtcblxuICBTdG9yeUxheWVyLnByb3RvdHlwZS5zZXRMYXllciA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgaWYgKHRoaXMubGF5ZXJfICYmIHRoaXMuc3RvcnlNYXBfKSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5zdG9yeU1hcF8ubWFwXztcbiAgICAgIHZhciBpZHggPSBtYXAuZ2V0TGF5ZXJzKCkuZ2V0QXJyYXkoKS5pbmRleE9mKHRoaXMubGF5ZXJfKTtcbiAgICAgIG1hcC5nZXRMYXllcnMoKS5zZXRBdChpZHgsIGxheWVyKTtcbiAgICB9XG4gICAgdGhpcy5sYXllcl8gPSBsYXllcjtcbiAgfTtcblxuICBtb2R1bGUuY29uc3RhbnQoJ1N0b3J5TGF5ZXInLCBTdG9yeUxheWVyKTtcblxuICBmdW5jdGlvbiBFZGl0YWJsZVN0b3J5TGF5ZXIoZGF0YSkge1xuICAgIFN0b3J5TGF5ZXIuY2FsbCh0aGlzLCBkYXRhKTtcbiAgfVxuXG4gIEVkaXRhYmxlU3RvcnlMYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN0b3J5TGF5ZXIucHJvdG90eXBlKTtcbiAgRWRpdGFibGVTdG9yeUxheWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVkaXRhYmxlU3RvcnlMYXllcjtcblxuICBtb2R1bGUuY29uc3RhbnQoJ0VkaXRhYmxlU3RvcnlMYXllcicsIEVkaXRhYmxlU3RvcnlMYXllcik7XG5cbiAgbW9kdWxlLnNlcnZpY2UoJ3N0QW5ub3RhdGVMYXllcicsIGZ1bmN0aW9uKCRodHRwLCAkcSkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2FkQ2FwYWJpbGl0aWVzOiBmdW5jdGlvbihzdG9yeUxheWVyKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gJ0dldENhcGFiaWxpdGllcycsIHNlcnZpY2UgPSAnV01TJztcbiAgICAgICAgLy8gYWx3YXlzIHVzZSB0aGUgdmlydHVhbCBzZXJ2aWNlIGZvciBHZXRDYXBhYmlsaXRpZXNcbiAgICAgICAgdmFyIHVybCA9IHN0b3J5TGF5ZXIuZ2V0KCd1cmwnKTtcbiAgICAgICAgaWYgKHVybCA9PT0gJy9nZW9zZXJ2ZXIvd21zJykge1xuICAgICAgICAgIHZhciBuYW1lID0gc3RvcnlMYXllci5nZXQoJ25hbWUnKTtcbiAgICAgICAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJy9nZW9zZXJ2ZXInLCAnL2dlb3NlcnZlci8nICsgcGFydHNbMF0gKyAnLycgKyBwYXJ0c1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ2h0dHA6JywgJycpO1xuXG4gICAgICAgIHJldHVybiAkaHR0cCh7XG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICdSRVFVRVNUJzogcmVxdWVzdCxcbiAgICAgICAgICAgICdTRVJWSUNFJzogc2VydmljZSxcbiAgICAgICAgICAgICdWRVJTSU9OJzogJzEuMS4xJyxcbiAgICAgICAgICAgICdUSUxFRCc6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pLnN1Y2Nlc3MoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIHZhciBjb250ZXh0ID0gbmV3IG93c2pzLkpzb25peC5Db250ZXh0KFtcbiAgICAgICAgICAgIG93c2pzLm1hcHBpbmdzLldNU0NfMV8xXzFcbiAgICAgICAgICBdKTtcbiAgICAgICAgICB2YXIgdW5tYXJzaGFsbGVyID0gY29udGV4dC5jcmVhdGVVbm1hcnNoYWxsZXIoKTtcbiAgICAgICAgICB2YXIgY2FwcyA9IHVubWFyc2hhbGxlci51bm1hcnNoYWxTdHJpbmcoZGF0YSk7XG4gICAgICAgICAgdmFyIGxheWVyID0gY2Fwcy52YWx1ZS5jYXBhYmlsaXR5LmxheWVyO1xuICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdsYXRsb25CQk9YJywgW1xuICAgICAgICAgICAgcGFyc2VGbG9hdChsYXllci5sYXRMb25Cb3VuZGluZ0JveC5taW54KSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQobGF5ZXIubGF0TG9uQm91bmRpbmdCb3gubWlueSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGxheWVyLmxhdExvbkJvdW5kaW5nQm94Lm1heHgpLFxuICAgICAgICAgICAgcGFyc2VGbG9hdChsYXllci5sYXRMb25Cb3VuZGluZ0JveC5tYXh5KVxuICAgICAgICAgIF0pO1xuICAgICAgICAgIHZhciB2ZW5kb3JTcGVjaWZpY0NhcGFiaWxpdGllcyA9IGNhcHMudmFsdWUuY2FwYWJpbGl0eS52ZW5kb3JTcGVjaWZpY0NhcGFiaWxpdGllcztcbiAgICAgICAgICB2YXIgdGlsZVNldHMgPSAodmVuZG9yU3BlY2lmaWNDYXBhYmlsaXRpZXMpPyB2ZW5kb3JTcGVjaWZpY0NhcGFiaWxpdGllcy50aWxlU2V0OiBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpPTAsIGlpPXRpbGVTZXRzLmxlbmd0aDsgaTxpaTsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGlsZVNldHNbaV0uc3JzID09PSAnRVBTRzo5MDA5MTMnKSB7XG4gICAgICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdyZXNvbHV0aW9ucycsIHRpbGVTZXRzW2ldLnJlc29sdXRpb25zLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgICB2YXIgYmJveCA9IHRpbGVTZXRzW2ldLmJvdW5kaW5nQm94O1xuICAgICAgICAgICAgICBzdG9yeUxheWVyLnNldCgnYmJveCcsIFtcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGJib3gubWlueCksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChiYm94Lm1pbnkpLFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoYmJveC5tYXh4KSxcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGJib3gubWF4eSlcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZm91bmQgPSBzdG9yeXRvb2xzLmNvcmUudGltZS5tYXBzLnJlYWRDYXBhYmlsaXRpZXNUaW1lRGltZW5zaW9ucyhjYXBzKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHN0b3J5TGF5ZXIuZ2V0KCduYW1lJyk7XG4gICAgICAgICAgaWYgKG5hbWUgaW4gZm91bmQpIHtcbiAgICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCd0aW1lcycsIGZvdW5kW25hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGRlc2NyaWJlRmVhdHVyZVR5cGU6IGZ1bmN0aW9uKHN0b3J5TGF5ZXIpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHJlcXVlc3QgPSAnRGVzY3JpYmVGZWF0dXJlVHlwZScsIHNlcnZpY2UgPSAnV0ZTJztcbiAgICAgICAgdmFyIGlkID0gc3RvcnlMYXllci5nZXQoJ2lkJyk7XG4gICAgICAgIHJldHVybiAkaHR0cCh7XG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICB1cmw6IHN0b3J5TGF5ZXIuZ2V0KCd1cmwnKS5yZXBsYWNlKCdodHRwOicsICcnKSxcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICdTRVJWSUNFJzogc2VydmljZSxcbiAgICAgICAgICAgICdWRVJTSU9OJzogJzEuMC4wJyxcbiAgICAgICAgICAgICdSRVFVRVNUJzogcmVxdWVzdCxcbiAgICAgICAgICAgICdUWVBFTkFNRSc6IGlkXG4gICAgICAgICAgfVxuICAgICAgICB9KS5zdWNjZXNzKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IHN0b3J5dG9vbHMuZWRpdC5XRlNEZXNjcmliZUZlYXR1cmVUeXBlLldGU0Rlc2NyaWJlRmVhdHVyZVR5cGUoKTtcbiAgICAgICAgICB2YXIgbGF5ZXJJbmZvID0gcGFyc2VyLnBhcnNlUmVzdWx0KGRhdGEpO1xuICAgICAgICAgIGlmIChsYXllckluZm8udGltZUF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgc3RvcnlMYXllci5zZXQoJ3RpbWVBdHRyaWJ1dGUnLCBsYXllckluZm8udGltZUF0dHJpYnV0ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9yeUxheWVyLmdldCgndGltZUVuZHBvaW50JykpIHtcbiAgICAgICAgICAgIG1lLmdldFRpbWVBdHRyaWJ1dGUoc3RvcnlMYXllcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwYXJ0cyA9IGlkLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgc3RvcnlMYXllci5zZXQoJ3R5cGVOYW1lJywgaWQpO1xuICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdmZWF0dXJlUHJlZml4JywgcGFydHNbMF0pO1xuICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdmZWF0dXJlTlMnLCBsYXllckluZm8uZmVhdHVyZU5TKTtcbiAgICAgICAgICBzdG9yeUxheWVyLnNldCgnZ2VvbVR5cGUnLCBsYXllckluZm8uZ2VvbVR5cGUpO1xuICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdhdHRyaWJ1dGVzJywgbGF5ZXJJbmZvLmF0dHJpYnV0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRUaW1lQXR0cmlidXRlOiBmdW5jdGlvbihzdG9yeUxheWVyKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAkaHR0cCh7XG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICB1cmw6IHN0b3J5TGF5ZXIuZ2V0KCd0aW1lRW5kcG9pbnQnKVxuICAgICAgICB9KS5zdWNjZXNzKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICBzdG9yeUxheWVyLnNldCgndGltZUF0dHJpYnV0ZScsIGRhdGEuYXR0cmlidXRlKTtcbiAgICAgICAgICBpZiAoZGF0YS5lbmRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdlbmRUaW1lQXR0cmlidXRlJywgZGF0YS5lbmRBdHRyaWJ1dGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0U3R5bGVOYW1lOiBmdW5jdGlvbihzdG9yeUxheWVyKSB7XG4gICAgICAgIGlmIChzdG9yeUxheWVyLmdldCgnY2FuU3R5bGVXTVMnKSkge1xuICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuICRodHRwKHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB1cmw6IHN0b3J5TGF5ZXIuZ2V0KCdwYXRoJykgKyAncmVzdC9sYXllcnMvJyArIHN0b3J5TGF5ZXIuZ2V0KCdpZCcpICsgJy5qc29uJ1xuICAgICAgICAgIH0pLnN1Y2Nlc3MoZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdzdHlsZU5hbWUnLCByZXNwb25zZS5sYXllci5kZWZhdWx0U3R5bGUubmFtZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRxLndoZW4oJycpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0RmVhdHVyZXM6IGZ1bmN0aW9uKHN0b3J5TGF5ZXIsIG1hcCkge1xuICAgICAgICB2YXIgbmFtZSA9IHN0b3J5TGF5ZXIuZ2V0KCdpZCcpO1xuICAgICAgICB2YXIgd2ZzVXJsID0gc3RvcnlMYXllci5nZXQoJ3VybCcpICsgJz9zZXJ2aWNlPVdGUyZ2ZXJzaW9uPTEuMS4wJnJlcXVlc3Q9R2V0RmVhdHVyZSZ0eXBlbmFtZT0nICtcbiAgICAgICAgICAgICAgbmFtZSArICcmb3V0cHV0Rm9ybWF0PWFwcGxpY2F0aW9uL2pzb24nICtcbiAgICAgICAgICAgICAgJyZzcnNOYW1lPScgKyBtYXAuZ2V0VmlldygpLmdldFByb2plY3Rpb24oKS5nZXRDb2RlKCk7XG4gICAgICAgIHJldHVybiAkaHR0cCh7XG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICB1cmw6IHdmc1VybFxuICAgICAgICB9KS5zdWNjZXNzKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgdmFyIGxheWVyID0gc3RvcnlMYXllci5nZXRMYXllcigpO1xuICAgICAgICAgIHZhciBmZWF0dXJlcyA9IG5ldyBvbC5mb3JtYXQuR2VvSlNPTigpLnJlYWRGZWF0dXJlcyhyZXNwb25zZSk7XG4gICAgICAgICAgc3RvcnlMYXllci5zZXQoJ2ZlYXR1cmVzJywgZmVhdHVyZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBtb2R1bGUuc2VydmljZSgnc3RCYXNlTGF5ZXJCdWlsZGVyJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJ1aWxkTGF5ZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ01hcFF1ZXN0Jykge1xuICAgICAgICAgIHJldHVybiBuZXcgb2wubGF5ZXIuVGlsZSh7XG4gICAgICAgICAgICBzdGF0ZTogZGF0YSxcbiAgICAgICAgICAgIHRpdGxlOiBkYXRhLnRpdGxlLFxuICAgICAgICAgICAgZ3JvdXA6ICdiYWNrZ3JvdW5kJyxcbiAgICAgICAgICAgIHNvdXJjZTogbmV3IG9sLnNvdXJjZS5NYXBRdWVzdCh7bGF5ZXI6IGRhdGEubGF5ZXJ9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ0hPVCcpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IG9sLmxheWVyLlRpbGUoe1xuICAgICAgICAgICAgc3RhdGU6IGRhdGEsXG4gICAgICAgICAgICB0aXRsZTogZGF0YS50aXRsZSxcbiAgICAgICAgICAgIGdyb3VwOiAnYmFja2dyb3VuZCcsXG4gICAgICAgICAgICBzb3VyY2U6IG5ldyBvbC5zb3VyY2UuT1NNKHtcbiAgICAgICAgICAgICAgYXR0cmlidXRpb25zOiBbXG4gICAgICAgICAgICAgICAgbmV3IG9sLkF0dHJpYnV0aW9uKHtcbiAgICAgICAgICAgICAgICAgIGh0bWw6ICdUaWxlcyBjb3VydGVzeSBvZiA8YSBocmVmPVwiLy9ob3Qub3BlbnN0cmVldG1hcC5vcmcvXCIgdGFyZ2V0PVwiX2JsYW5rXCI+SHVtYW5pdGFyaWFuIE9wZW5TdHJlZXRNYXAgVGVhbTwvYT4nXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgb2wuc291cmNlLk9TTS5BVFRSSUJVVElPTlxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBjcm9zc09yaWdpbjogbnVsbCxcbiAgICAgICAgICAgICAgdXJsOiAnLy97YS1jfS50aWxlLm9wZW5zdHJlZXRtYXAuZnIvaG90L3t6fS97eH0ve3l9LnBuZydcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnT1NNJykge1xuICAgICAgICAgIHJldHVybiBuZXcgb2wubGF5ZXIuVGlsZSh7XG4gICAgICAgICAgICBzdGF0ZTogZGF0YSxcbiAgICAgICAgICAgIHRpdGxlOiBkYXRhLnRpdGxlLFxuICAgICAgICAgICAgZ3JvdXA6ICdiYWNrZ3JvdW5kJyxcbiAgICAgICAgICAgIHNvdXJjZTogbmV3IG9sLnNvdXJjZS5PU00oKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ01hcEJveCcpIHtcbiAgICAgICAgICB2YXIgbGF5ZXIgPSBuZXcgb2wubGF5ZXIuVGlsZSh7c3RhdGU6IGRhdGEsIHRpdGxlOiBkYXRhLnRpdGxlLCBncm91cDogJ2JhY2tncm91bmQnfSk7XG4gICAgICAgICAgdmFyIG5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgICAgdmFyIHVybHMgPSBbXG4gICAgICAgICAgICAnLy9hLnRpbGVzLm1hcGJveC5jb20vdjEvbWFwYm94LicsXG4gICAgICAgICAgICAnLy9iLnRpbGVzLm1hcGJveC5jb20vdjEvbWFwYm94LicsXG4gICAgICAgICAgICAnLy9jLnRpbGVzLm1hcGJveC5jb20vdjEvbWFwYm94LicsXG4gICAgICAgICAgICAnLy9kLnRpbGVzLm1hcGJveC5jb20vdjEvbWFwYm94LidcbiAgICAgICAgICBdO1xuICAgICAgICAgIHZhciB0aWxlVXJsRnVuY3Rpb24gPSBmdW5jdGlvbih0aWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB6eHkgPSB0aWxlQ29vcmQ7XG4gICAgICAgICAgICBpZiAoenh5WzFdIDwgMCB8fCB6eHlbMl0gPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVybHNbTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpKjMpXSArIG5hbWUgKyAnLycgK1xuICAgICAgICAgICAgICAgICAgenh5WzBdLnRvU3RyaW5nKCkrJy8nKyB6eHlbMV0udG9TdHJpbmcoKSArJy8nK1xuICAgICAgICAgICAgICAgICAgenh5WzJdLnRvU3RyaW5nKCkgKycucG5nJztcbiAgICAgICAgICB9O1xuICAgICAgICAgIGxheWVyLnNldFNvdXJjZShuZXcgb2wuc291cmNlLlRpbGVJbWFnZSh7XG4gICAgICAgICAgICBjcm9zc09yaWdpbjogbnVsbCxcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICBuZXcgb2wuQXR0cmlidXRpb24oe1xuICAgICAgICAgICAgICAgIGh0bWw6IC9ed29ybGQvLnRlc3QobmFtZSkgP1xuICAgICAgICAgICAgICAgICAgICAgIFwiPGEgaHJlZj0nLy9tYXBib3guY29tJz5NYXBCb3g8L2E+IHwgU29tZSBEYXRhICZjb3B5OyBPU00gQ0MtQlktU0EgfCA8YSBocmVmPScvL21hcGJveC5jb20vdG9zJz5UZXJtcyBvZiBTZXJ2aWNlPC9hPlwiIDpcbiAgICAgICAgICAgICAgICAgICAgICBcIjxhIGhyZWY9Jy8vbWFwYm94LmNvbSc+TWFwQm94PC9hPiB8IDxhIGhyZWY9Jy8vbWFwYm94LmNvbS90b3MnPlRlcm1zIG9mIFNlcnZpY2U8L2E+XCJcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB0aWxlR3JpZDogbmV3IG9sLnRpbGVncmlkLlRpbGVHcmlkKHtcbiAgICAgICAgICAgICAgb3JpZ2luOiBbLTEyOCAqIDE1NjU0My4wMzM5MDYyNSwgLTEyOCAqIDE1NjU0My4wMzM5MDYyNV0sXG4gICAgICAgICAgICAgIHJlc29sdXRpb25zOiBbXG4gICAgICAgICAgICAgICAgMTU2NTQzLjAzMzkwNjI1LCA3ODI3MS41MTY5NTMxMjUsIDM5MTM1Ljc1ODQ3NjU2MjUsXG4gICAgICAgICAgICAgICAgMTk1NjcuODc5MjM4MjgxMjUsIDk3ODMuOTM5NjE5MTQwNjI1LCA0ODkxLjk2OTgwOTU3MDMxMjUsXG4gICAgICAgICAgICAgICAgMjQ0NS45ODQ5MDQ3ODUxNTYyLCAxMjIyLjk5MjQ1MjM5MjU3ODEsIDYxMS40OTYyMjYxOTYyODkxLFxuICAgICAgICAgICAgICAgIDMwNS43NDgxMTMwOTgxNDQ1MywgMTUyLjg3NDA1NjU0OTA3MjI2LCA3Ni40MzcwMjgyNzQ1MzYxMyxcbiAgICAgICAgICAgICAgICAzOC4yMTg1MTQxMzcyNjgwNjYsIDE5LjEwOTI1NzA2ODYzNDAzMywgOS41NTQ2Mjg1MzQzMTcwMTcsXG4gICAgICAgICAgICAgICAgNC43NzczMTQyNjcxNTg1MDgsIDIuMzg4NjU3MTMzNTc5MjU0LCAxLjE5NDMyODU2Njc4OTYyNyxcbiAgICAgICAgICAgICAgICAwLjU5NzE2NDI4MzM5NDgxMzVcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aWxlVXJsRnVuY3Rpb246IHRpbGVVcmxGdW5jdGlvblxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnV01TJykge1xuICAgICAgICAgIHJldHVybiBuZXcgb2wubGF5ZXIuVGlsZSh7XG4gICAgICAgICAgICBncm91cDogXCJiYWNrZ3JvdW5kXCIsXG4gICAgICAgICAgICBzb3VyY2U6IG5ldyBvbC5zb3VyY2UuVGlsZVdNUyh7XG4gICAgICAgICAgICAgIHVybDogZGF0YS51cmwsXG4gICAgICAgICAgICAgIHBhcmFtczogZGF0YS5wYXJhbXNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB0eXBlIGZvciA6ICcgKyBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBtb2R1bGUuc2VydmljZSgnc3RFZGl0YWJsZUxheWVyQnVpbGRlcicsIGZ1bmN0aW9uKCRxLCBzdEFubm90YXRlTGF5ZXIsIHN0QmFzZUxheWVyQnVpbGRlcikge1xuICAgIHJldHVybiB7XG4gICAgICBidWlsZEVkaXRhYmxlTGF5ZXI6IGZ1bmN0aW9uKGRhdGEsIG1hcCkge1xuICAgICAgICB2YXIgbGF5ZXIgPSBuZXcgRWRpdGFibGVTdG9yeUxheWVyKGRhdGEpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgLy8gVE9ETyBhZGQgdGhpcyBiYWNrIHdoZW4gd2UgaGF2ZSBXTVMtQyBHZXRDYXBzXG4gICAgICAgIHZhciBuZWVkc0NhcHMgPSAhKGRhdGEubGF0bG9uQkJPWCAmJiBkYXRhLnRpbWVzLyogJiYgZGF0YS5iYm94ICYmIGRhdGEucmVzb2x1dGlvbnMqLyk7XG4gICAgICAgIGlmIChuZWVkc0NhcHMpIHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHN0QW5ub3RhdGVMYXllci5sb2FkQ2FwYWJpbGl0aWVzKGxheWVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5lZWRzREZUID0gIWRhdGEuYXR0cmlidXRlcztcbiAgICAgICAgaWYgKG5lZWRzREZUKSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChzdEFubm90YXRlTGF5ZXIuZGVzY3JpYmVGZWF0dXJlVHlwZShsYXllcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZGF0YS50eXBlID09PSAnVkVDVE9SJyB8fCBkYXRhLnR5cGUgPT09ICdIRUFUTUFQJykgJiYgIWRhdGEuZmVhdHVyZXMpIHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHN0QW5ub3RhdGVMYXllci5nZXRGZWF0dXJlcyhsYXllciwgbWFwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChzdEFubm90YXRlTGF5ZXIuZ2V0U3R5bGVOYW1lKGxheWVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgJHEuYWxsKFxuICAgICAgICAgICAgICBwcm9taXNlc1xuICAgICAgICApLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBuZWVkcyB0byBiZSBkb25lIGhlcmUgd2hlbiBldmVyeXRoaW5nIGlzIHJlc29sdmVkXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLmdldCgnZmVhdHVyZXMnKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHRpbWVzID0gbGF5ZXIuZ2V0KCd0aW1lcycpO1xuICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHRpbWVzLnN0YXJ0IHx8IHRpbWVzWzBdO1xuICAgICAgICAgICAgICAgICAgICBzdG9yeXRvb2xzLmNvcmUudGltZS5tYXBzLmZpbHRlclZlY3RvckxheWVyKGxheWVyLCB7c3RhcnQ6IHN0YXJ0LCBlbmQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5nZXRMYXllcigpLmdldFNvdXJjZSgpLmFkZEZlYXR1cmVzKGxheWVyLmdldCgnZmVhdHVyZXMnKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGxheWVyLnNldFdNU1NvdXJjZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGxheWVyKTtcbiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBtb2R1bGUuc2VydmljZSgnc3RMYXllckJ1aWxkZXInLCBmdW5jdGlvbigkcSkge1xuICAgIHJldHVybiB7XG4gICAgICBidWlsZExheWVyOiBmdW5jdGlvbihkYXRhLCBtYXApIHtcbiAgICAgICAgdmFyIGxheWVyID0gbmV3IFN0b3J5TGF5ZXIoZGF0YSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgIGxheWVyLnNldFdNU1NvdXJjZSgpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGxheWVyKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgbW9kdWxlLnNlcnZpY2UoJ3N0U3RvcnlNYXBCYXNlQnVpbGRlcicsIGZ1bmN0aW9uKHN0QmFzZUxheWVyQnVpbGRlcikge1xuICAgIHJldHVybiB7XG4gICAgICBkZWZhdWx0TWFwOiBmdW5jdGlvbihzdG9yeW1hcCkge1xuICAgICAgICBzdG9yeW1hcC5nZXRNYXAoKS5zZXRWaWV3KG5ldyBvbC5WaWV3KHtjZW50ZXI6IFswLDBdLCB6b29tOiAzfSkpO1xuICAgICAgICB0aGlzLnNldEJhc2VMYXllcihzdG9yeW1hcCwge1xuICAgICAgICAgdGl0bGU6ICdXb3JsZCBMaWdodCcsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNYXBCb3gnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnd29ybGQtbGlnaHQnXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNldEJhc2VMYXllcjogZnVuY3Rpb24oc3RvcnltYXAsIGRhdGEpIHtcbiAgICAgICAgdmFyIGJhc2VMYXllciA9IHN0QmFzZUxheWVyQnVpbGRlci5idWlsZExheWVyKGRhdGEpO1xuICAgICAgICBzdG9yeW1hcC5zZXRCYXNlTGF5ZXIoYmFzZUxheWVyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBtb2R1bGUuc2VydmljZSgnc3RTdG9yeU1hcEJ1aWxkZXInLCBmdW5jdGlvbihzdExheWVyQnVpbGRlciwgc3RTdG9yeU1hcEJhc2VCdWlsZGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmeVN0b3J5TWFwOiBmdW5jdGlvbihzdG9yeW1hcCwgZGF0YSkge1xuICAgICAgICBzdG9yeW1hcC5jbGVhcigpO1xuICAgICAgICB2YXIgbWFwQ29uZmlnID0gc3Rvcnl0b29scy5tYXBzdG9yeS5NYXBDb25maWdUcmFuc2Zvcm1lci5NYXBDb25maWdUcmFuc2Zvcm1lcihkYXRhKTtcbiAgICAgICAgaWYgKG1hcENvbmZpZy5pZCA+PSAwKSB7XG4gICAgICAgICAgc3RvcnltYXAuc2V0KCdpZCcsIG1hcENvbmZpZy5pZCk7XG4gICAgICAgICAgc3RvcnltYXAuc2V0TW9kZShtYXBDb25maWcucGxheWJhY2tNb2RlKTtcbiAgICAgICAgICBpZiAoZGF0YS5hYm91dCAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHN0b3J5bWFwLnNldFN0b3J5VGl0bGUoZGF0YS5hYm91dC50aXRsZSk7XG4gICAgICAgICAgICBzdG9yeW1hcC5zZXRTdG9yeUFic3RyYWN0KGRhdGEuYWJvdXQuYWJzdHJhY3QpO1xuICAgICAgICAgICAgc3RvcnltYXAuc2V0U3RvcnlPd25lcihkYXRhLmFib3V0Lm93bmVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdG9yeW1hcC5zZXRDZW50ZXIobWFwQ29uZmlnLm1hcC5jZW50ZXIpO1xuICAgICAgICAgIHN0b3J5bWFwLnNldFpvb20obWFwQ29uZmlnLm1hcC56b29tKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBtYXBDb25maWcubWFwLmxheWVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgdmFyIGxheWVyQ29uZmlnID0gbWFwQ29uZmlnLm1hcC5sYXllcnNbaV07XG4gICAgICAgICAgaWYgKGxheWVyQ29uZmlnLmdyb3VwID09PSAnYmFja2dyb3VuZCcgJiYgbGF5ZXJDb25maWcudmlzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3RTdG9yeU1hcEJhc2VCdWlsZGVyLnNldEJhc2VMYXllcihzdG9yeW1hcCwgbGF5ZXJDb25maWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKmpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuICAgICAgICAgICAgc3RMYXllckJ1aWxkZXIuYnVpbGRMYXllcihsYXllckNvbmZpZywgc3RvcnltYXAuZ2V0TWFwKCkpLnRoZW4oZnVuY3Rpb24oc2wpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETyBpbnNlcnQgYXQgdGhlIGNvcnJlY3QgaW5kZXhcbiAgICAgICAgICAgICAgc3RvcnltYXAuYWRkU3RvcnlMYXllcihzbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RvcnltYXAuZ2V0TWFwKCkuc2V0VmlldyhuZXcgb2wuVmlldyh7XG4gICAgICAgICAgY2VudGVyOiBtYXBDb25maWcubWFwLmNlbnRlcixcbiAgICAgICAgICB6b29tOiBtYXBDb25maWcubWFwLnpvb20sXG4gICAgICAgICAgbWluWm9vbTogMyxcbiAgICAgICAgICBtYXhab29tOiAxN1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgbW9kdWxlLnNlcnZpY2UoJ3N0RWRpdGFibGVTdG9yeU1hcEJ1aWxkZXInLCBmdW5jdGlvbihzdFN0b3J5TWFwQmFzZUJ1aWxkZXIsIHN0RWRpdGFibGVMYXllckJ1aWxkZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZ5U3RvcnlMYXllcjogZnVuY3Rpb24oc3RvcnlsYXllciwgbmV3VHlwZSkge1xuICAgICAgICB2YXIgZGF0YSA9IHN0b3J5bGF5ZXIuZ2V0UHJvcGVydGllcygpO1xuICAgICAgICB2YXIgc3RvcnltYXAgPSBzdG9yeWxheWVyLmdldFN0b3J5TWFwKCk7XG4gICAgICAgIGRhdGEudHlwZSA9IG5ld1R5cGUgPyBuZXdUeXBlIDogKChkYXRhLnR5cGUgPT09ICdXTVMnKSA/ICdWRUNUT1InIDogJ1dNUycpO1xuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnV01TJykge1xuICAgICAgICAgIGRlbGV0ZSBkYXRhLmZlYXR1cmVzO1xuICAgICAgICB9XG4gICAgICAgIHN0RWRpdGFibGVMYXllckJ1aWxkZXIuYnVpbGRFZGl0YWJsZUxheWVyKGRhdGEsIHN0b3J5bWFwLmdldE1hcCgpKS50aGVuKGZ1bmN0aW9uKHNsKSB7XG4gICAgICAgICAgLy8gc2VxdWVuY2UgaXMgaW1wb3J0YW50IGhlcmUsIGZpcnN0IGNoYW5nZSBsYXllciwgdGhlbiB0aGUgdHlwZS5cbiAgICAgICAgICBzdG9yeWxheWVyLnNldExheWVyKHNsLmdldExheWVyKCkpO1xuICAgICAgICAgIHN0b3J5bGF5ZXIuc2V0KCd0eXBlJywgc2wuZ2V0KCd0eXBlJykpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBtb2RpZnlTdG9yeU1hcDogZnVuY3Rpb24oc3RvcnltYXAsIGRhdGEpIHtcbiAgICAgICAgc3RvcnltYXAuY2xlYXIoKTtcbiAgICAgICAgdmFyIG1hcENvbmZpZyA9IHN0b3J5dG9vbHMubWFwc3RvcnkuTWFwQ29uZmlnVHJhbnNmb3JtZXIuTWFwQ29uZmlnVHJhbnNmb3JtZXIoZGF0YSk7XG4gICAgICAgIGlmIChtYXBDb25maWcuaWQgPj0gMCkge1xuICAgICAgICAgIHN0b3J5bWFwLnNldCgnaWQnLCBtYXBDb25maWcuaWQpO1xuICAgICAgICAgIHN0b3J5bWFwLnNldE1vZGUobWFwQ29uZmlnLnBsYXliYWNrTW9kZSk7XG4gICAgICAgICAgaWYgKGRhdGEuYWJvdXQgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBzdG9yeW1hcC5zZXRTdG9yeVRpdGxlKGRhdGEuYWJvdXQudGl0bGUpO1xuICAgICAgICAgICAgc3RvcnltYXAuc2V0U3RvcnlBYnN0cmFjdChkYXRhLmFib3V0LmFic3RyYWN0KTtcbiAgICAgICAgICAgIHN0b3J5bWFwLnNldFN0b3J5T3duZXIoZGF0YS5hYm91dC5vd25lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG1hcENvbmZpZy5tYXAubGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICB2YXIgbGF5ZXJDb25maWcgPSBtYXBDb25maWcubWFwLmxheWVyc1tpXTtcbiAgICAgICAgICBpZiAobGF5ZXJDb25maWcuZ3JvdXAgPT09ICdiYWNrZ3JvdW5kJyAmJiBsYXllckNvbmZpZy52aXNpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdFN0b3J5TWFwQmFzZUJ1aWxkZXIuc2V0QmFzZUxheWVyKHN0b3J5bWFwLCBsYXllckNvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qanNoaW50IGxvb3BmdW5jOiB0cnVlICovXG4gICAgICAgICAgICBzdEVkaXRhYmxlTGF5ZXJCdWlsZGVyLmJ1aWxkRWRpdGFibGVMYXllcihsYXllckNvbmZpZywgc3RvcnltYXAuZ2V0TWFwKCkpLnRoZW4oZnVuY3Rpb24oc2wpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETyBpbnNlcnQgYXQgdGhlIGNvcnJlY3QgaW5kZXhcbiAgICAgICAgICAgICAgc3RvcnltYXAuYWRkU3RvcnlMYXllcihzbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RvcnltYXAuZ2V0TWFwKCkuc2V0VmlldyhuZXcgb2wuVmlldyh7XG4gICAgICAgICAgY2VudGVyOiBtYXBDb25maWcubWFwLmNlbnRlcixcbiAgICAgICAgICB6b29tOiBtYXBDb25maWcubWFwLnpvb20sXG4gICAgICAgICAgcHJvamVjdGlvbjogbWFwQ29uZmlnLm1hcC5wcm9qZWN0aW9uLFxuICAgICAgICAgIG1pblpvb206IDMsXG4gICAgICAgICAgbWF4Wm9vbTogMTdcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG59KSgpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnc3Rvcnl0b29scy5jb3JlLnBpbnMnLCBbXG4gICAgXSk7XG5cbiAgICB2YXIgcGlucyA9IHN0b3J5dG9vbHMuY29yZS5tYXBzLnBpbnM7XG5cbiAgICBmdW5jdGlvbiBTdG9yeVBpbkxheWVyTWFuYWdlcigpIHtcbiAgICAgICAgdGhpcy5zdG9yeVBpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYXAgPSBudWxsO1xuICAgIH1cbiAgICBTdG9yeVBpbkxheWVyTWFuYWdlci5wcm90b3R5cGUucGluc0NoYW5nZWQgPSBmdW5jdGlvbihwaW5zLCBhY3Rpb24pIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmIChhY3Rpb24gPT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBpbiA9IHBpbnNbaV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gdGhpcy5zdG9yeVBpbnMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdG9yeVBpbnNbal0uaWQgPT0gcGluLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3J5UGlucy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT0gJ2FkZCcpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yeVBpbnMucHVzaChwaW5zW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT0gJ2NoYW5nZScpIHtcbiAgICAgICAgICAgIC8vIHByb3ZpZGVkIGVkaXRzIGNvdWxkIGJlIHVzZWQgdG8gb3B0aW1pemUgYmVsb3dcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWN0aW9uPyA6JyArIGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRvZG8gb3B0aW1pemUgYnkgbG9va2luZyBhdCBjaGFuZ2VzXG4gICAgICAgIHZhciB0aW1lcyA9IHRoaXMuc3RvcnlQaW5zLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICBpZiAocC5zdGFydF90aW1lID4gcC5lbmRfdGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yeXRvb2xzLmNvcmUudXRpbHMuY3JlYXRlUmFuZ2UocC5lbmRfdGltZSwgcC5zdGFydF90aW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3J5dG9vbHMuY29yZS51dGlscy5jcmVhdGVSYW5nZShwLnN0YXJ0X3RpbWUsIHAuZW5kX3RpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXAuc3RvcnlQaW5zTGF5ZXIuc2V0KCd0aW1lcycsIHRpbWVzKTtcbiAgICAgICAgdGhpcy5tYXAuc3RvcnlQaW5zTGF5ZXIuc2V0KCdmZWF0dXJlcycsIHRoaXMuc3RvcnlQaW5zKTtcbiAgICB9O1xuICAgIFN0b3J5UGluTGF5ZXJNYW5hZ2VyLnByb3RvdHlwZS5sb2FkRnJvbUdlb0pTT04gPSBmdW5jdGlvbihnZW9qc29uLCBwcm9qZWN0aW9uLCBvdmVyd3JpdGUpIHtcblxuICAgICAgICBpZiAob3ZlcndyaXRlKXtcbiAgICAgICAgICAgIHRoaXMuc3RvcnlQaW5zID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2VvanNvbiAmJiBnZW9qc29uLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICB2YXIgbG9hZGVkID0gcGlucy5sb2FkRnJvbUdlb0pTT04oZ2VvanNvbiwgcHJvamVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLnBpbnNDaGFuZ2VkKGxvYWRlZCwgJ2FkZCcsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5zZXJ2aWNlKCdTdG9yeVBpbkxheWVyTWFuYWdlcicsIFN0b3J5UGluTGF5ZXJNYW5hZ2VyKTtcblxuICAgIG1vZHVsZS5jb25zdGFudCgnU3RvcnlQaW4nLCBwaW5zLlN0b3J5UGluKTtcblxuICAgIC8vIEB0b2RvIG5haXZlIGltcGxlbWVudGF0aW9uIG9uIGxvY2FsIHN0b3JhZ2UgZm9yIG5vd1xuICAgIG1vZHVsZS5zZXJ2aWNlKCdzdEFubm90YXRpb25zU3RvcmUnLCBmdW5jdGlvbihTdG9yeVBpbkxheWVyTWFuYWdlcikge1xuICAgICAgICBmdW5jdGlvbiBwYXRoKG1hcGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJy9tYXBzLycgKyBtYXBpZCArICcvYW5ub3RhdGlvbnMnO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldChtYXBpZCkge1xuICAgICAgICAgICAgdmFyIHNhdmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0ocGF0aChtYXBpZCkpO1xuICAgICAgICAgICAgc2F2ZWQgPSAoc2F2ZWQgPT09IG51bGwpID8gW10gOiBKU09OLnBhcnNlKHNhdmVkKTtcbiAgICAgICAgICAgIC8vIFRPRE8gaXMgdGhpcyBzdGlsbCBuZWVkZWQ/XG4gICAgICAgICAgICAvKnNhdmVkLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgIHMudGhlX2dlb20gPSBmb3JtYXQucmVhZEdlb21ldHJ5KHMudGhlX2dlb20pO1xuICAgICAgICAgICAgfSk7Ki9cbiAgICAgICAgICAgIHJldHVybiBzYXZlZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXQobWFwaWQsIGFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGlzIHRoaXMgc3RpbGwgbmVlZGVkP1xuICAgICAgICAgICAgLyphbm5vdGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocy50aGVfZ2VvbSAmJiAhYW5ndWxhci5pc1N0cmluZyhzLnRoZV9nZW9tKSkge1xuICAgICAgICAgICAgICAgICAgICBzLnRoZV9nZW9tID0gZm9ybWF0LndyaXRlR2VvbWV0cnkocy50aGVfZ2VvbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7Ki9cbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHBhdGgobWFwaWQpLFxuICAgICAgICAgICAgICAgIG5ldyBvbC5mb3JtYXQuR2VvSlNPTigpLndyaXRlRmVhdHVyZXMoYW5ub3RhdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHtkYXRhUHJvamVjdGlvbjogJ0VQU0c6NDMyNicsIGZlYXR1cmVQcm9qZWN0aW9uOiAnRVBTRzozODU3J30pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2FkQW5ub3RhdGlvbnM6IGZ1bmN0aW9uKG1hcGlkLCBwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0b3J5UGluTGF5ZXJNYW5hZ2VyLmxvYWRGcm9tR2VvSlNPTihnZXQobWFwaWQpLCBwcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVBbm5vdGF0aW9uczogZnVuY3Rpb24oYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2F2ZWQgPSBnZXQoKTtcbiAgICAgICAgICAgICAgICB2YXIgdG9EZWxldGUgPSBhbm5vdGF0aW9ucy5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5pZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzYXZlZCA9IHNhdmVkLmZpbHRlcihmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b0RlbGV0ZS5pbmRleE9mKHMuaWQpIDwgMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZXQoc2F2ZWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhdmVBbm5vdGF0aW9uczogZnVuY3Rpb24obWFwaWQsIGFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNhdmVkID0gZ2V0KCk7XG4gICAgICAgICAgICAgICAgdmFyIG1heElkID0gMDtcbiAgICAgICAgICAgICAgICBzYXZlZC5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4SWQgPSBNYXRoLm1heChtYXhJZCwgcy5pZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGNsb25lcyA9IFtdO1xuICAgICAgICAgICAgICAgIGFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGEuaWQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuaWQgPSArK21heElkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9uZSA9IGEuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEuZ2V0KCdzdGFydF90aW1lJykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUuc2V0KCdzdGFydF90aW1lJywgYS5nZXQoJ3N0YXJ0X3RpbWUnKS8xMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYS5nZXQoJ2VuZF90aW1lJykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUuc2V0KCdlbmRfdGltZScsIGEuZ2V0KCdlbmRfdGltZScpLzEwMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNsb25lcy5wdXNoKGNsb25lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZXQobWFwaWQsIGNsb25lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKCdzdG9yeXRvb2xzLmNvcmUuc3R5bGUub2wzU3R5bGVDb252ZXJ0ZXInLCBbXSk7XG5cbiAgICBtb2R1bGUuZmFjdG9yeSgnb2wzTWFya1JlbmRlcmVyJywgZnVuY3Rpb24ob2wzU3R5bGVDb252ZXJ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNoYXBlTmFtZSwgc2l6ZSkge1xuICAgICAgICAgICAgdmFyIGJsYWNrID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2V0Q29sb3IoJyMwMDAwMDAnKTtcbiAgICAgICAgICAgIHZhciBzdHJva2VXaWR0aCA9IDM7IC8vIGhhY2sgdG8gZml4IGRvd24tc2NhbGluZyBmb3IgeCBhbmQgY3Jvc3NcbiAgICAgICAgICAgIHZhciBvcHRzID0ge2NvbG9yOiBibGFjaywgd2lkdGg6IHN0cm9rZVdpZHRofTtcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBhbmd1bGFyLmVsZW1lbnQob2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTaGFwZSh7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDoge3NoYXBlOiBzaGFwZU5hbWUsIHNpemU6IHNpemUgLSBzdHJva2VXaWR0aH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5ldyBvbC5zdHlsZS5GaWxsKG9wdHMpLFxuICAgICAgICAgICAgICAgIG5ldyBvbC5zdHlsZS5TdHJva2Uob3B0cykpLmdldEltYWdlKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIG1vZHVsZS5mYWN0b3J5KCdvbDNTdHlsZUNvbnZlcnRlcicsIGZ1bmN0aW9uKHN0U3ZnSWNvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2VuZXJhdGVTaGFwZUNvbmZpZzogZnVuY3Rpb24oc3R5bGUsIGZpbGwsIHN0cm9rZSkge1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IHN0eWxlLnN5bWJvbC5zaGFwZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluYWwgc2l6ZSBpcyBhY3R1YWxseSAoMiAqIChyYWRpdXMgKyBzdHJva2Uud2lkdGgpKSArIDFcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzID0gc3R5bGUuc3ltYm9sLnNpemUgLyAyO1xuICAgICAgICAgICAgICAgIGlmIChzaGFwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogcmFkaXVzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3NxdWFyZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGU6IE1hdGguUEkgLyA0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3RyaWFuZ2xlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmdsZTogMFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdzdGFyJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXMyOiAwLjUqcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGU6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAnY3Jvc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IDQsXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmdsZTogMFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICd4Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXMyOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGU6IE1hdGguUEkgLyA0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGN1bGF0ZVJvdGF0aW9uOiBmdW5jdGlvbihzdHlsZSwgZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zeW1ib2wgJiYgc3R5bGUuc3ltYm9sLnJvdGF0aW9uQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zeW1ib2wucm90YXRpb25Vbml0cyA9PT0gJ3JhZGlhbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZS5nZXQoc3R5bGUuc3ltYm9sLnJvdGF0aW9uQXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZmVhdHVyZS5nZXQoc3R5bGUuc3ltYm9sLnJvdGF0aW9uQXR0cmlidXRlKS8zNjApKk1hdGguUEk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZVNoYXBlOiBmdW5jdGlvbihzdHlsZSwgZmlsbCwgc3Ryb2tlLCBmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuZ2VuZXJhdGVTaGFwZUNvbmZpZyhzdHlsZSwgZmlsbCwgc3Ryb2tlKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnICYmIGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnJvdGF0aW9uID0gdGhpcy5jYWxjdWxhdGVSb3RhdGlvbihzdHlsZSwgZmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zeW1ib2wuZ3JhcGhpYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHN0U3ZnSWNvbi5nZXRJbWFnZShzdHlsZS5zeW1ib2wuZ3JhcGhpYywgZmlsbC5nZXRDb2xvcigpLCBzdHJva2UuZ2V0Q29sb3IoKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgb2wuc3R5bGUuSWNvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmM6IGluZm8uZGF0YVVSSSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiB0aGlzLmNhbGN1bGF0ZVJvdGF0aW9uKHN0eWxlLCBmZWF0dXJlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlOiBzdHlsZS5zeW1ib2wuc2l6ZSAvIE1hdGgubWF4KGluZm8ud2lkdGgsIGluZm8uaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IHN0eWxlLnN5bWJvbC5vcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGUuc3ltYm9sLnNoYXBlID09PSAnY2lyY2xlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG9sLnN0eWxlLkNpcmNsZShjb25maWcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgb2wuc3R5bGUuUmVndWxhclNoYXBlKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFRleHQ6IGZ1bmN0aW9uKHN0eWxlLCBmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmxhYmVsICYmIHN0eWxlLmxhYmVsLmF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJycgKyBmZWF0dXJlLmdldChzdHlsZS5sYWJlbC5hdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlVGV4dDogZnVuY3Rpb24oc3R5bGUsIHN0cm9rZSwgZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5sYWJlbCAmJiBzdHlsZS5sYWJlbC5hdHRyaWJ1dGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBvbC5zdHlsZS5UZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IG5ldyBvbC5zdHlsZS5GaWxsKHtjb2xvcjogc3R5bGUubGFiZWwuZmlsbENvbG9yfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQ6IHN0eWxlLmxhYmVsLmZvbnRTdHlsZSArICcgJyArIHN0eWxlLmxhYmVsLmZvbnRXZWlnaHQgKyAnICcgKyBzdHlsZS5sYWJlbC5mb250U2l6ZSArICdweCAnICsgc3R5bGUubGFiZWwuZm9udEZhbWlseSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuZ2V0VGV4dChzdHlsZSwgZmVhdHVyZSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENvbG9yOiBmdW5jdGlvbihjb2xvciwgb3BhY2l0eSkge1xuICAgICAgICAgICAgICAgIHZhciByZ2JhID0gb2wuY29sb3IuYXNBcnJheShjb2xvcik7XG4gICAgICAgICAgICAgICAgaWYgKG9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZ2JhID0gcmdiYS5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICByZ2JhWzNdID0gb3BhY2l0eS8xMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAncmdiYSgnICsgcmdiYS5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVDYWNoZUtleTogZnVuY3Rpb24oc3R5bGUsIGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0VGV4dChzdHlsZSwgZmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzaWZ5ID0gKHN0eWxlLmNsYXNzaWZ5ICYmIHN0eWxlLmNsYXNzaWZ5LmF0dHJpYnV0ZSkgPyBmZWF0dXJlLmdldChzdHlsZS5jbGFzc2lmeS5hdHRyaWJ1dGUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IChzdHlsZS5zeW1ib2wgJiYgc3R5bGUuc3ltYm9sLnJvdGF0aW9uQXR0cmlidXRlKSA/IGZlYXR1cmUuZ2V0KHN0eWxlLnN5bWJvbC5yb3RhdGlvbkF0dHJpYnV0ZSk6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCArICd8JyArIGNsYXNzaWZ5ICsgJ3wnICsgcm90YXRpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVTdHlsZTogZnVuY3Rpb24oc3R5bGUsIGZlYXR1cmUsIHJlc29sdXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0LCBrZXkyO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdHlsZUNhY2hlXykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlQ2FjaGVfID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBKU09OLnN0cmluZ2lmeShzdHlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGVDYWNoZV9ba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3R5bGVDYWNoZV9ba2V5XS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTIgPSB0aGlzLmdlbmVyYXRlQ2FjaGVLZXkoc3R5bGUsIGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGVDYWNoZV9ba2V5XVtrZXkyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlQ2FjaGVfW2tleV1ba2V5Ml07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHlsZUNhY2hlX1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdHJva2U7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnN0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZURhc2g7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zdHJva2Uuc3Ryb2tlU3R5bGUgPT09ICdkYXNoZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaCA9IFs1XTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5zdHJva2Uuc3Ryb2tlU3R5bGUgPT09ICdkb3R0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaCA9IFsxLDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZSA9IG5ldyBvbC5zdHlsZS5TdHJva2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZURhc2g6IGxpbmVEYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuZ2V0Q29sb3Ioc3R5bGUuc3Ryb2tlLnN0cm9rZUNvbG9yLCBzdHlsZS5zdHJva2Uuc3Ryb2tlT3BhY2l0eSksXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogc3R5bGUuc3Ryb2tlLnN0cm9rZVdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuY2xhc3NpZnkgJiYgc3R5bGUuY2xhc3NpZnkuYXR0cmlidXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBpaT1zdHlsZS5ydWxlcy5sZW5ndGg7IGk8aWk7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBzdHlsZS5ydWxlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsID0gZmVhdHVyZS5nZXQoc3R5bGUuY2xhc3NpZnkuYXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gYXR0clZhbCA9PT0gcnVsZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocnVsZS5yYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gKGF0dHJWYWwgPj0gcnVsZS5yYW5nZS5taW4gJiYgYXR0clZhbCA8PSBydWxlLnJhbmdlLm1heCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IHRoaXMuZ2VuZXJhdGVUZXh0KHN0eWxlLCBzdHJva2UsIGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS5nZW9tVHlwZSA9PT0gJ3BvaW50JyAmJiBydWxlLnN0eWxlLnN5bWJvbC5maWxsQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW25ldyBvbC5zdHlsZS5TdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiB0aGlzLmdlbmVyYXRlU2hhcGUoc3R5bGUsIG5ldyBvbC5zdHlsZS5GaWxsKHtjb2xvcjogcnVsZS5zdHlsZS5zeW1ib2wuZmlsbENvbG9yfSksIHN0cm9rZSwgZmVhdHVyZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGUuZ2VvbVR5cGUgPT09ICdsaW5lJyAmJiBydWxlLnN0eWxlLnN0cm9rZS5zdHJva2VDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbbmV3IG9sLnN0eWxlLlN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBuZXcgb2wuc3R5bGUuU3Ryb2tlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogcnVsZS5zdHlsZS5zdHJva2Uuc3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLmdlb21UeXBlID09PSAncG9seWdvbicgJiYgcnVsZS5zdHlsZS5zeW1ib2wuZmlsbENvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtuZXcgb2wuc3R5bGUuU3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IG5ldyBvbC5zdHlsZS5GaWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogcnVsZS5zdHlsZS5zeW1ib2wuZmlsbENvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdHlsZUNhY2hlX1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZUNhY2hlX1trZXldID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkyID0gdGhpcy5nZW5lcmF0ZUNhY2hlS2V5KHN0eWxlLCBmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVDYWNoZV9ba2V5XVtrZXkyXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxsID0gbmV3IG9sLnN0eWxlLkZpbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuZ2V0Q29sb3Ioc3R5bGUuc3ltYm9sLmZpbGxDb2xvciwgc3R5bGUuc3ltYm9sLmZpbGxPcGFjaXR5KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IG9sLnN0eWxlLlN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogdGhpcy5nZW5lcmF0ZVNoYXBlKHN0eWxlLCBmaWxsLCBzdHJva2UsIGZlYXR1cmUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5nZW5lcmF0ZVRleHQoc3R5bGUsIHN0cm9rZSwgZmVhdHVyZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1RleHQgPSByZXN1bHRbMF0uZ2V0VGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzVGV4dCB8fCAoc3R5bGUuY2xhc3NpZnkgJiYgc3R5bGUuY2xhc3NpZnkuYXR0cmlidXRlKSB8fCAoc3R5bGUuc3ltYm9sICYmIHN0eWxlLnN5bWJvbC5yb3RhdGlvbkF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdHlsZUNhY2hlX1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZUNhY2hlX1trZXldID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkyPSB0aGlzLmdlbmVyYXRlQ2FjaGVLZXkoc3R5bGUsIGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZUNhY2hlX1trZXldW2tleTJdID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZUNhY2hlX1trZXldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnc3Rvcnl0b29scy5jb3JlLnN0eWxlLnN2Z0ljb24nLCBbXSk7XG5cbiAgICBtb2R1bGUuZmFjdG9yeSgnc3RTdmdJY29uJywgZnVuY3Rpb24oJGNhY2hlRmFjdG9yeSwgJGh0dHAsICRxLCAkbG9nKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gYW5ndWxhci5lbGVtZW50KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgdmFyIGltYWdlQ2FjaGUgPSAkY2FjaGVGYWN0b3J5KCdzdFN2Z0ltYWdlJyk7XG4gICAgICAgIHZhciBkYXRhQ2FjaGUgPSAkY2FjaGVGYWN0b3J5KCdzdFN2Z0RhdGEnKTtcbiAgICAgICAgZnVuY3Rpb24gcHJvY2VzcyhzdmcsIGZpbGwsIHN0cm9rZSkge1xuICAgICAgICAgICAgZWxlbWVudC5odG1sKHN2Zyk7XG4gICAgICAgICAgICAvLyBAdG9kbyBtYWtlIHNtYXJ0ZXJcbiAgICAgICAgICAgIFsncGF0aCcsICdwb2x5Z29uJywgJ2NpcmNsZScsICdlbGxpcHNlJywgJ3JlY3QnLCAnbGluZScsICdwb2x5bGluZSddLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZWxlbWVudC5maW5kKGVsKSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdG9kbyBkb2VzIGl0IG1ha2Ugc2Vuc2UgdG8gb3ZlcnJpZGUgc3Ryb2tlIHdpZHRoP1xuICAgICAgICAgICAgICAgICAgICBlID0gYW5ndWxhci5lbGVtZW50KGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3NzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdGaWxsID0gZS5jc3MoJ2ZpbGwnKSB8fCBlLmF0dHIoJ2ZpbGwnKSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRmlsbCAhPSAnbm9uZScgJiYgZXhpc3RpbmdGaWxsICE9ICdyZ2IoMjU1LCAyNTUsIDI1NSknICYmIGV4aXN0aW5nRmlsbC50b0xvd2VyQ2FzZSgpICE9ICcjZmZmZmZmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3NzLmZpbGwgPSBmaWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ1N0cm9rZSA9IGUuY3NzKCdzdHJva2UnKSB8fCBlLmF0dHIoJ3N0cm9rZScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdTdHJva2UgIT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc3Ryb2tlID0gc3Ryb2tlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGUuY3NzKGNzcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciByb290ID0gZWxlbWVudC5maW5kKCdzdmcnKTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHBhcnNlSW50KHJvb3QuYXR0cignd2lkdGgnKSk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VJbnQocm9vdC5hdHRyKCdoZWlnaHQnKSk7XG4gICAgICAgICAgICAvLyB1Z2ggLSB3ZSdyZSB0b3RhbGx5IGd1ZXNzaW5nIGhlcmUgYnV0IHRoaW5ncyBnbyBiYWRseSB3aXRob3V0OlxuICAgICAgICAgICAgLy8gb24gZmlyZWZveDogbnNfZXJyb3Jfbm90X2F2YWlsYWJsZSBvbiBjYWxsaW5nIGNhbnZhcy5kcmF3aW1hZ2VcbiAgICAgICAgICAgIC8vIG9uIGNocm9tZTogdmVyeSBsYXJnZSBpY29uIChkZWZhdWx0IHNpemUgYXMgaXQgcmVuZGVycylcbiAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGJlIGFibGUgdG8gc2V0IHRoZSBzcmMgb24gYW4gaW1nIGVsZW1lbnQgYW5kIGZpZ3VyZSB0aGlzIG91dC4uLlxuICAgICAgICAgICAgaWYgKGlzTmFOKHdpZHRoKSB8fCBpc05hTihoZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5hdHRyKCd3aWR0aCcsIDY0KTtcbiAgICAgICAgICAgICAgICByb290LmF0dHIoJ2hlaWdodCcsIDY0KTtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IDY0O1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IDY0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRhdGFVUkkgPSAnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwnICsgYnRvYShlbGVtZW50Lmh0bWwoKSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGFVUkk6IGRhdGFVUkksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXRJbWFnZTogZnVuY3Rpb24oc3ZnVVJJLCBmaWxsLCBzdHJva2UsIHN5bmMpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gc3ZnVVJJICsgZmlsbCArIHN0cm9rZTtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkID0gaW1hZ2VDYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShjYWNoZWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ZnID0gZGF0YUNhY2hlLmdldChzdmdVUkkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN2Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZUluZm8gPSBwcm9jZXNzKHN2ZywgZmlsbCwgc3Ryb2tlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZUluZm8udXJpID0gc3ZnVVJJO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlQ2FjaGUucHV0KGtleSwgaW1hZ2VJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW1hZ2VJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy53YXJuaW5nKCdubyBzdmcgZm9yJywgc3ZnVVJJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0SW1hZ2VEYXRhKHN2Z1VSSSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlSW5mbyA9IHByb2Nlc3MocmVzcG9uc2UuZGF0YSwgZmlsbCwgc3Ryb2tlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlSW5mby51cmkgPSBzdmdVUkk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZUNhY2hlLnB1dChrZXksIGltYWdlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGltYWdlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCdlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SW1hZ2VEYXRhOiBmdW5jdGlvbihzdmdVUkkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KHN2Z1VSSSwge2NhY2hlOiB0cnVlfSkuc3VjY2VzcyhmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhQ2FjaGUucHV0KHN2Z1VSSSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSkuZXJyb3IoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRsb2cud2FybignZXJyb3IgZmV0Y2hpbmcgJyArIHN2Z1VSSSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKCdzdG9yeXRvb2xzLmNvcmUudGltZS5zZXJ2aWNlcycsIFtdKTtcblxuICAgIHZhciBzdHV0aWxzID0gc3Rvcnl0b29scy5jb3JlLnRpbWUudXRpbHM7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIGEgc29ydGVkLCB1bmlxdWUgYXJyYXkgb2YgdGlja3MgZm9yIHRoZSBwcm92aWRlZCBsYXllcnMuIFRoZVxuICAgICAqIGFsZ29yaXRobSB1c2VzIGFueSBwcm92aWRlZCBpbnN0YW50IG9yIGV4dGVudChzdGFydCB2YWx1ZSB1c2VkKSBsaXN0IHZhbHVlc1xuICAgICAqIGFuZCBsb29rcyBhdCB0aGUgdG90YWwgcmFuZ2Ugb2YgYWxsIGludGVydmFsIHZhbHVlcyBjcmVhdGluZyBhIHRpY2sgYXQgdGhlXG4gICAgICogbWluaW11bSBpbnRlcnZhbCBmb3IgdGhlIHRvdGFsIHJhbmdlLiBTZWUgdGhlIHRlc3RzIGZvciBleGFtcGxlcy5cbiAgICAgKiBAcGFyYW0ge2FycmF5fG9sLk1hcH0gbGF5ZXJzV2l0aFRpbWVcbiAgICAgKiBAcmV0dXJucyBhcnJheSBvZiB0aWNrc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXB1dGVUaWNrcyhsYXllcnNXaXRoVGltZSkge1xuICAgICAgICAvLyBhbGxvdyBhIG1hcCB0byBiZSBwYXNzZWQgaW5cbiAgICAgICAgaWYgKCFhbmd1bGFyLmlzQXJyYXkobGF5ZXJzV2l0aFRpbWUpKSB7XG4gICAgICAgICAgICB2YXIgc3RvcnlNYXAgPSBsYXllcnNXaXRoVGltZTtcbiAgICAgICAgICAgIGxheWVyc1dpdGhUaW1lID0gc3RvcnlNYXAuZ2V0U3RvcnlMYXllcnMoKS5nZXRBcnJheSgpLmZpbHRlcihmdW5jdGlvbihsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVzID0gbC5nZXQoJ3RpbWVzJyk7XG4gICAgICAgICAgICAgICAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gdGltZXMgIT0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGF5ZXJzV2l0aFRpbWUucHVzaChzdG9yeU1hcC5zdG9yeVBpbnNMYXllcik7XG4gICAgICAgICAgICBsYXllcnNXaXRoVGltZS5wdXNoKHN0b3J5TWFwLnN0b3J5Qm94ZXNMYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRpY2tzID0ge307XG4gICAgICAgIHZhciB0b3RhbFJhbmdlID0gbnVsbDtcbiAgICAgICAgdmFyIGludGVydmFscyA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGRUaWNrKGFkZCkge1xuICAgICAgICAgICAgYWRkID0gc3R1dGlscy5nZXRUaW1lKGFkZCk7XG4gICAgICAgICAgICBpZiAoYWRkICE9PSBudWxsICYmICEgKGFkZCBpbiB0aWNrcykpIHtcbiAgICAgICAgICAgICAgICB0aWNrc1thZGRdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXllcnNXaXRoVGltZS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICAgIHZhciB0aW1lcyA9IGwuZ2V0KCd0aW1lcycpO1xuICAgICAgICAgICAgdmFyIHJhbmdlO1xuICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNBcnJheSh0aW1lcykpIHtcbiAgICAgICAgICAgICAgICAvLyBhbiBhcnJheSBvZiBpbnN0YW50cyBvciBleHRlbnRzXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBzdHV0aWxzLmNvbXB1dGVSYW5nZSh0aW1lcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R1dGlscy5pc1JhbmdlTGlrZSh0aW1lc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRpY2soci5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxSYW5nZSA9IHN0dXRpbHMuY3JlYXRlUmFuZ2Uocik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxSYW5nZS5leHRlbmQocik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcy5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRUaWNrKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWRkIGEgdGljayBhdCB0aGUgZW5kIHRvIGVuc3VyZSB3ZSBnZXQgdGhlcmVcbiAgICAgICAgICAgICAgICAvKmpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRUaWNrKHJhbmdlLmVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lcykge1xuICAgICAgICAgICAgICAgIC8vIGEgaW50ZXJ2YWwgKHJhbmdlK2R1cmF0aW9uKVxuICAgICAgICAgICAgICAgIHJhbmdlID0gdGltZXM7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxzLnB1c2godGltZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvdGFsUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBjb3B5LCB3aWxsIGJlIG1vZGlmeWluZ1xuICAgICAgICAgICAgICAgIHRvdGFsUmFuZ2UgPSBzdHV0aWxzLmNyZWF0ZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG90YWxSYW5nZS5leHRlbmQocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGludGVydmFscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGludGVydmFscy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbnRlcnZhbCAtIGIuaW50ZXJ2YWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzbWFsbGVzdCA9IGludGVydmFsc1swXTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRvdGFsUmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnQgPD0gdG90YWxSYW5nZS5lbmQpIHtcbiAgICAgICAgICAgICAgICBhZGRUaWNrKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHNtYWxsZXN0Lm9mZnNldChzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGlja3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aWNrcykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aWNrcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVGltZUNvbnRyb2xzTWFuYWdlcigkbG9nLCAkcm9vdFNjb3BlLCBTdG9yeVBpbkxheWVyTWFuYWdlciwgTWFwTWFuYWdlcikge1xuICAgICAgICB0aGlzLnRpbWVDb250cm9scyA9IG51bGw7XG4gICAgICAgIHZhciB0aW1lQ29udHJvbHNNYW5hZ2VyID0gdGhpcztcblxuICAgICAgICBmdW5jdGlvbiBtYXliZUNyZWF0ZVRpbWVDb250cm9scyh1cGRhdGUpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoXCJDcmVhdGluZyBUaW1lQ29udHJvbHMgd2l0aCBib3hlczogXCIpO1xuICAgICAgICAgICAvLyAkbG9nLmRlYnVnKFN0b3J5Qm94TGF5ZXJNYW5hZ2VyLnN0b3J5Qm94ZXMpO1xuICAgICAgICAgICAgaWYgKHRpbWVDb250cm9sc01hbmFnZXIudGltZUNvbnRyb2xzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVDb250cm9sc01hbmFnZXIudGltZUNvbnRyb2xzLnVwZGF0ZSh2YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByYW5nZSA9IGNvbXB1dGVUaWNrcyhNYXBNYW5hZ2VyLnN0b3J5TWFwKTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSBTdG9yeVBpbkxheWVyTWFuYWdlci5zdG9yeVBpbnM7XG4gICAgICAgICAgICAgICAgdGltZUNvbnRyb2xzTWFuYWdlci50aW1lQ29udHJvbHMgPSBzdG9yeXRvb2xzLmNvcmUudGltZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczogYW5ub3RhdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHN0b3J5TWFwOiBNYXBNYW5hZ2VyLnN0b3J5TWFwLFxuICAgICAgICAgICAgICAgICAgICBzdG9yeUxheWVyczogTWFwTWFuYWdlci5zdG9yeU1hcC5nZXRTdG9yeUxheWVycygpLmdldEFycmF5KCksXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBNYXBNYW5hZ2VyLnN0b3J5TWFwLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgIHRpbGVTdGF0dXNDYWxsYmFjazogZnVuY3Rpb24ocmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3RpbGVzTG9hZGVkJywgcmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2hhcHRlckNvdW50OiBNYXBNYW5hZ2VyLmNoYXB0ZXJDb3VudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRpbWVDb250cm9sc01hbmFnZXIudGltZUNvbnRyb2xzLm9uKCdyYW5nZUNoYW5nZScsIGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVDb250cm9sc01hbmFnZXIuY3VycmVudFJhbmdlID0gcmFuZ2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBNYXBNYW5hZ2VyLnN0b3J5TWFwLmdldFN0b3J5TGF5ZXJzKCkub24oJ2NoYW5nZTpsZW5ndGgnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1heWJlQ3JlYXRlVGltZUNvbnRyb2xzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGNvbXB1dGVUaWNrcyhNYXBNYW5hZ2VyLnN0b3J5TWFwKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yeUxheWVyczogTWFwTWFuYWdlci5zdG9yeU1hcC5nZXRTdG9yeUxheWVycygpLmdldEFycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiByYW5nZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBpbnNMYXllciA9IE1hcE1hbmFnZXIuc3RvcnlNYXAuc3RvcnlQaW5zTGF5ZXI7XG4gICAgICAgIHZhciBib3hlc0xheWVyID0gTWFwTWFuYWdlci5zdG9yeU1hcC5zdG9yeUJveGVzTGF5ZXI7XG4gICAgICAgIHBpbnNMYXllci5vbignY2hhbmdlOmZlYXR1cmVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtYXliZUNyZWF0ZVRpbWVDb250cm9scyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBjb21wdXRlVGlja3MoTWFwTWFuYWdlci5zdG9yeU1hcCk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcnlMYXllcnM6IE1hcE1hbmFnZXIuc3RvcnlNYXAuZ2V0U3RvcnlMYXllcnMoKS5nZXRBcnJheSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IHBpbnNMYXllci5nZXQoXCJmZWF0dXJlc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveGVzOiBib3hlc0xheWVyLmdldChcImZlYXR1cmVzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYm94ZXNMYXllci5vbignY2hhbmdlOmZlYXR1cmVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtYXliZUNyZWF0ZVRpbWVDb250cm9scyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBjb21wdXRlVGlja3MoTWFwTWFuYWdlci5zdG9yeU1hcCk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IHBpbnNMYXllci5nZXQoXCJmZWF0dXJlc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm94ZXM6IGJveGVzTGF5ZXIuZ2V0KFwiZmVhdHVyZXNcIilcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWF5YmVDcmVhdGVUaW1lQ29udHJvbHMoKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuY29uc3RhbnQoJ1RpbWVDb250cm9sc01hbmFnZXInLCBUaW1lQ29udHJvbHNNYW5hZ2VyKTtcblxuICAgIG1vZHVsZS5zZXJ2aWNlKCdUaW1lTWFjaGluZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tcHV0ZVRpY2tzOiBjb21wdXRlVGlja3NcbiAgICAgICAgfTtcbiAgICB9KTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnc3Rvcnl0b29scy5lZGl0LnN0eWxlLmRpcmVjdGl2ZXMnLCBbXSk7XG5cbiAgICBmdW5jdGlvbiBlZGl0b3JEaXJlY3RpdmUobmFtZSwgdGVtcGxhdGVVcmwsIHByb3BlcnR5LCBsaW5rZXIpIHtcbiAgICAgICAgbW9kdWxlLmRpcmVjdGl2ZShuYW1lLCBbJ3N0U3R5bGVDaG9pY2VzJywgZnVuY3Rpb24oc3R5bGVDaG9pY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RNb2RlbDogXCI9XCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBcIkBcIixcbiAgICAgICAgICAgICAgICAgICAgcG9wb3ZlcjogXCJAcG9wb3ZlclRleHRcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3R5bGUvd2lkZ2V0cy8nICsgdGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvIGJsZWNrIC0gZ3JhYmJpbmcgdGhlIGxheWVyIGZyb20gdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBzb21ldGhpbmcgbW9yZSBleHBsaWNpdFxuICAgICAgICAgICAgICAgICAgICBzY29wZS5sYXllciA9IHNjb3BlLiRwYXJlbnQubGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS4kcGFyZW50LmxheWVyO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihuZXUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmxheWVyID0gbmV1O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kYmxlY2tcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUubW9kZWwgPSBzY29wZS5zdE1vZGVsW3Byb3BlcnR5IHx8IHNjb3BlLnByb3BlcnR5XTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuc3R5bGVDaG9pY2VzID0gc3R5bGVDaG9pY2VzO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlua2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rZXIoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1dKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZGlyZWN0aXZlKCdzdHlsZUVkaXRvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3R5bGUvc3R5bGUtZWRpdG9yLmh0bWwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogJ3N0eWxlRWRpdG9yQ29udHJvbGxlcicsXG4gICAgICAgICAgICByZXF1aXJlOiAnP3N0eWxlRWRpdG9yQ29udHJvbGxlcicsXG4gICAgICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgICAgIGxheWVyIDogJz0nLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlIDogJz0nLFxuICAgICAgICAgICAgICAgIGZvcm1DaGFuZ2VkIDogJz0nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZGlyZWN0aXZlKCdhdHRyaWJ1dGVDb21ibycsIGZ1bmN0aW9uKCRsb2cpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ3N0eWxlL3dpZGdldHMvYXR0cmlidXRlLWNvbWJvLmh0bWwnLFxuICAgICAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgICAgICBsYXllcjogJz0nLFxuICAgICAgICAgICAgICAgIG1vZGVsOiBcIj1zdE1vZGVsXCIsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IFwiPT9cIixcbiAgICAgICAgICAgICAgICBjc3M6IFwiQGNzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlYWRBdHRyaWJ1dGVzKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUubGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmxheWVyLmdldCgnYXR0cmlidXRlcycpLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmNsdWRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMuZmlsdGVyID09PSAnbm9nZW9tJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlID0gYS50eXBlTlMgIT09ICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRycy5maWx0ZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgPSBhLnR5cGUgPT09ICdpbnRlZ2VyJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS50eXBlID09PSAnZG91YmxlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS50eXBlID09PSAnbG9uZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRycy5maWx0ZXIgPT09ICd1bmlxdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgPSBhLnR5cGUgPT09ICdpbnRlZ2VyJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS50eXBlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS50eXBlID09PSAnbG9uZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRycy5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvZy53YXJuKCd1bmtub3duIGZpbHRlcicsIGF0dHJzLmZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRycy5pbmNsdWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgPSBhdHRycy5pbmNsdWRlLmluZGV4T2YoYS50eXBlKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRzLnB1c2goYS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHMuc29ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuYXR0cmlidXRlcyA9IGF0dHM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5hdHRyaWJ1dGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQHRvZG8gaXMgd2F0Y2ggYWN0dWFsbHkgbmVlZGVkIGhlcmUgKHBvc3NpYmx5IHRoZSBjYXNlIGlmIHJldXNpbmcgdGhlIGVkaXRvcilcbiAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goJ2xheWVyJywgZnVuY3Rpb24obmV1LCBvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ldSAhPSBvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZWFkQXR0cmlidXRlcygpO1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgcHJvcGVydHkgdG8gbW9kaWZ5XG4gICAgICAgICAgICAgICAgc2NvcGUucHJvcGVydHkgPSBhdHRycy5wcm9wZXJ0eSB8fCAnYXR0cmlidXRlJztcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGNoYW5nZSB0aGUgbW9kZWxcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLm9uQ2hhbmdlID0gZnVuY3Rpb24ocHJvcGVydHksIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUubW9kZWxbcHJvcGVydHldID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGVkaXRvckRpcmVjdGl2ZSgnc3ltYm9sRWRpdG9yJywgJ3N5bWJvbC1lZGl0b3IuaHRtbCcsICdzeW1ib2wnLCBmdW5jdGlvbihzY29wZSwgZWwsIGF0dHJzKSB7XG4gICAgICAgIFsnc2hvd0dyYXBoaWMnLCAnc2hvd1JvdGF0aW9uJywgJ2hpZGVDb2xvciddLmZvckVhY2goZnVuY3Rpb24ob3B0KSB7XG4gICAgICAgICAgICBzY29wZVtvcHRdID0gYXR0cnNbb3B0XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNjb3BlLmdldFN5bWJvbGl6ZXJUZXh0ID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbC5zaGFwZSB8fCBtb2RlbC5ncmFwaGljO1xuICAgICAgICB9O1xuICAgICAgICBzY29wZS5nZXRTeW1ib2xpemVySW1hZ2UgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgZWRpdG9yRGlyZWN0aXZlKCdzdHJva2VFZGl0b3InLCAnc3Ryb2tlLWVkaXRvci5odG1sJywgJ3N0cm9rZScpO1xuICAgIGVkaXRvckRpcmVjdGl2ZSgnbnVtYmVyRWRpdG9yJywgJ251bWJlci1lZGl0b3IuaHRtbCcsIG51bGwsIGZ1bmN0aW9uKHNjb3BlLCBlbCwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgbWF4OiAzMCxcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIHN0ZXA6IDFcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmtleXMoZGVmYXVsdHMpLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgc2NvcGVbZV0gPSBhdHRyc1tlXSB8fCBkZWZhdWx0c1tlXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHdoZWVsKGV2KSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBlbC5maW5kKCdpbnB1dCcpO1xuICAgICAgICAgICAgdmFyIG1pbiA9IE51bWJlcihpbnB1dC5hdHRyKCdtaW4nKSkgfHwgMDtcbiAgICAgICAgICAgIHZhciBtYXggPSBOdW1iZXIoaW5wdXQuYXR0cignbWF4JykpO1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSBOdW1iZXIoaW5wdXQuYXR0cignc3RlcCcpKSB8fCAxO1xuICAgICAgICAgICAgdmFyIHZhbCA9IHNjb3BlLnN0TW9kZWxbc2NvcGUucHJvcGVydHldO1xuICAgICAgICAgICAgdmFyIHNjcm9sbCA9IGV2LmRldGFpbCB8fCBldi53aGVlbERlbHRhO1xuICAgICAgICAgICAgdmFsID0gTWF0aC5taW4obWF4LCB2YWwgKyAoc2Nyb2xsID4gMCA/IC1zdGVwOiBzdGVwKSk7XG4gICAgICAgICAgICB2YWwgPSBNYXRoLm1heChtaW4sIHZhbCk7XG4gICAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUuc3RNb2RlbFtzY29wZS5wcm9wZXJ0eV0gPSB2YWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbFswXS5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHdoZWVsLCBmYWxzZSApOyAvLyBGb3IgRkYgYW5kIE9wZXJhXG4gICAgICAgIGVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB3aGVlbCwgZmFsc2UgKTsgLy8gRm9yIG90aGVyc1xuICAgIH0pO1xuICAgIGVkaXRvckRpcmVjdGl2ZSgnY29sb3JFZGl0b3InLCAnY29sb3ItZWRpdG9yLmh0bWwnKTtcbiAgICBlZGl0b3JEaXJlY3RpdmUoJ2xhYmVsRWRpdG9yJywgJ2xhYmVsLWVkaXRvci5odG1sJywgJ2xhYmVsJywgZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgICAgLy8gQHRvZG8gb3RoZXIgb3B0aW9uc1xuICAgICAgICBzY29wZS5zdHlsZU1vZGVsID0ge1xuICAgICAgICAgICAgYm9sZCA6IHNjb3BlLm1vZGVsLmZvbnRXZWlnaHQgPT0gJ2JvbGQnLFxuICAgICAgICAgICAgaXRhbGljIDogc2NvcGUubW9kZWwuZm9udFN0eWxlID09ICdpdGFsaWMnXG4gICAgICAgIH07XG4gICAgICAgIHNjb3BlLnN0eWxlTW9kZWxDaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNjb3BlLm1vZGVsLmZvbnRXZWlnaHQgPSBzY29wZS5zdHlsZU1vZGVsLmJvbGQgPyAnYm9sZCcgOiAnbm9ybWFsJztcbiAgICAgICAgICAgIHNjb3BlLm1vZGVsLmZvbnRTdHlsZSA9IHNjb3BlLnN0eWxlTW9kZWwuaXRhbGljID8gJ2l0YWxpYycgOiAnbm9ybWFsJztcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEB0b2RvIGJyZWFrIGludG8gcGllY2VzIG9yIG1ha2Ugc2ltcGxlclxuICAgIC8vIEB0b2RvIGRvZXNuJ3Qgd2F0Y2ggaWNvbkNvbW1vbnMuZGVmYXVsdHMoKSAtIGNhbiBiZWNvbWUgb3V0IG9mIGRhdGVcbiAgICBtb2R1bGUuZGlyZWN0aXZlKCdncmFwaGljRWRpdG9yJywgZnVuY3Rpb24oc3RTdHlsZUNob2ljZXMsIG9sM01hcmtSZW5kZXJlciwgaWNvbkNvbW1vbnMsIGljb25Db21tb25zU2VhcmNoLCBzdFN2Z0ljb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ3N0eWxlL3dpZGdldHMvZ3JhcGhpYy1lZGl0b3IuaHRtbCcsXG4gICAgICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgICAgIHN5bWJvbDogJz0nXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjYW52YXMoc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGFuZ3VsYXIuZWxlbWVudChvbDNNYXJrUmVuZGVyZXIoc3ltYm9sLCAyNCkpO1xuICAgICAgICAgICAgICAgICAgICBlbC5hZGRDbGFzcygnc3ltYm9sLWljb24nKTtcbiAgICAgICAgICAgICAgICAgICAgZWwuYXR0cignbWFyaycsIHN5bWJvbCk7IC8vIGZvciB0ZXN0aW5nIHVudGlsIHdlIHVzZSBkYXRhIFVSSVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGltYWdlKGljb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gYW5ndWxhci5lbGVtZW50KCc8aW1nPicpO1xuICAgICAgICAgICAgICAgICAgICBlbC5hdHRyKCdzcmMnLCBpY29uLmRhdGFVUkkpO1xuICAgICAgICAgICAgICAgICAgICBlbC5hZGRDbGFzcygnc3ltYm9sLWljb24nKTtcbiAgICAgICAgICAgICAgICAgICAgZWwuYXR0cignZ3JhcGhpYycsIGljb24udXJpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGVsZW1lbnQgd2l0aCB0aGUgZGF0YS1jdXJyZW50LXN5bWJvbCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAvLyB0byBtYXRjaCB0aGUgY3VycmVudCBzeW1ib2xcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjdXJyZW50KCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBhbmd1bGFyLmVsZW1lbnQoZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jdXJyZW50LXN5bWJvbF0nKSk7XG4gICAgICAgICAgICAgICAgICAgIGVsLmZpbmQoJyonKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLnN5bWJvbC5zaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuYXBwZW5kKGNhbnZhcyhzY29wZS5zeW1ib2wuc2hhcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzY29wZS5zeW1ib2wuZ3JhcGhpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RTdmdJY29uLmdldEltYWdlKHNjb3BlLnN5bWJvbC5ncmFwaGljLCAnIzAwMCcsICcjZmZmJykudGhlbihmdW5jdGlvbihpY29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuYXBwZW5kKGltYWdlKGljb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjbGlja2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGFuZ3VsYXIuZWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmF0dHIoJ3NoYXBlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnN5bWJvbC5zaGFwZSA9IGVsLmF0dHIoJ3NoYXBlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5zeW1ib2wuZ3JhcGhpYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwuYXR0cignZ3JhcGhpYycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5zeW1ib2wuc2hhcGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuc3ltYm9sLmdyYXBoaWMgPSBlbC5hdHRyKCdncmFwaGljJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBtaWdodCBiZSBkb25lIGFub3RoZXIgd2F5IGJ1dCBiZWNhdXNlIHdlIGdldCBjYW52YXMgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAvLyBiYWNrIGZyb20gb2wzIHN0eWxlcywgd2UgYnVpbGQgdGhlIGRvbSBtYW51YWxseVxuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gYW5ndWxhci5lbGVtZW50KGVsZW1lbnRbMF0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnb2wtbWFya3MnKSk7XG4gICAgICAgICAgICAgICAgc3RTdHlsZUNob2ljZXMuc3ltYm9saXplcnMuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWcgPSBjYW52YXMocyk7XG4gICAgICAgICAgICAgICAgICAgIGltZy5hdHRyKCdzaGFwZScsIHMpO1xuICAgICAgICAgICAgICAgICAgICBpbWcub24oJ2NsaWNrJywgY2xpY2tlZCk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuYXBwZW5kKGltZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlUmVjZW50KCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ID0gYW5ndWxhci5lbGVtZW50KGVsZW1lbnRbMF0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncmVjZW50LWljb25zJykpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0Lmh0bWwoJycpO1xuICAgICAgICAgICAgICAgICAgICBpY29uQ29tbW9ucy5kZWZhdWx0cygpLnRoZW4oZnVuY3Rpb24oaWNvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25zLmZvckVhY2goZnVuY3Rpb24oaWNvbiwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWcgPSBpbWFnZShpY29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcub24oJ2NsaWNrJywgY2xpY2tlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5hcHBlbmQoaW1nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVseWluZyBvbiB0aGlzIGluIHRoZSB0ZXN0cyBhcyBhIG1lYW5zIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBrbm93aW5nIHdoZW4gdGhlIHJlY2VudCBpY29ucyBsb2FkaW5nIGhhcyBjb21wbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnJlY2VudCA9IGljb25zO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25seSBpbiBzY29wZSBmb3IgdHJpZ2dlcmluZyBpbiB0ZXN0c1xuICAgICAgICAgICAgICAgIHNjb3BlLl91cGRhdGVSZWNlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVjZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNjb3BlLl91cGRhdGVSZWNlbnQoKTtcbiAgICAgICAgICAgICAgICBzY29wZS5zaG93SWNvbkNvbW1vbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNvbW1vbnNTZWFyY2guc2VhcmNoKCkudGhlbihmdW5jdGlvbihzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugb2wzIHN0eWxlIGNyZWF0aW9uIGlzIHN5bmMsIHByZWxvYWQgaWNvbiBiZWZvcmUgc2V0dGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RTdmdJY29uLmdldEltYWdlRGF0YShzZWxlY3RlZC5ocmVmKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnN5bWJvbC5zaGFwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuc3ltYm9sLmdyYXBoaWMgPSBzZWxlY3RlZC5ocmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLl91cGRhdGVSZWNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgbW9kdWxlLmRpcmVjdGl2ZSgnY2xhc3NpZnlFZGl0b3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ3N0eWxlL3dpZGdldHMvY2xhc3NpZnktZWRpdG9yLmh0bWwnLFxuICAgICAgICAgICAgc2NvcGU6IHRydWUsXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgICAgICAgICBbJ3Nob3dNZXRob2QnLCdzaG93TWF4Q2xhc3NlcycsICdzaG93UmFuZ2UnLFxuICAgICAgICAgICAgICAgICAgICAnc2hvd0NvbG9yUmFtcCcsJ3Nob3dDb2xvclBhbGV0dGUnLCAnYXR0cmlidXRlRmlsdGVyJ10uZm9yRWFjaChmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVbb3B0XSA9IGF0dHJzW29wdF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZGlyZWN0aXZlKCdjb2xvclJhbXAnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgICAgIHJhbXA6IFwiPXJhbXBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IGVsZW1lbnRbMF0uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIGF0dHJzLndpZHRoLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc2NvcGUucmFtcCkuZm9yRWFjaChmdW5jdGlvbihzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gcGFyc2VGbG9hdChzdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oc3RvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcCwgc2NvcGUucmFtcFtzdG9wXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBhdHRycy53aWR0aCwgYXR0cnMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKCdyYW1wJywgcmVuZGVyKTtcbiAgICAgICAgICAgICAgICByZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIG1vZHVsZS5kaXJlY3RpdmUoJ2NvbG9yRmllbGQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlZ2V4ID0gLyheI1swLTlhLWZdezZ9JCl8KF4jWzAtOWEtZl17M30kKS9pO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZENvbG9yKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBAdG9kbyBzdXBwb3J0IG5hbWVkIGNvbG9ycz9cbiAgICAgICAgICAgIHJldHVybiByZWdleC5leGVjKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybCkge1xuICAgICAgICAgICAgICAgIGN0cmwuJHBhcnNlcnMucHVzaChmdW5jdGlvbih2aWV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ2NvbG9yJywgdmFsaWRDb2xvcih2aWV3VmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24obW9kZWxWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGxvYWRlZCBidXQgYWxzbyBwb3NzaWJsZSB0aGUgcGlja2VyIHdpZGdldCBtb2RpZmllc1xuICAgICAgICAgICAgICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnY29sb3InLCB2YWxpZENvbG9yKG1vZGVsVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsVmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZGlyZWN0aXZlKCdub0Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgJGVsZW1lbnQub24oJ2NsaWNrJywgZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIG1vZHVsZS5kaXJlY3RpdmUoJ3N0eWxlVHlwZUVkaXRvcicsIGZ1bmN0aW9uKCRjb21waWxlLCAkdGVtcGxhdGVDYWNoZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6IFwiRVwiLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKCdjdXJyZW50RWRpdG9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RWRpdG9yID0gc2NvcGUuY3VycmVudEVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLmN1cnJlbnRFZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVVybCA9ICdzdHlsZS90eXBlcy8nICsgY3VycmVudEVkaXRvci5uYW1lLnJlcGxhY2UoJyAnLCAnLScpICsgXCIuaHRtbFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5odG1sKCR0ZW1wbGF0ZUNhY2hlLmdldCh0ZW1wbGF0ZVVybCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGNvbXBpbGUoZWxlbWVudC5jb250ZW50cygpKShzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lmh0bWwoJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZGlyZWN0aXZlKCdydWxlc0VkaXRvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3R5bGUvcnVsZXMtZWRpdG9yLmh0bWwnLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUuZGVsZXRlUnVsZSA9IGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuYWN0aXZlU3R5bGUucnVsZXMgPSBzY29wZS5hY3RpdmVTdHlsZS5ydWxlcy5maWx0ZXIoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgIT09IHJ1bGU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnc3Rvcnl0b29scy5lZGl0LnN0eWxlLmljb25Db21tb25zJywgW10pO1xuXG4gICAgbW9kdWxlLmZhY3RvcnkoJ2ljb25Db21tb25zJywgZnVuY3Rpb24oJHEsIHN0U3ZnSWNvbiwgc3RSZWNlbnRDaG9pY2VzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWZhdWx0czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRxLmFsbChzdFJlY2VudENob2ljZXMuaWNvbnMucmVjZW50Lm1hcChmdW5jdGlvbih1cmkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0U3ZnSWNvbi5nZXRJbWFnZSh1cmkpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIG1vZHVsZS5mYWN0b3J5KCdpY29uQ29tbW9uc1NlYXJjaCcsIGZ1bmN0aW9uKCRodHRwLCAkbW9kYWwsICRpbmplY3Rvcikge1xuICAgICAgICB2YXIgaWNvbkNvbW1vbnNIb3N0ID0gJGluamVjdG9yLmhhcygnaWNvbkNvbW1vbnNIb3N0JykgP1xuICAgICAgICAgICAgJGluamVjdG9yLmdldCgnaWNvbkNvbW1vbnNIb3N0JykgOiAnaHR0cDovL2xvY2FsaG9zdDo4MDAwJztcbiAgICAgICAgZnVuY3Rpb24gZml4SHJlZnMoc3R1ZmYpIHtcbiAgICAgICAgICAgIHZhciB0b0ZpeCA9IHN0dWZmLmljb25zIHx8IHN0dWZmO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdG9GaXgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHRvRml4W2ldLmhyZWYgPSBpY29uQ29tbW9uc0hvc3QgKyB0b0ZpeFtpXS5ocmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0dWZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YWdFbmRwb2ludDogaWNvbkNvbW1vbnNIb3N0ICsgJy9pY29ucy9pY29uJyxcbiAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RhbCA9ICRtb2RhbC5vcGVuKHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogJ2xnJyxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ2ljb25Db21tb25zQ29udHJvbGxlcicsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc3R5bGUvd2lkZ2V0cy9pY29uLWNvbW1vbnMtc2VhcmNoLmh0bWwnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kYWwgPyB0aGlzLm1vZGFsLnJlc3VsdCA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q29sbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkaHR0cC5nZXQoaWNvbkNvbW1vbnNIb3N0ICsgJy9pY29ucy9jb2xsZWN0aW9ucycpLnN1Y2Nlc3MoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZml4SHJlZnMoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0TW9yZTogZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBocmVmID0gY29sbGVjdGlvbi5ocmVmO1xuICAgICAgICAgICAgICAgIGlmIChocmVmLmluZGV4T2YoaWNvbkNvbW1vbnNIb3N0KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gaWNvbkNvbW1vbnNIb3N0ICsgaHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICRodHRwLmdldChocmVmLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogY29sbGVjdGlvbi5fbmV4dFBhZ2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLnN1Y2Nlc3MoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZml4SHJlZnMoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q29sbGVjdGlvbkljb25zOiBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uLl9uZXh0UGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMucGFnZSA9IGNvbGxlY3Rpb24uX25leHRQYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KGljb25Db21tb25zSG9zdCArIGNvbGxlY3Rpb24uaHJlZiwge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICAgICAgICAgIH0pLnN1Y2Nlc3MoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZml4SHJlZnMoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QnlUYWc6IGZ1bmN0aW9uKHRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiAkaHR0cC5nZXQodGhpcy50YWdFbmRwb2ludCwge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogdGFnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5zdWNjZXNzKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpeEhyZWZzKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFRhZ3M6IGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KGljb25Db21tb25zSG9zdCArICcvaWNvbnMvc2VhcmNoL3RhZ3MnLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEudGFncztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIG1vZHVsZS5jb250cm9sbGVyKCdpY29uQ29tbW9uc0NvbnRyb2xsZXInLCBmdW5jdGlvbigkc2NvcGUsIGljb25Db21tb25zU2VhcmNoLCBzdFJlY2VudENob2ljZXMpIHtcbiAgICAgICAgdmFyIHRhZ0NvbGxlY3Rpb24gPSB7XG4gICAgICAgICAgICBocmVmOiBpY29uQ29tbW9uc1NlYXJjaC50YWdFbmRwb2ludFxuICAgICAgICB9LCBjb2xsZWN0aW9uID0ge1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVDb2xsZWN0aW9ucyhjb2xsZWN0aW9uLCByZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGljb25zID0gcmVzcG9uc2UuZGF0YS5pY29ucztcbiAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uLl9pY29ucykge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uX2ljb25zID0gY29sbGVjdGlvbi5faWNvbnMuY29uY2F0KGljb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbi5faWNvbnMgPSBpY29ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbGxlY3Rpb24uX21vcmUgPSByZXNwb25zZS5kYXRhLnBhZ2UgPCByZXNwb25zZS5kYXRhLnBhZ2VzO1xuICAgICAgICAgICAgY29sbGVjdGlvbi5fbmV4dFBhZ2UgPSByZXNwb25zZS5kYXRhLnBhZ2UgKyAxO1xuICAgICAgICAgICAgJHNjb3BlLmljb25zID0gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAkc2NvcGUubG9hZE1vcmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGljb25Db21tb25zU2VhcmNoLmdldE1vcmUoJHNjb3BlLmljb25zKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVDb2xsZWN0aW9ucygkc2NvcGUuaWNvbnMsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3RSZWNlbnRDaG9pY2VzLmljb25zLmFkZCgkc2NvcGUuc2VsZWN0ZWRJY29uLmhyZWYpO1xuICAgICAgICAgICAgaWNvbkNvbW1vbnNTZWFyY2gubW9kYWwuY2xvc2UoJHNjb3BlLnNlbGVjdGVkSWNvbik7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5kaXNtaXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpY29uQ29tbW9uc1NlYXJjaC5tb2RhbC5kaXNtaXNzKCk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS50YWdTZWxlY3QgPSBmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgICAgIHRhZ0NvbGxlY3Rpb24uX2ljb25zID0gW107XG4gICAgICAgICAgICBpY29uQ29tbW9uc1NlYXJjaC5nZXRCeVRhZyh0YWcpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUNvbGxlY3Rpb25zKHRhZ0NvbGxlY3Rpb24sIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS52aWV3Q29sbGVjdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzY29wZS5pY29ucyA9IGNvbGxlY3Rpb247XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS52aWV3VGFncyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHNjb3BlLmljb25zID0gdGFnQ29sbGVjdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgJHNjb3BlLmNvbGxlY3Rpb25TZWxlY3QgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLl9pY29ucyA9IFtdO1xuICAgICAgICAgICAgaWNvbkNvbW1vbnNTZWFyY2guZ2V0Q29sbGVjdGlvbkljb25zKGNvbGxlY3Rpb24pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUNvbGxlY3Rpb25zKGNvbGxlY3Rpb24sIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5pY29uU2VsZWN0ZWQgPSBmdW5jdGlvbihpY29uLCBkb25lKSB7XG4gICAgICAgICAgICAkc2NvcGUuc2VsZWN0ZWRJY29uID0gaWNvbjtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5zZWxlY3RlZENsYXNzID0gZnVuY3Rpb24oaWNvbikge1xuICAgICAgICAgICAgcmV0dXJuIGljb24gPT09ICRzY29wZS5zZWxlY3RlZEljb24gPyAnYWN0aXZlJyA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS5nZXRUYWdzID0gaWNvbkNvbW1vbnNTZWFyY2guZ2V0VGFncztcbiAgICAgICAgaWNvbkNvbW1vbnNTZWFyY2guZ2V0Q29sbGVjdGlvbnMoKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAkc2NvcGUuY29sbGVjdGlvbnMgPSByZXNwb25zZS5kYXRhLmNvbGxlY3Rpb25zO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pKCk7IiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnc3Rvcnl0b29scy5lZGl0LnN0eWxlLnN0eWxlQ2hvaWNlcycsIFtdKTtcblxuICAgIG1vZHVsZS5mYWN0b3J5KCdzdFN0eWxlQ2hvaWNlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3ltYm9saXplcnM6IFtcbiAgICAgICAgICAgICAgICAnY2lyY2xlJywgJ3NxdWFyZScsICd0cmlhbmdsZScsICdzdGFyJywgJ2Nyb3NzJywgJ3gnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcm90YXRpb25Vbml0czogW1xuICAgICAgICAgICAgICAgICdkZWdyZWVzJywgJ3JhZGlhbnMnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IFtcbiAgICAgICAgICAgICAgICAnc29saWQnLCAnZGFzaGVkJywgJ2RvdHRlZCdcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBmb250RmFtaWx5OiBbXG4gICAgICAgICAgICAgICAgJ3NlcmlmJywgJ3NhbnMtc2VyaWYnLCAnY3Vyc2l2ZScsICdtb25vc3BhY2UnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgY29sb3JSYW1wczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgMDogJyNmZjAwMDAnLFxuICAgICAgICAgICAgICAgICAgICAxOiAnIzAwMDBmZidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgMDogJyMwMGZmMDAnLFxuICAgICAgICAgICAgICAgICAgICAxOiAnI2ZmZmYwMCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLy8gQHRvZG8gYnVpbGQgdGhlc2Ugc3RhdGljYWxseSBhaGVhZCBvZiB0aW1lIHVzaW5nIGNvbG9yLXNjaGVtZS1qc1xuICAgICAgICAgICAgY29sb3JQYWxldHRlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NvbG9ycyAxJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsczogW1wiI2ZmOTkwMFwiLCBcIiNiMzZiMDBcIiwgXCIjZmZlNmJmXCIsIFwiI2ZmY2M4MFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIjMDBiMzY2XCIsIFwiIzAwN2Q0OFwiLCBcIiNiZmZmZTRcIiwgXCIjODBmZmM5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiM0MDAwOTlcIiwgXCIjMmQwMDZiXCIsIFwiI2RhYmZmZlwiLCBcIiNiNTgwZmZcIl1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NvbG9ycyAyJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsczogW1wiI2ZmOTlhYVwiLCBcIiNiMzZiYWFcIiwgXCIjYWFlNmJmXCIsIFwiI2FhY2M4MFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIjMDBiMzY2XCIsIFwiIzAwN2Q0OFwiLCBcIiNiZmFhZTRcIiwgXCIjODBhYWM5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiM0MGFhOTlcIiwgXCIjMmRhYTZiXCIsIFwiI2RhYmZhYVwiLCBcIiNiNTgwYWFcIl1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgY2xhc3NNZXRob2RzOiBbXG4gICAgICAgICAgICAgICAgJ05hdHVyYWwgQnJlYWtzJyxcbiAgICAgICAgICAgICAgICAnRXF1YWwgSW50ZXJ2YWwnLFxuICAgICAgICAgICAgICAgICdRdWFudGlsZScvKixcbiAgICAgICAgICAgICAgICAnR2VvbWV0cmljIEludGVydmFsJyxcbiAgICAgICAgICAgICAgICAnU3RhbmRhcmQgRGV2aWF0aW9uJyovXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZ2V0UGFsZXR0ZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IHRoaXMuY29sb3JQYWxldHRlcy5maWx0ZXIoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcC5uYW1lID09PSBuYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZC5sZW5ndGggPyBmb3VuZFswXSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZmFjdG9yeSgnc3RSZWNlbnRDaG9pY2VzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpY29uczogbmV3IFJlY2VudENob2ljZXMoJ2ljb25zJywgMjQpXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBSZWNlbnRDaG9pY2VzKG5hbWUsIG1heCkge1xuICAgICAgICB0aGlzLl9tYXggPSBtYXg7XG4gICAgICAgIHRoaXMuX2tleSA9ICdzdFJlY2VudENob2ljZXMtJyArIG5hbWU7XG4gICAgICAgIHZhciBzYXZlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuX2tleSk7XG4gICAgICAgIHRoaXMucmVjZW50ID0gc2F2ZWQgPyBKU09OLnBhcnNlKHNhdmVkKSA6IFtdO1xuICAgIH1cblxuICAgIFJlY2VudENob2ljZXMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVjZW50ID0gW107XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkodGhpcy5yZWNlbnQpKTtcbiAgICB9O1xuXG4gICAgUmVjZW50Q2hvaWNlcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oY2hvaWNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY2VudC5pbmRleE9mKGNob2ljZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlY2VudC5wdXNoKGNob2ljZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWNlbnQubGVuZ3RoID4gdGhpcy5fbWF4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlbnQuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkodGhpcy5yZWNlbnQpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKCdzdG9yeXRvb2xzLmVkaXQuc3R5bGUuc3R5bGVSdWxlQnVpbGRlcicsIFtcbiAgICAgICAgJ3N0b3J5dG9vbHMuZWRpdC5zdHlsZS5zdHlsZVR5cGVzJyxcbiAgICAgICAgJ3N0b3J5dG9vbHMuZWRpdC5zdHlsZS5zdHlsZUNob2ljZXMnXG4gICAgXSk7XG5cbiAgICBtb2R1bGUuZmFjdG9yeSgnc3RTdHlsZVJ1bGVCdWlsZGVyJywgZnVuY3Rpb24oc3RTdHlsZVR5cGVzLCBzdFN0eWxlQ2hvaWNlcykge1xuICAgICAgICBmdW5jdGlvbiBoZXgodikge1xuICAgICAgICAgICAgcmV0dXJuICgnMDAnICsgdi50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb2xvclJhbXBWYWx1ZXMocmFtcCwgbnVtKSB7XG4gICAgICAgICAgICBpZiAobnVtID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtyYW1wWzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb2xvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciByYW1wU3RvcHMgPSBPYmplY3Qua2V5cyhyYW1wKS5maWx0ZXIoZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnRvU3RyaW5nKCkuY2hhckF0KDApICE9ICckJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmFtcFN0b3BzLnNvcnQoKTtcbiAgICAgICAgICAgIHZhciBtcyA9IHJhbXBTdG9wcy5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSByYW1wW2tdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbcGFyc2VJbnQoJzB4JyArIHZhbC5zdWJzdHIoMSwgMikpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludCgnMHgnICsgdmFsLnN1YnN0cigzLCAyKSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KCcweCcgKyB2YWwuc3Vic3RyKDUsIDIpKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzdGVwID0gMS4wIC8gKG51bSAtIDEpO1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U3RvcHModmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRvZG8gZmluZCBzdG9wc1xuICAgICAgICAgICAgICAgIHJldHVybiBbcmFtcFN0b3BzWzBdLCByYW1wU3RvcHNbMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBAdG9kbyBoc3YgaW50ZXJwb2xhdGlvbiAoeWllbGRzIGJyaWdodGVyIGNvbG9ycyk/XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGkgKiBzdGVwO1xuICAgICAgICAgICAgICAgIHZhciBzdG9wcyA9IGdldFN0b3BzKHZhbCk7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSAodmFsIC0gc3RvcHNbMF0pIC8gKHN0b3BzWzFdIC0gc3RvcHNbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IG1zW3N0b3BzWzBdXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcCA9IG1zW3N0b3BzWzFdXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkID0gTWF0aC5mbG9vcihzdGFydFswXSArIChzdG9wWzBdIC0gc3RhcnRbMF0pICogcik7XG4gICAgICAgICAgICAgICAgdmFyIGdyZWVuID0gTWF0aC5mbG9vcihzdGFydFsxXSArIChzdG9wWzFdIC0gc3RhcnRbMV0pICogcik7XG4gICAgICAgICAgICAgICAgdmFyIGJsdWUgPSBNYXRoLmZsb29yKHN0YXJ0WzJdICsgKHN0b3BbMl0gLSBzdGFydFsyXSkgKiByKTtcbiAgICAgICAgICAgICAgICBjb2xvcnMucHVzaCgnIycgKyBoZXgocmVkKSArIGhleChncmVlbikgKyBoZXgoYmx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbG9ycztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZFJ1bGUocnVsZSwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBjb250ZXh0LnN0eWxlVHlwZS5ydWxlO1xuICAgICAgICAgICAgdmFyIHJ1bGVTdHlsZSA9IHt9O1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHR5cGUsIGZ1bmN0aW9uKGNvcHlSdWxlLCBzdHlsZVByb3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvcHlSdWxlLCBmdW5jdGlvbihjb3B5U291cmNlLCBjb3B5RGVzdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb3B5U291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb2xvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY29sb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGNvbnRleHQuY29sb3JzW2NvbnRleHQuaW5kZXggJSBjb250ZXh0LmNvbG9ycy5sZW5ndGhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhbmdlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5yYW5nZVN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gTWF0aC5yb3VuZChjb250ZXh0LnJhbmdlU3RlcCAqIGNvbnRleHQuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgY29weVNvdXJjZSAnICsgY29weVNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbY29weURlc3RdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcnVsZVN0eWxlW3N0eWxlUHJvcF0gPSB0YXJnZXQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJ1bGUuc3R5bGUgPSBydWxlU3R5bGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2NvbG9yUmFtcFZhbHVlczogY29sb3JSYW1wVmFsdWVzLFxuICAgICAgICAgICAgYnVpbGRSdWxlU3R5bGVzOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvcnM7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlU3RlcDtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuY2xhc3NpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLmNsYXNzaWZ5LmNvbG9yUmFtcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzID0gY29sb3JSYW1wVmFsdWVzKHN0eWxlLmNsYXNzaWZ5LmNvbG9yUmFtcCwgc3R5bGUucnVsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5jbGFzc2lmeS5jb2xvclBhbGV0dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWxldHRlID0gc3RTdHlsZUNob2ljZXMuZ2V0UGFsZXR0ZShzdHlsZS5jbGFzc2lmeS5jb2xvclBhbGV0dGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRvZG8gaW50ZXJwb2xhdGUgaWYgbmVlZGVkP1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzID0gcGFsZXR0ZS52YWxzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS5jbGFzc2lmeS5yYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VTdGVwID0gKHN0eWxlLmNsYXNzaWZ5LnJhbmdlLm1heCAtIHN0eWxlLmNsYXNzaWZ5LnJhbmdlLm1pbikgLyBzdHlsZS5ydWxlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yczogY29sb3JzLFxuICAgICAgICAgICAgICAgICAgICByYW5nZVN0ZXA6IHJhbmdlU3RlcCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVR5cGU6IHN0U3R5bGVUeXBlcy5nZXRTdHlsZVR5cGUoc3R5bGUudHlwZU5hbWUpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzdHlsZS5ydWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkUnVsZShyLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKCdzdG9yeXRvb2xzLmVkaXQuc3R5bGUuc3R5bGVUeXBlcycsIFtdKTtcblxuICAgIHZhciBkZWZhdWx0U3ltYm9sID0ge1xuICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgc2hhcGU6ICdjaXJjbGUnLFxuICAgICAgICBncmFwaGljOiBudWxsLFxuICAgICAgICBncmFwaGljVHlwZTogbnVsbCxcbiAgICAgICAgZmlsbENvbG9yOiAnI2Y1OTYyMCcsXG4gICAgICAgIGZpbGxPcGFjaXR5OiA3MCxcbiAgICAgICAgcm90YXRpb25BdHRyaWJ1dGU6IG51bGwsXG4gICAgICAgIHJvdGF0aW9uVW5pdHM6ICdkZWdyZWVzJ1xuICAgIH07XG5cbiAgICB2YXIgZGVmYXVsdFN0cm9rZSA9IHtcbiAgICAgICAgc3Ryb2tlQ29sb3I6ICcjZjU5NjIwJyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZVN0eWxlOiAnc29saWQnLFxuICAgICAgICBzdHJva2VPcGFjaXR5OiAxMDBcbiAgICB9O1xuXG4gICAgdmFyIGRlZmF1bHRMYWJlbCA9IHtcbiAgICAgICAgYXR0cmlidXRlOiBudWxsLFxuICAgICAgICBmaWxsQ29sb3I6ICcjZjU5NjIwJyxcbiAgICAgICAgZm9udEZhbWlseTogJ1NlcmlmJyxcbiAgICAgICAgZm9udFNpemU6IDEwLFxuICAgICAgICBmb250U3R5bGU6ICdub3JtYWwnLFxuICAgICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgICAgcGxhY2VtZW50OiAncG9pbnQnXG4gICAgfTtcblxuICAgIHZhciBkZWZhdWx0VW5pcXVlQ2xhc3MgPSB7XG4gICAgICAgIG1ldGhvZDogJ3VuaXF1ZScsXG4gICAgICAgIGF0dHJpYnV0ZTogbnVsbCxcbiAgICAgICAgbWF4Q2xhc3NlczogNSxcbiAgICAgICAgY29sb3JSYW1wOiBudWxsXG4gICAgfTtcblxuICAgIHZhciBkZWZhdWx0QnJlYWtzQ2xhc3MgPSB7XG4gICAgICAgIG1ldGhvZDogbnVsbCxcbiAgICAgICAgYXR0cmlidXRlOiBudWxsLFxuICAgICAgICBtYXhDbGFzc2VzOiA1LFxuICAgICAgICBjb2xvclJhbXA6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIGRlZmF1bHRSYW5nZUNsYXNzID0ge1xuICAgICAgICBtZXRob2Q6IG51bGwsXG4gICAgICAgIGF0dHJpYnV0ZTogbnVsbCxcbiAgICAgICAgbWF4Q2xhc3NlczogNSxcbiAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogMTZcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdHlwZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdzaW1wbGUgcG9pbnQnLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdTaW1wbGUnLFxuICAgICAgICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgICAgICAgICAgZ2VvbVR5cGU6ICdwb2ludCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ3VuaXF1ZSBwb2ludCcsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogJ1VuaXF1ZScsXG4gICAgICAgICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgICAgICAgICBnZW9tVHlwZTogJ3BvaW50JyxcbiAgICAgICAgICAgICAgICBjbGFzc2lmeTogZGVmYXVsdFVuaXF1ZUNsYXNzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVsZToge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnY29sb3InXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnY2xhc3MgcG9pbnQnLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdDaG9yb3BsZXRoJyxcbiAgICAgICAgICAgIHByb3RvdHlwZToge1xuICAgICAgICAgICAgICAgIGdlb21UeXBlOiAncG9pbnQnLFxuICAgICAgICAgICAgICAgIGNsYXNzaWZ5OiBkZWZhdWx0QnJlYWtzQ2xhc3NcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydWxlOiB7XG4gICAgICAgICAgICAgICAgc3ltYm9sIDoge1xuICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICdjb2xvcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdncmFkdWF0ZWQgcG9pbnQnLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdHcmFkdWF0ZWQnLFxuICAgICAgICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgICAgICAgICAgZ2VvbVR5cGU6ICdwb2ludCcsXG4gICAgICAgICAgICAgICAgY2xhc3NpZnk6IGRlZmF1bHRSYW5nZUNsYXNzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVsZToge1xuICAgICAgICAgICAgICAgIHN5bWJvbDoge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiAncmFuZ2UnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnaGVhdG1hcCcsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogJ0hlYXRNYXAnLFxuICAgICAgICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgICAgICAgICAgZ2VvbVR5cGU6ICdwb2ludCcsXG4gICAgICAgICAgICAgICAgcmFkaXVzOiA4LFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuOFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnc2ltcGxlIGxpbmUnLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdTaW1wbGUnLFxuICAgICAgICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgICAgICAgICAgZ2VvbVR5cGU6ICdsaW5lJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAndW5pcXVlIGxpbmUnLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdVbmlxdWUnLFxuICAgICAgICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgICAgICAgICAgZ2VvbVR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICBjbGFzc2lmeTogZGVmYXVsdFVuaXF1ZUNsYXNzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVsZToge1xuICAgICAgICAgICAgICAgIHN0cm9rZSA6IHtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6ICdjb2xvcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdzaW1wbGUgcG9seWdvbicsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogJ1NpbXBsZScsXG4gICAgICAgICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgICAgICAgICBnZW9tVHlwZTogJ3BvbHlnb24nXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICd1bmlxdWUgcG9seWdvbicsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogJ1VuaXF1ZScsXG4gICAgICAgICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgICAgICAgICBnZW9tVHlwZTogJ3BvbHlnb24nLFxuICAgICAgICAgICAgICAgIGNsYXNzaWZ5OiBkZWZhdWx0VW5pcXVlQ2xhc3NcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydWxlOiB7XG4gICAgICAgICAgICAgICAgc3ltYm9sIDoge1xuICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICdjb2xvcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdjbGFzcyBwb2x5Z29uJyxcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiAnQ2hvcm9wbGV0aCcsXG4gICAgICAgICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgICAgICAgICBnZW9tVHlwZTogJ3BvbHlnb24nLFxuICAgICAgICAgICAgICAgIGNsYXNzaWZ5OiBkZWZhdWx0QnJlYWtzQ2xhc3NcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydWxlOiB7XG4gICAgICAgICAgICAgICAgc3ltYm9sIDoge1xuICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICdjb2xvcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdO1xuXG4gICAgbW9kdWxlLnJ1bihmdW5jdGlvbigkaW5qZWN0b3IpIHtcbiAgICAgICAgaWYgKCRpbmplY3Rvci5oYXMoJ3N0U3R5bGVEZWZhdWx0cycpKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSAkaW5qZWN0b3IuZ2V0KCdzdFN0eWxlRGVmYXVsdHMnKTtcbiAgICAgICAgICAgIFtkZWZhdWx0U3ltYm9sLCBkZWZhdWx0U3Ryb2tlXS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNba10gPSBkZWZhdWx0c1trXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5mYWN0b3J5KCdzdFN0eWxlVHlwZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldFR5cGVzOiBmdW5jdGlvbihzdG9yeUxheWVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuZ3VsYXIuY29weSh0eXBlcykuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYucHJvdG90eXBlLmdlb21UeXBlID09PSBzdG9yeUxheWVyLmdldCgnZ2VvbVR5cGUnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRTdHlsZVR5cGU6IGZ1bmN0aW9uKHR5cGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdHlwZXMuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQubmFtZSA9PSB0eXBlTmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ2R1cGxpY2F0ZSB0eXBlIG5hbWVzISc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaC5sZW5ndGggPT09IDAgPyBudWxsIDogbWF0Y2hbMF07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlU3R5bGU6IGZ1bmN0aW9uKHN0eWxlVHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBiYXNlID0ge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IGRlZmF1bHRTeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogZGVmYXVsdFN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGRlZmF1bHRMYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZU5hbWU6IHN0eWxlVHlwZS5uYW1lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhbmd1bGFyLmV4dGVuZCh7fSwgYW5ndWxhci5jb3B5KGJhc2UpLCBzdHlsZVR5cGUucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoJ2NsYXNzaWZ5JyBpbiBzdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5ydWxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnc3Rvcnl0b29scy5lZGl0LnRpbWUuZGlyZWN0aXZlcycsIFtdKTtcblxuICAgIG1vZHVsZS5kaXJlY3RpdmUoJ3N0RGF0ZVRpbWVGaWVsZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAndGltZS9kYXRlLXRpbWUtZmllbGQuaHRtbCcsXG4gICAgICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgICAgIGRhdGVUaW1lOiAnPScsXG4gICAgICAgICAgICAgICAgY3VycmVudFRpbWU6ICc9J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUub3BlbiA9IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLm9wZW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIG1vZHVsZS5kaXJlY3RpdmUoJ2lzb0RhdGVUaW1lJywgZnVuY3Rpb24oJGxvZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtLCBhdHRycywgbmdNb2RlbEN0cmwpIHtcbiAgICAgICAgICAgICAgICBuZ01vZGVsQ3RybC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKG1vZGVsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHZhbCA9IG1vZGVsVmFsdWUgIT0gbnVsbCA/IG5ldyBEYXRlKG1vZGVsVmFsdWUpLnRvSVNPU3RyaW5nKCkgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZ01vZGVsQ3RybC4kcGFyc2Vycy5wdXNoKGZ1bmN0aW9uKHZpZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gIERhdGUucGFyc2Uodmlld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkID0gIWlzTmFOKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIG5nTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZGF0ZVRpbWUnLCB2YWxpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZCA/IHBhcnNlZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2NvcGUuc2V0RnJvbUN1cnJlbnRUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5jdXJyZW50VGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmdNb2RlbEN0cmwuJG1vZGVsVmFsdWUgPSBzY29wZS5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRsb2cuZXJyb3IoJ25vIGN1cnJlbnQgdGltZSBwcm92aWRlZCEnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59KSgpOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgUXVldWUgPSByZXF1aXJlKCcuL1F1ZXVlJyk7XG5cbi8qKlxuICogRGF0YVNldFxuICpcbiAqIFVzYWdlOlxuICogICAgIHZhciBkYXRhU2V0ID0gbmV3IERhdGFTZXQoe1xuICogICAgICAgICBmaWVsZElkOiAnX2lkJyxcbiAqICAgICAgICAgdHlwZToge1xuICogICAgICAgICAgICAgLy8gLi4uXG4gKiAgICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgZGF0YVNldC5hZGQoaXRlbSk7XG4gKiAgICAgZGF0YVNldC5hZGQoZGF0YSk7XG4gKiAgICAgZGF0YVNldC51cGRhdGUoaXRlbSk7XG4gKiAgICAgZGF0YVNldC51cGRhdGUoZGF0YSk7XG4gKiAgICAgZGF0YVNldC5yZW1vdmUoaWQpO1xuICogICAgIGRhdGFTZXQucmVtb3ZlKGlkcyk7XG4gKiAgICAgdmFyIGRhdGEgPSBkYXRhU2V0LmdldCgpO1xuICogICAgIHZhciBkYXRhID0gZGF0YVNldC5nZXQoaWQpO1xuICogICAgIHZhciBkYXRhID0gZGF0YVNldC5nZXQoaWRzKTtcbiAqICAgICB2YXIgZGF0YSA9IGRhdGFTZXQuZ2V0KGlkcywgb3B0aW9ucywgZGF0YSk7XG4gKiAgICAgZGF0YVNldC5jbGVhcigpO1xuICpcbiAqIEEgZGF0YSBzZXQgY2FuOlxuICogLSBhZGQvcmVtb3ZlL3VwZGF0ZSBkYXRhXG4gKiAtIGdpdmVzIHRyaWdnZXJzIHVwb24gY2hhbmdlcyBpbiB0aGUgZGF0YVxuICogLSBjYW4gIGltcG9ydC9leHBvcnQgZGF0YSBpbiB2YXJpb3VzIGRhdGEgZm9ybWF0c1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IFtkYXRhXSAgICBPcHRpb25hbCBhcnJheSB3aXRoIGluaXRpYWwgZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IGZpZWxkSWQgRmllbGQgbmFtZSBvZiB0aGUgaWQgaW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtcywgJ2lkJyBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nfSB0eXBlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIG1hcCB3aXRoIGZpZWxkIG5hbWVzIGFzIGtleSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgZmllbGQgdHlwZSBhcyB2YWx1ZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBxdWV1ZSAgIFF1ZXVlIGNoYW5nZXMgdG8gdGhlIERhdGFTZXQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbHVzaCB0aGVtIGFsbCBhdCBvbmNlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUXVldWUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge251bWJlcn0gZGVsYXkgIERlbGF5IGluIG1zLCBudWxsIGJ5IGRlZmF1bHRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge251bWJlcn0gbWF4ICAgIE1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHF1ZXVlLCBJbmZpbml0eSBieSBkZWZhdWx0XG4gKiBAY29uc3RydWN0b3IgRGF0YVNldFxuICovXG4vLyBUT0RPOiBhZGQgYSBEYXRhU2V0IGNvbnN0cnVjdG9yIERhdGFTZXQoZGF0YSwgb3B0aW9ucylcbmZ1bmN0aW9uIERhdGFTZXQgKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gY29ycmVjdGx5IHJlYWQgb3B0aW9uYWwgYXJndW1lbnRzXG4gIGlmIChkYXRhICYmICFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgb3B0aW9ucyA9IGRhdGE7XG4gICAgZGF0YSA9IG51bGw7XG4gIH1cblxuICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fZGF0YSA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hcCB3aXRoIGRhdGEgaW5kZXhlZCBieSBpZFxuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBEYXRhU2V0XG4gIHRoaXMuX2ZpZWxkSWQgPSB0aGlzLl9vcHRpb25zLmZpZWxkSWQgfHwgJ2lkJzsgICAvLyBuYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIGlkXG4gIHRoaXMuX3R5cGUgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcm5hbCBmaWVsZCB0eXBlcyAoTk9URTogdGhpcyBjYW4gZGlmZmVyIGZyb20gdGhpcy5fb3B0aW9ucy50eXBlKVxuXG4gIC8vIGFsbCB2YXJpYW50cyBvZiBhIERhdGUgYXJlIGludGVybmFsbHkgc3RvcmVkIGFzIERhdGUsIHNvIHdlIGNhbiBjb252ZXJ0XG4gIC8vIGZyb20gZXZlcnl0aGluZyB0byBldmVyeXRoaW5nIChhbHNvIGZyb20gSVNPRGF0ZSB0byBOdW1iZXIgZm9yIGV4YW1wbGUpXG4gIGlmICh0aGlzLl9vcHRpb25zLnR5cGUpIHtcbiAgICBmb3IgKHZhciBmaWVsZCBpbiB0aGlzLl9vcHRpb25zLnR5cGUpIHtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnR5cGUuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX29wdGlvbnMudHlwZVtmaWVsZF07XG4gICAgICAgIGlmICh2YWx1ZSA9PSAnRGF0ZScgfHwgdmFsdWUgPT0gJ0lTT0RhdGUnIHx8IHZhbHVlID09ICdBU1BEYXRlJykge1xuICAgICAgICAgIHRoaXMuX3R5cGVbZmllbGRdID0gJ0RhdGUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3R5cGVbZmllbGRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xLjEgKG9yIDIuMC4wPylcbiAgaWYgKHRoaXMuX29wdGlvbnMuY29udmVydCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uIFwiY29udmVydFwiIGlzIGRlcHJlY2F0ZWQuIFVzZSBcInR5cGVcIiBpbnN0ZWFkLicpO1xuICB9XG5cbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSB7fTsgIC8vIGV2ZW50IHN1YnNjcmliZXJzXG5cbiAgLy8gYWRkIGluaXRpYWwgZGF0YSB3aGVuIHByb3ZpZGVkXG4gIGlmIChkYXRhKSB7XG4gICAgdGhpcy5hZGQoZGF0YSk7XG4gIH1cblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3R9IHF1ZXVlICAgUXVldWUgY2hhbmdlcyB0byB0aGUgRGF0YVNldCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoIHRoZW0gYWxsIGF0IG9uY2UuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWV1ZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7bnVtYmVyfSBkZWxheSAgRGVsYXkgaW4gbXMsIG51bGwgYnkgZGVmYXVsdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7bnVtYmVyfSBtYXggICAgTWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgcXVldWUsIEluZmluaXR5IGJ5IGRlZmF1bHRcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucXVldWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLnF1ZXVlID09PSBmYWxzZSkge1xuICAgICAgLy8gZGVsZXRlIHF1ZXVlIGlmIGxvYWRlZFxuICAgICAgaWYgKHRoaXMuX3F1ZXVlKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLmRlc3Ryb3koKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3F1ZXVlO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSBxdWV1ZSBhbmQgdXBkYXRlIGl0cyBvcHRpb25zXG4gICAgICBpZiAoIXRoaXMuX3F1ZXVlKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gUXVldWUuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICByZXBsYWNlOiBbJ2FkZCcsICd1cGRhdGUnLCAncmVtb3ZlJ11cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5xdWV1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5fcXVldWUuc2V0T3B0aW9ucyhvcHRpb25zLnF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIGFuIGV2ZW50LCBhZGQgYW4gZXZlbnQgbGlzdGVuZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCAgICAgICAgRXZlbnQgbmFtZS4gQXZhaWxhYmxlIGV2ZW50czogJ3B1dCcsICd1cGRhdGUnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmVtb3ZlJ1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjayBtZXRob2QuIENhbGxlZCB3aXRoIHRocmVlIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBldmVudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdCB8IG51bGx9IHBhcmFtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IE51bWJlcn0gc2VuZGVySWRcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdO1xuICBpZiAoIXN1YnNjcmliZXJzKSB7XG4gICAgc3Vic2NyaWJlcnMgPSBbXTtcbiAgICB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0gPSBzdWJzY3JpYmVycztcbiAgfVxuXG4gIHN1YnNjcmliZXJzLnB1c2goe1xuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8vIFRPRE86IHJlbW92ZSB0aGlzIGRlcHJlY2F0ZWQgZnVuY3Rpb24gc29tZSBkYXkgKHJlcGxhY2VkIHdpdGggYG9uYCBzaW5jZSB2ZXJzaW9uIDAuNSwgZGVwcmVjYXRlZCBzaW5jZSB2NC4wKVxuRGF0YVNldC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFTZXQuc3Vic2NyaWJlIGlzIGRlcHJlY2F0ZWQuIFVzZSBEYXRhU2V0Lm9uIGluc3RlYWQuJyk7XG59O1xuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGZyb20gYW4gZXZlbnQsIHJlbW92ZSBhbiBldmVudCBsaXN0ZW5lclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdO1xuICBpZiAoc3Vic2NyaWJlcnMpIHtcbiAgICB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0gPSBzdWJzY3JpYmVycy5maWx0ZXIobGlzdGVuZXIgPT4gbGlzdGVuZXIuY2FsbGJhY2sgIT0gY2FsbGJhY2spO1xuICB9XG59O1xuXG4vLyBUT0RPOiByZW1vdmUgdGhpcyBkZXByZWNhdGVkIGZ1bmN0aW9uIHNvbWUgZGF5IChyZXBsYWNlZCB3aXRoIGBvbmAgc2luY2UgdmVyc2lvbiAwLjUsIGRlcHJlY2F0ZWQgc2luY2UgdjQuMClcbkRhdGFTZXQucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFTZXQudW5zdWJzY3JpYmUgaXMgZGVwcmVjYXRlZC4gVXNlIERhdGFTZXQub2ZmIGluc3RlYWQuJyk7XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3QgfCBudWxsfSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2VuZGVySWRdICAgICAgIE9wdGlvbmFsIGlkIG9mIHRoZSBzZW5kZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fdHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICBpZiAoZXZlbnQgPT0gJyonKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdHJpZ2dlciBldmVudCAqJyk7XG4gIH1cblxuICB2YXIgc3Vic2NyaWJlcnMgPSBbXTtcbiAgaWYgKGV2ZW50IGluIHRoaXMuX3N1YnNjcmliZXJzKSB7XG4gICAgc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5jb25jYXQodGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdKTtcbiAgfVxuICBpZiAoJyonIGluIHRoaXMuX3N1YnNjcmliZXJzKSB7XG4gICAgc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5jb25jYXQodGhpcy5fc3Vic2NyaWJlcnNbJyonXSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBpZiAoc3Vic2NyaWJlci5jYWxsYmFjaykge1xuICAgICAgc3Vic2NyaWJlci5jYWxsYmFjayhldmVudCwgcGFyYW1zLCBzZW5kZXJJZCB8fCBudWxsKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGRhdGEuXG4gKiBBZGRpbmcgYW4gaXRlbSB3aWxsIGZhaWwgd2hlbiB0aGVyZSBhbHJlYWR5IGlzIGFuIGl0ZW0gd2l0aCB0aGUgc2FtZSBpZC5cbiAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2VuZGVySWRdIE9wdGlvbmFsIHNlbmRlciBpZFxuICogQHJldHVybiB7QXJyYXl9IGFkZGVkSWRzICAgICAgQXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZSBhZGRlZCBpdGVtc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGF0YSwgc2VuZGVySWQpIHtcbiAgdmFyIGFkZGVkSWRzID0gW10sXG4gICAgICBpZCxcbiAgICAgIG1lID0gdGhpcztcblxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIC8vIEFycmF5XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlkID0gbWUuX2FkZEl0ZW0oZGF0YVtpXSk7XG4gICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIC8vIFNpbmdsZSBpdGVtXG4gICAgaWQgPSBtZS5fYWRkSXRlbShkYXRhKTtcbiAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZGF0YVR5cGUnKTtcbiAgfVxuXG4gIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICB0aGlzLl90cmlnZ2VyKCdhZGQnLCB7aXRlbXM6IGFkZGVkSWRzfSwgc2VuZGVySWQpO1xuICB9XG5cbiAgcmV0dXJuIGFkZGVkSWRzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgZXhpc3RpbmcgaXRlbXMuIFdoZW4gYW4gaXRlbSBkb2VzIG5vdCBleGlzdCwgaXQgd2lsbCBiZSBjcmVhdGVkXG4gKiBAcGFyYW0ge09iamVjdCB8IEFycmF5fSBkYXRhXG4gKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAqIEByZXR1cm4ge0FycmF5fSB1cGRhdGVkSWRzICAgICBUaGUgaWRzIG9mIHRoZSBhZGRlZCBvciB1cGRhdGVkIGl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBzZW5kZXJJZCkge1xuICB2YXIgYWRkZWRJZHMgPSBbXTtcbiAgdmFyIHVwZGF0ZWRJZHMgPSBbXTtcbiAgdmFyIHVwZGF0ZWREYXRhID0gW107XG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciBmaWVsZElkID0gbWUuX2ZpZWxkSWQ7XG5cbiAgdmFyIGFkZE9yVXBkYXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgaWQgPSBpdGVtW2ZpZWxkSWRdO1xuICAgIGlmIChtZS5fZGF0YVtpZF0pIHtcbiAgICAgIC8vIHVwZGF0ZSBpdGVtXG4gICAgICBpZCA9IG1lLl91cGRhdGVJdGVtKGl0ZW0pO1xuICAgICAgdXBkYXRlZElkcy5wdXNoKGlkKTtcbiAgICAgIHVwZGF0ZWREYXRhLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gYWRkIG5ldyBpdGVtXG4gICAgICBpZCA9IG1lLl9hZGRJdGVtKGl0ZW0pO1xuICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgfVxuICB9O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgLy8gQXJyYXlcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYWRkT3JVcGRhdGUoZGF0YVtpXSk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAvLyBTaW5nbGUgaXRlbVxuICAgIGFkZE9yVXBkYXRlKGRhdGEpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBkYXRhVHlwZScpO1xuICB9XG5cbiAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHtpdGVtczogYWRkZWRJZHN9LCBzZW5kZXJJZCk7XG4gIH1cbiAgaWYgKHVwZGF0ZWRJZHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fdHJpZ2dlcigndXBkYXRlJywge2l0ZW1zOiB1cGRhdGVkSWRzLCBkYXRhOiB1cGRhdGVkRGF0YX0sIHNlbmRlcklkKTtcbiAgfVxuXG4gIHJldHVybiBhZGRlZElkcy5jb25jYXQodXBkYXRlZElkcyk7XG59O1xuXG4vKipcbiAqIEdldCBhIGRhdGEgaXRlbSBvciBtdWx0aXBsZSBpdGVtcy5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgICAgZ2V0KClcbiAqICAgICBnZXQob3B0aW9uczogT2JqZWN0KVxuICpcbiAqICAgICBnZXQoaWQ6IE51bWJlciB8IFN0cmluZylcbiAqICAgICBnZXQoaWQ6IE51bWJlciB8IFN0cmluZywgb3B0aW9uczogT2JqZWN0KVxuICpcbiAqICAgICBnZXQoaWRzOiBOdW1iZXJbXSB8IFN0cmluZ1tdKVxuICogICAgIGdldChpZHM6IE51bWJlcltdIHwgU3RyaW5nW10sIG9wdGlvbnM6IE9iamVjdClcbiAqXG4gKiBXaGVyZTpcbiAqXG4gKiB7TnVtYmVyIHwgU3RyaW5nfSBpZCAgICAgICAgIFRoZSBpZCBvZiBhbiBpdGVtXG4gKiB7TnVtYmVyW10gfCBTdHJpbmd7fX0gaWRzICAgIEFuIGFycmF5IHdpdGggaWRzIG9mIGl0ZW1zXG4gKiB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICoge1N0cmluZ30gW3JldHVyblR5cGVdICAgICAgICBUeXBlIG9mIGRhdGEgdG8gYmUgcmV0dXJuZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSAnQXJyYXknIChkZWZhdWx0KSBvciAnT2JqZWN0Jy5cbiAqIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW3R5cGVdXG4gKiB7U3RyaW5nW119IFtmaWVsZHNdICAgICAgICAgIGZpZWxkIG5hbWVzIHRvIGJlIHJldHVybmVkXG4gKiB7ZnVuY3Rpb259IFtmaWx0ZXJdICAgICAgICAgIGZpbHRlciBpdGVtc1xuICoge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdICBPcmRlciB0aGUgaXRlbXMgYnkgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICogQHRocm93cyBFcnJvclxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoYXJncykge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIHBhcnNlIHRoZSBhcmd1bWVudHNcbiAgdmFyIGlkLCBpZHMsIG9wdGlvbnM7XG4gIHZhciBmaXJzdFR5cGUgPSB1dGlsLmdldFR5cGUoYXJndW1lbnRzWzBdKTtcbiAgaWYgKGZpcnN0VHlwZSA9PSAnU3RyaW5nJyB8fCBmaXJzdFR5cGUgPT0gJ051bWJlcicpIHtcbiAgICAvLyBnZXQoaWQgWywgb3B0aW9uc10pXG4gICAgaWQgPSBhcmd1bWVudHNbMF07XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgfVxuICBlbHNlIGlmIChmaXJzdFR5cGUgPT0gJ0FycmF5Jykge1xuICAgIC8vIGdldChpZHMgWywgb3B0aW9uc10pXG4gICAgaWRzID0gYXJndW1lbnRzWzBdO1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZ2V0KFssIG9wdGlvbnNdKVxuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgdGhlIHJldHVybiB0eXBlXG4gIHZhciByZXR1cm5UeXBlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJldHVyblR5cGUpIHtcbiAgICB2YXIgYWxsb3dlZFZhbHVlcyA9IFsnQXJyYXknLCAnT2JqZWN0J107XG4gICAgcmV0dXJuVHlwZSA9IGFsbG93ZWRWYWx1ZXMuaW5kZXhPZihvcHRpb25zLnJldHVyblR5cGUpID09IC0xID8gJ0FycmF5JyA6IG9wdGlvbnMucmV0dXJuVHlwZTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm5UeXBlID0gJ0FycmF5JztcbiAgfVxuXG4gIC8vIGJ1aWxkIG9wdGlvbnNcbiAgdmFyIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGU7XG4gIHZhciBmaWx0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyO1xuICB2YXIgaXRlbXMgPSBbXSwgaXRlbSwgaXRlbUlkLCBpLCBsZW47XG5cbiAgLy8gY29udmVydCBpdGVtc1xuICBpZiAoaWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gcmV0dXJuIGEgc2luZ2xlIGl0ZW1cbiAgICBpdGVtID0gbWUuX2dldEl0ZW0oaWQsIHR5cGUpO1xuICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlcihpdGVtKSkge1xuICAgICAgaXRlbSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGlkcyAhPSB1bmRlZmluZWQpIHtcbiAgICAvLyByZXR1cm4gYSBzdWJzZXQgb2YgaXRlbXNcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBtZS5fZ2V0SXRlbShpZHNbaV0sIHR5cGUpO1xuICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIHJldHVybiBhbGwgaXRlbXNcbiAgICBmb3IgKGl0ZW1JZCBpbiB0aGlzLl9kYXRhKSB7XG4gICAgICBpZiAodGhpcy5fZGF0YS5oYXNPd25Qcm9wZXJ0eShpdGVtSWQpKSB7XG4gICAgICAgIGl0ZW0gPSBtZS5fZ2V0SXRlbShpdGVtSWQsIHR5cGUpO1xuICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gb3JkZXIgdGhlIHJlc3VsdHNcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlciAmJiBpZCA9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9zb3J0KGl0ZW1zLCBvcHRpb25zLm9yZGVyKTtcbiAgfVxuXG4gIC8vIGZpbHRlciBmaWVsZHMgb2YgdGhlIGl0ZW1zXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmllbGRzKSB7XG4gICAgdmFyIGZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIGlmIChpZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ZW0gPSB0aGlzLl9maWx0ZXJGaWVsZHMoaXRlbSwgZmllbGRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpdGVtc1tpXSA9IHRoaXMuX2ZpbHRlckZpZWxkcyhpdGVtc1tpXSwgZmllbGRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXR1cm4gdGhlIHJlc3VsdHNcbiAgaWYgKHJldHVyblR5cGUgPT0gJ09iamVjdCcpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbaXRlbXNbaV0uaWRdID0gaXRlbXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKGlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYSBzaW5nbGUgaXRlbVxuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8ganVzdCByZXR1cm4gb3VyIGFycmF5XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldCBpZHMgb2YgYWxsIGl0ZW1zIG9yIGZyb20gYSBmaWx0ZXJlZCBzZXQgb2YgaXRlbXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheX0gaWRzXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmdldElkcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIsXG4gICAgICBvcmRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlcixcbiAgICAgIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGUsXG4gICAgICBpLFxuICAgICAgbGVuLFxuICAgICAgaWQsXG4gICAgICBpdGVtLFxuICAgICAgaXRlbXMsXG4gICAgICBpZHMgPSBbXTtcblxuICBpZiAoZmlsdGVyKSB7XG4gICAgLy8gZ2V0IGZpbHRlcmVkIGl0ZW1zXG4gICAgaWYgKG9yZGVyKSB7XG4gICAgICAvLyBjcmVhdGUgb3JkZXJlZCBsaXN0XG4gICAgICBpdGVtcyA9IFtdO1xuICAgICAgZm9yIChpZCBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgICAgICBpZiAoZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zb3J0KGl0ZW1zLCBvcmRlcik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlkc1tpXSA9IGl0ZW1zW2ldW3RoaXMuX2ZpZWxkSWRdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSB1bm9yZGVyZWQgbGlzdFxuICAgICAgZm9yIChpZCBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgICAgICBpZiAoZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgICBpZHMucHVzaChpdGVtW3RoaXMuX2ZpZWxkSWRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZ2V0IGFsbCBpdGVtc1xuICAgIGlmIChvcmRlcikge1xuICAgICAgLy8gY3JlYXRlIGFuIG9yZGVyZWQgbGlzdFxuICAgICAgaXRlbXMgPSBbXTtcbiAgICAgIGZvciAoaWQgaW4gZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGRhdGFbaWRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zb3J0KGl0ZW1zLCBvcmRlcik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlkc1tpXSA9IGl0ZW1zW2ldW3RoaXMuX2ZpZWxkSWRdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSB1bm9yZGVyZWQgbGlzdFxuICAgICAgZm9yIChpZCBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIGl0ZW0gPSBkYXRhW2lkXTtcbiAgICAgICAgICBpZHMucHVzaChpdGVtW3RoaXMuX2ZpZWxkSWRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZHM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERhdGFTZXQgaXRzZWxmLiBJcyBvdmVyd3JpdHRlbiBmb3IgZXhhbXBsZSBieSB0aGUgRGF0YVZpZXcsXG4gKiB3aGljaCByZXR1cm5zIHRoZSBEYXRhU2V0IGl0IGlzIGNvbm5lY3RlZCB0byBpbnN0ZWFkLlxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5nZXREYXRhU2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBldmVyeSBpdGVtIGluIHRoZSBkYXRhc2V0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW3R5cGVdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmdbXX0gW2ZpZWxkc10gZmlsdGVyIGZpZWxkc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIsXG4gICAgICB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdGhpcy5fb3B0aW9ucy50eXBlLFxuICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBpdGVtLFxuICAgICAgaWQ7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlcikge1xuICAgIC8vIGV4ZWN1dGUgZm9yRWFjaCBvbiBvcmRlcmVkIGxpc3RcbiAgICB2YXIgaXRlbXMgPSB0aGlzLmdldChvcHRpb25zKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgaWQgPSBpdGVtW3RoaXMuX2ZpZWxkSWRdO1xuICAgICAgY2FsbGJhY2soaXRlbSwgaWQpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyB1bm9yZGVyZWRcbiAgICBmb3IgKGlkIGluIGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICBpdGVtID0gdGhpcy5fZ2V0SXRlbShpZCwgdHlwZSk7XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNYXAgZXZlcnkgaXRlbSBpbiB0aGUgZGF0YXNldC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFt0eXBlXVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nW119IFtmaWVsZHNdIGZpbHRlciBmaWVsZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JqZWN0W119IG1hcHBlZEl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgZmlsdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcixcbiAgICAgIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGUsXG4gICAgICBtYXBwZWRJdGVtcyA9IFtdLFxuICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBpdGVtO1xuXG4gIC8vIGNvbnZlcnQgYW5kIGZpbHRlciBpdGVtc1xuICBmb3IgKHZhciBpZCBpbiBkYXRhKSB7XG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICBpdGVtID0gdGhpcy5fZ2V0SXRlbShpZCwgdHlwZSk7XG4gICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgbWFwcGVkSXRlbXMucHVzaChjYWxsYmFjayhpdGVtLCBpZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG9yZGVyIGl0ZW1zXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIpIHtcbiAgICB0aGlzLl9zb3J0KG1hcHBlZEl0ZW1zLCBvcHRpb25zLm9yZGVyKTtcbiAgfVxuXG4gIHJldHVybiBtYXBwZWRJdGVtcztcbn07XG5cbi8qKlxuICogRmlsdGVyIHRoZSBmaWVsZHMgb2YgYW4gaXRlbVxuICogQHBhcmFtIHtPYmplY3QgfCBudWxsfSBpdGVtXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBmaWVsZHMgICAgIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBmaWx0ZXJlZEl0ZW0gb3IgbnVsbCBpZiBubyBpdGVtIGlzIHByb3ZpZGVkXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fZmlsdGVyRmllbGRzID0gZnVuY3Rpb24gKGl0ZW0sIGZpZWxkcykge1xuICBpZiAoIWl0ZW0pIHsgLy8gaXRlbSBpcyBudWxsXG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICB2YXIgZmlsdGVyZWRJdGVtID0ge307XG5cbiAgaWYoQXJyYXkuaXNBcnJheShmaWVsZHMpKXtcbiAgICBmb3IgKHZhciBmaWVsZCBpbiBpdGVtKSB7XG4gICAgICBpZiAoaXRlbS5oYXNPd25Qcm9wZXJ0eShmaWVsZCkgJiYgKGZpZWxkcy5pbmRleE9mKGZpZWxkKSAhPSAtMSkpIHtcbiAgICAgICAgZmlsdGVyZWRJdGVtW2ZpZWxkXSA9IGl0ZW1bZmllbGRdO1xuICAgICAgfVxuICAgIH1cbiAgfWVsc2V7XG4gICAgZm9yICh2YXIgZmllbGQgaW4gaXRlbSkge1xuICAgICAgaWYgKGl0ZW0uaGFzT3duUHJvcGVydHkoZmllbGQpICYmIGZpZWxkcy5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgZmlsdGVyZWRJdGVtW2ZpZWxkc1tmaWVsZF1dID0gaXRlbVtmaWVsZF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbHRlcmVkSXRlbTtcbn07XG5cbi8qKlxuICogU29ydCB0aGUgcHJvdmlkZWQgYXJyYXkgd2l0aCBpdGVtc1xuICogQHBhcmFtIHtPYmplY3RbXX0gaXRlbXNcbiAqIEBwYXJhbSB7U3RyaW5nIHwgZnVuY3Rpb259IG9yZGVyICAgICAgQSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuX3NvcnQgPSBmdW5jdGlvbiAoaXRlbXMsIG9yZGVyKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKG9yZGVyKSkge1xuICAgIC8vIG9yZGVyIGJ5IHByb3ZpZGVkIGZpZWxkIG5hbWVcbiAgICB2YXIgbmFtZSA9IG9yZGVyOyAvLyBmaWVsZCBuYW1lXG4gICAgaXRlbXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgdmFyIGF2ID0gYVtuYW1lXTtcbiAgICAgIHZhciBidiA9IGJbbmFtZV07XG4gICAgICByZXR1cm4gKGF2ID4gYnYpID8gMSA6ICgoYXYgPCBidikgPyAtMSA6IDApO1xuICAgIH0pO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBvcmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIG9yZGVyIGJ5IHNvcnQgZnVuY3Rpb25cbiAgICBpdGVtcy5zb3J0KG9yZGVyKTtcbiAgfVxuICAvLyBUT0RPOiBleHRlbmQgb3JkZXIgYnkgYW4gT2JqZWN0IHtmaWVsZDpTdHJpbmcsIGRpcmVjdGlvbjpTdHJpbmd9XG4gIC8vICAgICAgIHdoZXJlIGRpcmVjdGlvbiBjYW4gYmUgJ2FzYycgb3IgJ2Rlc2MnXG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09yZGVyIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZycpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBvYmplY3QgYnkgcG9pbnRlciBvciBieSBpZFxuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBPYmplY3QgfCBBcnJheX0gaWQgT2JqZWN0IG9yIGlkLCBvciBhbiBhcnJheSB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RzIG9yIGlkcyB0byBiZSByZW1vdmVkXG4gKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAqIEByZXR1cm4ge0FycmF5fSByZW1vdmVkSWRzXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpZCwgc2VuZGVySWQpIHtcbiAgdmFyIHJlbW92ZWRJZHMgPSBbXSxcbiAgICAgIGksIGxlbiwgcmVtb3ZlZElkO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGlkKSkge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZW1vdmVkSWQgPSB0aGlzLl9yZW1vdmUoaWRbaV0pO1xuICAgICAgaWYgKHJlbW92ZWRJZCAhPSBudWxsKSB7XG4gICAgICAgIHJlbW92ZWRJZHMucHVzaChyZW1vdmVkSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICByZW1vdmVkSWQgPSB0aGlzLl9yZW1vdmUoaWQpO1xuICAgIGlmIChyZW1vdmVkSWQgIT0gbnVsbCkge1xuICAgICAgcmVtb3ZlZElkcy5wdXNoKHJlbW92ZWRJZCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlbW92ZWRJZHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fdHJpZ2dlcigncmVtb3ZlJywge2l0ZW1zOiByZW1vdmVkSWRzfSwgc2VuZGVySWQpO1xuICB9XG5cbiAgcmV0dXJuIHJlbW92ZWRJZHM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGJ5IGl0cyBpZFxuICogQHBhcmFtIHtOdW1iZXIgfCBTdHJpbmcgfCBPYmplY3R9IGlkICAgaWQgb3IgaXRlbVxuICogQHJldHVybnMge051bWJlciB8IFN0cmluZyB8IG51bGx9IGlkXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlmICh1dGlsLmlzTnVtYmVyKGlkKSB8fCB1dGlsLmlzU3RyaW5nKGlkKSkge1xuICAgIGlmICh0aGlzLl9kYXRhW2lkXSkge1xuICAgICAgZGVsZXRlIHRoaXMuX2RhdGFbaWRdO1xuICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoaWQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICB2YXIgaXRlbUlkID0gaWRbdGhpcy5fZmllbGRJZF07XG4gICAgaWYgKGl0ZW1JZCAmJiB0aGlzLl9kYXRhW2l0ZW1JZF0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9kYXRhW2l0ZW1JZF07XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgcmV0dXJuIGl0ZW1JZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSBkYXRhXG4gKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAqIEByZXR1cm4ge0FycmF5fSByZW1vdmVkSWRzICAgIFRoZSBpZHMgb2YgYWxsIHJlbW92ZWQgaXRlbXNcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoc2VuZGVySWQpIHtcbiAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKHRoaXMuX2RhdGEpO1xuXG4gIHRoaXMuX2RhdGEgPSB7fTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHtpdGVtczogaWRzfSwgc2VuZGVySWQpO1xuXG4gIHJldHVybiBpZHM7XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIGl0ZW0gd2l0aCBtYXhpbXVtIHZhbHVlIG9mIGEgc3BlY2lmaWVkIGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge09iamVjdCB8IG51bGx9IGl0ZW0gIEl0ZW0gY29udGFpbmluZyBtYXggdmFsdWUsIG9yIG51bGwgaWYgbm8gaXRlbXNcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgIG1heCA9IG51bGwsXG4gICAgICBtYXhGaWVsZCA9IG51bGw7XG5cbiAgZm9yICh2YXIgaWQgaW4gZGF0YSkge1xuICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhW2lkXTtcbiAgICAgIHZhciBpdGVtRmllbGQgPSBpdGVtW2ZpZWxkXTtcbiAgICAgIGlmIChpdGVtRmllbGQgIT0gbnVsbCAmJiAoIW1heCB8fCBpdGVtRmllbGQgPiBtYXhGaWVsZCkpIHtcbiAgICAgICAgbWF4ID0gaXRlbTtcbiAgICAgICAgbWF4RmllbGQgPSBpdGVtRmllbGQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1heDtcbn07XG5cbi8qKlxuICogRmluZCB0aGUgaXRlbSB3aXRoIG1pbmltdW0gdmFsdWUgb2YgYSBzcGVjaWZpZWQgZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gaXRlbSAgSXRlbSBjb250YWluaW5nIG1heCB2YWx1ZSwgb3IgbnVsbCBpZiBubyBpdGVtc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgbWluID0gbnVsbCxcbiAgICAgIG1pbkZpZWxkID0gbnVsbDtcblxuICBmb3IgKHZhciBpZCBpbiBkYXRhKSB7XG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICB2YXIgaXRlbSA9IGRhdGFbaWRdO1xuICAgICAgdmFyIGl0ZW1GaWVsZCA9IGl0ZW1bZmllbGRdO1xuICAgICAgaWYgKGl0ZW1GaWVsZCAhPSBudWxsICYmICghbWluIHx8IGl0ZW1GaWVsZCA8IG1pbkZpZWxkKSkge1xuICAgICAgICBtaW4gPSBpdGVtO1xuICAgICAgICBtaW5GaWVsZCA9IGl0ZW1GaWVsZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluO1xufTtcblxuLyoqXG4gKiBGaW5kIGFsbCBkaXN0aW5jdCB2YWx1ZXMgb2YgYSBzcGVjaWZpZWQgZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7QXJyYXl9IHZhbHVlcyAgQXJyYXkgY29udGFpbmluZyBhbGwgZGlzdGluY3QgdmFsdWVzLiBJZiBkYXRhIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBkbyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIGZpZWxkIGFyZSBpZ25vcmVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHJldHVybmVkIGFycmF5IGlzIHVub3JkZXJlZC5cbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuZGlzdGluY3QgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciBmaWVsZFR5cGUgPSB0aGlzLl9vcHRpb25zLnR5cGUgJiYgdGhpcy5fb3B0aW9ucy50eXBlW2ZpZWxkXSB8fCBudWxsO1xuICB2YXIgY291bnQgPSAwO1xuICB2YXIgaTtcblxuICBmb3IgKHZhciBwcm9wIGluIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhW3Byb3BdO1xuICAgICAgdmFyIHZhbHVlID0gaXRlbVtmaWVsZF07XG4gICAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBpZiAodmFsdWVzW2ldID09IHZhbHVlKSB7XG4gICAgICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFleGlzdHMgJiYgKHZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHZhbHVlc1tjb3VudF0gPSB2YWx1ZTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZmllbGRUeXBlKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gdXRpbC5jb252ZXJ0KHZhbHVlc1tpXSwgZmllbGRUeXBlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWVzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgaXRlbS4gV2lsbCBmYWlsIHdoZW4gYW4gaXRlbSB3aXRoIHRoZSBzYW1lIGlkIGFscmVhZHkgZXhpc3RzLlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAqIEByZXR1cm4ge1N0cmluZ30gaWRcbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl9hZGRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGlkID0gaXRlbVt0aGlzLl9maWVsZElkXTtcblxuICBpZiAoaWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGlzIGlkIGlzIGFscmVhZHkgdGFrZW5cbiAgICBpZiAodGhpcy5fZGF0YVtpZF0pIHtcbiAgICAgIC8vIGl0ZW0gYWxyZWFkeSBleGlzdHNcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBpdGVtOiBpdGVtIHdpdGggaWQgJyArIGlkICsgJyBhbHJlYWR5IGV4aXN0cycpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBnZW5lcmF0ZSBhbiBpZFxuICAgIGlkID0gdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgaXRlbVt0aGlzLl9maWVsZElkXSA9IGlkO1xuICB9XG5cbiAgdmFyIGQgPSB7fTtcbiAgZm9yICh2YXIgZmllbGQgaW4gaXRlbSkge1xuICAgIGlmIChpdGVtLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgdmFyIGZpZWxkVHlwZSA9IHRoaXMuX3R5cGVbZmllbGRdOyAgLy8gdHlwZSBtYXkgYmUgdW5kZWZpbmVkXG4gICAgICBkW2ZpZWxkXSA9IHV0aWwuY29udmVydChpdGVtW2ZpZWxkXSwgZmllbGRUeXBlKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fZGF0YVtpZF0gPSBkO1xuICB0aGlzLmxlbmd0aCsrO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbi8qKlxuICogR2V0IGFuIGl0ZW0uIEZpZWxkcyBjYW4gYmUgY29udmVydGVkIHRvIGEgc3BlY2lmaWMgdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbdHlwZXNdICBmaWVsZCB0eXBlcyB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBpdGVtXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fZ2V0SXRlbSA9IGZ1bmN0aW9uIChpZCwgdHlwZXMpIHtcbiAgdmFyIGZpZWxkLCB2YWx1ZTtcblxuICAvLyBnZXQgdGhlIGl0ZW0gZnJvbSB0aGUgZGF0YXNldFxuICB2YXIgcmF3ID0gdGhpcy5fZGF0YVtpZF07XG4gIGlmICghcmF3KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBjb252ZXJ0IHRoZSBpdGVtcyBmaWVsZCB0eXBlc1xuICB2YXIgY29udmVydGVkID0ge307XG4gIGlmICh0eXBlcykge1xuICAgIGZvciAoZmllbGQgaW4gcmF3KSB7XG4gICAgICBpZiAocmF3Lmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICB2YWx1ZSA9IHJhd1tmaWVsZF07XG4gICAgICAgIGNvbnZlcnRlZFtmaWVsZF0gPSB1dGlsLmNvbnZlcnQodmFsdWUsIHR5cGVzW2ZpZWxkXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIG5vIGZpZWxkIHR5cGVzIHNwZWNpZmllZCwgbm8gY29udmVydGluZyBuZWVkZWRcbiAgICBmb3IgKGZpZWxkIGluIHJhdykge1xuICAgICAgaWYgKHJhdy5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgdmFsdWUgPSByYXdbZmllbGRdO1xuICAgICAgICBjb252ZXJ0ZWRbZmllbGRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb252ZXJ0ZWQ7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBhIHNpbmdsZSBpdGVtOiBtZXJnZSB3aXRoIGV4aXN0aW5nIGl0ZW0uXG4gKiBXaWxsIGZhaWwgd2hlbiB0aGUgaXRlbSBoYXMgbm8gaWQsIG9yIHdoZW4gdGhlcmUgZG9lcyBub3QgZXhpc3QgYW4gaXRlbVxuICogd2l0aCB0aGUgc2FtZSBpZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGlkXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fdXBkYXRlSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBpZCA9IGl0ZW1bdGhpcy5fZmllbGRJZF07XG4gIGlmIChpZCA9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1cGRhdGUgaXRlbTogaXRlbSBoYXMgbm8gaWQgKGl0ZW06ICcgKyBKU09OLnN0cmluZ2lmeShpdGVtKSArICcpJyk7XG4gIH1cbiAgdmFyIGQgPSB0aGlzLl9kYXRhW2lkXTtcbiAgaWYgKCFkKSB7XG4gICAgLy8gaXRlbSBkb2Vzbid0IGV4aXN0XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXBkYXRlIGl0ZW06IG5vIGl0ZW0gd2l0aCBpZCAnICsgaWQgKyAnIGZvdW5kJyk7XG4gIH1cblxuICAvLyBtZXJnZSB3aXRoIGN1cnJlbnQgaXRlbVxuICBmb3IgKHZhciBmaWVsZCBpbiBpdGVtKSB7XG4gICAgaWYgKGl0ZW0uaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICB2YXIgZmllbGRUeXBlID0gdGhpcy5fdHlwZVtmaWVsZF07ICAvLyB0eXBlIG1heSBiZSB1bmRlZmluZWRcbiAgICAgIGRbZmllbGRdID0gdXRpbC5jb252ZXJ0KGl0ZW1bZmllbGRdLCBmaWVsZFR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNldDtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgRGF0YVNldCA9IHJlcXVpcmUoJy4vRGF0YVNldCcpO1xuXG4vKipcbiAqIERhdGFWaWV3XG4gKlxuICogYSBkYXRhdmlldyBvZmZlcnMgYSBmaWx0ZXJlZCB2aWV3IG9uIGEgZGF0YXNldCBvciBhbiBvdGhlciBkYXRhdmlldy5cbiAqXG4gKiBAcGFyYW0ge0RhdGFTZXQgfCBEYXRhVmlld30gZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgIEF2YWlsYWJsZSBvcHRpb25zOiBzZWUgbWV0aG9kIGdldFxuICpcbiAqIEBjb25zdHJ1Y3RvciBEYXRhVmlld1xuICovXG5mdW5jdGlvbiBEYXRhVmlldyAoZGF0YSwgb3B0aW9ucykge1xuICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgdGhpcy5faWRzID0ge307IC8vIGlkcyBvZiB0aGUgaXRlbXMgY3VycmVudGx5IGluIG1lbW9yeSAoanVzdCBjb250YWlucyBhIGJvb2xlYW4gdHJ1ZSlcbiAgdGhpcy5sZW5ndGggPSAwOyAvLyBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIERhdGFWaWV3XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9maWVsZElkID0gJ2lkJzsgLy8gbmFtZSBvZiB0aGUgZmllbGQgY29udGFpbmluZyBpZFxuICB0aGlzLl9zdWJzY3JpYmVycyA9IHt9OyAvLyBldmVudCBzdWJzY3JpYmVyc1xuXG4gIHZhciBtZSA9IHRoaXM7XG4gIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgbWUuX29uRXZlbnQuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdGhpcy5zZXREYXRhKGRhdGEpO1xufVxuXG4vLyBUT0RPOiBpbXBsZW1lbnQgYSBmdW5jdGlvbiAuY29uZmlnKCkgdG8gZHluYW1pY2FsbHkgdXBkYXRlIHRoaW5ncyBsaWtlIGNvbmZpZ3VyZWQgZmlsdGVyXG4vLyBhbmQgdHJpZ2dlciBjaGFuZ2VzIGFjY29yZGluZ2x5XG5cbi8qKlxuICogU2V0IGEgZGF0YSBzb3VyY2UgZm9yIHRoZSB2aWV3XG4gKiBAcGFyYW0ge0RhdGFTZXQgfCBEYXRhVmlld30gZGF0YVxuICovXG5EYXRhVmlldy5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBpZHMsIGksIGxlbjtcblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gY3VycmVudCBkYXRhc2V0XG4gICAgaWYgKHRoaXMuX2RhdGEub2ZmKSB7XG4gICAgICB0aGlzLl9kYXRhLm9mZignKicsIHRoaXMubGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgYSByZW1vdmUgb2YgYWxsIGl0ZW1zIGluIG1lbW9yeVxuICAgIGlkcyA9IFtdO1xuICAgIGZvciAodmFyIGlkIGluIHRoaXMuX2lkcykge1xuICAgICAgaWYgKHRoaXMuX2lkcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgaWRzLnB1c2goaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pZHMgPSB7fTtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fdHJpZ2dlcigncmVtb3ZlJywge2l0ZW1zOiBpZHN9KTtcbiAgfVxuXG4gIHRoaXMuX2RhdGEgPSBkYXRhO1xuXG4gIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgLy8gdXBkYXRlIGZpZWxkSWRcbiAgICB0aGlzLl9maWVsZElkID0gdGhpcy5fb3B0aW9ucy5maWVsZElkIHx8XG4gICAgICAgICh0aGlzLl9kYXRhICYmIHRoaXMuX2RhdGEub3B0aW9ucyAmJiB0aGlzLl9kYXRhLm9wdGlvbnMuZmllbGRJZCkgfHxcbiAgICAgICAgJ2lkJztcblxuICAgIC8vIHRyaWdnZXIgYW4gYWRkIG9mIGFsbCBhZGRlZCBpdGVtc1xuICAgIGlkcyA9IHRoaXMuX2RhdGEuZ2V0SWRzKHtmaWx0ZXI6IHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5maWx0ZXJ9KTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgdGhpcy5faWRzW2lkXSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gaWRzLmxlbmd0aDtcbiAgICB0aGlzLl90cmlnZ2VyKCdhZGQnLCB7aXRlbXM6IGlkc30pO1xuXG4gICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgaWYgKHRoaXMuX2RhdGEub24pIHtcbiAgICAgIHRoaXMuX2RhdGEub24oJyonLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVmcmVzaCB0aGUgRGF0YVZpZXcuIFVzZWZ1bCB3aGVuIHRoZSBEYXRhVmlldyBoYXMgYSBmaWx0ZXIgZnVuY3Rpb25cbiAqIGNvbnRhaW5pbmcgYSB2YXJpYWJsZSBwYXJhbWV0ZXIuXG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQ7XG4gIHZhciBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7ZmlsdGVyOiB0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMuZmlsdGVyfSk7XG4gIHZhciBuZXdJZHMgPSB7fTtcbiAgdmFyIGFkZGVkID0gW107XG4gIHZhciByZW1vdmVkID0gW107XG5cbiAgLy8gY2hlY2sgZm9yIGFkZGl0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgIGlkID0gaWRzW2ldO1xuICAgIG5ld0lkc1tpZF0gPSB0cnVlO1xuICAgIGlmICghdGhpcy5faWRzW2lkXSkge1xuICAgICAgYWRkZWQucHVzaChpZCk7XG4gICAgICB0aGlzLl9pZHNbaWRdID0gdHJ1ZTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgZm9yIHJlbW92YWxzXG4gIGZvciAoaWQgaW4gdGhpcy5faWRzKSB7XG4gICAgaWYgKHRoaXMuX2lkcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIGlmICghbmV3SWRzW2lkXSkge1xuICAgICAgICByZW1vdmVkLnB1c2goaWQpO1xuICAgICAgICBkZWxldGUgdGhpcy5faWRzW2lkXTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyB0cmlnZ2VyIGV2ZW50c1xuICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgdGhpcy5fdHJpZ2dlcignYWRkJywge2l0ZW1zOiBhZGRlZH0pO1xuICB9XG4gIGlmIChyZW1vdmVkLmxlbmd0aCkge1xuICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHtpdGVtczogcmVtb3ZlZH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBkYXRhIGZyb20gdGhlIGRhdGEgdmlld1xuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgICBnZXQoKVxuICogICAgIGdldChvcHRpb25zOiBPYmplY3QpXG4gKiAgICAgZ2V0KG9wdGlvbnM6IE9iamVjdCwgZGF0YTogQXJyYXkgfCBEYXRhVGFibGUpXG4gKlxuICogICAgIGdldChpZDogTnVtYmVyKVxuICogICAgIGdldChpZDogTnVtYmVyLCBvcHRpb25zOiBPYmplY3QpXG4gKiAgICAgZ2V0KGlkOiBOdW1iZXIsIG9wdGlvbnM6IE9iamVjdCwgZGF0YTogQXJyYXkgfCBEYXRhVGFibGUpXG4gKlxuICogICAgIGdldChpZHM6IE51bWJlcltdKVxuICogICAgIGdldChpZHM6IE51bWJlcltdLCBvcHRpb25zOiBPYmplY3QpXG4gKiAgICAgZ2V0KGlkczogTnVtYmVyW10sIG9wdGlvbnM6IE9iamVjdCwgZGF0YTogQXJyYXkgfCBEYXRhVGFibGUpXG4gKlxuICogV2hlcmU6XG4gKlxuICoge051bWJlciB8IFN0cmluZ30gaWQgICAgICAgICBUaGUgaWQgb2YgYW4gaXRlbVxuICoge051bWJlcltdIHwgU3RyaW5ne319IGlkcyAgICBBbiBhcnJheSB3aXRoIGlkcyBvZiBpdGVtc1xuICoge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICBBbiBPYmplY3Qgd2l0aCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gW3R5cGVdIFR5cGUgb2YgZGF0YSB0byBiZSByZXR1cm5lZC4gQ2FuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSAnRGF0YVRhYmxlJyBvciAnQXJyYXknIChkZWZhdWx0KVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFtjb252ZXJ0XVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nW119IFtmaWVsZHNdIGZpZWxkIG5hbWVzIHRvIGJlIHJldHVybmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIHtBcnJheSB8IERhdGFUYWJsZX0gW2RhdGFdICAgSWYgcHJvdmlkZWQsIGl0ZW1zIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheSBvciB0YWJsZS4gUmVxdWlyZWQgaW4gY2FzZSBvZiBHb29nbGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGF0YVRhYmxlLlxuICogQHBhcmFtIGFyZ3NcbiAqL1xuRGF0YVZpZXcucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gcGFyc2UgdGhlIGFyZ3VtZW50c1xuICB2YXIgaWRzLCBvcHRpb25zLCBkYXRhO1xuICB2YXIgZmlyc3RUeXBlID0gdXRpbC5nZXRUeXBlKGFyZ3VtZW50c1swXSk7XG4gIGlmIChmaXJzdFR5cGUgPT0gJ1N0cmluZycgfHwgZmlyc3RUeXBlID09ICdOdW1iZXInIHx8IGZpcnN0VHlwZSA9PSAnQXJyYXknKSB7XG4gICAgLy8gZ2V0KGlkKHMpIFssIG9wdGlvbnNdIFssIGRhdGFdKVxuICAgIGlkcyA9IGFyZ3VtZW50c1swXTsgIC8vIGNhbiBiZSBhIHNpbmdsZSBpZCBvciBhbiBhcnJheSB3aXRoIGlkc1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gICAgZGF0YSA9IGFyZ3VtZW50c1syXTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBnZXQoWywgb3B0aW9uc10gWywgZGF0YV0pXG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICBkYXRhID0gYXJndW1lbnRzWzFdO1xuICB9XG5cbiAgLy8gZXh0ZW5kIHRoZSBvcHRpb25zIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucyBhbmQgcHJvdmlkZWQgb3B0aW9uc1xuICB2YXIgdmlld09wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgLy8gY3JlYXRlIGEgY29tYmluZWQgZmlsdGVyIG1ldGhvZCB3aGVuIG5lZWRlZFxuICBpZiAodGhpcy5fb3B0aW9ucy5maWx0ZXIgJiYgb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcikge1xuICAgIHZpZXdPcHRpb25zLmZpbHRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gbWUuX29wdGlvbnMuZmlsdGVyKGl0ZW0pICYmIG9wdGlvbnMuZmlsdGVyKGl0ZW0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGJ1aWxkIHVwIHRoZSBjYWxsIHRvIHRoZSBsaW5rZWQgZGF0YSBzZXRcbiAgdmFyIGdldEFyZ3VtZW50cyA9IFtdO1xuICBpZiAoaWRzICE9IHVuZGVmaW5lZCkge1xuICAgIGdldEFyZ3VtZW50cy5wdXNoKGlkcyk7XG4gIH1cbiAgZ2V0QXJndW1lbnRzLnB1c2godmlld09wdGlvbnMpO1xuICBnZXRBcmd1bWVudHMucHVzaChkYXRhKTtcblxuICByZXR1cm4gdGhpcy5fZGF0YSAmJiB0aGlzLl9kYXRhLmdldC5hcHBseSh0aGlzLl9kYXRhLCBnZXRBcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBHZXQgaWRzIG9mIGFsbCBpdGVtcyBvciBmcm9tIGEgZmlsdGVyZWQgc2V0IG9mIGl0ZW1zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBBbiBPYmplY3Qgd2l0aCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICogQHJldHVybiB7QXJyYXl9IGlkc1xuICovXG5EYXRhVmlldy5wcm90b3R5cGUuZ2V0SWRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGlkcztcblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIHZhciBkZWZhdWx0RmlsdGVyID0gdGhpcy5fb3B0aW9ucy5maWx0ZXI7XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICBpZiAoZGVmYXVsdEZpbHRlcikge1xuICAgICAgICBmaWx0ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0RmlsdGVyKGl0ZW0pICYmIG9wdGlvbnMuZmlsdGVyKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmlsdGVyID0gZGVmYXVsdEZpbHRlcjtcbiAgICB9XG5cbiAgICBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7XG4gICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgIG9yZGVyOiBvcHRpb25zICYmIG9wdGlvbnMub3JkZXJcbiAgICB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZHMgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBpZHM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgRGF0YVNldCB0byB3aGljaCB0aGlzIERhdGFWaWV3IGlzIGNvbm5lY3RlZC4gSW4gY2FzZSB0aGVyZSBpcyBhIGNoYWluXG4gKiBvZiBtdWx0aXBsZSBEYXRhVmlld3MsIHRoZSByb290IERhdGFTZXQgb2YgdGhpcyBjaGFpbiBpcyByZXR1cm5lZC5cbiAqIEByZXR1cm4ge0RhdGFTZXR9IGRhdGFTZXRcbiAqL1xuRGF0YVZpZXcucHJvdG90eXBlLmdldERhdGFTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkYXRhU2V0ID0gdGhpcztcbiAgd2hpbGUgKGRhdGFTZXQgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIGRhdGFTZXQgPSBkYXRhU2V0Ll9kYXRhO1xuICB9XG4gIHJldHVybiBkYXRhU2V0IHx8IG51bGw7XG59O1xuXG4vKipcbiAqIEV2ZW50IGxpc3RlbmVyLiBXaWxsIHByb3BhZ2F0ZSBhbGwgZXZlbnRzIGZyb20gdGhlIGNvbm5lY3RlZCBkYXRhIHNldCB0b1xuICogdGhlIHN1YnNjcmliZXJzIG9mIHRoZSBEYXRhVmlldywgYnV0IHdpbGwgZmlsdGVyIHRoZSBpdGVtcyBhbmQgb25seSB0cmlnZ2VyXG4gKiB3aGVuIHRoZXJlIGFyZSBjaGFuZ2VzIGluIHRoZSBmaWx0ZXJlZCBkYXRhIHNldC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3QgfCBudWxsfSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZW5kZXJJZFxuICogQHByaXZhdGVcbiAqL1xuRGF0YVZpZXcucHJvdG90eXBlLl9vbkV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gIHZhciBpLCBsZW4sIGlkLCBpdGVtO1xuICB2YXIgaWRzID0gcGFyYW1zICYmIHBhcmFtcy5pdGVtcztcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICB2YXIgdXBkYXRlZERhdGEgPSBbXTtcbiAgdmFyIGFkZGVkID0gW107XG4gIHZhciB1cGRhdGVkID0gW107XG4gIHZhciByZW1vdmVkID0gW107XG5cbiAgaWYgKGlkcyAmJiBkYXRhKSB7XG4gICAgc3dpdGNoIChldmVudCkge1xuICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgLy8gZmlsdGVyIHRoZSBpZHMgb2YgdGhlIGFkZGVkIGl0ZW1zXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLmdldChpZCk7XG4gICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgYWRkZWQucHVzaChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgIC8vIGRldGVybWluZSB0aGUgZXZlbnQgZnJvbSB0aGUgdmlld3Mgdmlld3BvaW50OiBhbiB1cGRhdGVkXG4gICAgICAgIC8vIGl0ZW0gY2FuIGJlIGFkZGVkLCB1cGRhdGVkLCBvciByZW1vdmVkIGZyb20gdGhpcyB2aWV3LlxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZCA9IGlkc1tpXTtcbiAgICAgICAgICBpdGVtID0gdGhpcy5nZXQoaWQpO1xuXG4gICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pZHNbaWRdKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZWQucHVzaChpZCk7XG4gICAgICAgICAgICAgIHVwZGF0ZWREYXRhLnB1c2gocGFyYW1zLmRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICBhZGRlZC5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faWRzW2lkXSkge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5faWRzW2lkXTtcbiAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBub3RoaW5nIGludGVyZXN0aW5nIGZvciBtZSA6LShcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmVtb3ZlJzpcbiAgICAgICAgLy8gZmlsdGVyIHRoZSBpZHMgb2YgdGhlIHJlbW92ZWQgaXRlbXNcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWQgPSBpZHNbaV07XG4gICAgICAgICAgaWYgKHRoaXMuX2lkc1tpZF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pZHNbaWRdO1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCArPSBhZGRlZC5sZW5ndGggLSByZW1vdmVkLmxlbmd0aDtcblxuICAgIGlmIChhZGRlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHtpdGVtczogYWRkZWR9LCBzZW5kZXJJZCk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVkLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdHJpZ2dlcigndXBkYXRlJywge2l0ZW1zOiB1cGRhdGVkLCBkYXRhOiB1cGRhdGVkRGF0YX0sIHNlbmRlcklkKTtcbiAgICB9XG4gICAgaWYgKHJlbW92ZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7aXRlbXM6IHJlbW92ZWR9LCBzZW5kZXJJZCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBjb3B5IHN1YnNjcmlwdGlvbiBmdW5jdGlvbmFsaXR5IGZyb20gRGF0YVNldFxuRGF0YVZpZXcucHJvdG90eXBlLm9uID0gRGF0YVNldC5wcm90b3R5cGUub247XG5EYXRhVmlldy5wcm90b3R5cGUub2ZmID0gRGF0YVNldC5wcm90b3R5cGUub2ZmO1xuRGF0YVZpZXcucHJvdG90eXBlLl90cmlnZ2VyID0gRGF0YVNldC5wcm90b3R5cGUuX3RyaWdnZXI7XG5cbi8vIFRPRE86IG1ha2UgdGhlc2UgZnVuY3Rpb25zIGRlcHJlY2F0ZWQgKHJlcGxhY2VkIHdpdGggYG9uYCBhbmQgYG9mZmAgc2luY2UgdmVyc2lvbiAwLjUpXG5EYXRhVmlldy5wcm90b3R5cGUuc3Vic2NyaWJlID0gRGF0YVZpZXcucHJvdG90eXBlLm9uO1xuRGF0YVZpZXcucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gRGF0YVZpZXcucHJvdG90eXBlLm9mZjtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldzsiLCIvKipcbiAqIEEgcXVldWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAtIGRlbGF5OiBudW1iZXIgICAgV2hlbiBwcm92aWRlZCwgdGhlIHF1ZXVlIHdpbGwgYmUgZmx1c2hlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljYWxseSBhZnRlciBhbiBpbmFjdGl2aXR5IG9mIHRoaXMgZGVsYXlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIG1pbGxpc2Vjb25kcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgaXMgbnVsbC5cbiAqICAgICAgICAgICAgLSBtYXg6IG51bWJlciAgICAgIFdoZW4gdGhlIHF1ZXVlIGV4Y2VlZHMgdGhlIGdpdmVuIG1heGltdW0gbnVtYmVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBlbnRyaWVzLCB0aGUgcXVldWUgaXMgZmx1c2hlZCBhdXRvbWF0aWNhbGx5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBvZiBtYXggaXMgSW5maW5pdHkuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUXVldWUob3B0aW9ucykge1xuICAvLyBvcHRpb25zXG4gIHRoaXMuZGVsYXkgPSBudWxsO1xuICB0aGlzLm1heCA9IEluZmluaXR5O1xuXG4gIC8vIHByb3BlcnRpZXNcbiAgdGhpcy5fcXVldWUgPSBbXTtcbiAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gIHRoaXMuX2V4dGVuZGVkID0gbnVsbDtcblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBxdWV1ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgIC0gZGVsYXk6IG51bWJlciAgICBXaGVuIHByb3ZpZGVkLCB0aGUgcXVldWUgd2lsbCBiZSBmbHVzaGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGFmdGVyIGFuIGluYWN0aXZpdHkgb2YgdGhpcyBkZWxheVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gbWlsbGlzZWNvbmRzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBpcyBudWxsLlxuICogICAgICAgICAgICAtIG1heDogbnVtYmVyICAgICAgV2hlbiB0aGUgcXVldWUgZXhjZWVkcyB0aGUgZ2l2ZW4gbWF4aW11bSBudW1iZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGVudHJpZXMsIHRoZSBxdWV1ZSBpcyBmbHVzaGVkIGF1dG9tYXRpY2FsbHkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIG9mIG1heCBpcyBJbmZpbml0eS5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuZGVsYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5kZWxheSA9IG9wdGlvbnMuZGVsYXk7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMubWF4ID0gb3B0aW9ucy5tYXg7XG4gIH1cblxuICB0aGlzLl9mbHVzaElmTmVlZGVkKCk7XG59O1xuXG4vKipcbiAqIEV4dGVuZCBhbiBvYmplY3Qgd2l0aCBxdWV1aW5nIGZ1bmN0aW9uYWxpdHkuXG4gKiBUaGUgb2JqZWN0IHdpbGwgYmUgZXh0ZW5kZWQgd2l0aCBhIGZ1bmN0aW9uIGZsdXNoLCBhbmQgdGhlIG1ldGhvZHMgcHJvdmlkZWRcbiAqIGluIG9wdGlvbnMucmVwbGFjZSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggcXVldWVkIG9uZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgLSByZXBsYWNlOiBBcnJheS48c3RyaW5nPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBsaXN0IHdpdGggbWV0aG9kIG5hbWVzIG9mIHRoZSBtZXRob2RzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbiB0aGUgb2JqZWN0IHRvIGJlIHJlcGxhY2VkIHdpdGggcXVldWVkIG9uZXMuXG4gKiAgICAgICAgICAgIC0gZGVsYXk6IG51bWJlciAgICBXaGVuIHByb3ZpZGVkLCB0aGUgcXVldWUgd2lsbCBiZSBmbHVzaGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGFmdGVyIGFuIGluYWN0aXZpdHkgb2YgdGhpcyBkZWxheVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gbWlsbGlzZWNvbmRzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBpcyBudWxsLlxuICogICAgICAgICAgICAtIG1heDogbnVtYmVyICAgICAgV2hlbiB0aGUgcXVldWUgZXhjZWVkcyB0aGUgZ2l2ZW4gbWF4aW11bSBudW1iZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGVudHJpZXMsIHRoZSBxdWV1ZSBpcyBmbHVzaGVkIGF1dG9tYXRpY2FsbHkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIG9mIG1heCBpcyBJbmZpbml0eS5cbiAqIEByZXR1cm4ge1F1ZXVlfSBSZXR1cm5zIHRoZSBjcmVhdGVkIHF1ZXVlXG4gKi9cblF1ZXVlLmV4dGVuZCA9IGZ1bmN0aW9uIChvYmplY3QsIG9wdGlvbnMpIHtcbiAgdmFyIHF1ZXVlID0gbmV3IFF1ZXVlKG9wdGlvbnMpO1xuXG4gIGlmIChvYmplY3QuZmx1c2ggIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGFyZ2V0IG9iamVjdCBhbHJlYWR5IGhhcyBhIHByb3BlcnR5IGZsdXNoJyk7XG4gIH1cbiAgb2JqZWN0LmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHF1ZXVlLmZsdXNoKCk7XG4gIH07XG5cbiAgdmFyIG1ldGhvZHMgPSBbe1xuICAgIG5hbWU6ICdmbHVzaCcsXG4gICAgb3JpZ2luYWw6IHVuZGVmaW5lZFxuICB9XTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMucmVwbGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLnJlcGxhY2VbaV07XG4gICAgICBtZXRob2RzLnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBvcmlnaW5hbDogb2JqZWN0W25hbWVdXG4gICAgICB9KTtcbiAgICAgIHF1ZXVlLnJlcGxhY2Uob2JqZWN0LCBuYW1lKTtcbiAgICB9XG4gIH1cblxuICBxdWV1ZS5fZXh0ZW5kZWQgPSB7XG4gICAgb2JqZWN0OiBvYmplY3QsXG4gICAgbWV0aG9kczogbWV0aG9kc1xuICB9O1xuXG4gIHJldHVybiBxdWV1ZTtcbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgcXVldWUuIFRoZSBxdWV1ZSB3aWxsIGZpcnN0IGZsdXNoIGFsbCBxdWV1ZWQgYWN0aW9ucywgYW5kIGluXG4gKiBjYXNlIGl0IGhhcyBleHRlbmRlZCBhbiBvYmplY3QsIHdpbGwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICovXG5RdWV1ZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mbHVzaCgpO1xuXG4gIGlmICh0aGlzLl9leHRlbmRlZCkge1xuICAgIHZhciBvYmplY3QgPSB0aGlzLl9leHRlbmRlZC5vYmplY3Q7XG4gICAgdmFyIG1ldGhvZHMgPSB0aGlzLl9leHRlbmRlZC5tZXRob2RzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1ldGhvZCA9IG1ldGhvZHNbaV07XG4gICAgICBpZiAobWV0aG9kLm9yaWdpbmFsKSB7XG4gICAgICAgIG9iamVjdFttZXRob2QubmFtZV0gPSBtZXRob2Qub3JpZ2luYWw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIG9iamVjdFttZXRob2QubmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2V4dGVuZGVkID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBsYWNlIGEgbWV0aG9kIG9uIGFuIG9iamVjdCB3aXRoIGEgcXVldWVkIHZlcnNpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgICBPYmplY3QgaGF2aW5nIHRoZSBtZXRob2RcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgICBUaGUgbWV0aG9kIG5hbWVcbiAqL1xuUXVldWUucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbihvYmplY3QsIG1ldGhvZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuICB2YXIgb3JpZ2luYWwgPSBvYmplY3RbbWV0aG9kXTtcbiAgaWYgKCFvcmlnaW5hbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kICcgKyBtZXRob2QgKyAnIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgb2JqZWN0W21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY3JlYXRlIGFuIEFycmF5IHdpdGggdGhlIGFyZ3VtZW50c1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgLy8gYWRkIHRoaXMgY2FsbCB0byB0aGUgcXVldWVcbiAgICBtZS5xdWV1ZSh7XG4gICAgICBhcmdzOiBhcmdzLFxuICAgICAgZm46IG9yaWdpbmFsLFxuICAgICAgY29udGV4dDogdGhpc1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBRdWV1ZSBhIGNhbGxcbiAqIEBwYXJhbSB7ZnVuY3Rpb24gfCB7Zm46IGZ1bmN0aW9uLCBhcmdzOiBBcnJheX0gfCB7Zm46IGZ1bmN0aW9uLCBhcmdzOiBBcnJheSwgY29udGV4dDogT2JqZWN0fX0gZW50cnlcbiAqL1xuUXVldWUucHJvdG90eXBlLnF1ZXVlID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX3F1ZXVlLnB1c2goe2ZuOiBlbnRyeX0pO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuX3F1ZXVlLnB1c2goZW50cnkpO1xuICB9XG5cbiAgdGhpcy5fZmx1c2hJZk5lZWRlZCgpO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBxdWV1ZSBuZWVkcyB0byBiZSBmbHVzaGVkXG4gKiBAcHJpdmF0ZVxuICovXG5RdWV1ZS5wcm90b3R5cGUuX2ZsdXNoSWZOZWVkZWQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGZsdXNoIHdoZW4gdGhlIG1heGltdW0gaXMgZXhjZWVkZWQuXG4gIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPiB0aGlzLm1heCkge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxuXG4gIC8vIGZsdXNoIGFmdGVyIGEgcGVyaW9kIG9mIGluYWN0aXZpdHkgd2hlbiBhIGRlbGF5IGlzIGNvbmZpZ3VyZWRcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwICYmIHR5cGVvZiB0aGlzLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgbWUuZmx1c2goKTtcbiAgICB9LCB0aGlzLmRlbGF5KTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCBhbGwgcXVldWVkIGNhbGxzXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgd2hpbGUgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgIGVudHJ5LmZuLmFwcGx5KGVudHJ5LmNvbnRleHQgfHwgZW50cnkuZm4sIGVudHJ5LmFyZ3MgfHwgW10pO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXVlO1xuIiwidmFyIEhhbW1lciA9IHJlcXVpcmUoJy4vbW9kdWxlL2hhbW1lcicpO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgdG91Y2ggZXZlbnQsIHRha2luZyBwbGFjZSBiZWZvcmUgYSBnZXN0dXJlXG4gKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gKi9cbmV4cG9ydHMub25Ub3VjaCA9IGZ1bmN0aW9uIChoYW1tZXIsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrLmlucHV0SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5pc0ZpcnN0ICYmICFpc1RvdWNoaW5nKSB7XG4gICAgICBjYWxsYmFjayhldmVudCk7XG5cbiAgICAgIGlzVG91Y2hpbmcgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlzVG91Y2hpbmcgPSBmYWxzZTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfTtcblxuICBoYW1tZXIub24oJ2hhbW1lci5pbnB1dCcsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG59O1xuXG4vLyBpc1RvdWNoaW5nIGlzIHRydWUgd2hpbGUgYSB0b3VjaCBhY3Rpb24gaXMgYmVpbmcgZW1pdHRlZFxuLy8gdGhpcyBpcyBhIGhhY2sgdG8gcHJldmVudCBgdG91Y2hgIGZyb20gYmVpbmcgZmlyZWQgdHdpY2VcbnZhciBpc1RvdWNoaW5nID0gZmFsc2U7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSByZWxlYXNlIGV2ZW50LCB0YWtpbmcgcGxhY2UgYWZ0ZXIgYSBnZXN0dXJlXG4gKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gKi9cbmV4cG9ydHMub25SZWxlYXNlID0gZnVuY3Rpb24gKGhhbW1lciwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2suaW5wdXRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmlzRmluYWwgJiYgIWlzUmVsZWFzaW5nKSB7XG4gICAgICBjYWxsYmFjayhldmVudCk7XG5cbiAgICAgIGlzUmVsZWFzaW5nID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpc1JlbGVhc2luZyA9IGZhbHNlO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBoYW1tZXIub24oJ2hhbW1lci5pbnB1dCcsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG59O1xuXG5cbi8vIGlzUmVsZWFzaW5nIGlzIHRydWUgd2hpbGUgYSByZWxlYXNlIGFjdGlvbiBpcyBiZWluZyBlbWl0dGVkXG4vLyB0aGlzIGlzIGEgaGFjayB0byBwcmV2ZW50IGByZWxlYXNlYCBmcm9tIGJlaW5nIGZpcmVkIHR3aWNlXG52YXIgaXNSZWxlYXNpbmcgPSBmYWxzZTtcblxuXG4vKipcbiAqIFVucmVnaXN0ZXIgYSB0b3VjaCBldmVudCwgdGFraW5nIHBsYWNlIGJlZm9yZSBhIGdlc3R1cmVcbiAqIEBwYXJhbSB7SGFtbWVyfSBoYW1tZXIgICAgICAgQSBoYW1tZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGJhY2ssIGNhbGxlZCBhcyBjYWxsYmFjayhldmVudClcbiAqL1xuZXhwb3J0cy5vZmZUb3VjaCA9IGZ1bmN0aW9uIChoYW1tZXIsIGNhbGxiYWNrKSB7XG4gIGhhbW1lci5vZmYoJ2hhbW1lci5pbnB1dCcsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG59O1xuXG4vKipcbiAqIFVucmVnaXN0ZXIgYSByZWxlYXNlIGV2ZW50LCB0YWtpbmcgcGxhY2UgYmVmb3JlIGEgZ2VzdHVyZVxuICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICovXG5leHBvcnRzLm9mZlJlbGVhc2UgPSBleHBvcnRzLm9mZlRvdWNoO1xuIiwiLy8gT25seSBsb2FkIGhhbW1lci5qcyB3aGVuIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudFxuLy8gKGxvYWRpbmcgaGFtbWVyLmpzIGluIGEgbm9kZS5qcyBlbnZpcm9ubWVudCBnaXZlcyBlcnJvcnMpXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIHByb3BhZ2F0aW5nID0gcmVxdWlyZSgncHJvcGFnYXRpbmctaGFtbWVyanMnKTtcbiAgdmFyIEhhbW1lciA9IHdpbmRvd1snSGFtbWVyJ10gfHwgcmVxdWlyZSgnaGFtbWVyanMnKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9wYWdhdGluZyhIYW1tZXIsIHtcbiAgICBwcmV2ZW50RGVmYXVsdDogJ21vdXNlJ1xuICB9KTtcbn1cbmVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBFcnJvcignaGFtbWVyLmpzIGlzIG9ubHkgYXZhaWxhYmxlIGluIGEgYnJvd3Nlciwgbm90IGluIG5vZGUuanMuJyk7XG4gIH1cbn1cbiIsIi8vIGZpcnN0IGNoZWNrIGlmIG1vbWVudC5qcyBpcyBhbHJlYWR5IGxvYWRlZCBpbiB0aGUgYnJvd3NlciB3aW5kb3csIGlmIHNvLFxuLy8gdXNlIHRoaXMgaW5zdGFuY2UuIEVsc2UsIGxvYWQgdmlhIGNvbW1vbmpzLlxubW9kdWxlLmV4cG9ydHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpICYmIHdpbmRvd1snbW9tZW50J10gfHwgcmVxdWlyZSgnbW9tZW50Jyk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcm5nO1xuXG52YXIgZ2xvYmFsVmFyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IG51bGw7XG5cbmlmIChnbG9iYWxWYXIgJiYgZ2xvYmFsVmFyLmNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIC8vIFdIQVRXRyBjcnlwdG8tYmFzZWQgUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICAvLyBNb2RlcmF0ZWx5IGZhc3QsIGhpZ2ggcXVhbGl0eVxuICB2YXIgX3JuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBfcm5nID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoX3JuZHM4KTtcbiAgICByZXR1cm4gX3JuZHM4O1xuICB9O1xufVxuXG5pZiAoIV9ybmcpIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgX3JuZHMgPSBuZXcgQXJyYXkoMTYpO1xuICBfcm5nID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBfcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JuZHM7XG4gIH07XG59XG5cbi8vICAgICB1dWlkLmpzXG4vL1xuLy8gICAgIENvcHlyaWdodCAoYykgMjAxMC0yMDEyIFJvYmVydCBLaWVmZmVyXG4vLyAgICAgTUlUIExpY2Vuc2UgLSBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBXZSBmZWF0dXJlXG4vLyBkZXRlY3QgdG8gZGV0ZXJtaW5lIHRoZSBiZXN0IFJORyBzb3VyY2UsIG5vcm1hbGl6aW5nIHRvIGEgZnVuY3Rpb24gdGhhdFxuLy8gcmV0dXJucyAxMjgtYml0cyBvZiByYW5kb21uZXNzLCBzaW5jZSB0aGF0J3Mgd2hhdCdzIHVzdWFsbHkgcmVxdWlyZWRcblxuLy92YXIgX3JuZyA9IHJlcXVpcmUoJy4vcm5nJyk7XG5cbi8vIE1hcHMgZm9yIG51bWJlciA8LT4gaGV4IHN0cmluZyBjb252ZXJzaW9uXG52YXIgX2J5dGVUb0hleCA9IFtdO1xudmFyIF9oZXhUb0J5dGUgPSB7fTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgX2J5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gIF9oZXhUb0J5dGVbX2J5dGVUb0hleFtpXV0gPSBpO1xufVxuXG4vLyAqKmBwYXJzZSgpYCAtIFBhcnNlIGEgVVVJRCBpbnRvIGl0J3MgY29tcG9uZW50IGJ5dGVzKipcbmZ1bmN0aW9uIHBhcnNlKHMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwLFxuICAgICAgaWkgPSAwO1xuXG4gIGJ1ZiA9IGJ1ZiB8fCBbXTtcbiAgcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1swLTlhLWZdezJ9L2csIGZ1bmN0aW9uIChvY3QpIHtcbiAgICBpZiAoaWkgPCAxNikge1xuICAgICAgLy8gRG9uJ3Qgb3ZlcmZsb3chXG4gICAgICBidWZbaSArIGlpKytdID0gX2hleFRvQnl0ZVtvY3RdO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gWmVybyBvdXQgcmVtYWluaW5nIGJ5dGVzIGlmIHN0cmluZyB3YXMgc2hvcnRcbiAgd2hpbGUgKGlpIDwgMTYpIHtcbiAgICBidWZbaSArIGlpKytdID0gMDtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59XG5cbi8vICoqYHVucGFyc2UoKWAgLSBDb252ZXJ0IFVVSUQgYnl0ZSBhcnJheSAoYWxhIHBhcnNlKCkpIGludG8gYSBzdHJpbmcqKlxuZnVuY3Rpb24gdW5wYXJzZShidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwLFxuICAgICAgYnRoID0gX2J5dGVUb0hleDtcbiAgcmV0dXJuIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG59XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxuLy8gcmFuZG9tICMncyB3ZSBuZWVkIHRvIGluaXQgbm9kZSBhbmQgY2xvY2tzZXFcbnZhciBfc2VlZEJ5dGVzID0gX3JuZygpO1xuXG4vLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbnZhciBfbm9kZUlkID0gW19zZWVkQnl0ZXNbMF0gfCAweDAxLCBfc2VlZEJ5dGVzWzFdLCBfc2VlZEJ5dGVzWzJdLCBfc2VlZEJ5dGVzWzNdLCBfc2VlZEJ5dGVzWzRdLCBfc2VlZEJ5dGVzWzVdXTtcblxuLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbnZhciBfY2xvY2tzZXEgPSAoX3NlZWRCeXRlc1s2XSA8PCA4IHwgX3NlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG5cbi8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxudmFyIF9sYXN0TVNlY3MgPSAwLFxuICAgIF9sYXN0TlNlY3MgPSAwO1xuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTtcblxuICAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgdmFyIGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDtcblxuICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH1cblxuICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9XG5cbiAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3V1aWQudjEoKTogQ2FuXFwndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWMnKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgLy8gYHRpbWVfbG93YFxuICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gIC8vIGB0aW1lX21pZGBcbiAgdmFyIHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAvLyBgbm9kZWBcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyBuKyspIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogdW5wYXJzZShiKTtcbn1cblxuLy8gKipgdjQoKWAgLSBHZW5lcmF0ZSByYW5kb20gVVVJRCoqXG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIC8vIERlcHJlY2F0ZWQgLSAnZm9ybWF0JyBhcmd1bWVudCwgYXMgc3VwcG9ydGVkIGluIHYxLjJcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IF9ybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyBpaSsrKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgdW5wYXJzZShybmRzKTtcbn1cblxuLy8gRXhwb3J0IHB1YmxpYyBBUElcbnZhciB1dWlkID0gdjQ7XG51dWlkLnYxID0gdjE7XG51dWlkLnY0ID0gdjQ7XG51dWlkLnBhcnNlID0gcGFyc2U7XG51dWlkLnVucGFyc2UgPSB1bnBhcnNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV1aWQ7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk5VmMyVnljeTlCWTI5emRHRXZSR1YyWld4dmNHMWxiblF2YldGd2MzUnZjbmt2YzNSdmNua3RkRzl2YkhNdmJtOWtaVjl0YjJSMWJHVnpMM1pwY3k5c2FXSXZiVzlrZFd4bEwzVjFhV1F1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN08wRkJRVUVzU1VGQlNTeEpRVUZKTEVOQlFVTTdPMEZCUlZRc1NVRkJTU3hUUVVGVExFZEJRVWNzVDBGQlR5eE5RVUZOTEV0QlFVc3NWMEZCVnl4SFFVTjJReXhOUVVGTkxFZEJRMDRzVDBGQlR5eE5RVUZOTEV0QlFVc3NWMEZCVnl4SFFVRkhMRTFCUVUwc1IwRkJSeXhKUVVGSkxFTkJRVU03TzBGQlJYQkVMRWxCUVVrc1UwRkJVeXhKUVVGSkxGTkJRVk1zUTBGQlF5eE5RVUZOTEVsQlFVa3NUVUZCVFN4RFFVRkRMR1ZCUVdVc1JVRkJSVHM3TzBGQlJ6TkVMRTFCUVVrc1RVRkJUU3hIUVVGSExFbEJRVWtzVlVGQlZTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRPMEZCUTJoRExFMUJRVWtzUjBGQlJ5eFRRVUZUTEZOQlFWTXNSMEZCUnp0QlFVTXhRaXhWUVVGTkxFTkJRVU1zWlVGQlpTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMEZCUXk5Q0xGZEJRVThzVFVGQlRTeERRVUZETzBkQlEyWXNRMEZCUXp0RFFVTklPenRCUVVWRUxFbEJRVWtzUTBGQlF5eEpRVUZKTEVWQlFVVTdPenM3TzBGQlMxUXNUVUZCU1N4TFFVRkxMRWRCUVVjc1NVRkJTU3hMUVVGTExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTTdRVUZETVVJc1RVRkJTU3hIUVVGSExGbEJRVms3UVVGRGFrSXNVMEZCU3l4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4RlFVRkZMRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3UVVGRE9VSXNWVUZCU1N4RFFVRkRMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVUVzUzBGQlRTeERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhOUVVGTkxFVkJRVVVzUjBGQlJ5eFhRVUZYTEVOQlFVTTdRVUZEZEVRc1YwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVUVzU1VGQlN5eERRVUZETEVOQlFVRXNRVUZCUXl4SFFVRkhMRWxCUVVrc1EwRkJRenRMUVVNelF6czdRVUZGUkN4WFFVRlBMRXRCUVVzc1EwRkJRenRIUVVOa0xFTkJRVU03UTBGRFNEczdPenM3T3pzN096czdPenM3UVVGalJDeEpRVUZKTEZWQlFWVXNSMEZCUnl4RlFVRkZMRU5CUVVNN1FVRkRjRUlzU1VGQlNTeFZRVUZWTEVkQlFVY3NSVUZCUlN4RFFVRkRPMEZCUTNCQ0xFdEJRVXNzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVTdRVUZETlVJc1dVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRXRCUVVzc1EwRkJRU3hEUVVGRkxGRkJRVkVzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03UVVGRGJrUXNXVUZCVlN4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0RFFVTXZRanM3TzBGQlIwUXNVMEZCVXl4TFFVRkxMRU5CUVVNc1EwRkJReXhGUVVGRkxFZEJRVWNzUlVGQlJTeE5RVUZOTEVWQlFVVTdRVUZETjBJc1RVRkJTU3hEUVVGRExFZEJRVWNzUVVGQlF5eEhRVUZITEVsQlFVa3NUVUZCVFN4SlFVRkxMRU5CUVVNN1RVRkJSU3hGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZET3p0QlFVVnlReXhMUVVGSExFZEJRVWNzUjBGQlJ5eEpRVUZKTEVWQlFVVXNRMEZCUXp0QlFVTm9RaXhIUVVGRExFTkJRVU1zVjBGQlZ5eEZRVUZGTEVOQlFVTXNUMEZCVHl4RFFVRkRMR05CUVdNc1JVRkJSU3hWUVVGVkxFZEJRVWNzUlVGQlJUdEJRVU55UkN4UlFVRkpMRVZCUVVVc1IwRkJSeXhGUVVGRkxFVkJRVVU3TzBGQlExZ3NVMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhGUVVGRkxFVkJRVVVzUTBGQlF5eEhRVUZITEZWQlFWVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRenRMUVVOcVF6dEhRVU5HTEVOQlFVTXNRMEZCUXpzN08wRkJSMGdzVTBGQlR5eEZRVUZGTEVkQlFVY3NSVUZCUlN4RlFVRkZPMEZCUTJRc1QwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRenRIUVVOdVFqczdRVUZGUkN4VFFVRlBMRWRCUVVjc1EwRkJRenREUVVOYU96czdRVUZIUkN4VFFVRlRMRTlCUVU4c1EwRkJReXhIUVVGSExFVkJRVVVzVFVGQlRTeEZRVUZGTzBGQlF6VkNMRTFCUVVrc1EwRkJReXhIUVVGSExFMUJRVTBzU1VGQlNTeERRVUZETzAxQlFVVXNSMEZCUnl4SFFVRkhMRlZCUVZVc1EwRkJRenRCUVVOMFF5eFRRVUZQTEVkQlFVY3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEhRVU5vUXl4SFFVRkhMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUTI1RExFZEJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGRGJrTXNSMEZCUnl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4SFFVTnVReXhIUVVGSExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRMjVETEVkQlFVY3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEhRVU0zUWl4SFFVRkhMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNSMEZETjBJc1IwRkJSeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1EwRkRia003T3pzN096czdPMEZCVVVRc1NVRkJTU3hWUVVGVkxFZEJRVWNzU1VGQlNTeEZRVUZGTEVOQlFVTTdPenRCUVVkNFFpeEpRVUZKTEU5QlFVOHNSMEZCUnl4RFFVTmFMRlZCUVZVc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eEpRVUZKTEVWQlEzQkNMRlZCUVZVc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlF6RkZMRU5CUVVNN096dEJRVWRHTEVsQlFVa3NVMEZCVXl4SFFVRkhMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVUVzUjBGQlNTeE5RVUZOTEVOQlFVTTdPenRCUVVjNVJDeEpRVUZKTEZWQlFWVXNSMEZCUnl4RFFVRkRPMGxCUVVVc1ZVRkJWU3hIUVVGSExFTkJRVU1zUTBGQlF6czdPMEZCUjI1RExGTkJRVk1zUlVGQlJTeERRVUZETEU5QlFVOHNSVUZCUlN4SFFVRkhMRVZCUVVVc1RVRkJUU3hGUVVGRk8wRkJRMmhETEUxQlFVa3NRMEZCUXl4SFFVRkhMRWRCUVVjc1NVRkJTU3hOUVVGTkxFbEJRVWtzUTBGQlF5eERRVUZETzBGQlF6TkNMRTFCUVVrc1EwRkJReXhIUVVGSExFZEJRVWNzU1VGQlNTeEZRVUZGTEVOQlFVTTdPMEZCUld4Q0xGTkJRVThzUjBGQlJ5eFBRVUZQTEVsQlFVa3NSVUZCUlN4RFFVRkRPenRCUVVWNFFpeE5RVUZKTEZGQlFWRXNSMEZCUnl4UFFVRlBMRU5CUVVNc1VVRkJVU3hMUVVGTExGTkJRVk1zUjBGQlJ5eFBRVUZQTEVOQlFVTXNVVUZCVVN4SFFVRkhMRk5CUVZNc1EwRkJRenM3T3pzN08wRkJUVGRGTEUxQlFVa3NTMEZCU3l4SFFVRkhMRTlCUVU4c1EwRkJReXhMUVVGTExFdEJRVXNzVTBGQlV5eEhRVUZITEU5QlFVOHNRMEZCUXl4TFFVRkxMRWRCUVVjc1NVRkJTU3hKUVVGSkxFVkJRVVVzUTBGQlF5eFBRVUZQTEVWQlFVVXNRMEZCUXpzN096dEJRVWt2UlN4TlFVRkpMRXRCUVVzc1IwRkJSeXhQUVVGUExFTkJRVU1zUzBGQlN5eExRVUZMTEZOQlFWTXNSMEZCUnl4UFFVRlBMRU5CUVVNc1MwRkJTeXhIUVVGSExGVkJRVlVzUjBGQlJ5eERRVUZETEVOQlFVTTdPenRCUVVkNlJTeE5RVUZKTEVWQlFVVXNSMEZCUnl4QlFVRkRMRXRCUVVzc1IwRkJSeXhWUVVGVkxFZEJRVWtzUTBGQlF5eExRVUZMTEVkQlFVY3NWVUZCVlN4RFFVRkJMRWRCUVVrc1MwRkJTeXhEUVVGRE96czdRVUZITjBRc1RVRkJTU3hGUVVGRkxFZEJRVWNzUTBGQlF5eEpRVUZKTEU5QlFVOHNRMEZCUXl4UlFVRlJMRXRCUVVzc1UwRkJVeXhGUVVGRk8wRkJRelZETEZsQlFWRXNSMEZCUnl4UlFVRlJMRWRCUVVjc1EwRkJReXhIUVVGSExFMUJRVTBzUTBGQlF6dEhRVU5zUXpzN096dEJRVWxFTEUxQlFVa3NRMEZCUXl4RlFVRkZMRWRCUVVjc1EwRkJReXhKUVVGSkxFdEJRVXNzUjBGQlJ5eFZRVUZWTEVOQlFVRXNTVUZCU3l4UFFVRlBMRU5CUVVNc1MwRkJTeXhMUVVGTExGTkJRVk1zUlVGQlJUdEJRVU5xUlN4VFFVRkxMRWRCUVVjc1EwRkJReXhEUVVGRE8wZEJRMWc3T3p0QlFVZEVMRTFCUVVrc1MwRkJTeXhKUVVGSkxFdEJRVXNzUlVGQlJUdEJRVU5zUWl4VlFVRk5MRWxCUVVrc1MwRkJTeXhEUVVGRExHdEVRVUZyUkN4RFFVRkRMRU5CUVVNN1IwRkRja1U3TzBGQlJVUXNXVUZCVlN4SFFVRkhMRXRCUVVzc1EwRkJRenRCUVVOdVFpeFpRVUZWTEVkQlFVY3NTMEZCU3l4RFFVRkRPMEZCUTI1Q0xGZEJRVk1zUjBGQlJ5eFJRVUZSTEVOQlFVTTdPenRCUVVkeVFpeFBRVUZMTEVsQlFVa3NZMEZCWXl4RFFVRkRPenM3UVVGSGVFSXNUVUZCU1N4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFdEJRVXNzUjBGQlJ5eFRRVUZUTEVOQlFVRXNSMEZCU1N4TFFVRkxMRWRCUVVjc1MwRkJTeXhEUVVGQkxFZEJRVWtzVjBGQlZ5eERRVUZETzBGQlF6ZEVMRWRCUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVWQlFVVXNTMEZCU3l4RlFVRkZMRWRCUVVjc1NVRkJTU3hEUVVGRE8wRkJRekZDTEVkQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFVkJRVVVzUzBGQlN5eEZRVUZGTEVkQlFVY3NTVUZCU1N4RFFVRkRPMEZCUXpGQ0xFZEJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRVZCUVVVc1MwRkJTeXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETzBGQlEzcENMRWRCUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4SlFVRkpMRU5CUVVNN096dEJRVWR1UWl4TlFVRkpMRWRCUVVjc1IwRkJSeXhCUVVGRExFdEJRVXNzUjBGQlJ5eFhRVUZYTEVkQlFVY3NTMEZCU3l4SFFVRkpMRk5CUVZNc1EwRkJRenRCUVVOd1JDeEhRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFdEJRVXNzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXp0QlFVTXhRaXhIUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1NVRkJTU3hEUVVGRE96czdRVUZIY0VJc1IwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4TFFVRkxMRVZCUVVVc1IwRkJSeXhIUVVGSExFZEJRVWNzU1VGQlNTeERRVUZETzBGQlEycERMRWRCUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NTMEZCU3l4RlFVRkZMRWRCUVVjc1NVRkJTU3hEUVVGRE96czdRVUZITTBJc1IwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NVVUZCVVN4TFFVRkxMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU03T3p0QlFVY3ZRaXhIUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4UlFVRlJMRWRCUVVjc1NVRkJTU3hEUVVGRE96czdRVUZIZWtJc1RVRkJTU3hKUVVGSkxFZEJRVWNzVDBGQlR5eERRVUZETEVsQlFVa3NTVUZCU1N4UFFVRlBMRU5CUVVNN1FVRkRia01zVDBGQlN5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlR0QlFVTXhRaXhMUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEhRVU53UWpzN1FVRkZSQ3hUUVVGUExFZEJRVWNzUjBGQlJ5eEhRVUZITEVkQlFVY3NUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wTkJReTlDT3pzN096dEJRVXRFTEZOQlFWTXNSVUZCUlN4RFFVRkRMRTlCUVU4c1JVRkJSU3hIUVVGSExFVkJRVVVzVFVGQlRTeEZRVUZGT3p0QlFVVm9ReXhOUVVGSkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVsQlFVa3NUVUZCVFN4SlFVRkpMRU5CUVVNc1EwRkJRenM3UVVGRk0wSXNUVUZCU1N4UFFVRlBMRTlCUVU4c1FVRkJReXhKUVVGSkxGRkJRVkVzUlVGQlJUdEJRVU12UWl4UFFVRkhMRWRCUVVjc1QwRkJUeXhKUVVGSkxGRkJRVkVzUjBGQlJ5eEpRVUZKTEV0QlFVc3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU03UVVGRGFrUXNWMEZCVHl4SFFVRkhMRWxCUVVrc1EwRkJRenRIUVVOb1FqdEJRVU5FTEZOQlFVOHNSMEZCUnl4UFFVRlBMRWxCUVVrc1JVRkJSU3hEUVVGRE96dEJRVVY0UWl4TlFVRkpMRWxCUVVrc1IwRkJSeXhQUVVGUExFTkJRVU1zVFVGQlRTeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWRCUVVjc1NVRkJTU3hKUVVGSkxFTkJRVUVzUlVGQlJ5eERRVUZET3pzN1FVRkhja1FzVFVGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVsQlFVa3NSMEZCU1N4SlFVRkpMRU5CUVVNN1FVRkRiRU1zVFVGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVsQlFVa3NSMEZCU1N4SlFVRkpMRU5CUVVNN096dEJRVWRzUXl4TlFVRkpMRWRCUVVjc1JVRkJSVHRCUVVOUUxGTkJRVXNzU1VGQlNTeEZRVUZGTEVkQlFVY3NRMEZCUXl4RlFVRkZMRVZCUVVVc1IwRkJSeXhGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEVWQlFVVTdRVUZET1VJc1UwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU03UzBGRGVFSTdSMEZEUmpzN1FVRkZSQ3hUUVVGUExFZEJRVWNzU1VGQlNTeFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1EwRkROMEk3T3p0QlFVZEVMRWxCUVVrc1NVRkJTU3hIUVVGSExFVkJRVVVzUTBGQlF6dEJRVU5rTEVsQlFVa3NRMEZCUXl4RlFVRkZMRWRCUVVjc1JVRkJSU3hEUVVGRE8wRkJRMklzU1VGQlNTeERRVUZETEVWQlFVVXNSMEZCUnl4RlFVRkZMRU5CUVVNN1FVRkRZaXhKUVVGSkxFTkJRVU1zUzBGQlN5eEhRVUZITEV0QlFVc3NRMEZCUXp0QlFVTnVRaXhKUVVGSkxFTkJRVU1zVDBGQlR5eEhRVUZITEU5QlFVOHNRMEZCUXpzN1FVRkZka0lzVFVGQlRTeERRVUZETEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVNaUxDSm1hV3hsSWpvaVoyVnVaWEpoZEdWa0xtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJblpoY2lCZmNtNW5PMXh1WEc1MllYSWdaMnh2WW1Gc1ZtRnlJRDBnZEhsd1pXOW1JSGRwYm1SdmR5QWhQVDBnSjNWdVpHVm1hVzVsWkNkY2JpQWdJQ0EvSUhkcGJtUnZkMXh1SUNBZ0lEb2dkSGx3Wlc5bUlHZHNiMkpoYkNBaFBUMGdKM1Z1WkdWbWFXNWxaQ2NnUHlCbmJHOWlZV3dnT2lCdWRXeHNPMXh1WEc1cFppQW9aMnh2WW1Gc1ZtRnlJQ1ltSUdkc2IySmhiRlpoY2k1amNubHdkRzhnSmlZZ1kzSjVjSFJ2TG1kbGRGSmhibVJ2YlZaaGJIVmxjeWtnZTF4dUlDQXZMeUJYU0VGVVYwY2dZM0o1Y0hSdkxXSmhjMlZrSUZKT1J5QXRJR2gwZEhBNkx5OTNhV3RwTG5kb1lYUjNaeTV2Y21jdmQybHJhUzlEY25sd2RHOWNiaUFnTHk4Z1RXOWtaWEpoZEdWc2VTQm1ZWE4wTENCb2FXZG9JSEYxWVd4cGRIbGNiaUFnZG1GeUlGOXlibVJ6T0NBOUlHNWxkeUJWYVc1ME9FRnljbUY1S0RFMktUdGNiaUFnWDNKdVp5QTlJR1oxYm1OMGFXOXVJSGRvWVhSM1oxSk9SeWdwSUh0Y2JpQWdJQ0JqY25sd2RHOHVaMlYwVW1GdVpHOXRWbUZzZFdWektGOXlibVJ6T0NrN1hHNGdJQ0FnY21WMGRYSnVJRjl5Ym1Sek9EdGNiaUFnZlR0Y2JuMWNibHh1YVdZZ0tDRmZjbTVuS1NCN1hHNGdJQzh2SUUxaGRHZ3VjbUZ1Wkc5dEtDa3RZbUZ6WldRZ0tGSk9SeWxjYmlBZ0x5OWNiaUFnTHk4Z1NXWWdZV3hzSUdWc2MyVWdabUZwYkhNc0lIVnpaU0JOWVhSb0xuSmhibVJ2YlNncExpQWdTWFFuY3lCbVlYTjBMQ0JpZFhRZ2FYTWdiMllnZFc1emNHVmphV1pwWldSY2JpQWdMeThnY1hWaGJHbDBlUzVjYmlBZ2RtRnlJRjl5Ym1SeklEMGdibVYzSUVGeWNtRjVLREUyS1R0Y2JpQWdYM0p1WnlBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTUN3Z2Nqc2dhU0E4SURFMk95QnBLeXNwSUh0Y2JpQWdJQ0FnSUdsbUlDZ29hU0FtSURCNE1ETXBJRDA5UFNBd0tTQnlJRDBnVFdGMGFDNXlZVzVrYjIwb0tTQXFJREI0TVRBd01EQXdNREF3TzF4dUlDQWdJQ0FnWDNKdVpITmJhVjBnUFNCeUlENCtQaUFvS0drZ0ppQXdlREF6S1NBOFBDQXpLU0FtSURCNFptWTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2NtVjBkWEp1SUY5eWJtUnpPMXh1SUNCOU8xeHVmVnh1WEc0dkx5QWdJQ0FnZFhWcFpDNXFjMXh1THk5Y2JpOHZJQ0FnSUNCRGIzQjVjbWxuYUhRZ0tHTXBJREl3TVRBdE1qQXhNaUJTYjJKbGNuUWdTMmxsWm1abGNseHVMeThnSUNBZ0lFMUpWQ0JNYVdObGJuTmxJQzBnYUhSMGNEb3ZMMjl3Wlc1emIzVnlZMlV1YjNKbkwyeHBZMlZ1YzJWekwyMXBkQzFzYVdObGJuTmxMbkJvY0Z4dVhHNHZMeUJWYm1seGRXVWdTVVFnWTNKbFlYUnBiMjRnY21WeGRXbHlaWE1nWVNCb2FXZG9JSEYxWVd4cGRIa2djbUZ1Wkc5dElDTWdaMlZ1WlhKaGRHOXlMaUFnVjJVZ1ptVmhkSFZ5WlZ4dUx5OGdaR1YwWldOMElIUnZJR1JsZEdWeWJXbHVaU0IwYUdVZ1ltVnpkQ0JTVGtjZ2MyOTFjbU5sTENCdWIzSnRZV3hwZW1sdVp5QjBieUJoSUdaMWJtTjBhVzl1SUhSb1lYUmNiaTh2SUhKbGRIVnlibk1nTVRJNExXSnBkSE1nYjJZZ2NtRnVaRzl0Ym1WemN5d2djMmx1WTJVZ2RHaGhkQ2R6SUhkb1lYUW5jeUIxYzNWaGJHeDVJSEpsY1hWcGNtVmtYRzVjYmk4dmRtRnlJRjl5Ym1jZ1BTQnlaWEYxYVhKbEtDY3VMM0p1WnljcE8xeHVYRzR2THlCTllYQnpJR1p2Y2lCdWRXMWlaWElnUEMwK0lHaGxlQ0J6ZEhKcGJtY2dZMjl1ZG1WeWMybHZibHh1ZG1GeUlGOWllWFJsVkc5SVpYZ2dQU0JiWFR0Y2JuWmhjaUJmYUdWNFZHOUNlWFJsSUQwZ2UzMDdYRzVtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SURJMU5qc2dhU3NyS1NCN1hHNGdJRjlpZVhSbFZHOUlaWGhiYVYwZ1BTQW9hU0FySURCNE1UQXdLUzUwYjFOMGNtbHVaeWd4TmlrdWMzVmljM1J5S0RFcE8xeHVJQ0JmYUdWNFZHOUNlWFJsVzE5aWVYUmxWRzlJWlhoYmFWMWRJRDBnYVR0Y2JuMWNibHh1THk4Z0tpcGdjR0Z5YzJVb0tXQWdMU0JRWVhKelpTQmhJRlZWU1VRZ2FXNTBieUJwZENkeklHTnZiWEJ2Ym1WdWRDQmllWFJsY3lvcVhHNW1kVzVqZEdsdmJpQndZWEp6WlNoekxDQmlkV1lzSUc5bVpuTmxkQ2tnZTF4dUlDQjJZWElnYVNBOUlDaGlkV1lnSmlZZ2IyWm1jMlYwS1NCOGZDQXdMQ0JwYVNBOUlEQTdYRzVjYmlBZ1luVm1JRDBnWW5WbUlIeDhJRnRkTzF4dUlDQnpMblJ2VEc5M1pYSkRZWE5sS0NrdWNtVndiR0ZqWlNndld6QXRPV0V0WmwxN01uMHZaeXdnWm5WdVkzUnBiMjRnS0c5amRDa2dlMXh1SUNBZ0lHbG1JQ2hwYVNBOElERTJLU0I3SUM4dklFUnZiaWQwSUc5MlpYSm1iRzkzSVZ4dUlDQWdJQ0FnWW5WbVcya2dLeUJwYVNzclhTQTlJRjlvWlhoVWIwSjVkR1ZiYjJOMFhUdGNiaUFnSUNCOVhHNGdJSDBwTzF4dVhHNGdJQzh2SUZwbGNtOGdiM1YwSUhKbGJXRnBibWx1WnlCaWVYUmxjeUJwWmlCemRISnBibWNnZDJGeklITm9iM0owWEc0Z0lIZG9hV3hsSUNocGFTQThJREUyS1NCN1hHNGdJQ0FnWW5WbVcya2dLeUJwYVNzclhTQTlJREE3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnWW5WbU8xeHVmVnh1WEc0dkx5QXFLbUIxYm5CaGNuTmxLQ2xnSUMwZ1EyOXVkbVZ5ZENCVlZVbEVJR0o1ZEdVZ1lYSnlZWGtnS0dGc1lTQndZWEp6WlNncEtTQnBiblJ2SUdFZ2MzUnlhVzVuS2lwY2JtWjFibU4wYVc5dUlIVnVjR0Z5YzJVb1luVm1MQ0J2Wm1aelpYUXBJSHRjYmlBZ2RtRnlJR2tnUFNCdlptWnpaWFFnZkh3Z01Dd2dZblJvSUQwZ1gySjVkR1ZVYjBobGVEdGNiaUFnY21WMGRYSnVJR0owYUZ0aWRXWmJhU3NyWFYwZ0t5QmlkR2hiWW5WbVcya3JLMTFkSUN0Y2JpQWdJQ0FnSUdKMGFGdGlkV1piYVNzclhWMGdLeUJpZEdoYlluVm1XMmtySzExZElDc2dKeTBuSUN0Y2JpQWdJQ0FnSUdKMGFGdGlkV1piYVNzclhWMGdLeUJpZEdoYlluVm1XMmtySzExZElDc2dKeTBuSUN0Y2JpQWdJQ0FnSUdKMGFGdGlkV1piYVNzclhWMGdLeUJpZEdoYlluVm1XMmtySzExZElDc2dKeTBuSUN0Y2JpQWdJQ0FnSUdKMGFGdGlkV1piYVNzclhWMGdLeUJpZEdoYlluVm1XMmtySzExZElDc2dKeTBuSUN0Y2JpQWdJQ0FnSUdKMGFGdGlkV1piYVNzclhWMGdLeUJpZEdoYlluVm1XMmtySzExZElDdGNiaUFnSUNBZ0lHSjBhRnRpZFdaYmFTc3JYVjBnS3lCaWRHaGJZblZtVzJrcksxMWRJQ3RjYmlBZ0lDQWdJR0owYUZ0aWRXWmJhU3NyWFYwZ0t5QmlkR2hiWW5WbVcya3JLMTFkTzF4dWZWeHVYRzR2THlBcUttQjJNU2dwWUNBdElFZGxibVZ5WVhSbElIUnBiV1V0WW1GelpXUWdWVlZKUkNvcVhHNHZMMXh1THk4Z1NXNXpjR2x5WldRZ1lua2dhSFIwY0hNNkx5OW5hWFJvZFdJdVkyOXRMMHhwYjNOTEwxVlZTVVF1YW5OY2JpOHZJR0Z1WkNCb2RIUndPaTh2Wkc5amN5NXdlWFJvYjI0dWIzSm5MMnhwWW5KaGNua3ZkWFZwWkM1b2RHMXNYRzVjYmk4dklISmhibVJ2YlNBakozTWdkMlVnYm1WbFpDQjBieUJwYm1sMElHNXZaR1VnWVc1a0lHTnNiMk5yYzJWeFhHNTJZWElnWDNObFpXUkNlWFJsY3lBOUlGOXlibWNvS1R0Y2JseHVMeThnVUdWeUlEUXVOU3dnWTNKbFlYUmxJR0Z1WkNBME9DMWlhWFFnYm05a1pTQnBaQ3dnS0RRM0lISmhibVJ2YlNCaWFYUnpJQ3NnYlhWc2RHbGpZWE4wSUdKcGRDQTlJREVwWEc1MllYSWdYMjV2WkdWSlpDQTlJRnRjYmlBZ1gzTmxaV1JDZVhSbGMxc3dYU0I4SURCNE1ERXNYRzRnSUY5elpXVmtRbmwwWlhOYk1WMHNJRjl6WldWa1FubDBaWE5iTWwwc0lGOXpaV1ZrUW5sMFpYTmJNMTBzSUY5elpXVmtRbmwwWlhOYk5GMHNJRjl6WldWa1FubDBaWE5iTlYxY2JsMDdYRzVjYmk4dklGQmxjaUEwTGpJdU1pd2djbUZ1Wkc5dGFYcGxJQ2d4TkNCaWFYUXBJR05zYjJOcmMyVnhYRzUyWVhJZ1gyTnNiMk5yYzJWeElEMGdLRjl6WldWa1FubDBaWE5iTmwwZ1BEd2dPQ0I4SUY5elpXVmtRbmwwWlhOYk4xMHBJQ1lnTUhnelptWm1PMXh1WEc0dkx5QlFjbVYyYVc5MWN5QjFkV2xrSUdOeVpXRjBhVzl1SUhScGJXVmNiblpoY2lCZmJHRnpkRTFUWldOeklEMGdNQ3dnWDJ4aGMzUk9VMlZqY3lBOUlEQTdYRzVjYmk4dklGTmxaU0JvZEhSd2N6b3ZMMmRwZEdoMVlpNWpiMjB2WW5KdmIyWmhMMjV2WkdVdGRYVnBaQ0JtYjNJZ1FWQkpJR1JsZEdGcGJITmNibVoxYm1OMGFXOXVJSFl4S0c5d2RHbHZibk1zSUdKMVppd2diMlptYzJWMEtTQjdYRzRnSUhaaGNpQnBJRDBnWW5WbUlDWW1JRzltWm5ObGRDQjhmQ0F3TzF4dUlDQjJZWElnWWlBOUlHSjFaaUI4ZkNCYlhUdGNibHh1SUNCdmNIUnBiMjV6SUQwZ2IzQjBhVzl1Y3lCOGZDQjdmVHRjYmx4dUlDQjJZWElnWTJ4dlkydHpaWEVnUFNCdmNIUnBiMjV6TG1Oc2IyTnJjMlZ4SUNFOVBTQjFibVJsWm1sdVpXUWdQeUJ2Y0hScGIyNXpMbU5zYjJOcmMyVnhJRG9nWDJOc2IyTnJjMlZ4TzF4dVhHNGdJQzh2SUZWVlNVUWdkR2x0WlhOMFlXMXdjeUJoY21VZ01UQXdJRzVoYm04dGMyVmpiMjVrSUhWdWFYUnpJSE5wYm1ObElIUm9aU0JIY21WbmIzSnBZVzRnWlhCdlkyZ3NYRzRnSUM4dklDZ3hOVGd5TFRFd0xURTFJREF3T2pBd0tTNGdJRXBUVG5WdFltVnljeUJoY21WdUozUWdjSEpsWTJselpTQmxibTkxWjJnZ1ptOXlJSFJvYVhNc0lITnZYRzRnSUM4dklIUnBiV1VnYVhNZ2FHRnVaR3hsWkNCcGJuUmxjbTVoYkd4NUlHRnpJQ2R0YzJWamN5Y2dLR2x1ZEdWblpYSWdiV2xzYkdselpXTnZibVJ6S1NCaGJtUWdKMjV6WldOekoxeHVJQ0F2THlBb01UQXdMVzVoYm05elpXTnZibVJ6SUc5bVpuTmxkQ0JtY205dElHMXpaV056S1NCemFXNWpaU0IxYm1sNElHVndiMk5vTENBeE9UY3dMVEF4TFRBeElEQXdPakF3TGx4dUlDQjJZWElnYlhObFkzTWdQU0J2Y0hScGIyNXpMbTF6WldOeklDRTlQU0IxYm1SbFptbHVaV1FnUHlCdmNIUnBiMjV6TG0xelpXTnpJRG9nYm1WM0lFUmhkR1VvS1M1blpYUlVhVzFsS0NrN1hHNWNiaUFnTHk4Z1VHVnlJRFF1TWk0eExqSXNJSFZ6WlNCamIzVnVkQ0J2WmlCMWRXbGtKM01nWjJWdVpYSmhkR1ZrSUdSMWNtbHVaeUIwYUdVZ1kzVnljbVZ1ZENCamJHOWphMXh1SUNBdkx5QmplV05zWlNCMGJ5QnphVzExYkdGMFpTQm9hV2RvWlhJZ2NtVnpiMngxZEdsdmJpQmpiRzlqYTF4dUlDQjJZWElnYm5ObFkzTWdQU0J2Y0hScGIyNXpMbTV6WldOeklDRTlQU0IxYm1SbFptbHVaV1FnUHlCdmNIUnBiMjV6TG01elpXTnpJRG9nWDJ4aGMzUk9VMlZqY3lBcklERTdYRzVjYmlBZ0x5OGdWR2x0WlNCemFXNWpaU0JzWVhOMElIVjFhV1FnWTNKbFlYUnBiMjRnS0dsdUlHMXpaV056S1Z4dUlDQjJZWElnWkhRZ1BTQW9iWE5sWTNNZ0xTQmZiR0Z6ZEUxVFpXTnpLU0FySUNodWMyVmpjeUF0SUY5c1lYTjBUbE5sWTNNcElDOGdNVEF3TURBN1hHNWNiaUFnTHk4Z1VHVnlJRFF1TWk0eExqSXNJRUoxYlhBZ1kyeHZZMnR6WlhFZ2IyNGdZMnh2WTJzZ2NtVm5jbVZ6YzJsdmJseHVJQ0JwWmlBb1pIUWdQQ0F3SUNZbUlHOXdkR2x2Ym5NdVkyeHZZMnR6WlhFZ1BUMDlJSFZ1WkdWbWFXNWxaQ2tnZTF4dUlDQWdJR05zYjJOcmMyVnhJRDBnWTJ4dlkydHpaWEVnS3lBeElDWWdNSGd6Wm1abU8xeHVJQ0I5WEc1Y2JpQWdMeThnVW1WelpYUWdibk5sWTNNZ2FXWWdZMnh2WTJzZ2NtVm5jbVZ6YzJWeklDaHVaWGNnWTJ4dlkydHpaWEVwSUc5eUlIZGxKM1psSUcxdmRtVmtJRzl1ZEc4Z1lTQnVaWGRjYmlBZ0x5OGdkR2x0WlNCcGJuUmxjblpoYkZ4dUlDQnBaaUFvS0dSMElEd2dNQ0I4ZkNCdGMyVmpjeUErSUY5c1lYTjBUVk5sWTNNcElDWW1JRzl3ZEdsdmJuTXVibk5sWTNNZ1BUMDlJSFZ1WkdWbWFXNWxaQ2tnZTF4dUlDQWdJRzV6WldOeklEMGdNRHRjYmlBZ2ZWeHVYRzRnSUM4dklGQmxjaUEwTGpJdU1TNHlJRlJvY205M0lHVnljbTl5SUdsbUlIUnZieUJ0WVc1NUlIVjFhV1J6SUdGeVpTQnlaWEYxWlhOMFpXUmNiaUFnYVdZZ0tHNXpaV056SUQ0OUlERXdNREF3S1NCN1hHNGdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2QxZFdsa0xuWXhLQ2s2SUVOaGJseGNKM1FnWTNKbFlYUmxJRzF2Y21VZ2RHaGhiaUF4TUUwZ2RYVnBaSE12YzJWakp5azdYRzRnSUgxY2JseHVJQ0JmYkdGemRFMVRaV056SUQwZ2JYTmxZM003WEc0Z0lGOXNZWE4wVGxObFkzTWdQU0J1YzJWamN6dGNiaUFnWDJOc2IyTnJjMlZ4SUQwZ1kyeHZZMnR6WlhFN1hHNWNiaUFnTHk4Z1VHVnlJRFF1TVM0MElDMGdRMjl1ZG1WeWRDQm1jbTl0SUhWdWFYZ2daWEJ2WTJnZ2RHOGdSM0psWjI5eWFXRnVJR1Z3YjJOb1hHNGdJRzF6WldOeklDczlJREV5TWpFNU1qa3lPREF3TURBd08xeHVYRzRnSUM4dklHQjBhVzFsWDJ4dmQyQmNiaUFnZG1GeUlIUnNJRDBnS0NodGMyVmpjeUFtSURCNFptWm1abVptWmlrZ0tpQXhNREF3TUNBcklHNXpaV056S1NBbElEQjRNVEF3TURBd01EQXdPMXh1SUNCaVcya3JLMTBnUFNCMGJDQStQajRnTWpRZ0ppQXdlR1ptTzF4dUlDQmlXMmtySzEwZ1BTQjBiQ0ErUGo0Z01UWWdKaUF3ZUdabU8xeHVJQ0JpVzJrcksxMGdQU0IwYkNBK1BqNGdPQ0FtSURCNFptWTdYRzRnSUdKYmFTc3JYU0E5SUhSc0lDWWdNSGhtWmp0Y2JseHVJQ0F2THlCZ2RHbHRaVjl0YVdSZ1hHNGdJSFpoY2lCMGJXZ2dQU0FvYlhObFkzTWdMeUF3ZURFd01EQXdNREF3TUNBcUlERXdNREF3S1NBbUlEQjRabVptWm1abVpqdGNiaUFnWWx0cEt5dGRJRDBnZEcxb0lENCtQaUE0SUNZZ01IaG1aanRjYmlBZ1lsdHBLeXRkSUQwZ2RHMW9JQ1lnTUhobVpqdGNibHh1SUNBdkx5QmdkR2x0WlY5b2FXZG9YMkZ1WkY5MlpYSnphVzl1WUZ4dUlDQmlXMmtySzEwZ1BTQjBiV2dnUGo0K0lESTBJQ1lnTUhobUlId2dNSGd4TURzZ0x5OGdhVzVqYkhWa1pTQjJaWEp6YVc5dVhHNGdJR0piYVNzclhTQTlJSFJ0YUNBK1BqNGdNVFlnSmlBd2VHWm1PMXh1WEc0Z0lDOHZJR0JqYkc5amExOXpaWEZmYUdsZllXNWtYM0psYzJWeWRtVmtZQ0FvVUdWeUlEUXVNaTR5SUMwZ2FXNWpiSFZrWlNCMllYSnBZVzUwS1Z4dUlDQmlXMmtySzEwZ1BTQmpiRzlqYTNObGNTQStQajRnT0NCOElEQjRPREE3WEc1Y2JpQWdMeThnWUdOc2IyTnJYM05sY1Y5c2IzZGdYRzRnSUdKYmFTc3JYU0E5SUdOc2IyTnJjMlZ4SUNZZ01IaG1aanRjYmx4dUlDQXZMeUJnYm05a1pXQmNiaUFnZG1GeUlHNXZaR1VnUFNCdmNIUnBiMjV6TG01dlpHVWdmSHdnWDI1dlpHVkpaRHRjYmlBZ1ptOXlJQ2gyWVhJZ2JpQTlJREE3SUc0Z1BDQTJPeUJ1S3lzcElIdGNiaUFnSUNCaVcya2dLeUJ1WFNBOUlHNXZaR1ZiYmwwN1hHNGdJSDFjYmx4dUlDQnlaWFIxY200Z1luVm1JRDhnWW5WbUlEb2dkVzV3WVhKelpTaGlLVHRjYm4xY2JseHVMeThnS2lwZ2RqUW9LV0FnTFNCSFpXNWxjbUYwWlNCeVlXNWtiMjBnVlZWSlJDb3FYRzVjYmk4dklGTmxaU0JvZEhSd2N6b3ZMMmRwZEdoMVlpNWpiMjB2WW5KdmIyWmhMMjV2WkdVdGRYVnBaQ0JtYjNJZ1FWQkpJR1JsZEdGcGJITmNibVoxYm1OMGFXOXVJSFkwS0c5d2RHbHZibk1zSUdKMVppd2diMlptYzJWMEtTQjdYRzRnSUM4dklFUmxjSEpsWTJGMFpXUWdMU0FuWm05eWJXRjBKeUJoY21kMWJXVnVkQ3dnWVhNZ2MzVndjRzl5ZEdWa0lHbHVJSFl4TGpKY2JpQWdkbUZ5SUdrZ1BTQmlkV1lnSmlZZ2IyWm1jMlYwSUh4OElEQTdYRzVjYmlBZ2FXWWdLSFI1Y0dWdlppaHZjSFJwYjI1ektTQTlQU0FuYzNSeWFXNW5KeWtnZTF4dUlDQWdJR0oxWmlBOUlHOXdkR2x2Ym5NZ1BUMGdKMkpwYm1GeWVTY2dQeUJ1WlhjZ1FYSnlZWGtvTVRZcElEb2diblZzYkR0Y2JpQWdJQ0J2Y0hScGIyNXpJRDBnYm5Wc2JEdGNiaUFnZlZ4dUlDQnZjSFJwYjI1eklEMGdiM0IwYVc5dWN5QjhmQ0I3ZlR0Y2JseHVJQ0IyWVhJZ2NtNWtjeUE5SUc5d2RHbHZibk11Y21GdVpHOXRJSHg4SUNodmNIUnBiMjV6TG5KdVp5QjhmQ0JmY201bktTZ3BPMXh1WEc0Z0lDOHZJRkJsY2lBMExqUXNJSE5sZENCaWFYUnpJR1p2Y2lCMlpYSnphVzl1SUdGdVpDQmdZMnh2WTJ0ZmMyVnhYMmhwWDJGdVpGOXlaWE5sY25abFpHQmNiaUFnY201a2MxczJYU0E5SUNoeWJtUnpXelpkSUNZZ01IZ3daaWtnZkNBd2VEUXdPMXh1SUNCeWJtUnpXemhkSUQwZ0tISnVaSE5iT0YwZ0ppQXdlRE5tS1NCOElEQjRPREE3WEc1Y2JpQWdMeThnUTI5d2VTQmllWFJsY3lCMGJ5QmlkV1ptWlhJc0lHbG1JSEJ5YjNacFpHVmtYRzRnSUdsbUlDaGlkV1lwSUh0Y2JpQWdJQ0JtYjNJZ0tIWmhjaUJwYVNBOUlEQTdJR2xwSUR3Z01UWTdJR2xwS3lzcElIdGNiaUFnSUNBZ0lHSjFabHRwSUNzZ2FXbGRJRDBnY201a2MxdHBhVjA3WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnY21WMGRYSnVJR0oxWmlCOGZDQjFibkJoY25ObEtISnVaSE1wTzF4dWZWeHVYRzR2THlCRmVIQnZjblFnY0hWaWJHbGpJRUZRU1Z4dWRtRnlJSFYxYVdRZ1BTQjJORHRjYm5WMWFXUXVkakVnUFNCMk1UdGNiblYxYVdRdWRqUWdQU0IyTkR0Y2JuVjFhV1F1Y0dGeWMyVWdQU0J3WVhKelpUdGNiblYxYVdRdWRXNXdZWEp6WlNBOUlIVnVjR0Z5YzJVN1hHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdkWFZwWkR0Y2JpSmRmUT09IiwidmFyIGtleWNoYXJtID0gcmVxdWlyZSgna2V5Y2hhcm0nKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnZW1pdHRlci1jb21wb25lbnQnKTtcbnZhciBIYW1tZXIgPSByZXF1aXJlKCcuLi9tb2R1bGUvaGFtbWVyJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuLyoqXG4gKiBUdXJuIGFuIGVsZW1lbnQgaW50byBhbiBjbGlja1RvVXNlIGVsZW1lbnQuXG4gKiBXaGVuIG5vdCBhY3RpdmUsIHRoZSBlbGVtZW50IGhhcyBhIHRyYW5zcGFyZW50IG92ZXJsYXkuIFdoZW4gdGhlIG92ZXJsYXkgaXNcbiAqIGNsaWNrZWQsIHRoZSBtb2RlIGlzIGNoYW5nZWQgdG8gYWN0aXZlLlxuICogV2hlbiBhY3RpdmUsIHRoZSBlbGVtZW50IGlzIGRpc3BsYXllZCB3aXRoIGEgYmx1ZSBib3JkZXIgYXJvdW5kIGl0LCBhbmRcbiAqIHRoZSBpbnRlcmFjdGl2ZSBjb250ZW50cyBvZiB0aGUgZWxlbWVudCBjYW4gYmUgdXNlZC4gV2hlbiBjbGlja2VkIG91dHNpZGVcbiAqIHRoZSBlbGVtZW50LCB0aGUgZWxlbWVudHMgbW9kZSBpcyBjaGFuZ2VkIHRvIGluYWN0aXZlLlxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBY3RpdmF0b3IoY29udGFpbmVyKSB7XG4gIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgdGhpcy5kb20gPSB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgfTtcblxuICB0aGlzLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLm92ZXJsYXkuY2xhc3NOYW1lID0gJ3Zpcy1vdmVybGF5JztcblxuICB0aGlzLmRvbS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20ub3ZlcmxheSk7XG5cbiAgdGhpcy5oYW1tZXIgPSBIYW1tZXIodGhpcy5kb20ub3ZlcmxheSk7XG4gIHRoaXMuaGFtbWVyLm9uKCd0YXAnLCB0aGlzLl9vblRhcE92ZXJsYXkuYmluZCh0aGlzKSk7XG5cbiAgLy8gYmxvY2sgYWxsIHRvdWNoIGV2ZW50cyAoZXhjZXB0IHRhcClcbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIGV2ZW50cyA9IFtcbiAgICAndGFwJywgJ2RvdWJsZXRhcCcsICdwcmVzcycsXG4gICAgJ3BpbmNoJyxcbiAgICAncGFuJywgJ3BhbnN0YXJ0JywgJ3Bhbm1vdmUnLCAncGFuZW5kJ1xuICBdO1xuICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBtZS5oYW1tZXIub24oZXZlbnQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGF0dGFjaCBhIGNsaWNrIGV2ZW50IHRvIHRoZSB3aW5kb3csIGluIG9yZGVyIHRvIGRlYWN0aXZhdGUgd2hlbiBjbGlja2luZyBvdXRzaWRlIHRoZSB0aW1lbGluZVxuICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgIHRoaXMub25DbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFfaGFzUGFyZW50KGV2ZW50LnRhcmdldCwgY29udGFpbmVyKSkge1xuICAgICAgICBtZS5kZWFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcbiAgfVxuXG4gIGlmICh0aGlzLmtleWNoYXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmtleWNoYXJtLmRlc3Ryb3koKTtcbiAgfVxuICB0aGlzLmtleWNoYXJtID0ga2V5Y2hhcm0oKTtcblxuICAvLyBrZXljaGFybSBsaXN0ZW5lciBvbmx5IGJvdW5kZWQgd2hlbiBhY3RpdmUpXG4gIHRoaXMuZXNjTGlzdGVuZXIgPSB0aGlzLmRlYWN0aXZhdGUuYmluZCh0aGlzKTtcbn1cblxuLy8gdHVybiBpbnRvIGFuIGV2ZW50IGVtaXR0ZXJcbkVtaXR0ZXIoQWN0aXZhdG9yLnByb3RvdHlwZSk7XG5cbi8vIFRoZSBjdXJyZW50bHkgYWN0aXZlIGFjdGl2YXRvclxuQWN0aXZhdG9yLmN1cnJlbnQgPSBudWxsO1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIGFjdGl2YXRvci4gQ2xlYW5zIHVwIGFsbCBjcmVhdGVkIERPTSBhbmQgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbkFjdGl2YXRvci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5kZWFjdGl2YXRlKCk7XG5cbiAgLy8gcmVtb3ZlIGRvbVxuICB0aGlzLmRvbS5vdmVybGF5LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20ub3ZlcmxheSk7XG5cbiAgLy8gcmVtb3ZlIGdsb2JhbCBldmVudCBsaXN0ZW5lclxuICBpZiAodGhpcy5vbkNsaWNrKSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gIH1cblxuICAvLyBjbGVhbnVwIGhhbW1lciBpbnN0YW5jZXNcbiAgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICB0aGlzLmhhbW1lciA9IG51bGw7XG4gIC8vIEZJWE1FOiBjbGVhbmluZyB1cCBoYW1tZXIgaW5zdGFuY2VzIGRvZXNuJ3Qgd29yayAoVGltZWxpbmUgbm90IHJlbW92ZWQgZnJvbSBtZW1vcnkpXG59O1xuXG4vKipcbiAqIEFjdGl2YXRlIHRoZSBlbGVtZW50XG4gKiBPdmVybGF5IGlzIGhpZGRlbiwgZWxlbWVudCBpcyBkZWNvcmF0ZWQgd2l0aCBhIGJsdWUgc2hhZG93IGJvcmRlclxuICovXG5BY3RpdmF0b3IucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAvLyB3ZSBhbGxvdyBvbmx5IG9uZSBhY3RpdmUgYWN0aXZhdG9yIGF0IGEgdGltZVxuICBpZiAoQWN0aXZhdG9yLmN1cnJlbnQpIHtcbiAgICBBY3RpdmF0b3IuY3VycmVudC5kZWFjdGl2YXRlKCk7XG4gIH1cbiAgQWN0aXZhdG9yLmN1cnJlbnQgPSB0aGlzO1xuXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kb20ub3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5jb250YWluZXIsICd2aXMtYWN0aXZlJyk7XG5cbiAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbiAgdGhpcy5lbWl0KCdhY3RpdmF0ZScpO1xuXG4gIC8vIHVnbHkgaGFjazogYmluZCBFU0MgYWZ0ZXIgZW1pdHRpbmcgdGhlIGV2ZW50cywgYXMgdGhlIE5ldHdvcmsgcmViaW5kcyBhbGxcbiAgLy8ga2V5Ym9hcmQgZXZlbnRzIG9uIGEgJ2NoYW5nZScgZXZlbnRcbiAgdGhpcy5rZXljaGFybS5iaW5kKCdlc2MnLCB0aGlzLmVzY0xpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogRGVhY3RpdmF0ZSB0aGUgZWxlbWVudFxuICogT3ZlcmxheSBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIHRoZSBlbGVtZW50XG4gKi9cbkFjdGl2YXRvci5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgdGhpcy5kb20ub3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmNvbnRhaW5lciwgJ3Zpcy1hY3RpdmUnKTtcbiAgdGhpcy5rZXljaGFybS51bmJpbmQoJ2VzYycsIHRoaXMuZXNjTGlzdGVuZXIpO1xuXG4gIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gIHRoaXMuZW1pdCgnZGVhY3RpdmF0ZScpO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgYSB0YXAgZXZlbnQ6IGFjdGl2YXRlIHRoZSBjb250YWluZXJcbiAqIEBwYXJhbSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuQWN0aXZhdG9yLnByb3RvdHlwZS5fb25UYXBPdmVybGF5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIGFjdGl2YXRlIHRoZSBjb250YWluZXJcbiAgdGhpcy5hY3RpdmF0ZSgpO1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyB0aGUgcmVxdWVzdGVkIHBhcmVudCBlbGVtZW50IHNvbWV3aGVyZSBpblxuICogaXRzIGNoYWluIG9mIHBhcmVudCBub2Rlcy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBwYXJlbnQgaXMgZm91bmQgc29tZXdoZXJlIGluIHRoZVxuICogICAgICAgICAgICAgICAgICAgIGNoYWluIG9mIHBhcmVudCBub2Rlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9oYXNQYXJlbnQoZWxlbWVudCwgcGFyZW50KSB7XG4gIHdoaWxlIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWN0aXZhdG9yO1xuIiwibGV0IEhhbW1lciA9IHJlcXVpcmUoJy4uL21vZHVsZS9oYW1tZXInKTtcbmxldCBoYW1tZXJVdGlsID0gcmVxdWlyZSgnLi4vaGFtbWVyVXRpbCcpO1xubGV0IHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmNsYXNzIENvbG9yUGlja2VyIHtcbiAgY29uc3RydWN0b3IocGl4ZWxSYXRpbyA9IDEpIHtcbiAgICB0aGlzLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIHRoaXMuZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jZW50ZXJDb29yZGluYXRlcyA9IHt4OjI4OS8yLCB5OjI4OS8yfTtcbiAgICB0aGlzLnIgPSAyODkgKiAwLjQ5O1xuICAgIHRoaXMuY29sb3IgPSB7cjoyNTUsZzoyNTUsYjoyNTUsYToxLjB9O1xuICAgIHRoaXMuaHVlQ2lyY2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5pdGlhbENvbG9yID0ge3I6MjU1LGc6MjU1LGI6MjU1LGE6MS4wfTtcbiAgICB0aGlzLnByZXZpb3VzQ29sb3I9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFwcGxpZWQgPSBmYWxzZTtcblxuICAgIC8vIGJvdW5kIGJ5XG4gICAgdGhpcy51cGRhdGVDYWxsYmFjayA9ICgpID0+IHt9O1xuXG4gICAgLy8gY3JlYXRlIGFsbCBET00gZWxlbWVudHNcbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIHRoaXMgaW5zZXJ0cyB0aGUgY29sb3JQaWNrZXIgaW50byBhIGRpdiBmcm9tIHRoZSBET01cbiAgICogQHBhcmFtIGNvbnRhaW5lclxuICAgKi9cbiAgaW5zZXJ0VG8oY29udGFpbmVyKSB7XG4gICAgaWYgKHRoaXMuaGFtbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuaGFtbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcbiAgICB0aGlzLl9iaW5kSGFtbWVyKCk7XG5cbiAgICB0aGlzLl9zZXRTaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogdGhlIGNhbGxiYWNrIGlzIGV4ZWN1dGVkIG9uIGFwcGx5IGFuZCBzYXZlLiBCaW5kIGl0IHRvIHRoZSBhcHBsaWNhdGlvblxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHNldENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGF0dGVtcHRlZCB0byBzZXQgYXMgY29sb3JQaWNrZXIgY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cbiAgfVxuXG4gIF9pc0NvbG9yU3RyaW5nKGNvbG9yKSB7XG4gICAgdmFyIGh0bWxDb2xvcnMgPSB7YmxhY2s6ICcjMDAwMDAwJyxuYXZ5OiAnIzAwMDA4MCcsZGFya2JsdWU6ICcjMDAwMDhCJyxtZWRpdW1ibHVlOiAnIzAwMDBDRCcsYmx1ZTogJyMwMDAwRkYnLGRhcmtncmVlbjogJyMwMDY0MDAnLGdyZWVuOiAnIzAwODAwMCcsdGVhbDogJyMwMDgwODAnLGRhcmtjeWFuOiAnIzAwOEI4QicsZGVlcHNreWJsdWU6ICcjMDBCRkZGJyxkYXJrdHVycXVvaXNlOiAnIzAwQ0VEMScsbWVkaXVtc3ByaW5nZ3JlZW46ICcjMDBGQTlBJyxsaW1lOiAnIzAwRkYwMCcsc3ByaW5nZ3JlZW46ICcjMDBGRjdGJyxhcXVhOiAnIzAwRkZGRicsY3lhbjogJyMwMEZGRkYnLG1pZG5pZ2h0Ymx1ZTogJyMxOTE5NzAnLGRvZGdlcmJsdWU6ICcjMUU5MEZGJyxsaWdodHNlYWdyZWVuOiAnIzIwQjJBQScsZm9yZXN0Z3JlZW46ICcjMjI4QjIyJyxzZWFncmVlbjogJyMyRThCNTcnLGRhcmtzbGF0ZWdyYXk6ICcjMkY0RjRGJyxsaW1lZ3JlZW46ICcjMzJDRDMyJyxtZWRpdW1zZWFncmVlbjogJyMzQ0IzNzEnLHR1cnF1b2lzZTogJyM0MEUwRDAnLHJveWFsYmx1ZTogJyM0MTY5RTEnLHN0ZWVsYmx1ZTogJyM0NjgyQjQnLGRhcmtzbGF0ZWJsdWU6ICcjNDgzRDhCJyxtZWRpdW10dXJxdW9pc2U6ICcjNDhEMUNDJyxpbmRpZ286ICcjNEIwMDgyJyxkYXJrb2xpdmVncmVlbjogJyM1NTZCMkYnLGNhZGV0Ymx1ZTogJyM1RjlFQTAnLGNvcm5mbG93ZXJibHVlOiAnIzY0OTVFRCcsbWVkaXVtYXF1YW1hcmluZTogJyM2NkNEQUEnLGRpbWdyYXk6ICcjNjk2OTY5JyxzbGF0ZWJsdWU6ICcjNkE1QUNEJyxvbGl2ZWRyYWI6ICcjNkI4RTIzJyxzbGF0ZWdyYXk6ICcjNzA4MDkwJyxsaWdodHNsYXRlZ3JheTogJyM3Nzg4OTknLG1lZGl1bXNsYXRlYmx1ZTogJyM3QjY4RUUnLGxhd25ncmVlbjogJyM3Q0ZDMDAnLGNoYXJ0cmV1c2U6ICcjN0ZGRjAwJyxhcXVhbWFyaW5lOiAnIzdGRkZENCcsbWFyb29uOiAnIzgwMDAwMCcscHVycGxlOiAnIzgwMDA4MCcsb2xpdmU6ICcjODA4MDAwJyxncmF5OiAnIzgwODA4MCcsc2t5Ymx1ZTogJyM4N0NFRUInLGxpZ2h0c2t5Ymx1ZTogJyM4N0NFRkEnLGJsdWV2aW9sZXQ6ICcjOEEyQkUyJyxkYXJrcmVkOiAnIzhCMDAwMCcsZGFya21hZ2VudGE6ICcjOEIwMDhCJyxzYWRkbGVicm93bjogJyM4QjQ1MTMnLGRhcmtzZWFncmVlbjogJyM4RkJDOEYnLGxpZ2h0Z3JlZW46ICcjOTBFRTkwJyxtZWRpdW1wdXJwbGU6ICcjOTM3MEQ4JyxkYXJrdmlvbGV0OiAnIzk0MDBEMycscGFsZWdyZWVuOiAnIzk4RkI5OCcsZGFya29yY2hpZDogJyM5OTMyQ0MnLHllbGxvd2dyZWVuOiAnIzlBQ0QzMicsc2llbm5hOiAnI0EwNTIyRCcsYnJvd246ICcjQTUyQTJBJyxkYXJrZ3JheTogJyNBOUE5QTknLGxpZ2h0Ymx1ZTogJyNBREQ4RTYnLGdyZWVueWVsbG93OiAnI0FERkYyRicscGFsZXR1cnF1b2lzZTogJyNBRkVFRUUnLGxpZ2h0c3RlZWxibHVlOiAnI0IwQzRERScscG93ZGVyYmx1ZTogJyNCMEUwRTYnLGZpcmVicmljazogJyNCMjIyMjInLGRhcmtnb2xkZW5yb2Q6ICcjQjg4NjBCJyxtZWRpdW1vcmNoaWQ6ICcjQkE1NUQzJyxyb3N5YnJvd246ICcjQkM4RjhGJyxkYXJra2hha2k6ICcjQkRCNzZCJyxzaWx2ZXI6ICcjQzBDMEMwJyxtZWRpdW12aW9sZXRyZWQ6ICcjQzcxNTg1JyxpbmRpYW5yZWQ6ICcjQ0Q1QzVDJyxwZXJ1OiAnI0NEODUzRicsY2hvY29sYXRlOiAnI0QyNjkxRScsdGFuOiAnI0QyQjQ4QycsbGlnaHRncmV5OiAnI0QzRDNEMycscGFsZXZpb2xldHJlZDogJyNEODcwOTMnLHRoaXN0bGU6ICcjRDhCRkQ4JyxvcmNoaWQ6ICcjREE3MEQ2Jyxnb2xkZW5yb2Q6ICcjREFBNTIwJyxjcmltc29uOiAnI0RDMTQzQycsZ2FpbnNib3JvOiAnI0RDRENEQycscGx1bTogJyNEREEwREQnLGJ1cmx5d29vZDogJyNERUI4ODcnLGxpZ2h0Y3lhbjogJyNFMEZGRkYnLGxhdmVuZGVyOiAnI0U2RTZGQScsZGFya3NhbG1vbjogJyNFOTk2N0EnLHZpb2xldDogJyNFRTgyRUUnLHBhbGVnb2xkZW5yb2Q6ICcjRUVFOEFBJyxsaWdodGNvcmFsOiAnI0YwODA4MCcsa2hha2k6ICcjRjBFNjhDJyxhbGljZWJsdWU6ICcjRjBGOEZGJyxob25leWRldzogJyNGMEZGRjAnLGF6dXJlOiAnI0YwRkZGRicsc2FuZHlicm93bjogJyNGNEE0NjAnLHdoZWF0OiAnI0Y1REVCMycsYmVpZ2U6ICcjRjVGNURDJyx3aGl0ZXNtb2tlOiAnI0Y1RjVGNScsbWludGNyZWFtOiAnI0Y1RkZGQScsZ2hvc3R3aGl0ZTogJyNGOEY4RkYnLHNhbG1vbjogJyNGQTgwNzInLGFudGlxdWV3aGl0ZTogJyNGQUVCRDcnLGxpbmVuOiAnI0ZBRjBFNicsbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjRkFGQUQyJyxvbGRsYWNlOiAnI0ZERjVFNicscmVkOiAnI0ZGMDAwMCcsZnVjaHNpYTogJyNGRjAwRkYnLG1hZ2VudGE6ICcjRkYwMEZGJyxkZWVwcGluazogJyNGRjE0OTMnLG9yYW5nZXJlZDogJyNGRjQ1MDAnLHRvbWF0bzogJyNGRjYzNDcnLGhvdHBpbms6ICcjRkY2OUI0Jyxjb3JhbDogJyNGRjdGNTAnLGRhcmtvcmFuZ2U6ICcjRkY4QzAwJyxsaWdodHNhbG1vbjogJyNGRkEwN0EnLG9yYW5nZTogJyNGRkE1MDAnLGxpZ2h0cGluazogJyNGRkI2QzEnLHBpbms6ICcjRkZDMENCJyxnb2xkOiAnI0ZGRDcwMCcscGVhY2hwdWZmOiAnI0ZGREFCOScsbmF2YWpvd2hpdGU6ICcjRkZERUFEJyxtb2NjYXNpbjogJyNGRkU0QjUnLGJpc3F1ZTogJyNGRkU0QzQnLG1pc3R5cm9zZTogJyNGRkU0RTEnLGJsYW5jaGVkYWxtb25kOiAnI0ZGRUJDRCcscGFwYXlhd2hpcDogJyNGRkVGRDUnLGxhdmVuZGVyYmx1c2g6ICcjRkZGMEY1JyxzZWFzaGVsbDogJyNGRkY1RUUnLGNvcm5zaWxrOiAnI0ZGRjhEQycsbGVtb25jaGlmZm9uOiAnI0ZGRkFDRCcsZmxvcmFsd2hpdGU6ICcjRkZGQUYwJyxzbm93OiAnI0ZGRkFGQScseWVsbG93OiAnI0ZGRkYwMCcsbGlnaHR5ZWxsb3c6ICcjRkZGRkUwJyxpdm9yeTogJyNGRkZGRjAnLHdoaXRlOiAnI0ZGRkZGRid9O1xuICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gaHRtbENvbG9yc1tjb2xvcl07XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogU2V0IHRoZSBjb2xvciBvZiB0aGUgY29sb3JQaWNrZXJcbiAgICogU3VwcG9ydGVkIGZvcm1hdHM6XG4gICAqICdyZWQnICAgICAgICAgICAgICAgICAgIC0tPiBIVE1MIGNvbG9yIHN0cmluZ1xuICAgKiAnI2ZmZmZmZicgICAgICAgICAgICAgICAtLT4gaGV4IHN0cmluZ1xuICAgKiAncmJnKDI1NSwyNTUsMjU1KScgICAgICAtLT4gcmdiIHN0cmluZ1xuICAgKiAncmdiYSgyNTUsMjU1LDI1NSwxLjApJyAtLT4gcmdiYSBzdHJpbmdcbiAgICoge3I6MjU1LGc6MjU1LGI6MjU1fSAgICAgLS0+IHJnYiBvYmplY3RcbiAgICoge3I6MjU1LGc6MjU1LGI6MjU1LGE6MS4wfSAtLT4gcmdiYSBvYmplY3RcbiAgICogQHBhcmFtIGNvbG9yXG4gICAqIEBwYXJhbSBzZXRJbml0aWFsXG4gICAqL1xuICBzZXRDb2xvcihjb2xvciwgc2V0SW5pdGlhbCA9IHRydWUpIHtcbiAgICBpZiAoY29sb3IgPT09ICdub25lJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCByZ2JhO1xuXG4gICAgLy8gaWYgYSBodG1sIGNvbG9yIHNob3J0aGFuZCBpcyB1c2VkLCBjb252ZXJ0IHRvIGhleFxuICAgIHZhciBodG1sQ29sb3IgPSB0aGlzLl9pc0NvbG9yU3RyaW5nKGNvbG9yKTtcbiAgICBpZiAoaHRtbENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbG9yID0gaHRtbENvbG9yO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvcm1hdFxuICAgIGlmICh1dGlsLmlzU3RyaW5nKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKHV0aWwuaXNWYWxpZFJHQihjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgbGV0IHJnYmFBcnJheSA9IGNvbG9yLnN1YnN0cig0KS5zdWJzdHIoMCwgY29sb3IubGVuZ3RoIC0gNSkuc3BsaXQoJywnKTtcbiAgICAgICAgcmdiYSA9IHtyOnJnYmFBcnJheVswXSwgZzpyZ2JhQXJyYXlbMV0sIGI6cmdiYUFycmF5WzJdLCBhOjEuMH07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh1dGlsLmlzVmFsaWRSR0JBKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICBsZXQgcmdiYUFycmF5ID0gY29sb3Iuc3Vic3RyKDUpLnN1YnN0cigwLCBjb2xvci5sZW5ndGggLSA2KS5zcGxpdCgnLCcpO1xuICAgICAgICByZ2JhID0ge3I6cmdiYUFycmF5WzBdLCBnOnJnYmFBcnJheVsxXSwgYjpyZ2JhQXJyYXlbMl0sIGE6cmdiYUFycmF5WzNdfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHV0aWwuaXNWYWxpZEhleChjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgbGV0IHJnYk9iaiA9IHV0aWwuaGV4VG9SR0IoY29sb3IpO1xuICAgICAgICByZ2JhID0ge3I6cmdiT2JqLnIsIGc6cmdiT2JqLmcsIGI6cmdiT2JqLmIsIGE6MS4wfTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgaWYgKGNvbG9yLnIgIT09IHVuZGVmaW5lZCAmJiBjb2xvci5nICE9PSB1bmRlZmluZWQgJiYgY29sb3IuYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGV0IGFscGhhID0gY29sb3IuYSAhPT0gdW5kZWZpbmVkID8gY29sb3IuYSA6ICcxLjAnO1xuICAgICAgICAgIHJnYmEgPSB7cjpjb2xvci5yLCBnOmNvbG9yLmcsIGI6Y29sb3IuYiwgYTphbHBoYX07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZXQgY29sb3JcbiAgICBpZiAocmdiYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbG9yIHBhc3NlZCB0byB0aGUgY29sb3JQaWNrZXIuIFN1cHBvcnRlZCBhcmUgc3RyaW5nczogcmdiLCBoZXgsIHJnYmEuIE9iamVjdDogcmdiICh7cjpyLGc6ZyxiOmIsW2E6YV19KS4gU3VwcGxpZWQ6IFwiICsgSlNPTi5zdHJpbmdpZnkoY29sb3IpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9zZXRDb2xvcihyZ2JhLCBzZXRJbml0aWFsKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiB0aGlzIHNob3dzIHRoZSBjb2xvciBwaWNrZXIgYXQgYSBsb2NhdGlvbi4gVGhlIGh1ZSBjaXJjbGUgaXMgY29uc3RydWN0ZWQgb25jZSBhbmQgc3RvcmVkLlxuICAgKiBAcGFyYW0geFxuICAgKiBAcGFyYW0geVxuICAgKi9cbiAgc2hvdyh4LHkpIHtcbiAgICB0aGlzLmFwcGxpZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHRoaXMuZnJhbWUuc3R5bGUudG9wID0geSArICdweCc7XG4gICAgdGhpcy5mcmFtZS5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgdGhpcy5fZ2VuZXJhdGVIdWVDaXJjbGUoKTtcbiAgfVxuXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFBSSVZBVEUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICAvKipcbiAgICogSGlkZSB0aGUgcGlja2VyLiBJcyBjYWxsZWQgYnkgdGhlIGNhbmNlbCBidXR0b24uXG4gICAqIE9wdGlvbmFsIGJvb2xlYW4gdG8gc3RvcmUgdGhlIHByZXZpb3VzIGNvbG9yIGZvciBlYXN5IGFjY2VzcyBsYXRlciBvbi5cbiAgICogQHBhcmFtIHN0b3JlUHJldmlvdXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oaWRlKHN0b3JlUHJldmlvdXMgPSB0cnVlKSB7XG4gICAgLy8gc3RvcmUgdGhlIHByZXZpb3VzIGNvbG9yIGZvciBuZXh0IHRpbWU7XG4gICAgaWYgKHN0b3JlUHJldmlvdXMgPT09IHRydWUpIHtcbiAgICAgIHRoaXMucHJldmlvdXNDb2xvciA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmNvbG9yKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcHBsaWVkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuaW5pdGlhbENvbG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBib3VuZCB0byB0aGUgc2F2ZSBidXR0b24uIFNhdmVzIGFuZCBoaWRlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zYXZlKCkge1xuICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5jb2xvcik7XG4gICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG4gICAgdGhpcy5faGlkZSgpO1xuICB9XG5cblxuICAvKipcbiAgICogQm91bmQgdG8gYXBwbHkgYnV0dG9uLiBTYXZlcyBidXQgZG9lcyBub3QgY2xvc2UuIElzIHVuZG9uZSBieSB0aGUgY2FuY2VsIGJ1dHRvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseSgpIHtcbiAgICB0aGlzLmFwcGxpZWQgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5jb2xvcik7XG4gICAgdGhpcy5fdXBkYXRlUGlja2VyKHRoaXMuY29sb3IpO1xuICB9XG5cblxuICAvKipcbiAgICogbG9hZCB0aGUgY29sb3IgZnJvbSB0aGUgcHJldmlvdXMgc2Vzc2lvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2FkTGFzdCgpIHtcbiAgICBpZiAodGhpcy5wcmV2aW91c0NvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0Q29sb3IodGhpcy5wcmV2aW91c0NvbG9yLCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWxlcnQoXCJUaGVyZSBpcyBubyBsYXN0IGNvbG9yIHRvIGxvYWQuLi5cIik7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogc2V0IHRoZSBjb2xvciwgcGxhY2UgdGhlIHBpY2tlclxuICAgKiBAcGFyYW0gcmdiYVxuICAgKiBAcGFyYW0gc2V0SW5pdGlhbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldENvbG9yKHJnYmEsIHNldEluaXRpYWwgPSB0cnVlKSB7XG4gICAgLy8gc3RvcmUgdGhlIGluaXRpYWwgY29sb3JcbiAgICBpZiAoc2V0SW5pdGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3IgPSB1dGlsLmV4dGVuZCh7fSwgcmdiYSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb2xvciA9IHJnYmE7XG4gICAgbGV0IGhzdiA9IHV0aWwuUkdCVG9IU1YocmdiYS5yLCByZ2JhLmcsIHJnYmEuYik7XG5cbiAgICBsZXQgYW5nbGVDb252ZXJ0ID0gMiAqIE1hdGguUEk7XG4gICAgbGV0IHJhZGl1cyA9IHRoaXMuciAqIGhzdi5zO1xuICAgIGxldCB4ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy54ICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGVDb252ZXJ0ICogaHN2LmgpO1xuICAgIGxldCB5ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy55ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGVDb252ZXJ0ICogaHN2LmgpO1xuXG4gICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLmxlZnQgPSB4IC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudFdpZHRoICsgJ3B4JztcbiAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID0geSAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRIZWlnaHQgKyAncHgnO1xuXG4gICAgdGhpcy5fdXBkYXRlUGlja2VyKHJnYmEpO1xuICB9XG5cblxuICAvKipcbiAgICogYm91bmQgdG8gb3BhY2l0eSBjb250cm9sXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldE9wYWNpdHkodmFsdWUpIHtcbiAgICB0aGlzLmNvbG9yLmEgPSB2YWx1ZSAvIDEwMDtcbiAgICB0aGlzLl91cGRhdGVQaWNrZXIodGhpcy5jb2xvcik7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBib3VuZCB0byBicmlnaHRuZXNzIGNvbnRyb2xcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0QnJpZ2h0bmVzcyh2YWx1ZSkge1xuICAgIGxldCBoc3YgPSB1dGlsLlJHQlRvSFNWKHRoaXMuY29sb3IuciwgdGhpcy5jb2xvci5nLCB0aGlzLmNvbG9yLmIpO1xuICAgIGhzdi52ID0gdmFsdWUgLyAxMDA7XG4gICAgbGV0IHJnYmEgPSB1dGlsLkhTVlRvUkdCKGhzdi5oLCBoc3YucywgaHN2LnYpO1xuICAgIHJnYmFbJ2EnXSA9IHRoaXMuY29sb3IuYTtcbiAgICB0aGlzLmNvbG9yID0gcmdiYTtcbiAgICB0aGlzLl91cGRhdGVQaWNrZXIoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIHVwZGF0ZSB0aGUgY29sb3JwaWNrZXIuIEEgYmxhY2sgY2lyY2xlIG92ZXJsYXlzIHRoZSBodWUgY2lyY2xlIHRvIG1pbWljIHRoZSBicmlnaHRuZXNzIGRlY3JlYXNpbmcuXG4gICAqIEBwYXJhbSByZ2JhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlUGlja2VyKHJnYmEgPSB0aGlzLmNvbG9yKSB7XG4gICAgbGV0IGhzdiA9IHV0aWwuUkdCVG9IU1YocmdiYS5yLCByZ2JhLmcsIHJnYmEuYik7XG4gICAgbGV0IGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAodGhpcy5waXhlbFJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuICAgIH1cbiAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcblxuICAgIC8vIGNsZWFyIHRoZSBjYW52YXNcbiAgICBsZXQgdyA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50V2lkdGg7XG4gICAgbGV0IGggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudEhlaWdodDtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuXG4gICAgY3R4LnB1dEltYWdlRGF0YSh0aGlzLmh1ZUNpcmNsZSwgMCwwKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsJyArICgxLSBoc3YudikgKyAnKSc7XG4gICAgY3R4LmNpcmNsZSh0aGlzLmNlbnRlckNvb3JkaW5hdGVzLngsIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSwgdGhpcy5yKTtcbiAgICBjdHguZmlsbCgpO1xuXG4gICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWUgPSAxMDAgKiBoc3YudjtcbiAgICB0aGlzLm9wYWNpdHlSYW5nZS52YWx1ZSAgICA9IDEwMCAqIHJnYmEuYTtcblxuICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKCcgKyB0aGlzLmluaXRpYWxDb2xvci5yICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuZyArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmIgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5hICsgJyknO1xuICAgIHRoaXMubmV3Q29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoJyArIHRoaXMuY29sb3IuciArICcsJyArIHRoaXMuY29sb3IuZyArICcsJyArIHRoaXMuY29sb3IuYiArICcsJyArIHRoaXMuY29sb3IuYSArICcpJztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIHVzZWQgYnkgY3JlYXRlIHRvIHNldCB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFNpemUoKSB7XG4gICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcblxuICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMud2lkdGggPSAyODkgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5oZWlnaHQgPSAyODkgKiB0aGlzLnBpeGVsUmF0aW87XG4gIH1cblxuXG4gIC8qKlxuICAgKiBjcmVhdGUgYWxsIGRvbSBlbGVtZW50c1xuICAgKiBUT0RPOiBjbGVhbnVwLCBsb3RzIG9mIHNpbWlsYXIgZG9tIGVsZW1lbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlKCkge1xuICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtY29sb3ItcGlja2VyJztcblxuICAgIHRoaXMuY29sb3JQaWNrZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xhc3NOYW1lID0gJ3Zpcy1zZWxlY3Rvcic7XG4gICAgdGhpcy5jb2xvclBpY2tlckRpdi5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IpO1xuXG4gICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuY29sb3JQaWNrZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlckNhbnZhcyk7XG5cbiAgICBpZiAoIXRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dCkge1xuICAgICAgbGV0IG5vQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ0RJVicgKTtcbiAgICAgIG5vQ2FudmFzLnN0eWxlLmNvbG9yID0gJ3JlZCc7XG4gICAgICBub0NhbnZhcy5zdHlsZS5mb250V2VpZ2h0ID0gICdib2xkJyA7XG4gICAgICBub0NhbnZhcy5zdHlsZS5wYWRkaW5nID0gICcxMHB4JztcbiAgICAgIG5vQ2FudmFzLmlubmVySFRNTCA9ICAnRXJyb3I6IHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgY2FudmFzJztcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuYXBwZW5kQ2hpbGQobm9DYW52YXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGxldCBjdHggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG5cbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgfVxuXG4gICAgdGhpcy5jb2xvclBpY2tlckRpdi5jbGFzc05hbWUgPSAndmlzLWNvbG9yJztcblxuICAgIHRoaXMub3BhY2l0eURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMub3BhY2l0eURpdi5jbGFzc05hbWUgPSAndmlzLW9wYWNpdHknO1xuXG4gICAgdGhpcy5icmlnaHRuZXNzRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5icmlnaHRuZXNzRGl2LmNsYXNzTmFtZSA9ICd2aXMtYnJpZ2h0bmVzcyc7XG5cbiAgICB0aGlzLmFycm93RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5hcnJvd0Rpdi5jbGFzc05hbWUgPSAndmlzLWFycm93JztcblxuICAgIHRoaXMub3BhY2l0eVJhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UudHlwZSA9ICdyYW5nZSc7IC8vIE5vdCBzdXBwb3J0ZWQgb24gSUU5XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS5taW4gPSAnMCc7XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS5tYXggPSAnMTAwJztcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge31cbiAgICB0aGlzLm9wYWNpdHlSYW5nZS52YWx1ZSA9ICcxMDAnO1xuICAgIHRoaXMub3BhY2l0eVJhbmdlLmNsYXNzTmFtZSA9ICd2aXMtcmFuZ2UnO1xuXG4gICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS50eXBlID0gJ3JhbmdlJzsgLy8gTm90IHN1cHBvcnRlZCBvbiBJRTlcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm1pbiA9ICcwJztcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm1heCA9ICcxMDAnO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7fVxuICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLnZhbHVlID0gJzEwMCc7XG4gICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UuY2xhc3NOYW1lID0gJ3Zpcy1yYW5nZSc7XG5cbiAgICB0aGlzLm9wYWNpdHlEaXYuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5UmFuZ2UpO1xuICAgIHRoaXMuYnJpZ2h0bmVzc0Rpdi5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NSYW5nZSk7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMub3BhY2l0eVJhbmdlLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge21lLl9zZXRPcGFjaXR5KHRoaXMudmFsdWUpO307XG4gICAgdGhpcy5vcGFjaXR5UmFuZ2Uub25pbnB1dCAgPSBmdW5jdGlvbiAoKSB7bWUuX3NldE9wYWNpdHkodGhpcy52YWx1ZSk7fTtcbiAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHttZS5fc2V0QnJpZ2h0bmVzcyh0aGlzLnZhbHVlKTt9O1xuICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm9uaW5wdXQgID0gZnVuY3Rpb24gKCkge21lLl9zZXRCcmlnaHRuZXNzKHRoaXMudmFsdWUpO307XG5cbiAgICB0aGlzLmJyaWdodG5lc3NMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5icmlnaHRuZXNzTGFiZWwuY2xhc3NOYW1lID0gXCJ2aXMtbGFiZWwgdmlzLWJyaWdodG5lc3NcIjtcbiAgICB0aGlzLmJyaWdodG5lc3NMYWJlbC5pbm5lckhUTUwgPSAnYnJpZ2h0bmVzczonO1xuXG4gICAgdGhpcy5vcGFjaXR5TGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMub3BhY2l0eUxhYmVsLmNsYXNzTmFtZSA9IFwidmlzLWxhYmVsIHZpcy1vcGFjaXR5XCI7XG4gICAgdGhpcy5vcGFjaXR5TGFiZWwuaW5uZXJIVE1MID0gJ29wYWNpdHk6JztcblxuICAgIHRoaXMubmV3Q29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMubmV3Q29sb3JEaXYuY2xhc3NOYW1lID0gXCJ2aXMtbmV3LWNvbG9yXCI7XG4gICAgdGhpcy5uZXdDb2xvckRpdi5pbm5lckhUTUwgPSAnbmV3JztcblxuICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5jbGFzc05hbWUgPSBcInZpcy1pbml0aWFsLWNvbG9yXCI7XG4gICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuaW5uZXJIVE1MID0gJ2luaXRpYWwnO1xuXG4gICAgdGhpcy5jYW5jZWxCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuY2FuY2VsQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtY2FuY2VsXCI7XG4gICAgdGhpcy5jYW5jZWxCdXR0b24uaW5uZXJIVE1MID0gJ2NhbmNlbCc7XG4gICAgdGhpcy5jYW5jZWxCdXR0b24ub25jbGljayA9IHRoaXMuX2hpZGUuYmluZCh0aGlzLCBmYWxzZSk7XG5cbiAgICB0aGlzLmFwcGx5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmFwcGx5QnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtYXBwbHlcIjtcbiAgICB0aGlzLmFwcGx5QnV0dG9uLmlubmVySFRNTCA9ICdhcHBseSc7XG4gICAgdGhpcy5hcHBseUJ1dHRvbi5vbmNsaWNrID0gdGhpcy5fYXBwbHkuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuc2F2ZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5zYXZlQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtc2F2ZVwiO1xuICAgIHRoaXMuc2F2ZUJ1dHRvbi5pbm5lckhUTUwgPSAnc2F2ZSc7XG4gICAgdGhpcy5zYXZlQnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9zYXZlLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmxvYWRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMubG9hZEJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLWxvYWRcIjtcbiAgICB0aGlzLmxvYWRCdXR0b24uaW5uZXJIVE1MID0gJ2xvYWQgbGFzdCc7XG4gICAgdGhpcy5sb2FkQnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9sb2FkTGFzdC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyRGl2KTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYXJyb3dEaXYpO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzTGFiZWwpO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzRGl2KTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMub3BhY2l0eUxhYmVsKTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMub3BhY2l0eURpdik7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm5ld0NvbG9yRGl2KTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuaW5pdGlhbENvbG9yRGl2KTtcblxuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jYW5jZWxCdXR0b24pO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcHBseUJ1dHRvbik7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLnNhdmVCdXR0b24pO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5sb2FkQnV0dG9uKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGJpbmQgaGFtbWVyIHRvIHRoZSBjb2xvciBwaWNrZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9iaW5kSGFtbWVyKCkge1xuICAgIHRoaXMuZHJhZyA9IHt9O1xuICAgIHRoaXMucGluY2ggPSB7fTtcbiAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5jb2xvclBpY2tlckNhbnZhcyk7XG4gICAgdGhpcy5oYW1tZXIuZ2V0KCdwaW5jaCcpLnNldCh7ZW5hYmxlOiB0cnVlfSk7XG5cbiAgICBoYW1tZXJVdGlsLm9uVG91Y2godGhpcy5oYW1tZXIsIChldmVudCkgPT4ge3RoaXMuX21vdmVTZWxlY3RvcihldmVudCl9KTtcbiAgICB0aGlzLmhhbW1lci5vbigndGFwJywgICAgICAgKGV2ZW50KSA9PiB7dGhpcy5fbW92ZVNlbGVjdG9yKGV2ZW50KX0pO1xuICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5zdGFydCcsICAoZXZlbnQpID0+IHt0aGlzLl9tb3ZlU2VsZWN0b3IoZXZlbnQpfSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3Bhbm1vdmUnLCAgIChldmVudCkgPT4ge3RoaXMuX21vdmVTZWxlY3RvcihldmVudCl9KTtcbiAgICB0aGlzLmhhbW1lci5vbigncGFuZW5kJywgICAgKGV2ZW50KSA9PiB7dGhpcy5fbW92ZVNlbGVjdG9yKGV2ZW50KX0pO1xuICB9XG5cblxuICAvKipcbiAgICogZ2VuZXJhdGUgdGhlIGh1ZSBjaXJjbGUuIFRoaXMgaXMgcmVsYXRpdmVseSBoZWF2eSAoMjAwbXMpIGFuZCBpcyBkb25lIG9ubHkgb25jZSBvbiB0aGUgZmlyc3QgdGltZSBpdCBpcyBzaG93bi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZW5lcmF0ZUh1ZUNpcmNsZSgpIHtcbiAgICBpZiAodGhpcy5nZW5lcmF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICBsZXQgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgaWYgKHRoaXMucGl4ZWxSYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICB9XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcblxuICAgICAgLy8gY2xlYXIgdGhlIGNhbnZhc1xuICAgICAgbGV0IHcgPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgbGV0IGggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG5cblxuICAgICAgLy8gZHJhdyBodWUgY2lyY2xlXG4gICAgICBsZXQgeCwgeSwgaHVlLCBzYXQ7XG4gICAgICB0aGlzLmNlbnRlckNvb3JkaW5hdGVzID0ge3g6IHcgKiAwLjUsIHk6IGggKiAwLjV9O1xuICAgICAgdGhpcy5yID0gMC40OSAqIHc7XG4gICAgICBsZXQgYW5nbGVDb252ZXJ0ID0gKDIgKiBNYXRoLlBJKSAvIDM2MDtcbiAgICAgIGxldCBoZmFjID0gMSAvIDM2MDtcbiAgICAgIGxldCBzZmFjID0gMSAvIHRoaXMucjtcbiAgICAgIGxldCByZ2I7XG4gICAgICBmb3IgKGh1ZSA9IDA7IGh1ZSA8IDM2MDsgaHVlKyspIHtcbiAgICAgICAgZm9yIChzYXQgPSAwOyBzYXQgPCB0aGlzLnI7IHNhdCsrKSB7XG4gICAgICAgICAgeCA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCArIHNhdCAqIE1hdGguc2luKGFuZ2xlQ29udmVydCAqIGh1ZSk7XG4gICAgICAgICAgeSA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSArIHNhdCAqIE1hdGguY29zKGFuZ2xlQ29udmVydCAqIGh1ZSk7XG4gICAgICAgICAgcmdiID0gdXRpbC5IU1ZUb1JHQihodWUgKiBoZmFjLCBzYXQgKiBzZmFjLCAxKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYignICsgcmdiLnIgKyAnLCcgKyByZ2IuZyArICcsJyArIHJnYi5iICsgJyknO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCh4IC0gMC41LCB5IC0gMC41LCAyLCAyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwwLDAsMSknO1xuICAgICAgY3R4LmNpcmNsZSh0aGlzLmNlbnRlckNvb3JkaW5hdGVzLngsIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSwgdGhpcy5yKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgdGhpcy5odWVDaXJjbGUgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsMCx3LGgpO1xuICAgIH1cbiAgICB0aGlzLmdlbmVyYXRlZCA9IHRydWU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBtb3ZlIHRoZSBzZWxlY3Rvci4gVGhpcyBpcyBjYWxsZWQgYnkgaGFtbWVyIGZ1bmN0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbW92ZVNlbGVjdG9yKGV2ZW50KSB7XG4gICAgbGV0IHJlY3QgPSB0aGlzLmNvbG9yUGlja2VyRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBsZWZ0ID0gZXZlbnQuY2VudGVyLnggLSByZWN0LmxlZnQ7XG4gICAgbGV0IHRvcCA9IGV2ZW50LmNlbnRlci55IC0gcmVjdC50b3A7XG5cbiAgICBsZXQgY2VudGVyWSA9IDAuNSAqIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xpZW50SGVpZ2h0O1xuICAgIGxldCBjZW50ZXJYID0gMC41ICogdGhpcy5jb2xvclBpY2tlckRpdi5jbGllbnRXaWR0aDtcblxuICAgIGxldCB4ID0gbGVmdCAtIGNlbnRlclg7XG4gICAgbGV0IHkgPSB0b3AgLSBjZW50ZXJZO1xuXG4gICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih4LHkpO1xuICAgIGxldCByYWRpdXMgPSAwLjk4ICogTWF0aC5taW4oTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpLCBjZW50ZXJYKTtcblxuICAgIGxldCBuZXdUb3AgPSBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMgKyBjZW50ZXJZO1xuICAgIGxldCBuZXdMZWZ0ID0gTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzICsgY2VudGVyWDtcblxuICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS50b3AgPSBuZXdUb3AgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50SGVpZ2h0ICsgJ3B4JztcbiAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUubGVmdCA9IG5ld0xlZnQgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50V2lkdGggKyAncHgnO1xuXG4gICAgLy8gc2V0IGNvbG9yXG4gICAgbGV0IGggPSBhbmdsZSAvICgyICogTWF0aC5QSSk7XG4gICAgaCA9IGggPCAwID8gaCArIDEgOiBoO1xuICAgIGxldCBzID0gcmFkaXVzIC8gdGhpcy5yO1xuICAgIGxldCBoc3YgPSB1dGlsLlJHQlRvSFNWKHRoaXMuY29sb3IuciwgdGhpcy5jb2xvci5nLCB0aGlzLmNvbG9yLmIpO1xuICAgIGhzdi5oID0gaDtcbiAgICBoc3YucyA9IHM7XG4gICAgbGV0IHJnYmEgPSB1dGlsLkhTVlRvUkdCKGhzdi5oLCBoc3YucywgaHN2LnYpO1xuICAgIHJnYmFbJ2EnXSA9IHRoaXMuY29sb3IuYTtcbiAgICB0aGlzLmNvbG9yID0gcmdiYTtcblxuICAgIC8vIHVwZGF0ZSBwcmV2aWV3c1xuICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKCcgKyB0aGlzLmluaXRpYWxDb2xvci5yICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuZyArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmIgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5hICsgJyknO1xuICAgIHRoaXMubmV3Q29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoJyArIHRoaXMuY29sb3IuciArICcsJyArIHRoaXMuY29sb3IuZyArICcsJyArIHRoaXMuY29sb3IuYiArICcsJyArIHRoaXMuY29sb3IuYSArICcpJztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2xvclBpY2tlcjsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuaW1wb3J0IENvbG9yUGlja2VyIGZyb20gJy4vQ29sb3JQaWNrZXInXG5cbi8qKlxuICogVGhlIHdheSB0aGlzIHdvcmtzIGlzIGZvciBhbGwgcHJvcGVydGllcyBvZiB0aGlzLnBvc3NpYmxlIG9wdGlvbnMsIHlvdSBjYW4gc3VwcGx5IHRoZSBwcm9wZXJ0eSBuYW1lIGluIGFueSBmb3JtIHRvIGxpc3QgdGhlIG9wdGlvbnMuXG4gKiBCb29sZWFuIG9wdGlvbnMgYXJlIHJlY29nbmlzZWQgYXMgQm9vbGVhblxuICogTnVtYmVyIG9wdGlvbnMgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFtkZWZhdWx0IHZhbHVlLCBtaW4gdmFsdWUsIG1heCB2YWx1ZSwgc3RlcHNpemVdXG4gKiBDb2xvcnMgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFsnY29sb3InLCAnI2ZmZmZmZiddXG4gKiBTdHJpbmdzIHdpdGggc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFtvcHRpb24xLCBvcHRpb24yLCBvcHRpb24zLCAuLl1cbiAqXG4gKiBUaGUgb3B0aW9ucyBhcmUgbWF0Y2hlZCB3aXRoIHRoZWlyIGNvdW50ZXJwYXJ0cyBpbiBlYWNoIG9mIHRoZSBtb2R1bGVzIGFuZCB0aGUgdmFsdWVzIHVzZWQgaW4gdGhlIGNvbmZpZ3VyYXRpb24gYXJlXG4gKlxuICogQHBhcmFtIHBhcmVudE1vZHVsZSAgICAgICAgfCB0aGUgbG9jYXRpb24gd2hlcmUgcGFyZW50TW9kdWxlLnNldE9wdGlvbnMoKSBjYW4gYmUgY2FsbGVkXG4gKiBAcGFyYW0gZGVmYXVsdENvbnRhaW5lciAgICB8IHRoZSBkZWZhdWx0IGNvbnRhaW5lciBvZiB0aGUgbW9kdWxlXG4gKiBAcGFyYW0gY29uZmlndXJlT3B0aW9ucyAgICB8IHRoZSBmdWxseSBjb25maWd1cmVkIGFuZCBwcmVkZWZpbmVkIG9wdGlvbnMgc2V0IGZvdW5kIGluIGFsbE9wdGlvbnMuanNcbiAqIEBwYXJhbSBwaXhlbFJhdGlvICAgICAgICAgIHwgY2FudmFzIHBpeGVsIHJhdGlvXG4gKi9cbmNsYXNzIENvbmZpZ3VyYXRvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudE1vZHVsZSwgZGVmYXVsdENvbnRhaW5lciwgY29uZmlndXJlT3B0aW9ucywgcGl4ZWxSYXRpbyA9IDEpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudE1vZHVsZTtcbiAgICB0aGlzLmNoYW5nZWRPcHRpb25zID0gW107XG4gICAgdGhpcy5jb250YWluZXIgPSBkZWZhdWx0Q29udGFpbmVyO1xuICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMucG9wdXBDb3VudGVyID0gMDtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBmaWx0ZXI6IHRydWUsXG4gICAgICBjb250YWluZXI6IHVuZGVmaW5lZCxcbiAgICAgIHNob3dCdXR0b246IHRydWVcbiAgICB9O1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmNvbmZpZ3VyZU9wdGlvbnMgPSBjb25maWd1cmVPcHRpb25zO1xuICAgIHRoaXMubW9kdWxlT3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZG9tRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnBvcHVwRGl2ID0ge307XG4gICAgdGhpcy5wb3B1cExpbWl0ID0gNTtcbiAgICB0aGlzLnBvcHVwSGlzdG9yeSA9IHt9O1xuICAgIHRoaXMuY29sb3JQaWNrZXIgPSBuZXcgQ29sb3JQaWNrZXIocGl4ZWxSYXRpbyk7XG4gICAgdGhpcy53cmFwcGVyID0gdW5kZWZpbmVkO1xuICB9XG5cblxuICAvKipcbiAgICogcmVmcmVzaCBhbGwgb3B0aW9ucy5cbiAgICogQmVjYXVzZSBhbGwgbW9kdWxlcyBwYXJzZSB0aGVpciBvcHRpb25zIGJ5IHRoZW1zZWx2ZXMsIHdlIGp1c3QgdXNlIHRoZWlyIG9wdGlvbnMuIFdlIGNvcHkgdGhlbSBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmVzZXQgdGhlIHBvcHVwIGhpc3RvcnkgYmVjYXVzZSB0aGUgaW5kaWNlcyBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQuXG4gICAgICB0aGlzLnBvcHVwSGlzdG9yeSA9IHt9O1xuICAgICAgdGhpcy5fcmVtb3ZlUG9wdXAoKTtcblxuICAgICAgbGV0IGVuYWJsZWQgPSB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucy5qb2luKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0J1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnNob3dCdXR0b24gPSBvcHRpb25zLnNob3dCdXR0b247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZW5hYmxlZCA9IG9wdGlvbnMuZW5hYmxlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gdHJ1ZTtcbiAgICAgICAgZW5hYmxlZCA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucztcbiAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZpbHRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIHRoaXMuX2NsZWFuKCk7XG4gIH1cblxuXG4gIHNldE1vZHVsZU9wdGlvbnMobW9kdWxlT3B0aW9ucykge1xuICAgIHRoaXMubW9kdWxlT3B0aW9ucyA9IG1vZHVsZU9wdGlvbnM7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgICB9XG4gICAgICB0aGlzLl9jcmVhdGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFsbCBET00gZWxlbWVudHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGUoKSB7XG4gICAgdGhpcy5fY2xlYW4oKTtcbiAgICB0aGlzLmNoYW5nZWRPcHRpb25zID0gW107XG5cbiAgICBsZXQgZmlsdGVyID0gdGhpcy5vcHRpb25zLmZpbHRlcjtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgbGV0IHNob3cgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBvcHRpb24gaW4gdGhpcy5jb25maWd1cmVPcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5jb25maWd1cmVPcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcbiAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG4gICAgICAgIHNob3cgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzaG93ID0gZmlsdGVyKG9wdGlvbixbXSk7XG4gICAgICAgICAgc2hvdyA9IHNob3cgfHwgdGhpcy5faGFuZGxlT2JqZWN0KHRoaXMuY29uZmlndXJlT3B0aW9uc1tvcHRpb25dLCBbb3B0aW9uXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlsdGVyID09PSB0cnVlIHx8IGZpbHRlci5pbmRleE9mKG9wdGlvbikgIT09IC0xKSB7XG4gICAgICAgICAgc2hvdyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSB0cnVlO1xuXG4gICAgICAgICAgLy8gbGluZWJyZWFrIGJldHdlZW4gY2F0ZWdvcmllc1xuICAgICAgICAgIGlmIChjb3VudGVyID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbWFrZUl0ZW0oW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhIGhlYWRlciBmb3IgdGhlIGNhdGVnb3J5XG4gICAgICAgICAgdGhpcy5fbWFrZUhlYWRlcihvcHRpb24pO1xuXG4gICAgICAgICAgLy8gZ2V0IHRoZSBzdWJvcHRpb25zXG4gICAgICAgICAgdGhpcy5faGFuZGxlT2JqZWN0KHRoaXMuY29uZmlndXJlT3B0aW9uc1tvcHRpb25dLCBbb3B0aW9uXSk7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRlcisrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0J1dHRvbiA9PT0gdHJ1ZSkge1xuICAgICAgbGV0IGdlbmVyYXRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b24nO1xuICAgICAgZ2VuZXJhdGVCdXR0b24uaW5uZXJIVE1MID0gJ2dlbmVyYXRlIG9wdGlvbnMnO1xuICAgICAgZ2VuZXJhdGVCdXR0b24ub25jbGljayA9ICAgICAoKSA9PiB7dGhpcy5fcHJpbnRPcHRpb25zKCk7fTtcbiAgICAgIGdlbmVyYXRlQnV0dG9uLm9ubW91c2VvdmVyID0gKCkgPT4ge2dlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWJ1dHRvbiBob3Zlcic7fTtcbiAgICAgIGdlbmVyYXRlQnV0dG9uLm9ubW91c2VvdXQgPSAgKCkgPT4ge2dlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWJ1dHRvbic7fTtcblxuICAgICAgdGhpcy5vcHRpb25zQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctb3B0aW9uLWNvbnRhaW5lcic7XG5cbiAgICAgIHRoaXMuZG9tRWxlbWVudHMucHVzaCh0aGlzLm9wdGlvbnNDb250YWluZXIpO1xuICAgICAgdGhpcy5kb21FbGVtZW50cy5wdXNoKGdlbmVyYXRlQnV0dG9uKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wdXNoKCk7XG4gICAgdGhpcy5jb2xvclBpY2tlci5pbnNlcnRUbyh0aGlzLmNvbnRhaW5lcik7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBkcmF3IGFsbCBET00gZWxlbWVudHMgb24gdGhlIHNjcmVlblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3B1c2goKSB7XG4gICAgdGhpcy53cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy53cmFwcGVyLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbi13cmFwcGVyJztcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kb21FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3Nob3dQb3B1cElmTmVlZGVkKClcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGRlbGV0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2xlYW4oKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud3JhcHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgICAgdGhpcy53cmFwcGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmRvbUVsZW1lbnRzID0gW107XG5cbiAgICB0aGlzLl9yZW1vdmVQb3B1cCgpO1xuICB9XG5cblxuICAvKipcbiAgICogZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBhY3R1YWxPcHRpb25zIGlmIGl0IGV4aXN0c1xuICAgKiBAcGFyYW0ge2FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICogQHJldHVybnMgeyp9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0VmFsdWUocGF0aCkge1xuICAgIGxldCBiYXNlID0gdGhpcy5tb2R1bGVPcHRpb25zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGJhc2VbcGF0aFtpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBiYXNlID0gYmFzZVtwYXRoW2ldXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBiYXNlID0gdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBhbGwgb3B0aW9uIGVsZW1lbnRzIGFyZSB3cmFwcGVkIGluIGFuIGl0ZW1cbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIGRvbUVsZW1lbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFrZUl0ZW0ocGF0aCwgLi4uZG9tRWxlbWVudHMpIHtcbiAgICBpZiAodGhpcy5hbGxvd0NyZWF0aW9uID09PSB0cnVlKSB7XG4gICAgICBsZXQgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaXRlbS5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1pdGVtIHZpcy1jb25maWctcycgKyBwYXRoLmxlbmd0aDtcbiAgICAgIGRvbUVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgaXRlbS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kb21FbGVtZW50cy5wdXNoKGl0ZW0pO1xuICAgICAgcmV0dXJuIHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGhlYWRlciBmb3IgbWFqb3Igc3ViamVjdHNcbiAgICogQHBhcmFtIG5hbWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlSGVhZGVyKG5hbWUpIHtcbiAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWhlYWRlcic7XG4gICAgZGl2LmlubmVySFRNTCA9IG5hbWU7XG4gICAgdGhpcy5fbWFrZUl0ZW0oW10sZGl2KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIG1ha2UgYSBsYWJlbCwgaWYgaXQgaXMgYW4gb2JqZWN0IGxhYmVsLCBpdCBnZXRzIGRpZmZlcmVudCBzdHlsaW5nLlxuICAgKiBAcGFyYW0gbmFtZVxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcGFyYW0gb2JqZWN0TGFiZWxcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21ha2VMYWJlbChuYW1lLCBwYXRoLCBvYmplY3RMYWJlbCA9IGZhbHNlKSB7XG4gICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1sYWJlbCB2aXMtY29uZmlnLXMnICsgcGF0aC5sZW5ndGg7XG4gICAgaWYgKG9iamVjdExhYmVsID09PSB0cnVlKSB7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxpPjxiPicgKyBuYW1lICsgJzo8L2I+PC9pPic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZGl2LmlubmVySFRNTCA9IG5hbWUgKyAnOic7XG4gICAgfVxuICAgIHJldHVybiBkaXY7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBtYWtlIGEgZHJvcGRvd24gbGlzdCBmb3IgbXVsdGlwbGUgcG9zc2libGUgc3RyaW5nIG9wdG9pbnNcbiAgICogQHBhcmFtIGFyclxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlRHJvcGRvd24oYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgIGxldCBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICBzZWxlY3QuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctc2VsZWN0JztcbiAgICBsZXQgc2VsZWN0ZWRWYWx1ZSA9IDA7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChhcnIuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgIHNlbGVjdGVkVmFsdWUgPSBhcnIuaW5kZXhPZih2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgIG9wdGlvbi52YWx1ZSA9IGFycltpXTtcbiAgICAgIGlmIChpID09PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9ICdzZWxlY3RlZCc7XG4gICAgICB9XG4gICAgICBvcHRpb24uaW5uZXJIVE1MID0gYXJyW2ldO1xuICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgfVxuXG4gICAgbGV0IG1lID0gdGhpcztcbiAgICBzZWxlY3Qub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7bWUuX3VwZGF0ZSh0aGlzLnZhbHVlLCBwYXRoKTt9O1xuXG4gICAgbGV0IGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGgtMV0sIHBhdGgpO1xuICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBzZWxlY3QpO1xuICB9XG5cblxuICAvKipcbiAgICogbWFrZSBhIHJhbmdlIG9iamVjdCBmb3IgbnVtZXJpYyBvcHRpb25zXG4gICAqIEBwYXJhbSBhcnJcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFrZVJhbmdlKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICBsZXQgZGVmYXVsdFZhbHVlID0gYXJyWzBdO1xuICAgIGxldCBtaW4gPSBhcnJbMV07XG4gICAgbGV0IG1heCA9IGFyclsyXTtcbiAgICBsZXQgc3RlcCA9IGFyclszXTtcbiAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHJhbmdlLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXJhbmdlJztcbiAgICB0cnkge1xuICAgICAgcmFuZ2UudHlwZSA9ICdyYW5nZSc7IC8vIG5vdCBzdXBwb3J0ZWQgb24gSUU5XG4gICAgICByYW5nZS5taW4gPSBtaW47XG4gICAgICByYW5nZS5tYXggPSBtYXg7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHt9XG4gICAgcmFuZ2Uuc3RlcCA9IHN0ZXA7XG5cbiAgICAvLyBzZXQgdXAgdGhlIHBvcHVwIHNldHRpbmdzIGluIGNhc2UgdGhleSBhcmUgbmVlZGVkLlxuICAgIGxldCBwb3B1cFN0cmluZyA9ICcnO1xuICAgIGxldCBwb3B1cFZhbHVlID0gMDtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgZmFjdG9yID0gMS4yMDtcbiAgICAgIGlmICh2YWx1ZSA8IDAgJiYgdmFsdWUgKiBmYWN0b3IgPCBtaW4pIHtcbiAgICAgICAgcmFuZ2UubWluID0gTWF0aC5jZWlsKHZhbHVlICogZmFjdG9yKTtcbiAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1pbjtcbiAgICAgICAgcG9wdXBTdHJpbmcgPSAncmFuZ2UgaW5jcmVhc2VkJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhbHVlIC8gZmFjdG9yIDwgbWluKSB7XG4gICAgICAgIHJhbmdlLm1pbiA9IE1hdGguY2VpbCh2YWx1ZSAvIGZhY3Rvcik7XG4gICAgICAgIHBvcHVwVmFsdWUgPSByYW5nZS5taW47XG4gICAgICAgIHBvcHVwU3RyaW5nID0gJ3JhbmdlIGluY3JlYXNlZCc7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgKiBmYWN0b3IgPiBtYXggJiYgbWF4ICE9PSAxKSB7XG4gICAgICAgIHJhbmdlLm1heCA9IE1hdGguY2VpbCh2YWx1ZSAqIGZhY3Rvcik7XG4gICAgICAgIHBvcHVwVmFsdWUgPSByYW5nZS5tYXg7XG4gICAgICAgIHBvcHVwU3RyaW5nID0gJ3JhbmdlIGluY3JlYXNlZCc7XG4gICAgICB9XG4gICAgICByYW5nZS52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJhbmdlLnZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIGxldCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgaW5wdXQuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctcmFuZ2VpbnB1dCc7XG4gICAgaW5wdXQudmFsdWUgPSByYW5nZS52YWx1ZTtcblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgcmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7aW5wdXQudmFsdWUgPSB0aGlzLnZhbHVlOyBtZS5fdXBkYXRlKE51bWJlcih0aGlzLnZhbHVlKSwgcGF0aCk7fTtcbiAgICByYW5nZS5vbmlucHV0ICA9IGZ1bmN0aW9uICgpIHtpbnB1dC52YWx1ZSA9IHRoaXMudmFsdWU7IH07XG5cbiAgICBsZXQgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aC0xXSwgcGF0aCk7XG4gICAgbGV0IGl0ZW1JbmRleCA9IHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCByYW5nZSwgaW5wdXQpO1xuXG4gICAgLy8gaWYgYSBwb3B1cCBpcyBuZWVkZWQgQU5EIGl0IGhhcyBub3QgYmVlbiBzaG93biBmb3IgdGhpcyB2YWx1ZSwgc2hvdyBpdC5cbiAgICBpZiAocG9wdXBTdHJpbmcgIT09ICcnICYmIHRoaXMucG9wdXBIaXN0b3J5W2l0ZW1JbmRleF0gIT09IHBvcHVwVmFsdWUpIHtcbiAgICAgIHRoaXMucG9wdXBIaXN0b3J5W2l0ZW1JbmRleF0gPSBwb3B1cFZhbHVlO1xuICAgICAgdGhpcy5fc2V0dXBQb3B1cChwb3B1cFN0cmluZywgaXRlbUluZGV4KTtcbiAgICB9XG5cbiAgfVxuXG5cbiAgLyoqXG4gICAqIHByZXBhcmUgdGhlIHBvcHVwXG4gICAqIEBwYXJhbSBzdHJpbmdcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBQb3B1cChzdHJpbmcsIGluZGV4KSB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgPT09IHRydWUgJiYgdGhpcy5hbGxvd0NyZWF0aW9uID09PSB0cnVlICYmIHRoaXMucG9wdXBDb3VudGVyIDwgdGhpcy5wb3B1cExpbWl0KSB7XG4gICAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5pZCA9IFwidmlzLWNvbmZpZ3VyYXRpb24tcG9wdXBcIjtcbiAgICAgIGRpdi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uLXBvcHVwXCI7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gc3RyaW5nO1xuICAgICAgZGl2Lm9uY2xpY2sgPSAoKSA9PiB7dGhpcy5fcmVtb3ZlUG9wdXAoKX07XG4gICAgICB0aGlzLnBvcHVwQ291bnRlciArPSAxO1xuICAgICAgdGhpcy5wb3B1cERpdiA9IHtodG1sOmRpdiwgaW5kZXg6aW5kZXh9O1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIHJlbW92ZSB0aGUgcG9wdXAgZnJvbSB0aGUgZG9tXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVtb3ZlUG9wdXAoKSB7XG4gICAgaWYgKHRoaXMucG9wdXBEaXYuaHRtbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucG9wdXBEaXYuaGlkZVRpbWVvdXQpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucG9wdXBEaXYuZGVsZXRlVGltZW91dCk7XG4gICAgICB0aGlzLnBvcHVwRGl2ID0ge307XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogU2hvdyB0aGUgcG9wdXAgaWYgaXQgaXMgbmVlZGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Nob3dQb3B1cElmTmVlZGVkKCkge1xuICAgIGlmICh0aGlzLnBvcHVwRGl2Lmh0bWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IGNvcnJlc3BvbmRpbmdFbGVtZW50ID0gdGhpcy5kb21FbGVtZW50c1t0aGlzLnBvcHVwRGl2LmluZGV4XTtcbiAgICAgIGxldCByZWN0ID0gY29ycmVzcG9uZGluZ0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwuc3R5bGUubGVmdCA9IHJlY3QubGVmdCArIFwicHhcIjtcbiAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5zdHlsZS50b3AgPSByZWN0LnRvcCAtIDMwICsgXCJweFwiOyAvLyAzMCBpcyB0aGUgaGVpZ2h0O1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpXG4gICAgICB0aGlzLnBvcHVwRGl2LmhpZGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIH0sMTUwMCk7XG4gICAgICB0aGlzLnBvcHVwRGl2LmRlbGV0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlUG9wdXAoKTtcbiAgICAgIH0sMTgwMClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogbWFrZSBhIGNoZWNrYm94IGZvciBib29sZWFuIG9wdGlvbnMuXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWVcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFrZUNoZWNrYm94KGRlZmF1bHRWYWx1ZSwgdmFsdWUsIHBhdGgpIHtcbiAgICB2YXIgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGNoZWNrYm94LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgIGNoZWNrYm94LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNoZWNrYm94JztcbiAgICBjaGVja2JveC5jaGVja2VkID0gZGVmYXVsdFZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjaGVja2JveC5jaGVja2VkID0gdmFsdWU7XG4gICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZS5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe3BhdGg6cGF0aCwgdmFsdWU6dmFsdWV9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtwYXRoOnBhdGgsIHZhbHVlOnZhbHVlfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbWUgPSB0aGlzO1xuICAgIGNoZWNrYm94Lm9uY2hhbmdlID0gZnVuY3Rpb24oKSB7bWUuX3VwZGF0ZSh0aGlzLmNoZWNrZWQsIHBhdGgpfTtcblxuICAgIGxldCBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoKTtcbiAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgY2hlY2tib3gpO1xuICB9XG5cbiAgLyoqXG4gICAqIG1ha2UgYSB0ZXh0IGlucHV0IGZpZWxkIGZvciBzdHJpbmcgb3B0aW9ucy5cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZVxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlVGV4dElucHV0KGRlZmF1bHRWYWx1ZSwgdmFsdWUsIHBhdGgpIHtcbiAgICB2YXIgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGNoZWNrYm94LnR5cGUgPSAndGV4dCc7XG4gICAgY2hlY2tib3guY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctdGV4dCc7XG4gICAgY2hlY2tib3gudmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtwYXRoOnBhdGgsIHZhbHVlOnZhbHVlfSk7XG4gICAgfVxuXG4gICAgbGV0IG1lID0gdGhpcztcbiAgICBjaGVja2JveC5vbmNoYW5nZSA9IGZ1bmN0aW9uKCkge21lLl91cGRhdGUodGhpcy52YWx1ZSwgcGF0aCl9O1xuXG4gICAgbGV0IGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGgtMV0sIHBhdGgpO1xuICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBjaGVja2JveCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBtYWtlIGEgY29sb3IgZmllbGQgd2l0aCBhIGNvbG9yIHBpY2tlciBmb3IgY29sb3IgZmllbGRzXG4gICAqIEBwYXJhbSBhcnJcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFrZUNvbG9yRmllbGQoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgIGxldCBkZWZhdWx0Q29sb3IgPSBhcnJbMV07XG4gICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvciA6IHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlICE9PSAnbm9uZScpIHtcbiAgICAgIGRpdi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jb2xvckJsb2NrJztcbiAgICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBkaXYuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY29sb3JCbG9jayBub25lJztcbiAgICB9XG5cbiAgICB2YWx1ZSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyBkZWZhdWx0Q29sb3IgOiB2YWx1ZTtcbiAgICBkaXYub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3Nob3dDb2xvclBpY2tlcih2YWx1ZSxkaXYscGF0aCk7XG4gICAgfTtcblxuICAgIGxldCBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoKTtcbiAgICB0aGlzLl9tYWtlSXRlbShwYXRoLGxhYmVsLCBkaXYpO1xuICB9XG5cblxuICAvKipcbiAgICogdXNlZCBieSB0aGUgY29sb3IgYnV0dG9ucyB0byBjYWxsIHRoZSBjb2xvciBwaWNrZXIuXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHBhcmFtIGRpdlxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Nob3dDb2xvclBpY2tlcih2YWx1ZSwgZGl2LCBwYXRoKSB7XG4gICAgbGV0IHJlY3QgPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGJvZHlSZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgcGlja2VyWCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGggKyA1O1xuICAgIGxldCBwaWNrZXJZID0gcmVjdC50b3AgLSBib2R5UmVjdC50b3AgKyByZWN0LmhlaWdodCArMjtcbiAgICB0aGlzLmNvbG9yUGlja2VyLnNob3cocGlja2VyWCxwaWNrZXJZKTtcbiAgICB0aGlzLmNvbG9yUGlja2VyLnNldENvbG9yKHZhbHVlKTtcbiAgICB0aGlzLmNvbG9yUGlja2VyLnNldENhbGxiYWNrKChjb2xvcikgPT4ge1xuICAgICAgbGV0IGNvbG9yU3RyaW5nID0gJ3JnYmEoJyArIGNvbG9yLnIgKyAnLCcgKyBjb2xvci5nICsgJywnICsgY29sb3IuYiArICcsJyArIGNvbG9yLmEgKyAnKSc7XG4gICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3JTdHJpbmc7XG4gICAgICB0aGlzLl91cGRhdGUoY29sb3JTdHJpbmcscGF0aCk7XG4gICAgfSlcbiAgfVxuXG5cbiAgLyoqXG4gICAqIHBhcnNlIGFuIG9iamVjdCBhbmQgZHJhdyB0aGUgY29ycmVjdCBpdGVtc1xuICAgKiBAcGFyYW0gb2JqXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFuZGxlT2JqZWN0KG9iaiwgcGF0aCA9IFtdLCBjaGVja09ubHkgPSBmYWxzZSkge1xuICAgIGxldCBzaG93ID0gZmFsc2U7XG4gICAgbGV0IGZpbHRlciA9IHRoaXMub3B0aW9ucy5maWx0ZXI7XG4gICAgbGV0IHZpc2libGVJblNldCA9IGZhbHNlO1xuICAgIGZvciAobGV0IHN1Yk9iaiBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoc3ViT2JqKSkge1xuICAgICAgICBzaG93ID0gdHJ1ZTtcbiAgICAgICAgbGV0IGl0ZW0gPSBvYmpbc3ViT2JqXTtcbiAgICAgICAgbGV0IG5ld1BhdGggPSB1dGlsLmNvcHlBbmRFeHRlbmRBcnJheShwYXRoLCBzdWJPYmopO1xuICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHNob3cgPSBmaWx0ZXIoc3ViT2JqLHBhdGgpO1xuXG4gICAgICAgICAgLy8gaWYgbmVlZGVkIHdlIG11c3QgZ28gZGVlcGVyIGludG8gdGhlIG9iamVjdC5cbiAgICAgICAgICBpZiAoc2hvdyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBBcnJheSkgJiYgdHlwZW9mIGl0ZW0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBpdGVtICE9PSAnYm9vbGVhbicgJiYgaXRlbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgc2hvdyA9IHRoaXMuX2hhbmRsZU9iamVjdChpdGVtLCBuZXdQYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gY2hlY2tPbmx5ID09PSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB2aXNpYmxlSW5TZXQgPSB0cnVlO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuX2dldFZhbHVlKG5ld1BhdGgpO1xuXG4gICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlQXJyYXkoaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX21ha2VUZXh0SW5wdXQoaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aGlzLl9tYWtlQ2hlY2tib3goaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBjb2xsYXBzZSB0aGUgcGh5c2ljcyBvcHRpb25zIHRoYXQgYXJlIG5vdCBlbmFibGVkXG4gICAgICAgICAgICBsZXQgZHJhdyA9IHRydWU7XG4gICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKCdwaHlzaWNzJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm1vZHVsZU9wdGlvbnMucGh5c2ljcy5zb2x2ZXIgIT09IHN1Yk9iaikge1xuICAgICAgICAgICAgICAgIGRyYXcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAvLyBpbml0aWFsbHkgY29sbGFwc2Ugb3B0aW9ucyB3aXRoIGFuIGRpc2FibGVkIGVuYWJsZWQgb3B0aW9uLlxuICAgICAgICAgICAgICBpZiAoaXRlbS5lbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5hYmxlZFBhdGggPSB1dGlsLmNvcHlBbmRFeHRlbmRBcnJheShuZXdQYXRoLCAnZW5hYmxlZCcpO1xuICAgICAgICAgICAgICAgIGxldCBlbmFibGVkVmFsdWUgPSB0aGlzLl9nZXRWYWx1ZShlbmFibGVkUGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZWRWYWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHN1Yk9iaiwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShuZXdQYXRoLCBsYWJlbCk7XG4gICAgICAgICAgICAgICAgICB2aXNpYmxlSW5TZXQgPSB0aGlzLl9oYW5kbGVPYmplY3QoaXRlbSwgbmV3UGF0aCkgfHwgdmlzaWJsZUluU2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VDaGVja2JveChpdGVtLCBlbmFibGVkVmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwoc3ViT2JqLCBuZXdQYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShuZXdQYXRoLCBsYWJlbCk7XG4gICAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgpIHx8IHZpc2libGVJblNldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2RvbnQga25vdyBob3cgdG8gaGFuZGxlJywgaXRlbSwgc3ViT2JqLCBuZXdQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZpc2libGVJblNldDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGhhbmRsZSB0aGUgYXJyYXkgdHlwZSBvZiBvcHRpb25cbiAgICogQHBhcmFtIG9wdGlvbk5hbWVcbiAgICogQHBhcmFtIGFyclxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVBcnJheShhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBhcnJbMF0gPT09ICdzdHJpbmcnICYmIGFyclswXSA9PT0gJ2NvbG9yJykge1xuICAgICAgdGhpcy5fbWFrZUNvbG9yRmllbGQoYXJyLCB2YWx1ZSwgcGF0aCk7XG4gICAgICBpZiAoYXJyWzFdICE9PSB2YWx1ZSkge3RoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7cGF0aDpwYXRoLCB2YWx1ZTp2YWx1ZX0pO31cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGFyclswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX21ha2VEcm9wZG93bihhcnIsIHZhbHVlLCBwYXRoKTtcbiAgICAgIGlmIChhcnJbMF0gIT09IHZhbHVlKSB7dGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtwYXRoOnBhdGgsIHZhbHVlOnZhbHVlfSk7fVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgYXJyWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5fbWFrZVJhbmdlKGFyciwgdmFsdWUsIHBhdGgpO1xuICAgICAgaWYgKGFyclswXSAhPT0gdmFsdWUpIHt0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe3BhdGg6cGF0aCwgdmFsdWU6TnVtYmVyKHZhbHVlKX0pO31cbiAgICB9XG4gIH1cblxuXG5cbiAgLyoqXG4gICAqIGNhbGxlZCB0byB1cGRhdGUgdGhlIG5ldHdvcmsgd2l0aCB0aGUgbmV3IHNldHRpbmdzLlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGUodmFsdWUsIHBhdGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuX2NvbnN0cnVjdE9wdGlvbnModmFsdWUscGF0aCk7XG5cbiAgICBpZiAodGhpcy5wYXJlbnQuYm9keSAmJiB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIgJiYgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyLmVtaXQpIHtcbiAgICAgIHRoaXMucGFyZW50LmJvZHkuZW1pdHRlci5lbWl0KFwiY29uZmlnQ2hhbmdlXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLnBhcmVudC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgX2NvbnN0cnVjdE9wdGlvbnModmFsdWUsIHBhdGgsIG9wdGlvbnNPYmogPSB7fSkge1xuICAgIGxldCBwb2ludGVyID0gb3B0aW9uc09iajtcblxuICAgIC8vIHdoZW4gZHJvcGRvd24gYm94ZXMgY2FuIGJlIHN0cmluZyBvciBib29sZWFuLCB3ZSB0eXBlY2FzdCBpdCBpbnRvIGNvcnJlY3QgdHlwZXNcbiAgICB2YWx1ZSA9IHZhbHVlID09PSAndHJ1ZScgID8gdHJ1ZSAgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IHZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiB2YWx1ZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0gIT09ICdnbG9iYWwnKSB7XG4gICAgICAgIGlmIChwb2ludGVyW3BhdGhbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb2ludGVyW3BhdGhbaV1dID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgIT09IHBhdGgubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyW3BhdGhbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHBvaW50ZXJbcGF0aFtpXV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uc09iajtcblxuICB9XG5cbiAgX3ByaW50T3B0aW9ucygpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHByZT52YXIgb3B0aW9ucyA9ICcgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zLCBudWxsLCAyKSArICc8L3ByZT4nO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGFuZ2VkT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fY29uc3RydWN0T3B0aW9ucyh0aGlzLmNoYW5nZWRPcHRpb25zW2ldLnZhbHVlLCB0aGlzLmNoYW5nZWRPcHRpb25zW2ldLnBhdGgsIG9wdGlvbnMpXG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlndXJhdG9yOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5sZXQgZXJyb3JGb3VuZCA9IGZhbHNlO1xubGV0IGFsbE9wdGlvbnM7XG5sZXQgcHJpbnRTdHlsZSA9ICdiYWNrZ3JvdW5kOiAjRkZlZWVlOyBjb2xvcjogI2RkMDAwMCc7XG4vKipcbiAqICBVc2VkIHRvIHZhbGlkYXRlIG9wdGlvbnMuXG4gKi9cbmNsYXNzIFZhbGlkYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICB9XG5cbiAgLyoqXG4gICAqIE1haW4gZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBwYXJhbSBzdWJPYmplY3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGUob3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgc3ViT2JqZWN0KSB7XG4gICAgZXJyb3JGb3VuZCA9IGZhbHNlO1xuICAgIGFsbE9wdGlvbnMgPSByZWZlcmVuY2VPcHRpb25zO1xuICAgIGxldCB1c2VkT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnM7XG4gICAgaWYgKHN1Yk9iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1c2VkT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnNbc3ViT2JqZWN0XTtcbiAgICB9XG4gICAgVmFsaWRhdG9yLnBhcnNlKG9wdGlvbnMsIHVzZWRPcHRpb25zLCBbXSk7XG4gICAgcmV0dXJuIGVycm9yRm91bmQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBXaWxsIHRyYXZlcnNlIGFuIG9iamVjdCByZWN1cnNpdmVseSBhbmQgY2hlY2sgZXZlcnkgdmFsdWVcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHBhcmFtIHJlZmVyZW5jZU9wdGlvbnNcbiAgICogQHBhcmFtIHBhdGhcbiAgICovXG4gIHN0YXRpYyBwYXJzZShvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKSB7XG4gICAgZm9yIChsZXQgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcbiAgICAgICAgVmFsaWRhdG9yLmNoZWNrKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogQ2hlY2sgZXZlcnkgdmFsdWUuIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGNhbGwgdGhlIHBhcnNlIGZ1bmN0aW9uIG9uIHRoYXQgb2JqZWN0LlxuICAgKiBAcGFyYW0gb3B0aW9uXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBwYXJhbSByZWZlcmVuY2VPcHRpb25zXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqL1xuICBzdGF0aWMgY2hlY2sob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKSB7XG4gICAgaWYgKHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXSA9PT0gdW5kZWZpbmVkICYmIHJlZmVyZW5jZU9wdGlvbnMuX19hbnlfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBWYWxpZGF0b3IuZ2V0U3VnZ2VzdGlvbihvcHRpb24sIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWZlcmVuY2VPcHRpb25zW29wdGlvbl0gPT09IHVuZGVmaW5lZCAmJiByZWZlcmVuY2VPcHRpb25zLl9fYW55X18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gX19hbnlfXyBpcyBhIHdpbGRjYXJkLiBBbnkgdmFsdWUgaXMgYWNjZXB0ZWQgYW5kIHdpbGwgYmUgZnVydGhlciBhbmFseXNlZCBieSByZWZlcmVuY2UuXG4gICAgICBpZiAoVmFsaWRhdG9yLmdldFR5cGUob3B0aW9uc1tvcHRpb25dKSA9PT0gJ29iamVjdCcgJiYgcmVmZXJlbmNlT3B0aW9uc1snX19hbnlfXyddLl9fdHlwZV9fICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGFueSBzdWJncm91cCBpcyBub3QgYSBwcmVkZWZpbmVkIG9iamVjdCBpbnQgaGUgY29uZmlndXJhdG9yIHdlIGRvIG5vdCBsb29rIGRlZXBlciBpbnRvIHRoZSBvYmplY3QuXG4gICAgICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsICdfX2FueV9fJywgcmVmZXJlbmNlT3B0aW9uc1snX19hbnlfXyddLl9fdHlwZV9fLCBwYXRoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBWYWxpZGF0b3IuY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCAnX19hbnlfXycsIHJlZmVyZW5jZU9wdGlvbnNbJ19fYW55X18nXSwgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gU2luY2UgYWxsIG9wdGlvbnMgaW4gdGhlIHJlZmVyZW5jZSBhcmUgb2JqZWN0cywgd2UgY2FuIGNoZWNrIHdoZXRoZXIgdGhleSBhcmUgc3VwcG9zZWQgdG8gYmUgb2JqZWN0IHRvIGxvb2sgZm9yIHRoZSBfX3R5cGVfXyBmaWVsZC5cbiAgICAgIGlmIChyZWZlcmVuY2VPcHRpb25zW29wdGlvbl0uX190eXBlX18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBpZiB0aGlzIHNob3VsZCBiZSBhbiBvYmplY3QsIHdlIGNoZWNrIGlmIHRoZSBjb3JyZWN0IHR5cGUgaGFzIGJlZW4gc3VwcGxpZWQgdG8gYWNjb3VudCBmb3Igc2hvcnRoYW5kIG9wdGlvbnMuXG4gICAgICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIG9wdGlvbiwgcmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dLl9fdHlwZV9fLCBwYXRoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBWYWxpZGF0b3IuY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBvcHRpb24sIHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXSwgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAgb3B0aW9uICAgICB8IHRoZSBvcHRpb24gcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9ICBvcHRpb25zICAgIHwgVGhlIHN1cHBsaWVkIG9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgcmVmZXJlbmNlT3B0aW9ucyAgICB8IFRoZSByZWZlcmVuY2Ugb3B0aW9ucyBjb250YWluaW5nIGFsbCBvcHRpb25zIGFuZCB0aGVpciBhbGxvd2VkIGZvcm1hdHNcbiAgICogQHBhcmFtIHtTdHJpbmd9ICByZWZlcmVuY2VPcHRpb24gICAgIHwgVXN1YWxseSB0aGlzIGlzIHRoZSBzYW1lIGFzIG9wdGlvbiwgZXhjZXB0IHdoZW4gaGFuZGxpbmcgYW4gX19hbnlfXyB0YWcuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAgcmVmT3B0aW9uVHlwZSAgICAgICB8IFRoaXMgaXMgdGhlIHR5cGUgb2JqZWN0IGZyb20gdGhlIHJlZmVyZW5jZSBvcHRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgcGF0aCAgICAgIHwgd2hlcmUgaW4gdGhlIG9iamVjdCBpcyB0aGUgb3B0aW9uXG4gICAqL1xuICBzdGF0aWMgY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCByZWZlcmVuY2VPcHRpb24sIHJlZk9wdGlvbk9iaiwgcGF0aCkge1xuICAgIGxldCBvcHRpb25UeXBlID0gVmFsaWRhdG9yLmdldFR5cGUob3B0aW9uc1tvcHRpb25dKTtcbiAgICBsZXQgcmVmT3B0aW9uVHlwZSA9IHJlZk9wdGlvbk9ialtvcHRpb25UeXBlXTtcbiAgICBpZiAocmVmT3B0aW9uVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBpZiB0aGUgdHlwZSBpcyBjb3JyZWN0LCB3ZSBjaGVjayBpZiBpdCBpcyBzdXBwb3NlZCB0byBiZSBvbmUgb2YgYSBmZXcgc2VsZWN0IHZhbHVlc1xuICAgICAgaWYgKFZhbGlkYXRvci5nZXRUeXBlKHJlZk9wdGlvblR5cGUpID09PSAnYXJyYXknKSB7XG4gICAgICAgIGlmIChyZWZPcHRpb25UeXBlLmluZGV4T2Yob3B0aW9uc1tvcHRpb25dKSA9PT0gLTEpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnJWNJbnZhbGlkIG9wdGlvbiBkZXRlY3RlZCBpbiBcIicgKyBvcHRpb24gKyAnXCIuJyArXG4gICAgICAgICAgICAnIEFsbG93ZWQgdmFsdWVzIGFyZTonICsgVmFsaWRhdG9yLnByaW50KHJlZk9wdGlvblR5cGUpICsgJyBub3QgXCInICsgb3B0aW9uc1tvcHRpb25dICsgJ1wiLiAnICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSwgcHJpbnRTdHlsZSk7XG4gICAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9uVHlwZSA9PT0gJ29iamVjdCcgJiYgcmVmZXJlbmNlT3B0aW9uICE9PSBcIl9fYW55X19cIikge1xuICAgICAgICAgIHBhdGggPSB1dGlsLmNvcHlBbmRFeHRlbmRBcnJheShwYXRoLCBvcHRpb24pO1xuICAgICAgICAgIFZhbGlkYXRvci5wYXJzZShvcHRpb25zW29wdGlvbl0sIHJlZmVyZW5jZU9wdGlvbnNbcmVmZXJlbmNlT3B0aW9uXSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wdGlvblR5cGUgPT09ICdvYmplY3QnICYmIHJlZmVyZW5jZU9wdGlvbiAhPT0gXCJfX2FueV9fXCIpIHtcbiAgICAgICAgcGF0aCA9IHV0aWwuY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wdGlvbik7XG4gICAgICAgIFZhbGlkYXRvci5wYXJzZShvcHRpb25zW29wdGlvbl0sIHJlZmVyZW5jZU9wdGlvbnNbcmVmZXJlbmNlT3B0aW9uXSwgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZk9wdGlvbk9ialsnYW55J10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gdHlwZSBvZiB0aGUgZmllbGQgaXMgaW5jb3JyZWN0IGFuZCB0aGUgZmllbGQgY2Fubm90IGJlIGFueVxuICAgICAgY29uc29sZS5sb2coJyVjSW52YWxpZCB0eXBlIHJlY2VpdmVkIGZvciBcIicgKyBvcHRpb24gKyAnXCIuIEV4cGVjdGVkOiAnICsgVmFsaWRhdG9yLnByaW50KE9iamVjdC5rZXlzKHJlZk9wdGlvbk9iaikpICsgJy4gUmVjZWl2ZWQgWycgKyBvcHRpb25UeXBlICsgJ10gXCInICsgb3B0aW9uc1tvcHRpb25dICsgJ1wiJyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbiksIHByaW50U3R5bGUpO1xuICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgfVxuICB9XG5cblxuICBzdGF0aWMgZ2V0VHlwZShvYmplY3QpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmplY3Q7XG5cbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm5vZGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICdkb20nO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5faXNBTW9tZW50T2JqZWN0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAnbW9tZW50JztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzdGF0aWMgZ2V0U3VnZ2VzdGlvbihvcHRpb24sIG9wdGlvbnMsIHBhdGgpIHtcbiAgICBsZXQgbG9jYWxTZWFyY2ggPSBWYWxpZGF0b3IuZmluZEluT3B0aW9ucyhvcHRpb24sb3B0aW9ucyxwYXRoLGZhbHNlKTtcbiAgICBsZXQgZ2xvYmFsU2VhcmNoID0gVmFsaWRhdG9yLmZpbmRJbk9wdGlvbnMob3B0aW9uLGFsbE9wdGlvbnMsW10sdHJ1ZSk7XG5cbiAgICBsZXQgbG9jYWxTZWFyY2hUaHJlc2hvbGQgPSA4O1xuICAgIGxldCBnbG9iYWxTZWFyY2hUaHJlc2hvbGQgPSA0O1xuXG4gICAgaWYgKGxvY2FsU2VhcmNoLmluZGV4TWF0Y2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5sb2coJyVjVW5rbm93biBvcHRpb24gZGV0ZWN0ZWQ6IFwiJyArIG9wdGlvbiArICdcIiBpbiAnICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uLCcnKSArICdQZXJoYXBzIGl0IHdhcyBpbmNvbXBsZXRlPyBEaWQgeW91IG1lYW46IFwiJyArIGxvY2FsU2VhcmNoLmluZGV4TWF0Y2ggKyAnXCI/XFxuXFxuJywgcHJpbnRTdHlsZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGdsb2JhbFNlYXJjaC5kaXN0YW5jZSA8PSBnbG9iYWxTZWFyY2hUaHJlc2hvbGQgJiYgbG9jYWxTZWFyY2guZGlzdGFuY2UgPiBnbG9iYWxTZWFyY2guZGlzdGFuY2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKCclY1Vua25vd24gb3B0aW9uIGRldGVjdGVkOiBcIicgKyBvcHRpb24gKyAnXCIgaW4gJyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwnJykgKyAnUGVyaGFwcyBpdCB3YXMgbWlzcGxhY2VkPyBNYXRjaGluZyBvcHRpb24gZm91bmQgYXQ6ICcgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihnbG9iYWxTZWFyY2gucGF0aCwgZ2xvYmFsU2VhcmNoLmNsb3Nlc3RNYXRjaCwnJyksIHByaW50U3R5bGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb2NhbFNlYXJjaC5kaXN0YW5jZSA8PSBsb2NhbFNlYXJjaFRocmVzaG9sZCkge1xuICAgICAgY29uc29sZS5sb2coJyVjVW5rbm93biBvcHRpb24gZGV0ZWN0ZWQ6IFwiJyArIG9wdGlvbiArICdcIi4gRGlkIHlvdSBtZWFuIFwiJyArIGxvY2FsU2VhcmNoLmNsb3Nlc3RNYXRjaCArICdcIj8nICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uKSwgcHJpbnRTdHlsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJyVjVW5rbm93biBvcHRpb24gZGV0ZWN0ZWQ6IFwiJyArIG9wdGlvbiArICdcIi4gRGlkIHlvdSBtZWFuIG9uZSBvZiB0aGVzZTogJyArIFZhbGlkYXRvci5wcmludChPYmplY3Qua2V5cyhvcHRpb25zKSkgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pLCBwcmludFN0eWxlKTtcbiAgICB9XG5cbiAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0cmF2ZXJzZSB0aGUgb3B0aW9ucyBpbiBzZWFyY2ggZm9yIGEgbWF0Y2guXG4gICAqIEBwYXJhbSBvcHRpb25cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIHJlY3Vyc2l2ZVxuICAgKiBAcmV0dXJucyB7e2Nsb3Nlc3RNYXRjaDogc3RyaW5nLCBwYXRoOiBBcnJheSwgZGlzdGFuY2U6IG51bWJlcn19XG4gICAqL1xuICBzdGF0aWMgZmluZEluT3B0aW9ucyhvcHRpb24sIG9wdGlvbnMsIHBhdGgsIHJlY3Vyc2l2ZSA9IGZhbHNlKSB7XG4gICAgbGV0IG1pbiA9IDFlOTtcbiAgICBsZXQgY2xvc2VzdE1hdGNoID0gJyc7XG4gICAgbGV0IGNsb3Nlc3RNYXRjaFBhdGggPSBbXTtcbiAgICBsZXQgbG93ZXJDYXNlT3B0aW9uID0gb3B0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IGluZGV4TWF0Y2ggPSB1bmRlZmluZWQ7XG4gICAgZm9yIChsZXQgb3AgaW4gb3B0aW9ucykge1xuICAgICAgbGV0IGRpc3RhbmNlO1xuICAgICAgaWYgKG9wdGlvbnNbb3BdLl9fdHlwZV9fICE9PSB1bmRlZmluZWQgJiYgcmVjdXJzaXZlID09PSB0cnVlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBWYWxpZGF0b3IuZmluZEluT3B0aW9ucyhvcHRpb24sIG9wdGlvbnNbb3BdLCB1dGlsLmNvcHlBbmRFeHRlbmRBcnJheShwYXRoLG9wKSk7XG4gICAgICAgIGlmIChtaW4gPiByZXN1bHQuZGlzdGFuY2UpIHtcbiAgICAgICAgICBjbG9zZXN0TWF0Y2ggPSByZXN1bHQuY2xvc2VzdE1hdGNoO1xuICAgICAgICAgIGNsb3Nlc3RNYXRjaFBhdGggPSByZXN1bHQucGF0aDtcbiAgICAgICAgICBtaW4gPSByZXN1bHQuZGlzdGFuY2U7XG4gICAgICAgICAgaW5kZXhNYXRjaCA9IHJlc3VsdC5pbmRleE1hdGNoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9wLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihsb3dlckNhc2VPcHRpb24pICE9PSAtMSkge1xuICAgICAgICAgIGluZGV4TWF0Y2ggPSBvcDtcbiAgICAgICAgfVxuICAgICAgICBkaXN0YW5jZSA9IFZhbGlkYXRvci5sZXZlbnNodGVpbkRpc3RhbmNlKG9wdGlvbiwgb3ApO1xuICAgICAgICBpZiAobWluID4gZGlzdGFuY2UpIHtcbiAgICAgICAgICBjbG9zZXN0TWF0Y2ggPSBvcDtcbiAgICAgICAgICBjbG9zZXN0TWF0Y2hQYXRoID0gdXRpbC5jb3B5QXJyYXkocGF0aCk7XG4gICAgICAgICAgbWluID0gZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtjbG9zZXN0TWF0Y2g6Y2xvc2VzdE1hdGNoLCBwYXRoOmNsb3Nlc3RNYXRjaFBhdGgsIGRpc3RhbmNlOm1pbiwgaW5kZXhNYXRjaDogaW5kZXhNYXRjaH07XG4gIH1cblxuICBzdGF0aWMgcHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24sIHByZWZpeCA9ICdQcm9ibGVtIHZhbHVlIGZvdW5kIGF0OiBcXG4nKSB7XG4gICAgbGV0IHN0ciA9ICdcXG5cXG4nICsgcHJlZml4ICsgJ29wdGlvbnMgPSB7XFxuJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaSArIDE7IGorKykge1xuICAgICAgICBzdHIgKz0gJyAgJztcbiAgICAgIH1cbiAgICAgIHN0ciArPSBwYXRoW2ldICsgJzoge1xcbidcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXRoLmxlbmd0aCArIDE7IGorKykge1xuICAgICAgc3RyICs9ICcgICc7XG4gICAgfVxuICAgIHN0ciArPSBvcHRpb24gKyAnXFxuJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoICsgMTsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBhdGgubGVuZ3RoIC0gaTsgaisrKSB7XG4gICAgICAgIHN0ciArPSAnICAnO1xuICAgICAgfVxuICAgICAgc3RyICs9ICd9XFxuJ1xuICAgIH1cbiAgICByZXR1cm4gc3RyICsgJ1xcblxcbic7XG4gIH1cblxuICBzdGF0aWMgcHJpbnQob3B0aW9ucykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvcHRpb25zKS5yZXBsYWNlKC8oXFxcIil8KFxcWyl8KFxcXSl8KCxcIl9fdHlwZV9fXCIpL2csIFwiXCIpLnJlcGxhY2UoLyhcXCwpL2csICcsICcpXG4gIH1cblxuXG4gIC8vIENvbXB1dGUgdGhlIGVkaXQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3NcbiAgLy8gaHR0cDovL2VuLndpa2lib29rcy5vcmcvd2lraS9BbGdvcml0aG1fSW1wbGVtZW50YXRpb24vU3RyaW5ncy9MZXZlbnNodGVpbl9kaXN0YW5jZSNKYXZhU2NyaXB0XG4gIC8qXG4gICBDb3B5cmlnaHQgKGMpIDIwMTEgQW5kcmVpIE1hY2tlbnppZVxuXG4gICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gICAqL1xuICBzdGF0aWMgbGV2ZW5zaHRlaW5EaXN0YW5jZShhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoID09PSAwKSByZXR1cm4gYi5sZW5ndGg7XG4gICAgaWYgKGIubGVuZ3RoID09PSAwKSByZXR1cm4gYS5sZW5ndGg7XG5cbiAgICB2YXIgbWF0cml4ID0gW107XG5cbiAgICAvLyBpbmNyZW1lbnQgYWxvbmcgdGhlIGZpcnN0IGNvbHVtbiBvZiBlYWNoIHJvd1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgbWF0cml4W2ldID0gW2ldO1xuICAgIH1cblxuICAgIC8vIGluY3JlbWVudCBlYWNoIGNvbHVtbiBpbiB0aGUgZmlyc3Qgcm93XG4gICAgdmFyIGo7XG4gICAgZm9yIChqID0gMDsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICBtYXRyaXhbMF1bal0gPSBqO1xuICAgIH1cblxuICAgIC8vIEZpbGwgaW4gdGhlIHJlc3Qgb2YgdGhlIG1hdHJpeFxuICAgIGZvciAoaSA9IDE7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChqID0gMTsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChiLmNoYXJBdChpIC0gMSkgPT0gYS5jaGFyQXQoaiAtIDEpKSB7XG4gICAgICAgICAgbWF0cml4W2ldW2pdID0gbWF0cml4W2kgLSAxXVtqIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0cml4W2ldW2pdID0gTWF0aC5taW4obWF0cml4W2kgLSAxXVtqIC0gMV0gKyAxLCAvLyBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgIE1hdGgubWluKG1hdHJpeFtpXVtqIC0gMV0gKyAxLCAvLyBpbnNlcnRpb25cbiAgICAgICAgICAgICAgbWF0cml4W2kgLSAxXVtqXSArIDEpKTsgLy8gZGVsZXRpb25cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRyaXhbYi5sZW5ndGhdW2EubGVuZ3RoXTtcbiAgfVxuXG47XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgVmFsaWRhdG9yO1xuZXhwb3J0IHtwcmludFN0eWxlfSIsInZhciBFbWl0dGVyID0gcmVxdWlyZSgnZW1pdHRlci1jb21wb25lbnQnKTtcbnZhciBIYW1tZXIgPSByZXF1aXJlKCcuLi9tb2R1bGUvaGFtbWVyJyk7XG52YXIgaGFtbWVyVXRpbCA9IHJlcXVpcmUoJy4uL2hhbW1lclV0aWwnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIERhdGFTZXQgPSByZXF1aXJlKCcuLi9EYXRhU2V0Jyk7XG52YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuLi9EYXRhVmlldycpO1xudmFyIFJhbmdlID0gcmVxdWlyZSgnLi9SYW5nZScpO1xudmFyIEl0ZW1TZXQgPSByZXF1aXJlKCcuL2NvbXBvbmVudC9JdGVtU2V0Jyk7XG52YXIgVGltZUF4aXMgPSByZXF1aXJlKCcuL2NvbXBvbmVudC9UaW1lQXhpcycpO1xudmFyIEFjdGl2YXRvciA9IHJlcXVpcmUoJy4uL3NoYXJlZC9BY3RpdmF0b3InKTtcbnZhciBEYXRlVXRpbCA9IHJlcXVpcmUoJy4vRGF0ZVV0aWwnKTtcbnZhciBDdXN0b21UaW1lID0gcmVxdWlyZSgnLi9jb21wb25lbnQvQ3VzdG9tVGltZScpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHRpbWVsaW5lIHZpc3VhbGl6YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb3JlICgpIHt9XG5cbi8vIHR1cm4gQ29yZSBpbnRvIGFuIGV2ZW50IGVtaXR0ZXJcbkVtaXR0ZXIoQ29yZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgbWFpbiBET00gZm9yIHRoZSBDb3JlOiBhIHJvb3QgcGFuZWwgY29udGFpbmluZyBsZWZ0LCByaWdodCxcbiAqIHRvcCwgYm90dG9tLCBjb250ZW50LCBhbmQgYmFja2dyb3VuZCBwYW5lbC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyICBUaGUgY29udGFpbmVyIGVsZW1lbnQgd2hlcmUgdGhlIENvcmUgd2lsbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGF0dGFjaGVkLlxuICogQHByb3RlY3RlZFxuICovXG5Db3JlLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICB0aGlzLmRvbSA9IHt9O1xuXG4gIHRoaXMuZG9tLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICB0aGlzLmRvbS5yb290ICAgICAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kVmVydGljYWwgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5sZWZ0Q29udGFpbmVyICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5yaWdodENvbnRhaW5lciAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5jZW50ZXIgICAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5sZWZ0ICAgICAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5yaWdodCAgICAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS50b3AgICAgICAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5ib3R0b20gICAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5zaGFkb3dUb3AgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5zaGFkb3dCb3R0b20gICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5zaGFkb3dUb3BMZWZ0ICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5zaGFkb3dCb3R0b21MZWZ0ICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5zaGFkb3dUb3BSaWdodCAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5zaGFkb3dCb3R0b21SaWdodCAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIHRoaXMuZG9tLnJvb3QuY2xhc3NOYW1lICAgICAgICAgICAgICAgICA9ICd2aXMtdGltZWxpbmUnO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmNsYXNzTmFtZSAgICAgICAgICAgPSAndmlzLXBhbmVsIHZpcy1iYWNrZ3JvdW5kJztcbiAgdGhpcy5kb20uYmFja2dyb3VuZFZlcnRpY2FsLmNsYXNzTmFtZSAgID0gJ3Zpcy1wYW5lbCB2aXMtYmFja2dyb3VuZCB2aXMtdmVydGljYWwnO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbC5jbGFzc05hbWUgPSAndmlzLXBhbmVsIHZpcy1iYWNrZ3JvdW5kIHZpcy1ob3Jpem9udGFsJztcbiAgdGhpcy5kb20uY2VudGVyQ29udGFpbmVyLmNsYXNzTmFtZSAgICAgID0gJ3Zpcy1wYW5lbCB2aXMtY2VudGVyJztcbiAgdGhpcy5kb20ubGVmdENvbnRhaW5lci5jbGFzc05hbWUgICAgICAgID0gJ3Zpcy1wYW5lbCB2aXMtbGVmdCc7XG4gIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyLmNsYXNzTmFtZSAgICAgICA9ICd2aXMtcGFuZWwgdmlzLXJpZ2h0JztcbiAgdGhpcy5kb20udG9wLmNsYXNzTmFtZSAgICAgICAgICAgICAgICAgID0gJ3Zpcy1wYW5lbCB2aXMtdG9wJztcbiAgdGhpcy5kb20uYm90dG9tLmNsYXNzTmFtZSAgICAgICAgICAgICAgID0gJ3Zpcy1wYW5lbCB2aXMtYm90dG9tJztcbiAgdGhpcy5kb20ubGVmdC5jbGFzc05hbWUgICAgICAgICAgICAgICAgID0gJ3Zpcy1jb250ZW50JztcbiAgdGhpcy5kb20uY2VudGVyLmNsYXNzTmFtZSAgICAgICAgICAgICAgID0gJ3Zpcy1jb250ZW50JztcbiAgdGhpcy5kb20ucmlnaHQuY2xhc3NOYW1lICAgICAgICAgICAgICAgID0gJ3Zpcy1jb250ZW50JztcbiAgdGhpcy5kb20uc2hhZG93VG9wLmNsYXNzTmFtZSAgICAgICAgICAgID0gJ3Zpcy1zaGFkb3cgdmlzLXRvcCc7XG4gIHRoaXMuZG9tLnNoYWRvd0JvdHRvbS5jbGFzc05hbWUgICAgICAgICA9ICd2aXMtc2hhZG93IHZpcy1ib3R0b20nO1xuICB0aGlzLmRvbS5zaGFkb3dUb3BMZWZ0LmNsYXNzTmFtZSAgICAgICAgPSAndmlzLXNoYWRvdyB2aXMtdG9wJztcbiAgdGhpcy5kb20uc2hhZG93Qm90dG9tTGVmdC5jbGFzc05hbWUgICAgID0gJ3Zpcy1zaGFkb3cgdmlzLWJvdHRvbSc7XG4gIHRoaXMuZG9tLnNoYWRvd1RvcFJpZ2h0LmNsYXNzTmFtZSAgICAgICA9ICd2aXMtc2hhZG93IHZpcy10b3AnO1xuICB0aGlzLmRvbS5zaGFkb3dCb3R0b21SaWdodC5jbGFzc05hbWUgICAgPSAndmlzLXNoYWRvdyB2aXMtYm90dG9tJztcblxuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmJhY2tncm91bmQpO1xuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmJhY2tncm91bmRWZXJ0aWNhbCk7XG4gIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20uYmFja2dyb3VuZEhvcml6b250YWwpO1xuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lcik7XG4gIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20ubGVmdENvbnRhaW5lcik7XG4gIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20ucmlnaHRDb250YWluZXIpO1xuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLnRvcCk7XG4gIHRoaXMuZG9tLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5kb20uYm90dG9tKTtcblxuICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uY2VudGVyKTtcbiAgdGhpcy5kb20ubGVmdENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5sZWZ0KTtcbiAgdGhpcy5kb20ucmlnaHRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20ucmlnaHQpO1xuXG4gIHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dUb3ApO1xuICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93Qm90dG9tKTtcbiAgdGhpcy5kb20ubGVmdENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dUb3BMZWZ0KTtcbiAgdGhpcy5kb20ubGVmdENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dCb3R0b21MZWZ0KTtcbiAgdGhpcy5kb20ucmlnaHRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93VG9wUmlnaHQpO1xuICB0aGlzLmRvbS5yaWdodENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5zaGFkb3dCb3R0b21SaWdodCk7XG5cbiAgdGhpcy5vbigncmFuZ2VjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVkcmF3KCk7IC8vIHRoaXMgYWxsb3dzIG92ZXJyaWRpbmcgdGhlIF9yZWRyYXcgbWV0aG9kXG4gIH0uYmluZCh0aGlzKSk7XG4gIHRoaXMub24oJ3RvdWNoJywgICAgICAgdGhpcy5fb25Ub3VjaC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5vbigncGFuJywgICAgICAgICB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKSk7XG5cbiAgdmFyIG1lID0gdGhpcztcbiAgdGhpcy5vbignY2hhbmdlJywgZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICBpZiAocHJvcGVydGllcyAmJiBwcm9wZXJ0aWVzLnF1ZXVlID09IHRydWUpIHtcbiAgICAgIC8vIHJlZHJhdyBvbmNlIG9uIG5leHQgdGlja1xuICAgICAgaWYgKCFtZS5fcmVkcmF3VGltZXIpIHtcbiAgICAgICAgbWUuX3JlZHJhd1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWUuX3JlZHJhd1RpbWVyID0gbnVsbDtcbiAgICAgICAgICBtZS5fcmVkcmF3KCk7XG4gICAgICAgIH0sIDApXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gcmVkcmF3IGltbWVkaWF0ZWx5XG4gICAgICBtZS5fcmVkcmF3KCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBjcmVhdGUgZXZlbnQgbGlzdGVuZXJzIGZvciBhbGwgaW50ZXJlc3RpbmcgZXZlbnRzLCB0aGVzZSBldmVudHMgd2lsbCBiZVxuICAvLyBlbWl0dGVkIHZpYSBlbWl0dGVyXG4gIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLmRvbS5yb290KTtcbiAgdGhpcy5oYW1tZXIuZ2V0KCdwaW5jaCcpLnNldCh7ZW5hYmxlOiB0cnVlfSk7XG4gIHRoaXMuaGFtbWVyLmdldCgncGFuJykuc2V0KHt0aHJlc2hvbGQ6NSwgZGlyZWN0aW9uOjMwfSk7IC8vIDMwIGlzIEFMTF9ESVJFQ1RJT05TIGluIGhhbW1lci5cbiAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcblxuICB2YXIgZXZlbnRzID0gW1xuICAgICd0YXAnLCAnZG91YmxldGFwJywgJ3ByZXNzJyxcbiAgICAncGluY2gnLFxuICAgICdwYW4nLCAncGFuc3RhcnQnLCAncGFubW92ZScsICdwYW5lbmQnXG4gICAgICAvLyBUT0RPOiBjbGVhbnVwXG4gICAgLy8ndG91Y2gnLCAncGluY2gnLFxuICAgIC8vJ3RhcCcsICdkb3VibGV0YXAnLCAnaG9sZCcsXG4gICAgLy8nZHJhZ3N0YXJ0JywgJ2RyYWcnLCAnZHJhZ2VuZCcsXG4gICAgLy8nbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcgLy8gRE9NTW91c2VTY3JvbGwgaXMgbmVlZGVkIGZvciBGaXJlZm94XG4gIF07XG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAobWUuaXNBY3RpdmUoKSkge1xuICAgICAgICBtZS5lbWl0KHR5cGUsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1lLmhhbW1lci5vbih0eXBlLCBsaXN0ZW5lcik7XG4gICAgbWUubGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gIH0pO1xuXG4gIC8vIGVtdWxhdGUgYSB0b3VjaCBldmVudCAoZW1pdHRlZCBiZWZvcmUgdGhlIHN0YXJ0IG9mIGEgcGFuLCBwaW5jaCwgdGFwLCBvciBwcmVzcylcbiAgaGFtbWVyVXRpbC5vblRvdWNoKHRoaXMuaGFtbWVyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBtZS5lbWl0KCd0b3VjaCcsIGV2ZW50KTtcbiAgfS5iaW5kKHRoaXMpKTtcblxuICAvLyBlbXVsYXRlIGEgcmVsZWFzZSBldmVudCAoZW1pdHRlZCBhZnRlciBhIHBhbiwgcGluY2gsIHRhcCwgb3IgcHJlc3MpXG4gIGhhbW1lclV0aWwub25SZWxlYXNlKHRoaXMuaGFtbWVyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBtZS5lbWl0KCdyZWxlYXNlJywgZXZlbnQpO1xuICB9LmJpbmQodGhpcykpO1xuXG4gIGZ1bmN0aW9uIG9uTW91c2VXaGVlbChldmVudCkge1xuICAgIGlmIChtZS5pc0FjdGl2ZSgpKSB7XG4gICAgICBtZS5lbWl0KCdtb3VzZXdoZWVsJywgZXZlbnQpO1xuICAgIH1cbiAgfVxuICB0aGlzLmRvbS5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBvbk1vdXNlV2hlZWwpO1xuICB0aGlzLmRvbS5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgb25Nb3VzZVdoZWVsKTtcblxuICAvLyBzaXplIHByb3BlcnRpZXMgb2YgZWFjaCBvZiB0aGUgcGFuZWxzXG4gIHRoaXMucHJvcHMgPSB7XG4gICAgcm9vdDoge30sXG4gICAgYmFja2dyb3VuZDoge30sXG4gICAgY2VudGVyQ29udGFpbmVyOiB7fSxcbiAgICBsZWZ0Q29udGFpbmVyOiB7fSxcbiAgICByaWdodENvbnRhaW5lcjoge30sXG4gICAgY2VudGVyOiB7fSxcbiAgICBsZWZ0OiB7fSxcbiAgICByaWdodDoge30sXG4gICAgdG9wOiB7fSxcbiAgICBib3R0b206IHt9LFxuICAgIGJvcmRlcjoge30sXG4gICAgc2Nyb2xsVG9wOiAwLFxuICAgIHNjcm9sbFRvcE1pbjogMFxuICB9O1xuXG4gIHRoaXMuY3VzdG9tVGltZXMgPSBbXTtcblxuICAvLyBzdG9yZSBzdGF0ZSBpbmZvcm1hdGlvbiBuZWVkZWQgZm9yIHRvdWNoIGV2ZW50c1xuICB0aGlzLnRvdWNoID0ge307XG5cbiAgdGhpcy5yZWRyYXdDb3VudCA9IDA7XG5cbiAgLy8gYXR0YWNoIHRoZSByb290IHBhbmVsIHRvIHRoZSBwcm92aWRlZCBjb250YWluZXJcbiAgaWYgKCFjb250YWluZXIpIHRocm93IG5ldyBFcnJvcignTm8gY29udGFpbmVyIHByb3ZpZGVkJyk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5yb290KTtcbn07XG5cbi8qKlxuICogU2V0IG9wdGlvbnMuIE9wdGlvbnMgd2lsbCBiZSBwYXNzZWQgdG8gYWxsIGNvbXBvbmVudHMgbG9hZGVkIGluIHRoZSBUaW1lbGluZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gb3JpZW50YXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVydGljYWwgb3JpZW50YXRpb24gZm9yIHRoZSBUaW1lbGluZSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuIGJlICdib3R0b20nIChkZWZhdWx0KSBvciAndG9wJy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IE51bWJlcn0gd2lkdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2lkdGggZm9yIHRoZSB0aW1lbGluZSwgYSBudW1iZXIgaW4gcGl4ZWxzIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgY3NzIHN0cmluZyBsaWtlICcxMDAwcHgnIG9yICc3NSUnLiAnMTAwJScgYnkgZGVmYXVsdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IE51bWJlcn0gaGVpZ2h0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpeGVkIGhlaWdodCBmb3IgdGhlIFRpbWVsaW5lLCBhIG51bWJlciBpbiBwaXhlbHMgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBjc3Mgc3RyaW5nIGxpa2UgJzQwMHB4JyBvciAnNzUlJy4gSWYgdW5kZWZpbmVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgVGltZWxpbmUgd2lsbCBhdXRvbWF0aWNhbGx5IHNpemUgc3VjaCB0aGF0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0cyBjb250ZW50cyBmaXQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBOdW1iZXJ9IG1pbkhlaWdodFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNaW5pbXVtIGhlaWdodCBmb3IgdGhlIFRpbWVsaW5lLCBhIG51bWJlciBpbiBwaXhlbHMgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBjc3Mgc3RyaW5nIGxpa2UgJzQwMHB4JyBvciAnNzUlJy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IE51bWJlcn0gbWF4SGVpZ2h0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1heGltdW0gaGVpZ2h0IGZvciB0aGUgVGltZWxpbmUsIGEgbnVtYmVyIGluIHBpeGVscyBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGNzcyBzdHJpbmcgbGlrZSAnNDAwcHgnIG9yICc3NSUnLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyIHwgRGF0ZSB8IFN0cmluZ30gc3RhcnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RhcnQgZGF0ZSBmb3IgdGhlIHZpc2libGUgd2luZG93XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXIgfCBEYXRlIHwgU3RyaW5nfSBlbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kIGRhdGUgZm9yIHRoZSB2aXNpYmxlIHdpbmRvd1xuICovXG5Db3JlLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICAvLyBjb3B5IHRoZSBrbm93biBvcHRpb25zXG4gICAgdmFyIGZpZWxkcyA9IFtcbiAgICAgICd3aWR0aCcsICdoZWlnaHQnLCAnbWluSGVpZ2h0JywgJ21heEhlaWdodCcsICdhdXRvUmVzaXplJyxcbiAgICAgICdzdGFydCcsICdlbmQnLCAnY2xpY2tUb1VzZScsICdkYXRhQXR0cmlidXRlcycsICdoaWRkZW5EYXRlcycsXG4gICAgICAnbG9jYWxlJywgJ2xvY2FsZXMnLCAnbW9tZW50JyxcbiAgICAgICd0aHJvdHRsZVJlZHJhdydcbiAgICBdO1xuICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmICgnb3JpZW50YXRpb24nIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID0ge1xuICAgICAgICAgIGl0ZW06IG9wdGlvbnMub3JpZW50YXRpb24sXG4gICAgICAgICAgYXhpczogb3B0aW9ucy5vcmllbnRhdGlvblxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICgnaXRlbScgaW4gb3B0aW9ucy5vcmllbnRhdGlvbikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtID0gb3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnYXhpcycgaW4gb3B0aW9ucy5vcmllbnRhdGlvbikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID0gb3B0aW9ucy5vcmllbnRhdGlvbi5heGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID09PSAnYm90aCcpIHtcbiAgICAgIGlmICghdGhpcy50aW1lQXhpczIpIHtcbiAgICAgICAgdmFyIHRpbWVBeGlzMiA9IHRoaXMudGltZUF4aXMyID0gbmV3IFRpbWVBeGlzKHRoaXMuYm9keSk7XG4gICAgICAgIHRpbWVBeGlzMi5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zID8gdXRpbC5leHRlbmQoe30sIG9wdGlvbnMpIDoge307XG4gICAgICAgICAgX29wdGlvbnMub3JpZW50YXRpb24gPSAndG9wJzsgLy8gb3ZlcnJpZGUgdGhlIG9yaWVudGF0aW9uIG9wdGlvbiwgYWx3YXlzIHRvcFxuICAgICAgICAgIFRpbWVBeGlzLnByb3RvdHlwZS5zZXRPcHRpb25zLmNhbGwodGltZUF4aXMyLCBfb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKHRpbWVBeGlzMik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXMudGltZUF4aXMyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY29tcG9uZW50cy5pbmRleE9mKHRoaXMudGltZUF4aXMyKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZUF4aXMyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy50aW1lQXhpczIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBncmFwaDJkJ3MgZHJhd1BvaW50cyBpcyBhIGZ1bmN0aW9uIGRlbGVnYXRlIHRoZSBjYWxsYmFjayB0byB0aGUgb25SZW5kZXIgcHJvcGVydHlcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZHJhd1BvaW50cyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRpb25zLmRyYXdQb2ludHMgPSB7XG4gICAgICAgICAgb25SZW5kZXI6IG9wdGlvbnMuZHJhd1BvaW50c1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoJ2hpZGRlbkRhdGVzJyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgIERhdGVVdGlsLmNvbnZlcnRIaWRkZW5PcHRpb25zKHRoaXMub3B0aW9ucy5tb21lbnQsIHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLmhpZGRlbkRhdGVzKTtcbiAgICB9XG5cbiAgICBpZiAoJ2NsaWNrVG9Vc2UnIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLmNsaWNrVG9Vc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2YXRvcikge1xuICAgICAgICAgIHRoaXMuYWN0aXZhdG9yID0gbmV3IEFjdGl2YXRvcih0aGlzLmRvbS5yb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2YXRvcikge1xuICAgICAgICAgIHRoaXMuYWN0aXZhdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5hY3RpdmF0b3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJ3Nob3dDdXN0b21UaW1lJyBpbiBvcHRpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBgc2hvd0N1c3RvbVRpbWVgIGlzIGRlcHJlY2F0ZWQuIENyZWF0ZSBhIGN1c3RvbSB0aW1lIGJhciB2aWEgdGltZWxpbmUuYWRkQ3VzdG9tVGltZSh0aW1lIFssIGlkXSknKTtcbiAgICB9XG5cbiAgICAvLyBlbmFibGUvZGlzYWJsZSBhdXRvUmVzaXplXG4gICAgdGhpcy5faW5pdEF1dG9SZXNpemUoKTtcbiAgfVxuXG4gIC8vIHByb3BhZ2F0ZSBvcHRpb25zIHRvIGFsbCBjb21wb25lbnRzXG4gIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiBjb21wb25lbnQuc2V0T3B0aW9ucyhvcHRpb25zKSk7XG5cbiAgLy8gZW5hYmxlL2Rpc2FibGUgY29uZmlndXJlXG4gIGlmICgnY29uZmlndXJlJyBpbiBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZ3VyYXRvcikge1xuICAgICAgdGhpcy5jb25maWd1cmF0b3IgPSB0aGlzLl9jcmVhdGVDb25maWd1cmF0b3IoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZ3VyYXRvci5zZXRPcHRpb25zKG9wdGlvbnMuY29uZmlndXJlKTtcblxuICAgIC8vIGNvbGxlY3QgdGhlIHNldHRpbmdzIG9mIGFsbCBjb21wb25lbnRzLCBhbmQgcGFzcyB0aGVtIHRvIHRoZSBjb25maWd1cmF0aW9uIHN5c3RlbVxuICAgIHZhciBhcHBsaWVkT3B0aW9ucyA9IHV0aWwuZGVlcEV4dGVuZCh7fSwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICB1dGlsLmRlZXBFeHRlbmQoYXBwbGllZE9wdGlvbnMsIGNvbXBvbmVudC5vcHRpb25zKTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbmZpZ3VyYXRvci5zZXRNb2R1bGVPcHRpb25zKHtnbG9iYWw6IGFwcGxpZWRPcHRpb25zfSk7XG4gIH1cblxuICAvLyBvdmVycmlkZSByZWRyYXcgd2l0aCBhIHRocm90dGxlZCB2ZXJzaW9uXG4gIGlmICghdGhpcy5fb3JpZ1JlZHJhdykge1xuICAgIHRoaXMuX29yaWdSZWRyYXcgPSB0aGlzLl9yZWRyYXcuYmluZCh0aGlzKTtcbiAgfVxuICB0aGlzLl9yZWRyYXcgPSB1dGlsLnRocm90dGxlKHRoaXMuX29yaWdSZWRyYXcsIHRoaXMub3B0aW9ucy50aHJvdHRsZVJlZHJhdyk7XG5cbiAgLy8gcmVkcmF3IGV2ZXJ5dGhpbmdcbiAgdGhpcy5fcmVkcmF3KCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBUaW1lbGluZSBpcyBhY3RpdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuQ29yZS5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5hY3RpdmF0b3IgfHwgdGhpcy5hY3RpdmF0b3IuYWN0aXZlO1xufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBDb3JlLCBjbGVhbiB1cCBhbGwgRE9NIGVsZW1lbnRzIGFuZCBldmVudCBsaXN0ZW5lcnMuXG4gKi9cbkNvcmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHVuYmluZCBkYXRhc2V0c1xuICB0aGlzLnNldEl0ZW1zKG51bGwpO1xuICB0aGlzLnNldEdyb3VwcyhudWxsKTtcblxuICAvLyByZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICB0aGlzLm9mZigpO1xuXG4gIC8vIHN0b3AgY2hlY2tpbmcgZm9yIGNoYW5nZWQgc2l6ZVxuICB0aGlzLl9zdG9wQXV0b1Jlc2l6ZSgpO1xuXG4gIC8vIHJlbW92ZSBmcm9tIERPTVxuICBpZiAodGhpcy5kb20ucm9vdC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5kb20ucm9vdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLnJvb3QpO1xuICB9XG4gIHRoaXMuZG9tID0gbnVsbDtcblxuICAvLyByZW1vdmUgQWN0aXZhdG9yXG4gIGlmICh0aGlzLmFjdGl2YXRvcikge1xuICAgIHRoaXMuYWN0aXZhdG9yLmRlc3Ryb3koKTtcbiAgICBkZWxldGUgdGhpcy5hY3RpdmF0b3I7XG4gIH1cblxuICAvLyBjbGVhbnVwIGhhbW1lciB0b3VjaCBldmVudHNcbiAgZm9yICh2YXIgZXZlbnQgaW4gdGhpcy5saXN0ZW5lcnMpIHtcbiAgICBpZiAodGhpcy5saXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICBkZWxldGUgdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgIH1cbiAgfVxuICB0aGlzLmxpc3RlbmVycyA9IG51bGw7XG4gIHRoaXMuaGFtbWVyID0gbnVsbDtcblxuICAvLyBnaXZlIGFsbCBjb21wb25lbnRzIHRoZSBvcHBvcnR1bml0eSB0byBjbGVhbnVwXG4gIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiBjb21wb25lbnQuZGVzdHJveSgpKTtcblxuICB0aGlzLmJvZHkgPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFNldCBhIGN1c3RvbSB0aW1lIGJhclxuICogQHBhcmFtIHtEYXRlfSB0aW1lXG4gKiBAcGFyYW0ge251bWJlcn0gW2lkPXVuZGVmaW5lZF0gT3B0aW9uYWwgaWQgb2YgdGhlIGN1c3RvbSB0aW1lIGJhciB0byBiZSBhZGp1c3RlZC5cbiAqL1xuQ29yZS5wcm90b3R5cGUuc2V0Q3VzdG9tVGltZSA9IGZ1bmN0aW9uICh0aW1lLCBpZCkge1xuICB2YXIgY3VzdG9tVGltZXMgPSB0aGlzLmN1c3RvbVRpbWVzLmZpbHRlcihmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGlkID09PSBjb21wb25lbnQub3B0aW9ucy5pZDtcbiAgfSk7XG5cbiAgaWYgKGN1c3RvbVRpbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gY3VzdG9tIHRpbWUgYmFyIGZvdW5kIHdpdGggaWQgJyArIEpTT04uc3RyaW5naWZ5KGlkKSlcbiAgfVxuXG4gIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPiAwKSB7XG4gICAgY3VzdG9tVGltZXNbMF0uc2V0Q3VzdG9tVGltZSh0aW1lKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBjdXN0b20gdGltZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaWQ9dW5kZWZpbmVkXSAgICBJZCBvZiB0aGUgY3VzdG9tIHRpbWUgYmFyLlxuICogQHJldHVybiB7RGF0ZSB8IHVuZGVmaW5lZH0gY3VzdG9tVGltZVxuICovXG5Db3JlLnByb3RvdHlwZS5nZXRDdXN0b21UaW1lID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIGN1c3RvbVRpbWVzID0gdGhpcy5jdXN0b21UaW1lcy5maWx0ZXIoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgIHJldHVybiBjb21wb25lbnQub3B0aW9ucy5pZCA9PT0gaWQ7XG4gIH0pO1xuXG4gIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGN1c3RvbSB0aW1lIGJhciBmb3VuZCB3aXRoIGlkICcgKyBKU09OLnN0cmluZ2lmeShpZCkpXG4gIH1cbiAgcmV0dXJuIGN1c3RvbVRpbWVzWzBdLmdldEN1c3RvbVRpbWUoKTtcbn07XG5cbi8qKlxuICogU2V0IGEgY3VzdG9tIHRpdGxlIGZvciB0aGUgY3VzdG9tIHRpbWUgYmFyLlxuICogQHBhcmFtIHtTdHJpbmd9IFt0aXRsZV0gQ3VzdG9tIHRpdGxlXG4gKiBAcGFyYW0ge251bWJlcn0gW2lkPXVuZGVmaW5lZF0gICAgSWQgb2YgdGhlIGN1c3RvbSB0aW1lIGJhci5cbiAqL1xuQ29yZS5wcm90b3R5cGUuc2V0Q3VzdG9tVGltZVRpdGxlID0gZnVuY3Rpb24odGl0bGUsIGlkKSB7XG4gIHZhciBjdXN0b21UaW1lcyA9IHRoaXMuY3VzdG9tVGltZXMuZmlsdGVyKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gY29tcG9uZW50Lm9wdGlvbnMuaWQgPT09IGlkO1xuICB9KTtcblxuICBpZiAoY3VzdG9tVGltZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBjdXN0b20gdGltZSBiYXIgZm91bmQgd2l0aCBpZCAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKVxuICB9XG4gIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGN1c3RvbVRpbWVzWzBdLnNldEN1c3RvbVRpdGxlKHRpdGxlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBtZXRhIGluZm9ybWF0aW9uIGZyb20gYW4gZXZlbnQuXG4gKiBTaG91bGQgYmUgb3ZlcnJpZGRlbiBieSBjbGFzc2VzIGV4dGVuZGluZyBDb3JlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCByZWxhdGVkIGluZm9ybWF0aW9uLlxuICovXG5Db3JlLnByb3RvdHlwZS5nZXRFdmVudFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcmV0dXJuIHsgZXZlbnQ6IGV2ZW50IH07XG59O1xuXG4vKipcbiAqIEFkZCBjdXN0b20gdmVydGljYWwgYmFyXG4gKiBAcGFyYW0ge0RhdGUgfCBTdHJpbmcgfCBOdW1iZXJ9IFt0aW1lXSAgQSBEYXRlLCB1bml4IHRpbWVzdGFtcCwgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJU08gZGF0ZSBzdHJpbmcuIFRpbWUgcG9pbnQgd2hlcmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmV3IGJhciBzaG91bGQgYmUgcGxhY2VkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBwcm92aWRlZCwgYG5ldyBEYXRlKClgIHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSB1c2VkLlxuICogQHBhcmFtIHtOdW1iZXIgfCBTdHJpbmd9IFtpZD11bmRlZmluZWRdIElkIG9mIHRoZSBuZXcgYmFyLiBPcHRpb25hbFxuICogQHJldHVybiB7TnVtYmVyIHwgU3RyaW5nfSAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGlkIG9mIHRoZSBuZXcgYmFyXG4gKi9cbkNvcmUucHJvdG90eXBlLmFkZEN1c3RvbVRpbWUgPSBmdW5jdGlvbiAodGltZSwgaWQpIHtcbiAgdmFyIHRpbWVzdGFtcCA9IHRpbWUgIT09IHVuZGVmaW5lZFxuICAgICAgPyB1dGlsLmNvbnZlcnQodGltZSwgJ0RhdGUnKS52YWx1ZU9mKClcbiAgICAgIDogbmV3IERhdGUoKTtcblxuICB2YXIgZXhpc3RzID0gdGhpcy5jdXN0b21UaW1lcy5zb21lKGZ1bmN0aW9uIChjdXN0b21UaW1lKSB7XG4gICAgcmV0dXJuIGN1c3RvbVRpbWUub3B0aW9ucy5pZCA9PT0gaWQ7XG4gIH0pO1xuICBpZiAoZXhpc3RzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIGN1c3RvbSB0aW1lIHdpdGggaWQgJyArIEpTT04uc3RyaW5naWZ5KGlkKSArICcgYWxyZWFkeSBleGlzdHMnKTtcbiAgfVxuXG4gIHZhciBjdXN0b21UaW1lID0gbmV3IEN1c3RvbVRpbWUodGhpcy5ib2R5LCB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB7XG4gICAgdGltZSA6IHRpbWVzdGFtcCxcbiAgICBpZCA6IGlkXG4gIH0pKTtcblxuICB0aGlzLmN1c3RvbVRpbWVzLnB1c2goY3VzdG9tVGltZSk7XG4gIHRoaXMuY29tcG9uZW50cy5wdXNoKGN1c3RvbVRpbWUpO1xuICB0aGlzLl9yZWRyYXcoKTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBwcmV2aW91c2x5IGFkZGVkIGN1c3RvbSBiYXJcbiAqIEBwYXJhbSB7aW50fSBpZCBJRCBvZiB0aGUgY3VzdG9tIGJhciB0byBiZSByZW1vdmVkXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBiYXIgZXhpc3RzIGFuZCBpcyByZW1vdmVkLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuQ29yZS5wcm90b3R5cGUucmVtb3ZlQ3VzdG9tVGltZSA9IGZ1bmN0aW9uIChpZCkge1xuICB2YXIgY3VzdG9tVGltZXMgPSB0aGlzLmN1c3RvbVRpbWVzLmZpbHRlcihmdW5jdGlvbiAoYmFyKSB7XG4gICAgcmV0dXJuIChiYXIub3B0aW9ucy5pZCA9PT0gaWQpO1xuICB9KTtcblxuICBpZiAoY3VzdG9tVGltZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBjdXN0b20gdGltZSBiYXIgZm91bmQgd2l0aCBpZCAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKVxuICB9XG5cbiAgY3VzdG9tVGltZXMuZm9yRWFjaChmdW5jdGlvbiAoY3VzdG9tVGltZSkge1xuICAgIHRoaXMuY3VzdG9tVGltZXMuc3BsaWNlKHRoaXMuY3VzdG9tVGltZXMuaW5kZXhPZihjdXN0b21UaW1lKSwgMSk7XG4gICAgdGhpcy5jb21wb25lbnRzLnNwbGljZSh0aGlzLmNvbXBvbmVudHMuaW5kZXhPZihjdXN0b21UaW1lKSwgMSk7XG4gICAgY3VzdG9tVGltZS5kZXN0cm95KCk7XG4gIH0uYmluZCh0aGlzKSlcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGlkJ3Mgb2YgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGl0ZW1zLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgaWRzIG9mIHRoZSB2aXNpYmxlIGl0ZW1zXG4gKi9cbkNvcmUucHJvdG90eXBlLmdldFZpc2libGVJdGVtcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5nZXRWaXNpYmxlSXRlbXMoKSB8fCBbXTtcbn07XG5cbi8qKlxuICogU2V0IENvcmUgd2luZG93IHN1Y2ggdGhhdCBpdCBmaXRzIGFsbCBpdGVtc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFuaW1hdGlvbjogYm9vbGVhbiB8IHtkdXJhdGlvbjogbnVtYmVyLCBlYXNpbmdGdW5jdGlvbjogc3RyaW5nfWBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCB0byBzcGVjaWZ5IGR1cmF0aW9uIGFuZCBlYXNpbmcgZnVuY3Rpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICovXG5Db3JlLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciByYW5nZSA9IHRoaXMuZ2V0RGF0YVJhbmdlKCk7XG5cbiAgLy8gc2tpcCByYW5nZSBzZXQgaWYgdGhlcmUgaXMgbm8gbWluIGFuZCBtYXggZGF0ZVxuICBpZiAocmFuZ2UubWluID09PSBudWxsICYmIHJhbmdlLm1heCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGFwcGx5IGEgbWFyZ2luIG9mIDElIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBkYXRhXG4gIHZhciBpbnRlcnZhbCA9IHJhbmdlLm1heCAtIHJhbmdlLm1pbjtcbiAgdmFyIG1pbiA9IG5ldyBEYXRlKHJhbmdlLm1pbi52YWx1ZU9mKCkgLSBpbnRlcnZhbCAqIDAuMDEpO1xuICB2YXIgbWF4ID0gbmV3IERhdGUocmFuZ2UubWF4LnZhbHVlT2YoKSArIGludGVydmFsICogMC4wMSk7XG5cbiAgdmFyIGFuaW1hdGlvbiA9IChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5hbmltYXRpb24gOiB0cnVlO1xuICB0aGlzLnJhbmdlLnNldFJhbmdlKG1pbiwgbWF4LCBhbmltYXRpb24pO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGRhdGEgcmFuZ2Ugb2YgdGhlIGl0ZW1zIHN0YXJ0IGFuZCBlbmQgZGF0ZXNcbiAqIEByZXR1cm5zIHt7bWluOiBEYXRlIHwgbnVsbCwgbWF4OiBEYXRlIHwgbnVsbH19XG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvcmUucHJvdG90eXBlLmdldERhdGFSYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IFRpbWVsaW5lIGFuZCBHcmFwaDJkXG4gIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludm9rZSBhYnN0cmFjdCBtZXRob2QgZ2V0RGF0YVJhbmdlJyk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdmlzaWJsZSB3aW5kb3cuIEJvdGggcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwsIHlvdSBjYW4gY2hhbmdlIG9ubHlcbiAqIHN0YXJ0IG9yIG9ubHkgZW5kLiBTeW50YXg6XG4gKlxuICogICAgIFRpbWVMaW5lLnNldFdpbmRvdyhzdGFydCwgZW5kKVxuICogICAgIFRpbWVMaW5lLnNldFdpbmRvdyhzdGFydCwgZW5kLCBvcHRpb25zKVxuICogICAgIFRpbWVMaW5lLnNldFdpbmRvdyhyYW5nZSlcbiAqXG4gKiBXaGVyZSBzdGFydCBhbmQgZW5kIGNhbiBiZSBhIERhdGUsIG51bWJlciwgb3Igc3RyaW5nLCBhbmQgcmFuZ2UgaXMgYW5cbiAqIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgc3RhcnQgYW5kIGVuZC5cbiAqXG4gKiBAcGFyYW0ge0RhdGUgfCBOdW1iZXIgfCBTdHJpbmcgfCBPYmplY3R9IFtzdGFydF0gU3RhcnQgZGF0ZSBvZiB2aXNpYmxlIHdpbmRvd1xuICogQHBhcmFtIHtEYXRlIHwgTnVtYmVyIHwgU3RyaW5nfSBbZW5kXSAgICAgICAgICAgIEVuZCBkYXRlIG9mIHZpc2libGUgd2luZG93XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5pbWF0aW9uOiBib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9YFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMsIGFuZCBkZWZhdWx0IGVhc2luZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gKi9cbkNvcmUucHJvdG90eXBlLnNldFdpbmRvdyA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIG9wdGlvbnMpIHtcbiAgdmFyIGFuaW1hdGlvbjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgIHZhciByYW5nZSA9IGFyZ3VtZW50c1swXTtcbiAgICBhbmltYXRpb24gPSAocmFuZ2UuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQpID8gcmFuZ2UuYW5pbWF0aW9uIDogdHJ1ZTtcbiAgICB0aGlzLnJhbmdlLnNldFJhbmdlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGFuaW1hdGlvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgYW5pbWF0aW9uID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb24gIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmFuaW1hdGlvbiA6IHRydWU7XG4gICAgdGhpcy5yYW5nZS5zZXRSYW5nZShzdGFydCwgZW5kLCBhbmltYXRpb24pO1xuICB9XG59O1xuXG4vKipcbiAqIE1vdmUgdGhlIHdpbmRvdyBzdWNoIHRoYXQgZ2l2ZW4gdGltZSBpcyBjZW50ZXJlZCBvbiBzY3JlZW4uXG4gKiBAcGFyYW0ge0RhdGUgfCBOdW1iZXIgfCBTdHJpbmd9IHRpbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRpb246IGJvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ31gXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RobHkgdG8gdGhlIG5ldyB3aW5kb3cuIEFuIG9iamVjdCBjYW4gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzICdlYXNlSW5PdXRRdWFkJy5cbiAqL1xuQ29yZS5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24odGltZSwgb3B0aW9ucykge1xuICB2YXIgaW50ZXJ2YWwgPSB0aGlzLnJhbmdlLmVuZCAtIHRoaXMucmFuZ2Uuc3RhcnQ7XG4gIHZhciB0ID0gdXRpbC5jb252ZXJ0KHRpbWUsICdEYXRlJykudmFsdWVPZigpO1xuXG4gIHZhciBzdGFydCA9IHQgLSBpbnRlcnZhbCAvIDI7XG4gIHZhciBlbmQgPSB0ICsgaW50ZXJ2YWwgLyAyO1xuICB2YXIgYW5pbWF0aW9uID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb24gIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmFuaW1hdGlvbiA6IHRydWU7XG5cbiAgdGhpcy5yYW5nZS5zZXRSYW5nZShzdGFydCwgZW5kLCBhbmltYXRpb24pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHZpc2libGUgd2luZG93XG4gKiBAcmV0dXJuIHt7c3RhcnQ6IERhdGUsIGVuZDogRGF0ZX19ICAgVmlzaWJsZSByYW5nZVxuICovXG5Db3JlLnByb3RvdHlwZS5nZXRXaW5kb3cgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJhbmdlID0gdGhpcy5yYW5nZS5nZXRSYW5nZSgpO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBuZXcgRGF0ZShyYW5nZS5zdGFydCksXG4gICAgZW5kOiBuZXcgRGF0ZShyYW5nZS5lbmQpXG4gIH07XG59O1xuXG4vKipcbiAqIEZvcmNlIGEgcmVkcmF3LiBDYW4gYmUgb3ZlcnJpZGRlbiBieSBpbXBsZW1lbnRhdGlvbnMgb2YgQ29yZVxuICpcbiAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBvdmVycmlkZGVuIG9uIGNvbnN0cnVjdGlvbiB3aXRoIGEgdHJvdHRsZWQgdmVyc2lvblxuICovXG5Db3JlLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcmVkcmF3KCk7XG59O1xuXG4vKipcbiAqIFJlZHJhdyBmb3IgaW50ZXJuYWwgdXNlLiBSZWRyYXdzIGFsbCBjb21wb25lbnRzLiBTZWUgYWxzbyB0aGUgcHVibGljXG4gKiBtZXRob2QgcmVkcmF3LlxuICogQHByb3RlY3RlZFxuICovXG5Db3JlLnByb3RvdHlwZS5fcmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNpemVkID0gZmFsc2U7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICB2YXIgZG9tID0gdGhpcy5kb207XG5cbiAgaWYgKCFkb20pIHJldHVybjsgLy8gd2hlbiBkZXN0cm95ZWRcblxuICBEYXRlVXRpbC51cGRhdGVIaWRkZW5EYXRlcyh0aGlzLm9wdGlvbnMubW9tZW50LCB0aGlzLmJvZHksIHRoaXMub3B0aW9ucy5oaWRkZW5EYXRlcyk7XG5cbiAgLy8gdXBkYXRlIGNsYXNzIG5hbWVzXG4gIGlmIChvcHRpb25zLm9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgdXRpbC5hZGRDbGFzc05hbWUoZG9tLnJvb3QsICd2aXMtdG9wJyk7XG4gICAgdXRpbC5yZW1vdmVDbGFzc05hbWUoZG9tLnJvb3QsICd2aXMtYm90dG9tJyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdXRpbC5yZW1vdmVDbGFzc05hbWUoZG9tLnJvb3QsICd2aXMtdG9wJyk7XG4gICAgdXRpbC5hZGRDbGFzc05hbWUoZG9tLnJvb3QsICd2aXMtYm90dG9tJyk7XG4gIH1cblxuICAvLyB1cGRhdGUgcm9vdCB3aWR0aCBhbmQgaGVpZ2h0IG9wdGlvbnNcbiAgZG9tLnJvb3Quc3R5bGUubWF4SGVpZ2h0ID0gdXRpbC5vcHRpb24uYXNTaXplKG9wdGlvbnMubWF4SGVpZ2h0LCAnJyk7XG4gIGRvbS5yb290LnN0eWxlLm1pbkhlaWdodCA9IHV0aWwub3B0aW9uLmFzU2l6ZShvcHRpb25zLm1pbkhlaWdodCwgJycpO1xuICBkb20ucm9vdC5zdHlsZS53aWR0aCA9IHV0aWwub3B0aW9uLmFzU2l6ZShvcHRpb25zLndpZHRoLCAnJyk7XG5cbiAgLy8gY2FsY3VsYXRlIGJvcmRlciB3aWR0aHNcbiAgcHJvcHMuYm9yZGVyLmxlZnQgICA9IChkb20uY2VudGVyQ29udGFpbmVyLm9mZnNldFdpZHRoIC0gZG9tLmNlbnRlckNvbnRhaW5lci5jbGllbnRXaWR0aCkgLyAyO1xuICBwcm9wcy5ib3JkZXIucmlnaHQgID0gcHJvcHMuYm9yZGVyLmxlZnQ7XG4gIHByb3BzLmJvcmRlci50b3AgICAgPSAoZG9tLmNlbnRlckNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSBkb20uY2VudGVyQ29udGFpbmVyLmNsaWVudEhlaWdodCkgLyAyO1xuICBwcm9wcy5ib3JkZXIuYm90dG9tID0gcHJvcHMuYm9yZGVyLnRvcDtcbiAgdmFyIGJvcmRlclJvb3RIZWlnaHQ9IGRvbS5yb290Lm9mZnNldEhlaWdodCAtIGRvbS5yb290LmNsaWVudEhlaWdodDtcbiAgdmFyIGJvcmRlclJvb3RXaWR0aCA9IGRvbS5yb290Lm9mZnNldFdpZHRoIC0gZG9tLnJvb3QuY2xpZW50V2lkdGg7XG5cbiAgLy8gd29ya2Fyb3VuZCBmb3IgYSBidWcgaW4gSUU6IHRoZSBjbGllbnRXaWR0aCBvZiBhbiBlbGVtZW50IHdpdGhcbiAgLy8gYSBoZWlnaHQ6MHB4IGFuZCBvdmVyZmxvdzpoaWRkZW4gaXMgbm90IGNhbGN1bGF0ZWQgYW5kIGFsd2F5cyBoYXMgdmFsdWUgMFxuICBpZiAoZG9tLmNlbnRlckNvbnRhaW5lci5jbGllbnRIZWlnaHQgPT09IDApIHtcbiAgICBwcm9wcy5ib3JkZXIubGVmdCA9IHByb3BzLmJvcmRlci50b3A7XG4gICAgcHJvcHMuYm9yZGVyLnJpZ2h0ICA9IHByb3BzLmJvcmRlci5sZWZ0O1xuICB9XG4gIGlmIChkb20ucm9vdC5jbGllbnRIZWlnaHQgPT09IDApIHtcbiAgICBib3JkZXJSb290V2lkdGggPSBib3JkZXJSb290SGVpZ2h0O1xuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBoZWlnaHRzLiBJZiBhbnkgb2YgdGhlIHNpZGUgcGFuZWxzIGlzIGVtcHR5LCB3ZSBzZXQgdGhlIGhlaWdodCB0b1xuICAvLyBtaW51cyB0aGUgYm9yZGVyIHdpZHRoLCBzdWNoIHRoYXQgdGhlIGJvcmRlciB3aWxsIGJlIGludmlzaWJsZVxuICBwcm9wcy5jZW50ZXIuaGVpZ2h0ID0gZG9tLmNlbnRlci5vZmZzZXRIZWlnaHQ7XG4gIHByb3BzLmxlZnQuaGVpZ2h0ICAgPSBkb20ubGVmdC5vZmZzZXRIZWlnaHQ7XG4gIHByb3BzLnJpZ2h0LmhlaWdodCAgPSBkb20ucmlnaHQub2Zmc2V0SGVpZ2h0O1xuICBwcm9wcy50b3AuaGVpZ2h0ICAgID0gZG9tLnRvcC5jbGllbnRIZWlnaHQgICAgfHwgLXByb3BzLmJvcmRlci50b3A7XG4gIHByb3BzLmJvdHRvbS5oZWlnaHQgPSBkb20uYm90dG9tLmNsaWVudEhlaWdodCB8fCAtcHJvcHMuYm9yZGVyLmJvdHRvbTtcblxuICAvLyBUT0RPOiBjb21wZW5zYXRlIGJvcmRlcnMgd2hlbiBhbnkgb2YgdGhlIHBhbmVscyBpcyBlbXB0eS5cblxuICAvLyBhcHBseSBhdXRvIGhlaWdodFxuICAvLyBUT0RPOiBvbmx5IGNhbGN1bGF0ZSBhdXRvSGVpZ2h0IHdoZW4gbmVlZGVkIChlbHNlIHdlIGNhdXNlIGFuIGV4dHJhIHJlZmxvdy9yZXBhaW50IG9mIHRoZSBET00pXG4gIHZhciBjb250ZW50SGVpZ2h0ID0gTWF0aC5tYXgocHJvcHMubGVmdC5oZWlnaHQsIHByb3BzLmNlbnRlci5oZWlnaHQsIHByb3BzLnJpZ2h0LmhlaWdodCk7XG4gIHZhciBhdXRvSGVpZ2h0ID0gcHJvcHMudG9wLmhlaWdodCArIGNvbnRlbnRIZWlnaHQgKyBwcm9wcy5ib3R0b20uaGVpZ2h0ICtcbiAgICBib3JkZXJSb290SGVpZ2h0ICsgcHJvcHMuYm9yZGVyLnRvcCArIHByb3BzLmJvcmRlci5ib3R0b207XG4gIGRvbS5yb290LnN0eWxlLmhlaWdodCA9IHV0aWwub3B0aW9uLmFzU2l6ZShvcHRpb25zLmhlaWdodCwgYXV0b0hlaWdodCArICdweCcpO1xuXG4gIC8vIGNhbGN1bGF0ZSBoZWlnaHRzIG9mIHRoZSBjb250ZW50IHBhbmVsc1xuICBwcm9wcy5yb290LmhlaWdodCA9IGRvbS5yb290Lm9mZnNldEhlaWdodDtcbiAgcHJvcHMuYmFja2dyb3VuZC5oZWlnaHQgPSBwcm9wcy5yb290LmhlaWdodCAtIGJvcmRlclJvb3RIZWlnaHQ7XG4gIHZhciBjb250YWluZXJIZWlnaHQgPSBwcm9wcy5yb290LmhlaWdodCAtIHByb3BzLnRvcC5oZWlnaHQgLSBwcm9wcy5ib3R0b20uaGVpZ2h0IC1cbiAgICBib3JkZXJSb290SGVpZ2h0O1xuICBwcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0ICA9IGNvbnRhaW5lckhlaWdodDtcbiAgcHJvcHMubGVmdENvbnRhaW5lci5oZWlnaHQgICAgPSBjb250YWluZXJIZWlnaHQ7XG4gIHByb3BzLnJpZ2h0Q29udGFpbmVyLmhlaWdodCAgID0gcHJvcHMubGVmdENvbnRhaW5lci5oZWlnaHQ7XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSB3aWR0aHMgb2YgdGhlIHBhbmVsc1xuICBwcm9wcy5yb290LndpZHRoID0gZG9tLnJvb3Qub2Zmc2V0V2lkdGg7XG4gIHByb3BzLmJhY2tncm91bmQud2lkdGggPSBwcm9wcy5yb290LndpZHRoIC0gYm9yZGVyUm9vdFdpZHRoO1xuICBwcm9wcy5sZWZ0LndpZHRoID0gZG9tLmxlZnRDb250YWluZXIuY2xpZW50V2lkdGggICB8fCAtcHJvcHMuYm9yZGVyLmxlZnQ7XG4gIHByb3BzLmxlZnRDb250YWluZXIud2lkdGggPSBwcm9wcy5sZWZ0LndpZHRoO1xuICBwcm9wcy5yaWdodC53aWR0aCA9IGRvbS5yaWdodENvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAtcHJvcHMuYm9yZGVyLnJpZ2h0O1xuICBwcm9wcy5yaWdodENvbnRhaW5lci53aWR0aCA9IHByb3BzLnJpZ2h0LndpZHRoO1xuICB2YXIgY2VudGVyV2lkdGggPSBwcm9wcy5yb290LndpZHRoIC0gcHJvcHMubGVmdC53aWR0aCAtIHByb3BzLnJpZ2h0LndpZHRoIC0gYm9yZGVyUm9vdFdpZHRoO1xuICBwcm9wcy5jZW50ZXIud2lkdGggICAgICAgICAgPSBjZW50ZXJXaWR0aDtcbiAgcHJvcHMuY2VudGVyQ29udGFpbmVyLndpZHRoID0gY2VudGVyV2lkdGg7XG4gIHByb3BzLnRvcC53aWR0aCAgICAgICAgICAgICA9IGNlbnRlcldpZHRoO1xuICBwcm9wcy5ib3R0b20ud2lkdGggICAgICAgICAgPSBjZW50ZXJXaWR0aDtcblxuICAvLyByZXNpemUgdGhlIHBhbmVsc1xuICBkb20uYmFja2dyb3VuZC5zdHlsZS5oZWlnaHQgICAgICAgICAgID0gcHJvcHMuYmFja2dyb3VuZC5oZWlnaHQgKyAncHgnO1xuICBkb20uYmFja2dyb3VuZFZlcnRpY2FsLnN0eWxlLmhlaWdodCAgID0gcHJvcHMuYmFja2dyb3VuZC5oZWlnaHQgKyAncHgnO1xuICBkb20uYmFja2dyb3VuZEhvcml6b250YWwuc3R5bGUuaGVpZ2h0ID0gcHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCArICdweCc7XG4gIGRvbS5jZW50ZXJDb250YWluZXIuc3R5bGUuaGVpZ2h0ICAgICAgPSBwcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0ICsgJ3B4JztcbiAgZG9tLmxlZnRDb250YWluZXIuc3R5bGUuaGVpZ2h0ICAgICAgICA9IHByb3BzLmxlZnRDb250YWluZXIuaGVpZ2h0ICsgJ3B4JztcbiAgZG9tLnJpZ2h0Q29udGFpbmVyLnN0eWxlLmhlaWdodCAgICAgICA9IHByb3BzLnJpZ2h0Q29udGFpbmVyLmhlaWdodCArICdweCc7XG5cbiAgZG9tLmJhY2tncm91bmQuc3R5bGUud2lkdGggICAgICAgICAgICA9IHByb3BzLmJhY2tncm91bmQud2lkdGggKyAncHgnO1xuICBkb20uYmFja2dyb3VuZFZlcnRpY2FsLnN0eWxlLndpZHRoICAgID0gcHJvcHMuY2VudGVyQ29udGFpbmVyLndpZHRoICsgJ3B4JztcbiAgZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLnN0eWxlLndpZHRoICA9IHByb3BzLmJhY2tncm91bmQud2lkdGggKyAncHgnO1xuICBkb20uY2VudGVyQ29udGFpbmVyLnN0eWxlLndpZHRoICAgICAgID0gcHJvcHMuY2VudGVyLndpZHRoICsgJ3B4JztcbiAgZG9tLnRvcC5zdHlsZS53aWR0aCAgICAgICAgICAgICAgICAgICA9IHByb3BzLnRvcC53aWR0aCArICdweCc7XG4gIGRvbS5ib3R0b20uc3R5bGUud2lkdGggICAgICAgICAgICAgICAgPSBwcm9wcy5ib3R0b20ud2lkdGggKyAncHgnO1xuXG4gIC8vIHJlcG9zaXRpb24gdGhlIHBhbmVsc1xuICBkb20uYmFja2dyb3VuZC5zdHlsZS5sZWZ0ICAgICAgICAgICA9ICcwJztcbiAgZG9tLmJhY2tncm91bmQuc3R5bGUudG9wICAgICAgICAgICAgPSAnMCc7XG4gIGRvbS5iYWNrZ3JvdW5kVmVydGljYWwuc3R5bGUubGVmdCAgID0gKHByb3BzLmxlZnQud2lkdGggKyBwcm9wcy5ib3JkZXIubGVmdCkgKyAncHgnO1xuICBkb20uYmFja2dyb3VuZFZlcnRpY2FsLnN0eWxlLnRvcCAgICA9ICcwJztcbiAgZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLnN0eWxlLmxlZnQgPSAnMCc7XG4gIGRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbC5zdHlsZS50b3AgID0gcHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gIGRvbS5jZW50ZXJDb250YWluZXIuc3R5bGUubGVmdCAgICAgID0gcHJvcHMubGVmdC53aWR0aCArICdweCc7XG4gIGRvbS5jZW50ZXJDb250YWluZXIuc3R5bGUudG9wICAgICAgID0gcHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gIGRvbS5sZWZ0Q29udGFpbmVyLnN0eWxlLmxlZnQgICAgICAgID0gJzAnO1xuICBkb20ubGVmdENvbnRhaW5lci5zdHlsZS50b3AgICAgICAgICA9IHByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICBkb20ucmlnaHRDb250YWluZXIuc3R5bGUubGVmdCAgICAgICA9IChwcm9wcy5sZWZ0LndpZHRoICsgcHJvcHMuY2VudGVyLndpZHRoKSArICdweCc7XG4gIGRvbS5yaWdodENvbnRhaW5lci5zdHlsZS50b3AgICAgICAgID0gcHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gIGRvbS50b3Auc3R5bGUubGVmdCAgICAgICAgICAgICAgICAgID0gcHJvcHMubGVmdC53aWR0aCArICdweCc7XG4gIGRvbS50b3Auc3R5bGUudG9wICAgICAgICAgICAgICAgICAgID0gJzAnO1xuICBkb20uYm90dG9tLnN0eWxlLmxlZnQgICAgICAgICAgICAgICA9IHByb3BzLmxlZnQud2lkdGggKyAncHgnO1xuICBkb20uYm90dG9tLnN0eWxlLnRvcCAgICAgICAgICAgICAgICA9IChwcm9wcy50b3AuaGVpZ2h0ICsgcHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCkgKyAncHgnO1xuXG4gIC8vIHVwZGF0ZSB0aGUgc2Nyb2xsVG9wLCBmZWFzaWJsZSByYW5nZSBmb3IgdGhlIG9mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAvLyB3aGVuIHRoZSBoZWlnaHQgb2YgdGhlIENvcmUgb3Igb2YgdGhlIGNvbnRlbnRzIG9mIHRoZSBjZW50ZXIgY2hhbmdlZFxuICB0aGlzLl91cGRhdGVTY3JvbGxUb3AoKTtcblxuICAvLyByZXBvc2l0aW9uIHRoZSBzY3JvbGxhYmxlIGNvbnRlbnRzXG4gIHZhciBvZmZzZXQgPSB0aGlzLnByb3BzLnNjcm9sbFRvcDtcbiAgaWYgKG9wdGlvbnMub3JpZW50YXRpb24uaXRlbSAhPSAndG9wJykge1xuICAgIG9mZnNldCArPSBNYXRoLm1heCh0aGlzLnByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgLSB0aGlzLnByb3BzLmNlbnRlci5oZWlnaHQgLVxuICAgICAgdGhpcy5wcm9wcy5ib3JkZXIudG9wIC0gdGhpcy5wcm9wcy5ib3JkZXIuYm90dG9tLCAwKTtcbiAgfVxuICBkb20uY2VudGVyLnN0eWxlLmxlZnQgPSAnMCc7XG4gIGRvbS5jZW50ZXIuc3R5bGUudG9wICA9IG9mZnNldCArICdweCc7XG4gIGRvbS5sZWZ0LnN0eWxlLmxlZnQgICA9ICcwJztcbiAgZG9tLmxlZnQuc3R5bGUudG9wICAgID0gb2Zmc2V0ICsgJ3B4JztcbiAgZG9tLnJpZ2h0LnN0eWxlLmxlZnQgID0gJzAnO1xuICBkb20ucmlnaHQuc3R5bGUudG9wICAgPSBvZmZzZXQgKyAncHgnO1xuXG4gIC8vIHNob3cgc2hhZG93cyB3aGVuIHZlcnRpY2FsIHNjcm9sbGluZyBpcyBhdmFpbGFibGVcbiAgdmFyIHZpc2liaWxpdHlUb3AgPSB0aGlzLnByb3BzLnNjcm9sbFRvcCA9PSAwID8gJ2hpZGRlbicgOiAnJztcbiAgdmFyIHZpc2liaWxpdHlCb3R0b20gPSB0aGlzLnByb3BzLnNjcm9sbFRvcCA9PSB0aGlzLnByb3BzLnNjcm9sbFRvcE1pbiA/ICdoaWRkZW4nIDogJyc7XG4gIGRvbS5zaGFkb3dUb3Auc3R5bGUudmlzaWJpbGl0eSAgICAgICAgICA9IHZpc2liaWxpdHlUb3A7XG4gIGRvbS5zaGFkb3dCb3R0b20uc3R5bGUudmlzaWJpbGl0eSAgICAgICA9IHZpc2liaWxpdHlCb3R0b207XG4gIGRvbS5zaGFkb3dUb3BMZWZ0LnN0eWxlLnZpc2liaWxpdHkgICAgICA9IHZpc2liaWxpdHlUb3A7XG4gIGRvbS5zaGFkb3dCb3R0b21MZWZ0LnN0eWxlLnZpc2liaWxpdHkgICA9IHZpc2liaWxpdHlCb3R0b207XG4gIGRvbS5zaGFkb3dUb3BSaWdodC5zdHlsZS52aXNpYmlsaXR5ICAgICA9IHZpc2liaWxpdHlUb3A7XG4gIGRvbS5zaGFkb3dCb3R0b21SaWdodC5zdHlsZS52aXNpYmlsaXR5ICA9IHZpc2liaWxpdHlCb3R0b207XG5cbiAgLy8gcmVkcmF3IGFsbCBjb21wb25lbnRzXG4gIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICByZXNpemVkID0gY29tcG9uZW50LnJlZHJhdygpIHx8IHJlc2l6ZWQ7XG4gIH0pO1xuICBpZiAocmVzaXplZCkge1xuICAgIC8vIGtlZXAgcmVwYWludGluZyB1bnRpbCBhbGwgc2l6ZXMgYXJlIHNldHRsZWRcbiAgICB2YXIgTUFYX1JFRFJBV1MgPSAzOyAvLyBtYXhpbXVtIG51bWJlciBvZiBjb25zZWN1dGl2ZSByZWRyYXdzXG4gICAgaWYgKHRoaXMucmVkcmF3Q291bnQgPCBNQVhfUkVEUkFXUykge1xuICAgICAgdGhpcy5yZWRyYXdDb3VudCsrO1xuICAgICAgdGhpcy5fcmVkcmF3KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IGluZmluaXRlIGxvb3AgaW4gcmVkcmF3PycpO1xuICAgIH1cbiAgICB0aGlzLnJlZHJhd0NvdW50ID0gMDtcbiAgfVxufTtcblxuLy8gVE9ETzogZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMS4wLCByZW1vdmUgc29tZSBkYXlcbkNvcmUucHJvdG90eXBlLnJlcGFpbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gcmVwYWludCBpcyBkZXByZWNhdGVkLiBVc2UgcmVkcmF3IGluc3RlYWQuJyk7XG59O1xuXG4vKipcbiAqIFNldCBhIGN1cnJlbnQgdGltZS4gVGhpcyBjYW4gYmUgdXNlZCBmb3IgZXhhbXBsZSB0byBlbnN1cmUgdGhhdCBhIGNsaWVudCdzXG4gKiB0aW1lIGlzIHN5bmNocm9uaXplZCB3aXRoIGEgc2hhcmVkIHNlcnZlciB0aW1lLlxuICogT25seSBhcHBsaWNhYmxlIHdoZW4gb3B0aW9uIGBzaG93Q3VycmVudFRpbWVgIGlzIHRydWUuXG4gKiBAcGFyYW0ge0RhdGUgfCBTdHJpbmcgfCBOdW1iZXJ9IHRpbWUgICAgIEEgRGF0ZSwgdW5peCB0aW1lc3RhbXAsIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElTTyBkYXRlIHN0cmluZy5cbiAqL1xuQ29yZS5wcm90b3R5cGUuc2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbih0aW1lKSB7XG4gIGlmICghdGhpcy5jdXJyZW50VGltZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uIHNob3dDdXJyZW50VGltZSBtdXN0IGJlIHRydWUnKTtcbiAgfVxuXG4gIHRoaXMuY3VycmVudFRpbWUuc2V0Q3VycmVudFRpbWUodGltZSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB0aW1lLlxuICogT25seSBhcHBsaWNhYmxlIHdoZW4gb3B0aW9uIGBzaG93Q3VycmVudFRpbWVgIGlzIHRydWUuXG4gKiBAcmV0dXJuIHtEYXRlfSBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUuXG4gKi9cbkNvcmUucHJvdG90eXBlLmdldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jdXJyZW50VGltZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uIHNob3dDdXJyZW50VGltZSBtdXN0IGJlIHRydWUnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnJlbnRUaW1lLmdldEN1cnJlbnRUaW1lKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBwb3NpdGlvbiBvbiBzY3JlZW4gKHBpeGVscykgdG8gYSBkYXRldGltZVxuICogQHBhcmFtIHtpbnR9ICAgICB4ICAgIFBvc2l0aW9uIG9uIHRoZSBzY3JlZW4gaW4gcGl4ZWxzXG4gKiBAcmV0dXJuIHtEYXRlfSAgIHRpbWUgVGhlIGRhdGV0aW1lIHRoZSBjb3JyZXNwb25kcyB3aXRoIGdpdmVuIHBvc2l0aW9uIHhcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuLy8gVE9ETzogbW92ZSB0aGlzIGZ1bmN0aW9uIHRvIFJhbmdlXG5Db3JlLnByb3RvdHlwZS5fdG9UaW1lID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gRGF0ZVV0aWwudG9UaW1lKHRoaXMsIHgsIHRoaXMucHJvcHMuY2VudGVyLndpZHRoKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHBvc2l0aW9uIG9uIHRoZSBnbG9iYWwgc2NyZWVuIChwaXhlbHMpIHRvIGEgZGF0ZXRpbWVcbiAqIEBwYXJhbSB7aW50fSAgICAgeCAgICBQb3NpdGlvbiBvbiB0aGUgc2NyZWVuIGluIHBpeGVsc1xuICogQHJldHVybiB7RGF0ZX0gICB0aW1lIFRoZSBkYXRldGltZSB0aGUgY29ycmVzcG9uZHMgd2l0aCBnaXZlbiBwb3NpdGlvbiB4XG4gKiBAcHJvdGVjdGVkXG4gKi9cbi8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiB0byBSYW5nZVxuQ29yZS5wcm90b3R5cGUuX3RvR2xvYmFsVGltZSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIERhdGVVdGlsLnRvVGltZSh0aGlzLCB4LCB0aGlzLnByb3BzLnJvb3Qud2lkdGgpO1xuICAvL3ZhciBjb252ZXJzaW9uID0gdGhpcy5yYW5nZS5jb252ZXJzaW9uKHRoaXMucHJvcHMucm9vdC53aWR0aCk7XG4gIC8vcmV0dXJuIG5ldyBEYXRlKHggLyBjb252ZXJzaW9uLnNjYWxlICsgY29udmVyc2lvbi5vZmZzZXQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgZGF0ZXRpbWUgKERhdGUgb2JqZWN0KSBpbnRvIGEgcG9zaXRpb24gb24gdGhlIHNjcmVlblxuICogQHBhcmFtIHtEYXRlfSAgIHRpbWUgQSBkYXRlXG4gKiBAcmV0dXJuIHtpbnR9ICAgeCAgICBUaGUgcG9zaXRpb24gb24gdGhlIHNjcmVlbiBpbiBwaXhlbHMgd2hpY2ggY29ycmVzcG9uZHNcbiAqICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGdpdmVuIGRhdGUuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbi8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiB0byBSYW5nZVxuQ29yZS5wcm90b3R5cGUuX3RvU2NyZWVuID0gZnVuY3Rpb24odGltZSkge1xuICByZXR1cm4gRGF0ZVV0aWwudG9TY3JlZW4odGhpcywgdGltZSwgdGhpcy5wcm9wcy5jZW50ZXIud2lkdGgpO1xufTtcblxuXG5cbi8qKlxuICogQ29udmVydCBhIGRhdGV0aW1lIChEYXRlIG9iamVjdCkgaW50byBhIHBvc2l0aW9uIG9uIHRoZSByb290XG4gKiBUaGlzIGlzIHVzZWQgdG8gZ2V0IHRoZSBwaXhlbCBkZW5zaXR5IGVzdGltYXRlIGZvciB0aGUgc2NyZWVuLCBub3QgdGhlIGNlbnRlciBwYW5lbFxuICogQHBhcmFtIHtEYXRlfSAgIHRpbWUgQSBkYXRlXG4gKiBAcmV0dXJuIHtpbnR9ICAgeCAgICBUaGUgcG9zaXRpb24gb24gcm9vdCBpbiBwaXhlbHMgd2hpY2ggY29ycmVzcG9uZHNcbiAqICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGdpdmVuIGRhdGUuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbi8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiB0byBSYW5nZVxuQ29yZS5wcm90b3R5cGUuX3RvR2xvYmFsU2NyZWVuID0gZnVuY3Rpb24odGltZSkge1xuICByZXR1cm4gRGF0ZVV0aWwudG9TY3JlZW4odGhpcywgdGltZSwgdGhpcy5wcm9wcy5yb290LndpZHRoKTtcbiAgLy92YXIgY29udmVyc2lvbiA9IHRoaXMucmFuZ2UuY29udmVyc2lvbih0aGlzLnByb3BzLnJvb3Qud2lkdGgpO1xuICAvL3JldHVybiAodGltZS52YWx1ZU9mKCkgLSBjb252ZXJzaW9uLm9mZnNldCkgKiBjb252ZXJzaW9uLnNjYWxlO1xufTtcblxuXG4vKipcbiAqIEluaXRpYWxpemUgd2F0Y2hpbmcgd2hlbiBvcHRpb24gYXV0b1Jlc2l6ZSBpcyB0cnVlXG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5faW5pdEF1dG9SZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuYXV0b1Jlc2l6ZSA9PSB0cnVlKSB7XG4gICAgdGhpcy5fc3RhcnRBdXRvUmVzaXplKCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5fc3RvcEF1dG9SZXNpemUoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYXRjaCBmb3IgY2hhbmdlcyBpbiB0aGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyLiBPbiByZXNpemUsIHRoZSBQYW5lbCB3aWxsXG4gKiBhdXRvbWF0aWNhbGx5IHJlZHJhdyBpdHNlbGYuXG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fc3RhcnRBdXRvUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIHRoaXMuX3N0b3BBdXRvUmVzaXplKCk7XG5cbiAgdGhpcy5fb25SZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAobWUub3B0aW9ucy5hdXRvUmVzaXplICE9IHRydWUpIHtcbiAgICAgIC8vIHN0b3Agd2F0Y2hpbmcgd2hlbiB0aGUgb3B0aW9uIGF1dG9SZXNpemUgaXMgY2hhbmdlZCB0byBmYWxzZVxuICAgICAgbWUuX3N0b3BBdXRvUmVzaXplKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1lLmRvbS5yb290KSB7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBmcmFtZSBpcyByZXNpemVkXG4gICAgICAvLyBOb3RlOiB3ZSBjb21wYXJlIG9mZnNldFdpZHRoIGhlcmUsIG5vdCBjbGllbnRXaWR0aC4gRm9yIHNvbWUgcmVhc29uLFxuICAgICAgLy8gSUUgZG9lcyBub3QgcmVzdG9yZSB0aGUgY2xpZW50V2lkdGggZnJvbSAwIHRvIHRoZSBhY3R1YWwgd2lkdGggYWZ0ZXJcbiAgICAgIC8vIGNoYW5naW5nIHRoZSB0aW1lbGluZSdzIGNvbnRhaW5lciBkaXNwbGF5IHN0eWxlIGZyb20gbm9uZSB0byB2aXNpYmxlXG4gICAgICBpZiAoKG1lLmRvbS5yb290Lm9mZnNldFdpZHRoICE9IG1lLnByb3BzLmxhc3RXaWR0aCkgfHxcbiAgICAgICAgKG1lLmRvbS5yb290Lm9mZnNldEhlaWdodCAhPSBtZS5wcm9wcy5sYXN0SGVpZ2h0KSkge1xuICAgICAgICBtZS5wcm9wcy5sYXN0V2lkdGggPSBtZS5kb20ucm9vdC5vZmZzZXRXaWR0aDtcbiAgICAgICAgbWUucHJvcHMubGFzdEhlaWdodCA9IG1lLmRvbS5yb290Lm9mZnNldEhlaWdodDtcblxuICAgICAgICBtZS5lbWl0KCdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvIHdpbmRvdyByZXNpemVcbiAgdXRpbC5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplKTtcblxuICB0aGlzLndhdGNoVGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLl9vblJlc2l6ZSwgMTAwMCk7XG59O1xuXG4vKipcbiAqIFN0b3Agd2F0Y2hpbmcgZm9yIGEgcmVzaXplIG9mIHRoZSBmcmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbkNvcmUucHJvdG90eXBlLl9zdG9wQXV0b1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMud2F0Y2hUaW1lcikge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy53YXRjaFRpbWVyKTtcbiAgICB0aGlzLndhdGNoVGltZXIgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93LnJlc2l6ZVxuICBpZiAodGhpcy5fb25SZXNpemUpIHtcbiAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUpO1xuICAgIHRoaXMuX29uUmVzaXplID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydCBtb3ZpbmcgdGhlIHRpbWVsaW5lIHZlcnRpY2FsbHlcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fb25Ub3VjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICB0aGlzLnRvdWNoLmFsbG93RHJhZ2dpbmcgPSB0cnVlO1xuICB0aGlzLnRvdWNoLmluaXRpYWxTY3JvbGxUb3AgPSB0aGlzLnByb3BzLnNjcm9sbFRvcDtcbn07XG5cbi8qKlxuICogU3RhcnQgbW92aW5nIHRoZSB0aW1lbGluZSB2ZXJ0aWNhbGx5XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX29uUGluY2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdGhpcy50b3VjaC5hbGxvd0RyYWdnaW5nID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIE1vdmUgdGhlIHRpbWVsaW5lIHZlcnRpY2FsbHlcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIHJlZnVzZSB0byBkcmFnIHdoZW4gd2Ugd2hlcmUgcGluY2hpbmcgdG8gcHJldmVudCB0aGUgdGltZWxpbmUgbWFrZSBhIGp1bXBcbiAgLy8gd2hlbiByZWxlYXNpbmcgdGhlIGZpbmdlcnMgaW4gb3Bwb3NpdGUgb3JkZXIgZnJvbSB0aGUgdG91Y2ggc2NyZWVuXG4gIGlmICghdGhpcy50b3VjaC5hbGxvd0RyYWdnaW5nKSByZXR1cm47XG5cbiAgdmFyIGRlbHRhID0gZXZlbnQuZGVsdGFZO1xuXG4gIHZhciBvbGRTY3JvbGxUb3AgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKTtcbiAgdmFyIG5ld1Njcm9sbFRvcCA9IHRoaXMuX3NldFNjcm9sbFRvcCh0aGlzLnRvdWNoLmluaXRpYWxTY3JvbGxUb3AgKyBkZWx0YSk7XG5cblxuICBpZiAobmV3U2Nyb2xsVG9wICE9IG9sZFNjcm9sbFRvcCkge1xuICAgIHRoaXMuX3JlZHJhdygpOyAvLyBUT0RPOiB0aGlzIGNhdXNlcyB0d28gcmVkcmF3cyB3aGVuIGRyYWdnaW5nLCB0aGUgb3RoZXIgaXMgdHJpZ2dlcmVkIGJ5IHJhbmdlY2hhbmdlIGFscmVhZHlcbiAgICB0aGlzLmVtaXQoXCJ2ZXJ0aWNhbERyYWdcIik7XG4gIH1cbn07XG5cbi8qKlxuICogQXBwbHkgYSBzY3JvbGxUb3BcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGxUb3BcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNjcm9sbFRvcCAgUmV0dXJucyB0aGUgYXBwbGllZCBzY3JvbGxUb3BcbiAqIEBwcml2YXRlXG4gKi9cbkNvcmUucHJvdG90eXBlLl9zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoc2Nyb2xsVG9wKSB7XG4gIHRoaXMucHJvcHMuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICB0aGlzLl91cGRhdGVTY3JvbGxUb3AoKTtcbiAgcmV0dXJuIHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGN1cnJlbnQgc2Nyb2xsVG9wIHdoZW4gdGhlIGhlaWdodCBvZiAgdGhlIGNvbnRhaW5lcnMgaGFzIGJlZW4gY2hhbmdlZFxuICogQHJldHVybnMge051bWJlcn0gc2Nyb2xsVG9wICBSZXR1cm5zIHRoZSBhcHBsaWVkIHNjcm9sbFRvcFxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX3VwZGF0ZVNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gcmVjYWxjdWxhdGUgdGhlIHNjcm9sbFRvcE1pblxuICB2YXIgc2Nyb2xsVG9wTWluID0gTWF0aC5taW4odGhpcy5wcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0IC0gdGhpcy5wcm9wcy5jZW50ZXIuaGVpZ2h0LCAwKTsgLy8gaXMgbmVnYXRpdmUgb3IgemVyb1xuICBpZiAoc2Nyb2xsVG9wTWluICE9IHRoaXMucHJvcHMuc2Nyb2xsVG9wTWluKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBib3R0b20gb3JpZW50YXRpb24sIGNoYW5nZSB0aGUgc2Nyb2xsVG9wIHN1Y2ggdGhhdCB0aGUgY29udGVudHNcbiAgICAvLyBkbyBub3QgbW92ZSByZWxhdGl2ZSB0byB0aGUgdGltZSBheGlzIGF0IHRoZSBib3R0b21cbiAgICBpZiAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gIT0gJ3RvcCcpIHtcbiAgICAgIHRoaXMucHJvcHMuc2Nyb2xsVG9wICs9IChzY3JvbGxUb3BNaW4gLSB0aGlzLnByb3BzLnNjcm9sbFRvcE1pbik7XG4gICAgfVxuICAgIHRoaXMucHJvcHMuc2Nyb2xsVG9wTWluID0gc2Nyb2xsVG9wTWluO1xuICB9XG5cbiAgLy8gbGltaXQgdGhlIHNjcm9sbFRvcCB0byB0aGUgZmVhc2libGUgc2Nyb2xsIHJhbmdlXG4gIGlmICh0aGlzLnByb3BzLnNjcm9sbFRvcCA+IDApIHRoaXMucHJvcHMuc2Nyb2xsVG9wID0gMDtcbiAgaWYgKHRoaXMucHJvcHMuc2Nyb2xsVG9wIDwgc2Nyb2xsVG9wTWluKSB0aGlzLnByb3BzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcE1pbjtcblxuICByZXR1cm4gdGhpcy5wcm9wcy5zY3JvbGxUb3A7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBzY3JvbGxUb3BcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNjcm9sbFRvcFxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX2dldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xufTtcblxuLyoqXG4gKiBMb2FkIGEgY29uZmlndXJhdG9yXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fY3JlYXRlQ29uZmlndXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgYWJzdHJhY3QgbWV0aG9kIF9jcmVhdGVDb25maWd1cmF0b3InKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29yZTtcbiIsIlxuLyoqXG4gKiB1c2VkIGluIENvcmUgdG8gY29udmVydCB0aGUgb3B0aW9ucyBpbnRvIGEgdm9sYXRpbGUgdmFyaWFibGVcbiAqIFxuICogQHBhcmFtIHtmdW5jdGlvbn0gbW9tZW50XG4gKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICogQHBhcmFtIHtBcnJheSB8IE9iamVjdH0gaGlkZGVuRGF0ZXNcbiAqL1xuZXhwb3J0cy5jb252ZXJ0SGlkZGVuT3B0aW9ucyA9IGZ1bmN0aW9uKG1vbWVudCwgYm9keSwgaGlkZGVuRGF0ZXMpIHtcbiAgaWYgKGhpZGRlbkRhdGVzICYmICFBcnJheS5pc0FycmF5KGhpZGRlbkRhdGVzKSkge1xuICAgIHJldHVybiBleHBvcnRzLmNvbnZlcnRIaWRkZW5PcHRpb25zKG1vbWVudCwgYm9keSwgW2hpZGRlbkRhdGVzXSlcbiAgfVxuXG4gIGJvZHkuaGlkZGVuRGF0ZXMgPSBbXTtcbiAgaWYgKGhpZGRlbkRhdGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGlkZGVuRGF0ZXMpID09IHRydWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhpZGRlbkRhdGVzW2ldLnJlcGVhdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGRhdGVJdGVtID0ge307XG4gICAgICAgICAgZGF0ZUl0ZW0uc3RhcnQgPSBtb21lbnQoaGlkZGVuRGF0ZXNbaV0uc3RhcnQpLnRvRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgICBkYXRlSXRlbS5lbmQgPSBtb21lbnQoaGlkZGVuRGF0ZXNbaV0uZW5kKS50b0RhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgICAgYm9keS5oaWRkZW5EYXRlcy5wdXNoKGRhdGVJdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYm9keS5oaWRkZW5EYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnN0YXJ0IC0gYi5zdGFydDtcbiAgICAgIH0pOyAvLyBzb3J0IGJ5IHN0YXJ0IHRpbWVcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBjcmVhdGUgbmV3IGVudHJlZXMgZm9yIHRoZSByZXBlYXRpbmcgaGlkZGVuIGRhdGVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb21lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gKiBAcGFyYW0ge0FycmF5IHwgT2JqZWN0fSBoaWRkZW5EYXRlc1xuICovXG5leHBvcnRzLnVwZGF0ZUhpZGRlbkRhdGVzID0gZnVuY3Rpb24gKG1vbWVudCwgYm9keSwgaGlkZGVuRGF0ZXMpIHtcbiAgaWYgKGhpZGRlbkRhdGVzICYmICFBcnJheS5pc0FycmF5KGhpZGRlbkRhdGVzKSkge1xuICAgIHJldHVybiBleHBvcnRzLnVwZGF0ZUhpZGRlbkRhdGVzKG1vbWVudCwgYm9keSwgW2hpZGRlbkRhdGVzXSlcbiAgfVxuXG4gIGlmIChoaWRkZW5EYXRlcyAmJiBib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwb3J0cy5jb252ZXJ0SGlkZGVuT3B0aW9ucyhtb21lbnQsIGJvZHksIGhpZGRlbkRhdGVzKTtcblxuICAgIHZhciBzdGFydCA9IG1vbWVudChib2R5LnJhbmdlLnN0YXJ0KTtcbiAgICB2YXIgZW5kID0gbW9tZW50KGJvZHkucmFuZ2UuZW5kKTtcblxuICAgIHZhciB0b3RhbFJhbmdlID0gKGJvZHkucmFuZ2UuZW5kIC0gYm9keS5yYW5nZS5zdGFydCk7XG4gICAgdmFyIHBpeGVsVGltZSA9IHRvdGFsUmFuZ2UgLyBib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci53aWR0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoaWRkZW5EYXRlc1tpXS5yZXBlYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc3RhcnREYXRlID0gbW9tZW50KGhpZGRlbkRhdGVzW2ldLnN0YXJ0KTtcbiAgICAgICAgdmFyIGVuZERhdGUgPSBtb21lbnQoaGlkZGVuRGF0ZXNbaV0uZW5kKTtcblxuICAgICAgICBpZiAoc3RhcnREYXRlLl9kID09IFwiSW52YWxpZCBEYXRlXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBwbGllZCBzdGFydCBkYXRlIGlzIG5vdCB2YWxpZDogXCIgKyBoaWRkZW5EYXRlc1tpXS5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZERhdGUuX2QgPT0gXCJJbnZhbGlkIERhdGVcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cHBsaWVkIGVuZCBkYXRlIGlzIG5vdCB2YWxpZDogXCIgKyBoaWRkZW5EYXRlc1tpXS5lbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gZW5kRGF0ZSAtIHN0YXJ0RGF0ZTtcbiAgICAgICAgaWYgKGR1cmF0aW9uID49IDQgKiBwaXhlbFRpbWUpIHtcblxuICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgIHZhciBydW5VbnRpbCA9IGVuZC5jbG9uZSgpO1xuICAgICAgICAgIHN3aXRjaCAoaGlkZGVuRGF0ZXNbaV0ucmVwZWF0KSB7XG4gICAgICAgICAgICBjYXNlIFwiZGFpbHlcIjogLy8gY2FzZSBvZiB0aW1lXG4gICAgICAgICAgICAgIGlmIChzdGFydERhdGUuZGF5KCkgIT0gZW5kRGF0ZS5kYXkoKSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhcnREYXRlLmRheU9mWWVhcihzdGFydC5kYXlPZlllYXIoKSk7XG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS55ZWFyKHN0YXJ0LnllYXIoKSk7XG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zdWJ0cmFjdCg3LCdkYXlzJyk7XG5cbiAgICAgICAgICAgICAgZW5kRGF0ZS5kYXlPZlllYXIoc3RhcnQuZGF5T2ZZZWFyKCkpO1xuICAgICAgICAgICAgICBlbmREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgZW5kRGF0ZS5zdWJ0cmFjdCg3IC0gb2Zmc2V0LCdkYXlzJyk7XG5cbiAgICAgICAgICAgICAgcnVuVW50aWwuYWRkKDEsICd3ZWVrcycpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ3ZWVrbHlcIjpcbiAgICAgICAgICAgICAgdmFyIGRheU9mZnNldCA9IGVuZERhdGUuZGlmZihzdGFydERhdGUsJ2RheXMnKVxuICAgICAgICAgICAgICB2YXIgZGF5ID0gc3RhcnREYXRlLmRheSgpO1xuXG4gICAgICAgICAgICAgIC8vIHNldCB0aGUgc3RhcnQgZGF0ZSB0byB0aGUgcmFuZ2Uuc3RhcnRcbiAgICAgICAgICAgICAgc3RhcnREYXRlLmRhdGUoc3RhcnQuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgc3RhcnREYXRlLm1vbnRoKHN0YXJ0Lm1vbnRoKCkpO1xuICAgICAgICAgICAgICBzdGFydERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICBlbmREYXRlID0gc3RhcnREYXRlLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgLy8gZm9yY2VcbiAgICAgICAgICAgICAgc3RhcnREYXRlLmRheShkYXkpO1xuICAgICAgICAgICAgICBlbmREYXRlLmRheShkYXkpO1xuICAgICAgICAgICAgICBlbmREYXRlLmFkZChkYXlPZmZzZXQsJ2RheXMnKTtcblxuICAgICAgICAgICAgICBzdGFydERhdGUuc3VidHJhY3QoMSwnd2Vla3MnKTtcbiAgICAgICAgICAgICAgZW5kRGF0ZS5zdWJ0cmFjdCgxLCd3ZWVrcycpO1xuXG4gICAgICAgICAgICAgIHJ1blVudGlsLmFkZCgxLCAnd2Vla3MnKTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgXCJtb250aGx5XCI6XG4gICAgICAgICAgICAgIGlmIChzdGFydERhdGUubW9udGgoKSAhPSBlbmREYXRlLm1vbnRoKCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS5tb250aChzdGFydC5tb250aCgpKTtcbiAgICAgICAgICAgICAgc3RhcnREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgc3RhcnREYXRlLnN1YnRyYWN0KDEsJ21vbnRocycpO1xuXG4gICAgICAgICAgICAgIGVuZERhdGUubW9udGgoc3RhcnQubW9udGgoKSk7XG4gICAgICAgICAgICAgIGVuZERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICBlbmREYXRlLnN1YnRyYWN0KDEsJ21vbnRocycpO1xuICAgICAgICAgICAgICBlbmREYXRlLmFkZChvZmZzZXQsJ21vbnRocycpO1xuXG4gICAgICAgICAgICAgIHJ1blVudGlsLmFkZCgxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInllYXJseVwiOlxuICAgICAgICAgICAgICBpZiAoc3RhcnREYXRlLnllYXIoKSAhPSBlbmREYXRlLnllYXIoKSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhcnREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgc3RhcnREYXRlLnN1YnRyYWN0KDEsJ3llYXJzJyk7XG4gICAgICAgICAgICAgIGVuZERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICBlbmREYXRlLnN1YnRyYWN0KDEsJ3llYXJzJyk7XG4gICAgICAgICAgICAgIGVuZERhdGUuYWRkKG9mZnNldCwneWVhcnMnKTtcblxuICAgICAgICAgICAgICBydW5VbnRpbC5hZGQoMSwgJ3llYXJzJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXcm9uZyByZXBlYXQgZm9ybWF0LCBhbGxvd2VkIGFyZTogZGFpbHksIHdlZWtseSwgbW9udGhseSwgeWVhcmx5LiBHaXZlbjpcIiwgaGlkZGVuRGF0ZXNbaV0ucmVwZWF0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoc3RhcnREYXRlIDwgcnVuVW50aWwpIHtcbiAgICAgICAgICAgIGJvZHkuaGlkZGVuRGF0ZXMucHVzaCh7c3RhcnQ6IHN0YXJ0RGF0ZS52YWx1ZU9mKCksIGVuZDogZW5kRGF0ZS52YWx1ZU9mKCl9KTtcbiAgICAgICAgICAgIHN3aXRjaCAoaGlkZGVuRGF0ZXNbaV0ucmVwZWF0KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJkYWlseVwiOlxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5hZGQoMSwgJ2RheXMnKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLmFkZCgxLCAnZGF5cycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwid2Vla2x5XCI6XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLmFkZCgxLCAnd2Vla3MnKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLmFkZCgxLCAnd2Vla3MnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIm1vbnRobHlcIjpcbiAgICAgICAgICAgICAgICBzdGFydERhdGUuYWRkKDEsICdtb250aHMnKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLmFkZCgxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ5ZWFybHlcIjpcbiAgICAgICAgICAgICAgICBzdGFydERhdGUuYWRkKDEsICd5Jyk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5hZGQoMSwgJ3knKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldyb25nIHJlcGVhdCBmb3JtYXQsIGFsbG93ZWQgYXJlOiBkYWlseSwgd2Vla2x5LCBtb250aGx5LCB5ZWFybHkuIEdpdmVuOlwiLCBoaWRkZW5EYXRlc1tpXS5yZXBlYXQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYm9keS5oaWRkZW5EYXRlcy5wdXNoKHtzdGFydDogc3RhcnREYXRlLnZhbHVlT2YoKSwgZW5kOiBlbmREYXRlLnZhbHVlT2YoKX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJlbW92ZSBkdXBsaWNhdGVzLCBtZXJnZSB3aGVyZSBwb3NzaWJsZVxuICAgIGV4cG9ydHMucmVtb3ZlRHVwbGljYXRlcyhib2R5KTtcbiAgICAvLyBlbnN1cmUgdGhlIG5ldyBwb3NpdGlvbnMgYXJlIG5vdCBvbiBoaWRkZW4gZGF0ZXNcbiAgICB2YXIgc3RhcnRIaWRkZW4gPSBleHBvcnRzLmlzSGlkZGVuKGJvZHkucmFuZ2Uuc3RhcnQsIGJvZHkuaGlkZGVuRGF0ZXMpO1xuICAgIHZhciBlbmRIaWRkZW4gPSBleHBvcnRzLmlzSGlkZGVuKGJvZHkucmFuZ2UuZW5kLGJvZHkuaGlkZGVuRGF0ZXMpO1xuICAgIHZhciByYW5nZVN0YXJ0ID0gYm9keS5yYW5nZS5zdGFydDtcbiAgICB2YXIgcmFuZ2VFbmQgPSBib2R5LnJhbmdlLmVuZDtcbiAgICBpZiAoc3RhcnRIaWRkZW4uaGlkZGVuID09IHRydWUpIHtyYW5nZVN0YXJ0ID0gYm9keS5yYW5nZS5zdGFydFRvRnJvbnQgPT0gdHJ1ZSA/IHN0YXJ0SGlkZGVuLnN0YXJ0RGF0ZSAtIDEgOiBzdGFydEhpZGRlbi5lbmREYXRlICsgMTt9XG4gICAgaWYgKGVuZEhpZGRlbi5oaWRkZW4gPT0gdHJ1ZSkgICB7cmFuZ2VFbmQgICA9IGJvZHkucmFuZ2UuZW5kVG9Gcm9udCA9PSB0cnVlID8gICBlbmRIaWRkZW4uc3RhcnREYXRlIC0gMSAgIDogZW5kSGlkZGVuLmVuZERhdGUgKyAxO31cbiAgICBpZiAoc3RhcnRIaWRkZW4uaGlkZGVuID09IHRydWUgfHwgZW5kSGlkZGVuLmhpZGRlbiA9PSB0cnVlKSB7XG4gICAgICBib2R5LnJhbmdlLl9hcHBseVJhbmdlKHJhbmdlU3RhcnQsIHJhbmdlRW5kKTtcbiAgICB9XG4gIH1cblxufVxuXG5cbi8qKlxuICogcmVtb3ZlIGR1cGxpY2F0ZXMgZnJvbSB0aGUgaGlkZGVuIGRhdGVzIGxpc3QuIER1cGxpY2F0ZXMgYXJlIGV2aWwuIFRoZXkgbWVzcyBldmVyeXRoaW5nIHVwLlxuICogU2NhbGVzIHdpdGggTl4yXG4gKiBAcGFyYW0gYm9keVxuICovXG5leHBvcnRzLnJlbW92ZUR1cGxpY2F0ZXMgPSBmdW5jdGlvbihib2R5KSB7XG4gIHZhciBoaWRkZW5EYXRlcyA9IGJvZHkuaGlkZGVuRGF0ZXM7XG4gIHZhciBzYWZlRGF0ZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChpICE9IGogJiYgaGlkZGVuRGF0ZXNbal0ucmVtb3ZlICE9IHRydWUgJiYgaGlkZGVuRGF0ZXNbaV0ucmVtb3ZlICE9IHRydWUpIHtcbiAgICAgICAgLy8gaiBpbnNpZGUgaVxuICAgICAgICBpZiAoaGlkZGVuRGF0ZXNbal0uc3RhcnQgPj0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQgJiYgaGlkZGVuRGF0ZXNbal0uZW5kIDw9IGhpZGRlbkRhdGVzW2ldLmVuZCkge1xuICAgICAgICAgIGhpZGRlbkRhdGVzW2pdLnJlbW92ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaiBzdGFydCBpbnNpZGUgaVxuICAgICAgICBlbHNlIGlmIChoaWRkZW5EYXRlc1tqXS5zdGFydCA+PSBoaWRkZW5EYXRlc1tpXS5zdGFydCAmJiBoaWRkZW5EYXRlc1tqXS5zdGFydCA8PSBoaWRkZW5EYXRlc1tpXS5lbmQpIHtcbiAgICAgICAgICBoaWRkZW5EYXRlc1tpXS5lbmQgPSBoaWRkZW5EYXRlc1tqXS5lbmQ7XG4gICAgICAgICAgaGlkZGVuRGF0ZXNbal0ucmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBqIGVuZCBpbnNpZGUgaVxuICAgICAgICBlbHNlIGlmIChoaWRkZW5EYXRlc1tqXS5lbmQgPj0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQgJiYgaGlkZGVuRGF0ZXNbal0uZW5kIDw9IGhpZGRlbkRhdGVzW2ldLmVuZCkge1xuICAgICAgICAgIGhpZGRlbkRhdGVzW2ldLnN0YXJ0ID0gaGlkZGVuRGF0ZXNbal0uc3RhcnQ7XG4gICAgICAgICAgaGlkZGVuRGF0ZXNbal0ucmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGlkZGVuRGF0ZXNbaV0ucmVtb3ZlICE9PSB0cnVlKSB7XG4gICAgICBzYWZlRGF0ZXMucHVzaChoaWRkZW5EYXRlc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgYm9keS5oaWRkZW5EYXRlcyA9IHNhZmVEYXRlcztcbiAgYm9keS5oaWRkZW5EYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xuICB9KTsgLy8gc29ydCBieSBzdGFydCB0aW1lXG59O1xuXG5leHBvcnRzLnByaW50RGF0ZXMgPSBmdW5jdGlvbihkYXRlcykge1xuICBmb3IgKHZhciBpID0wOyBpIDwgZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zb2xlLmxvZyhpLCBuZXcgRGF0ZShkYXRlc1tpXS5zdGFydCksbmV3IERhdGUoZGF0ZXNbaV0uZW5kKSwgZGF0ZXNbaV0uc3RhcnQsIGRhdGVzW2ldLmVuZCwgZGF0ZXNbaV0ucmVtb3ZlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBVc2VkIGluIFRpbWVTdGVwIHRvIGF2b2lkIHRoZSBoaWRkZW4gdGltZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb21lbnRcbiAqIEBwYXJhbSB7VGltZVN0ZXB9IHRpbWVTdGVwXG4gKiBAcGFyYW0gcHJldmlvdXNUaW1lXG4gKi9cbmV4cG9ydHMuc3RlcE92ZXJIaWRkZW5EYXRlcyA9IGZ1bmN0aW9uKG1vbWVudCwgdGltZVN0ZXAsIHByZXZpb3VzVGltZSkge1xuICB2YXIgc3RlcEluSGlkZGVuID0gZmFsc2U7XG4gIHZhciBjdXJyZW50VmFsdWUgPSB0aW1lU3RlcC5jdXJyZW50LnZhbHVlT2YoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lU3RlcC5oaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGFydERhdGUgPSB0aW1lU3RlcC5oaWRkZW5EYXRlc1tpXS5zdGFydDtcbiAgICB2YXIgZW5kRGF0ZSA9IHRpbWVTdGVwLmhpZGRlbkRhdGVzW2ldLmVuZDtcbiAgICBpZiAoY3VycmVudFZhbHVlID49IHN0YXJ0RGF0ZSAmJiBjdXJyZW50VmFsdWUgPCBlbmREYXRlKSB7XG4gICAgICBzdGVwSW5IaWRkZW4gPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0ZXBJbkhpZGRlbiA9PSB0cnVlICYmIGN1cnJlbnRWYWx1ZSA8IHRpbWVTdGVwLl9lbmQudmFsdWVPZigpICYmIGN1cnJlbnRWYWx1ZSAhPSBwcmV2aW91c1RpbWUpIHtcbiAgICB2YXIgcHJldlZhbHVlID0gbW9tZW50KHByZXZpb3VzVGltZSk7XG4gICAgdmFyIG5ld1ZhbHVlID0gbW9tZW50KGVuZERhdGUpO1xuICAgIC8vY2hlY2sgaWYgdGhlIG5leHQgc3RlcCBzaG91bGQgYmUgbWFqb3JcbiAgICBpZiAocHJldlZhbHVlLnllYXIoKSAhPSBuZXdWYWx1ZS55ZWFyKCkpIHt0aW1lU3RlcC5zd2l0Y2hlZFllYXIgPSB0cnVlO31cbiAgICBlbHNlIGlmIChwcmV2VmFsdWUubW9udGgoKSAhPSBuZXdWYWx1ZS5tb250aCgpKSB7dGltZVN0ZXAuc3dpdGNoZWRNb250aCA9IHRydWU7fVxuICAgIGVsc2UgaWYgKHByZXZWYWx1ZS5kYXlPZlllYXIoKSAhPSBuZXdWYWx1ZS5kYXlPZlllYXIoKSkge3RpbWVTdGVwLnN3aXRjaGVkRGF5ID0gdHJ1ZTt9XG5cbiAgICB0aW1lU3RlcC5jdXJyZW50ID0gbmV3VmFsdWU7XG4gIH1cbn07XG5cblxuLy8vKipcbi8vICogVXNlZCBpbiBUaW1lU3RlcCB0byBhdm9pZCB0aGUgaGlkZGVuIHRpbWVzLlxuLy8gKiBAcGFyYW0gdGltZVN0ZXBcbi8vICogQHBhcmFtIHByZXZpb3VzVGltZVxuLy8gKi9cbi8vZXhwb3J0cy5jaGVja0ZpcnN0U3RlcCA9IGZ1bmN0aW9uKHRpbWVTdGVwKSB7XG4vLyAgdmFyIHN0ZXBJbkhpZGRlbiA9IGZhbHNlO1xuLy8gIHZhciBjdXJyZW50VmFsdWUgPSB0aW1lU3RlcC5jdXJyZW50LnZhbHVlT2YoKTtcbi8vICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVTdGVwLmhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4vLyAgICB2YXIgc3RhcnREYXRlID0gdGltZVN0ZXAuaGlkZGVuRGF0ZXNbaV0uc3RhcnQ7XG4vLyAgICB2YXIgZW5kRGF0ZSA9IHRpbWVTdGVwLmhpZGRlbkRhdGVzW2ldLmVuZDtcbi8vICAgIGlmIChjdXJyZW50VmFsdWUgPj0gc3RhcnREYXRlICYmIGN1cnJlbnRWYWx1ZSA8IGVuZERhdGUpIHtcbi8vICAgICAgc3RlcEluSGlkZGVuID0gdHJ1ZTtcbi8vICAgICAgYnJlYWs7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBpZiAoc3RlcEluSGlkZGVuID09IHRydWUgJiYgY3VycmVudFZhbHVlIDw9IHRpbWVTdGVwLl9lbmQudmFsdWVPZigpKSB7XG4vLyAgICB2YXIgbmV3VmFsdWUgPSBtb21lbnQoZW5kRGF0ZSk7XG4vLyAgICB0aW1lU3RlcC5jdXJyZW50ID0gbmV3VmFsdWUudG9EYXRlKCk7XG4vLyAgfVxuLy99O1xuXG4vKipcbiAqIHJlcGxhY2VzIHRoZSBDb3JlIHRvU2NyZWVuIG1ldGhvZHNcbiAqIEBwYXJhbSBDb3JlXG4gKiBAcGFyYW0gdGltZVxuICogQHBhcmFtIHdpZHRoXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLnRvU2NyZWVuID0gZnVuY3Rpb24oQ29yZSwgdGltZSwgd2lkdGgpIHtcbiAgaWYgKENvcmUuYm9keS5oaWRkZW5EYXRlcy5sZW5ndGggPT0gMCkge1xuICAgIHZhciBjb252ZXJzaW9uID0gQ29yZS5yYW5nZS5jb252ZXJzaW9uKHdpZHRoKTtcbiAgICByZXR1cm4gKHRpbWUudmFsdWVPZigpIC0gY29udmVyc2lvbi5vZmZzZXQpICogY29udmVyc2lvbi5zY2FsZTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgaGlkZGVuID0gZXhwb3J0cy5pc0hpZGRlbih0aW1lLCBDb3JlLmJvZHkuaGlkZGVuRGF0ZXMpO1xuICAgIGlmIChoaWRkZW4uaGlkZGVuID09IHRydWUpIHtcbiAgICAgIHRpbWUgPSBoaWRkZW4uc3RhcnREYXRlO1xuICAgIH1cblxuICAgIHZhciBkdXJhdGlvbiA9IGV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZXR3ZWVuKENvcmUuYm9keS5oaWRkZW5EYXRlcywgQ29yZS5yYW5nZS5zdGFydCwgQ29yZS5yYW5nZS5lbmQpO1xuICAgIHRpbWUgPSBleHBvcnRzLmNvcnJlY3RUaW1lRm9ySGlkZGVuKENvcmUub3B0aW9ucy5tb21lbnQsIENvcmUuYm9keS5oaWRkZW5EYXRlcywgQ29yZS5yYW5nZSwgdGltZSk7XG5cbiAgICB2YXIgY29udmVyc2lvbiA9IENvcmUucmFuZ2UuY29udmVyc2lvbih3aWR0aCwgZHVyYXRpb24pO1xuICAgIHJldHVybiAodGltZS52YWx1ZU9mKCkgLSBjb252ZXJzaW9uLm9mZnNldCkgKiBjb252ZXJzaW9uLnNjYWxlO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVwbGFjZXMgdGhlIGNvcmUgdG9UaW1lIG1ldGhvZHNcbiAqIEBwYXJhbSBib2R5XG4gKiBAcGFyYW0gcmFuZ2VcbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0gd2lkdGhcbiAqIEByZXR1cm5zIHtEYXRlfVxuICovXG5leHBvcnRzLnRvVGltZSA9IGZ1bmN0aW9uKENvcmUsIHgsIHdpZHRoKSB7XG4gIGlmIChDb3JlLmJvZHkuaGlkZGVuRGF0ZXMubGVuZ3RoID09IDApIHtcbiAgICB2YXIgY29udmVyc2lvbiA9IENvcmUucmFuZ2UuY29udmVyc2lvbih3aWR0aCk7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHggLyBjb252ZXJzaW9uLnNjYWxlICsgY29udmVyc2lvbi5vZmZzZXQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBoaWRkZW5EdXJhdGlvbiA9IGV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZXR3ZWVuKENvcmUuYm9keS5oaWRkZW5EYXRlcywgQ29yZS5yYW5nZS5zdGFydCwgQ29yZS5yYW5nZS5lbmQpO1xuICAgIHZhciB0b3RhbER1cmF0aW9uID0gQ29yZS5yYW5nZS5lbmQgLSBDb3JlLnJhbmdlLnN0YXJ0IC0gaGlkZGVuRHVyYXRpb247XG4gICAgdmFyIHBhcnRpYWxEdXJhdGlvbiA9IHRvdGFsRHVyYXRpb24gKiB4IC8gd2lkdGg7XG4gICAgdmFyIGFjY3VtdWxhdGVkSGlkZGVuRHVyYXRpb24gPSBleHBvcnRzLmdldEFjY3VtdWxhdGVkSGlkZGVuRHVyYXRpb24oQ29yZS5ib2R5LmhpZGRlbkRhdGVzLCBDb3JlLnJhbmdlLCBwYXJ0aWFsRHVyYXRpb24pO1xuXG4gICAgdmFyIG5ld1RpbWUgPSBuZXcgRGF0ZShhY2N1bXVsYXRlZEhpZGRlbkR1cmF0aW9uICsgcGFydGlhbER1cmF0aW9uICsgQ29yZS5yYW5nZS5zdGFydCk7XG4gICAgcmV0dXJuIG5ld1RpbWU7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTdXBwb3J0IGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIGhpZGRlbkRhdGVzXG4gKiBAcGFyYW0gcmFuZ2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZXR3ZWVuID0gZnVuY3Rpb24oaGlkZGVuRGF0ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGR1cmF0aW9uID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGFydERhdGUgPSBoaWRkZW5EYXRlc1tpXS5zdGFydDtcbiAgICB2YXIgZW5kRGF0ZSA9IGhpZGRlbkRhdGVzW2ldLmVuZDtcbiAgICAvLyBpZiB0aW1lIGFmdGVyIHRoZSBjdXRvdXQsIGFuZCB0aGVcbiAgICBpZiAoc3RhcnREYXRlID49IHN0YXJ0ICYmIGVuZERhdGUgPCBlbmQpIHtcbiAgICAgIGR1cmF0aW9uICs9IGVuZERhdGUgLSBzdGFydERhdGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBkdXJhdGlvbjtcbn07XG5cblxuLyoqXG4gKiBTdXBwb3J0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gbW9tZW50XG4gKiBAcGFyYW0gaGlkZGVuRGF0ZXNcbiAqIEBwYXJhbSByYW5nZVxuICogQHBhcmFtIHRpbWVcbiAqIEByZXR1cm5zIHt7ZHVyYXRpb246IG51bWJlciwgdGltZTogKiwgb2Zmc2V0OiBudW1iZXJ9fVxuICovXG5leHBvcnRzLmNvcnJlY3RUaW1lRm9ySGlkZGVuID0gZnVuY3Rpb24obW9tZW50LCBoaWRkZW5EYXRlcywgcmFuZ2UsIHRpbWUpIHtcbiAgdGltZSA9IG1vbWVudCh0aW1lKS50b0RhdGUoKS52YWx1ZU9mKCk7XG4gIHRpbWUgLT0gZXhwb3J0cy5nZXRIaWRkZW5EdXJhdGlvbkJlZm9yZShtb21lbnQsIGhpZGRlbkRhdGVzLHJhbmdlLHRpbWUpO1xuICByZXR1cm4gdGltZTtcbn07XG5cbmV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUgPSBmdW5jdGlvbihtb21lbnQsIGhpZGRlbkRhdGVzLCByYW5nZSwgdGltZSkge1xuICB2YXIgdGltZU9mZnNldCA9IDA7XG4gIHRpbWUgPSBtb21lbnQodGltZSkudG9EYXRlKCkudmFsdWVPZigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RhcnREYXRlID0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQ7XG4gICAgdmFyIGVuZERhdGUgPSBoaWRkZW5EYXRlc1tpXS5lbmQ7XG4gICAgLy8gaWYgdGltZSBhZnRlciB0aGUgY3V0b3V0LCBhbmQgdGhlXG4gICAgaWYgKHN0YXJ0RGF0ZSA+PSByYW5nZS5zdGFydCAmJiBlbmREYXRlIDwgcmFuZ2UuZW5kKSB7XG4gICAgICBpZiAodGltZSA+PSBlbmREYXRlKSB7XG4gICAgICAgIHRpbWVPZmZzZXQgKz0gKGVuZERhdGUgLSBzdGFydERhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGltZU9mZnNldDtcbn1cblxuLyoqXG4gKiBzdW0gdGhlIGR1cmF0aW9uIGZyb20gc3RhcnQgdG8gZmluaXNoLCBpbmNsdWRpbmcgdGhlIGhpZGRlbiBkdXJhdGlvbixcbiAqIHVudGlsIHRoZSByZXF1aXJlZCBhbW91bnQgaGFzIGJlZW4gcmVhY2hlZCwgcmV0dXJuIHRoZSBhY2N1bXVsYXRlZCBoaWRkZW4gZHVyYXRpb25cbiAqIEBwYXJhbSBoaWRkZW5EYXRlc1xuICogQHBhcmFtIHJhbmdlXG4gKiBAcGFyYW0gdGltZVxuICogQHJldHVybnMge3tkdXJhdGlvbjogbnVtYmVyLCB0aW1lOiAqLCBvZmZzZXQ6IG51bWJlcn19XG4gKi9cbmV4cG9ydHMuZ2V0QWNjdW11bGF0ZWRIaWRkZW5EdXJhdGlvbiA9IGZ1bmN0aW9uKGhpZGRlbkRhdGVzLCByYW5nZSwgcmVxdWlyZWREdXJhdGlvbikge1xuICB2YXIgaGlkZGVuRHVyYXRpb24gPSAwO1xuICB2YXIgZHVyYXRpb24gPSAwO1xuICB2YXIgcHJldmlvdXNQb2ludCA9IHJhbmdlLnN0YXJ0O1xuICAvL2V4cG9ydHMucHJpbnREYXRlcyhoaWRkZW5EYXRlcylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGFydERhdGUgPSBoaWRkZW5EYXRlc1tpXS5zdGFydDtcbiAgICB2YXIgZW5kRGF0ZSA9IGhpZGRlbkRhdGVzW2ldLmVuZDtcbiAgICAvLyBpZiB0aW1lIGFmdGVyIHRoZSBjdXRvdXQsIGFuZCB0aGVcbiAgICBpZiAoc3RhcnREYXRlID49IHJhbmdlLnN0YXJ0ICYmIGVuZERhdGUgPCByYW5nZS5lbmQpIHtcbiAgICAgIGR1cmF0aW9uICs9IHN0YXJ0RGF0ZSAtIHByZXZpb3VzUG9pbnQ7XG4gICAgICBwcmV2aW91c1BvaW50ID0gZW5kRGF0ZTtcbiAgICAgIGlmIChkdXJhdGlvbiA+PSByZXF1aXJlZER1cmF0aW9uKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGhpZGRlbkR1cmF0aW9uICs9IGVuZERhdGUgLSBzdGFydERhdGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhpZGRlbkR1cmF0aW9uO1xufTtcblxuXG5cbi8qKlxuICogdXNlZCB0byBzdGVwIG92ZXIgdG8gZWl0aGVyIHNpZGUgb2YgYSBoaWRkZW4gYmxvY2suIENvcnJlY3Rpb24gaXMgZGlzYWJsZWQgb24gdGFibGV0cywgbWlnaHQgYmUgc2V0IHRvIHRydWVcbiAqIEBwYXJhbSBoaWRkZW5EYXRlc1xuICogQHBhcmFtIHRpbWVcbiAqIEBwYXJhbSBkaXJlY3Rpb25cbiAqIEBwYXJhbSBjb3JyZWN0aW9uRW5hYmxlZFxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMuc25hcEF3YXlGcm9tSGlkZGVuID0gZnVuY3Rpb24oaGlkZGVuRGF0ZXMsIHRpbWUsIGRpcmVjdGlvbiwgY29ycmVjdGlvbkVuYWJsZWQpIHtcbiAgdmFyIGlzSGlkZGVuID0gZXhwb3J0cy5pc0hpZGRlbih0aW1lLCBoaWRkZW5EYXRlcyk7XG4gIGlmIChpc0hpZGRlbi5oaWRkZW4gPT0gdHJ1ZSkge1xuICAgIGlmIChkaXJlY3Rpb24gPCAwKSB7XG4gICAgICBpZiAoY29ycmVjdGlvbkVuYWJsZWQgPT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gaXNIaWRkZW4uc3RhcnREYXRlIC0gKGlzSGlkZGVuLmVuZERhdGUgLSB0aW1lKSAtIDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzSGlkZGVuLnN0YXJ0RGF0ZSAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGNvcnJlY3Rpb25FbmFibGVkID09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGlzSGlkZGVuLmVuZERhdGUgKyAodGltZSAtIGlzSGlkZGVuLnN0YXJ0RGF0ZSkgKyAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0hpZGRlbi5lbmREYXRlICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cblxufVxuXG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0aW1lIGlzIGhpZGRlblxuICpcbiAqIEBwYXJhbSB0aW1lXG4gKiBAcGFyYW0gaGlkZGVuRGF0ZXNcbiAqIEByZXR1cm5zIHt7aGlkZGVuOiBib29sZWFuLCBzdGFydERhdGU6IFdpbmRvdy5zdGFydCwgZW5kRGF0ZTogKn19XG4gKi9cbmV4cG9ydHMuaXNIaWRkZW4gPSBmdW5jdGlvbih0aW1lLCBoaWRkZW5EYXRlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN0YXJ0RGF0ZSA9IGhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuICAgIHZhciBlbmREYXRlID0gaGlkZGVuRGF0ZXNbaV0uZW5kO1xuXG4gICAgaWYgKHRpbWUgPj0gc3RhcnREYXRlICYmIHRpbWUgPCBlbmREYXRlKSB7IC8vIGlmIHRoZSBzdGFydCBpcyBlbnRlcmluZyBhIGhpZGRlbiB6b25lXG4gICAgICByZXR1cm4ge2hpZGRlbjogdHJ1ZSwgc3RhcnREYXRlOiBzdGFydERhdGUsIGVuZERhdGU6IGVuZERhdGV9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7aGlkZGVuOiBmYWxzZSwgc3RhcnREYXRlOiBzdGFydERhdGUsIGVuZERhdGU6IGVuZERhdGV9O1xufSIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIGhhbW1lclV0aWwgPSByZXF1aXJlKCcuLi9oYW1tZXJVdGlsJyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnLi4vbW9kdWxlL21vbWVudCcpO1xudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vY29tcG9uZW50L0NvbXBvbmVudCcpO1xudmFyIERhdGVVdGlsID0gcmVxdWlyZSgnLi9EYXRlVXRpbCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBSYW5nZVxuICogQSBSYW5nZSBjb250cm9scyBhIG51bWVyaWMgcmFuZ2Ugd2l0aCBhIHN0YXJ0IGFuZCBlbmQgdmFsdWUuXG4gKiBUaGUgUmFuZ2UgYWRqdXN0cyB0aGUgcmFuZ2UgYmFzZWQgb24gbW91c2UgZXZlbnRzIG9yIHByb2dyYW1tYXRpYyBjaGFuZ2VzLFxuICogYW5kIHRyaWdnZXJzIGV2ZW50cyB3aGVuIHRoZSByYW5nZSBpcyBjaGFuZ2luZyBvciBoYXMgYmVlbiBjaGFuZ2VkLlxuICogQHBhcmFtIHt7ZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3QsIGVtaXR0ZXI6IEVtaXR0ZXJ9fSBib2R5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIFNlZSBkZXNjcmlwdGlvbiBhdCBSYW5nZS5zZXRPcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFJhbmdlKGJvZHksIG9wdGlvbnMpIHtcbiAgdmFyIG5vdyA9IG1vbWVudCgpLmhvdXJzKDApLm1pbnV0ZXMoMCkuc2Vjb25kcygwKS5taWxsaXNlY29uZHMoMCk7XG4gIHRoaXMuc3RhcnQgPSBub3cuY2xvbmUoKS5hZGQoLTMsICdkYXlzJykudmFsdWVPZigpOyAvLyBOdW1iZXJcbiAgdGhpcy5lbmQgPSBub3cuY2xvbmUoKS5hZGQoNCwgJ2RheXMnKS52YWx1ZU9mKCk7ICAgLy8gTnVtYmVyXG5cbiAgdGhpcy5ib2R5ID0gYm9keTtcbiAgdGhpcy5kZWx0YURpZmZlcmVuY2UgPSAwO1xuICB0aGlzLnNjYWxlT2Zmc2V0ID0gMDtcbiAgdGhpcy5zdGFydFRvRnJvbnQgPSBmYWxzZTtcbiAgdGhpcy5lbmRUb0Zyb250ID0gdHJ1ZTtcblxuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBzdGFydDogbnVsbCxcbiAgICBlbmQ6IG51bGwsXG4gICAgbW9tZW50OiBtb21lbnQsXG4gICAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsIC8vICdob3Jpem9udGFsJyBvciAndmVydGljYWwnXG4gICAgbW92ZWFibGU6IHRydWUsXG4gICAgem9vbWFibGU6IHRydWUsXG4gICAgbWluOiBudWxsLFxuICAgIG1heDogbnVsbCxcbiAgICB6b29tTWluOiAxMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pbGxpc2Vjb25kc1xuICAgIHpvb21NYXg6IDEwMDAgKiA2MCAqIDYwICogMjQgKiAzNjUgKiAxMDAwMCAgLy8gbWlsbGlzZWNvbmRzXG4gIH07XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICB0aGlzLnByb3BzID0ge1xuICAgIHRvdWNoOiB7fVxuICB9O1xuICB0aGlzLmFuaW1hdGlvblRpbWVyID0gbnVsbDtcblxuICAvLyBkcmFnIGxpc3RlbmVycyBmb3IgZHJhZ2dpbmdcbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3BhbnN0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdwYW5tb3ZlJywgIHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpKTtcbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3BhbmVuZCcsICAgdGhpcy5fb25EcmFnRW5kLmJpbmQodGhpcykpO1xuXG4gIC8vIG1vdXNlIHdoZWVsIGZvciB6b29taW5nXG4gIHRoaXMuYm9keS5lbWl0dGVyLm9uKCdtb3VzZXdoZWVsJywgdGhpcy5fb25Nb3VzZVdoZWVsLmJpbmQodGhpcykpO1xuXG4gIC8vIHBpbmNoIHRvIHpvb21cbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3RvdWNoJywgdGhpcy5fb25Ub3VjaC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3BpbmNoJywgdGhpcy5fb25QaW5jaC5iaW5kKHRoaXMpKTtcblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG59XG5cblJhbmdlLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBTZXQgb3B0aW9ucyBmb3IgdGhlIHJhbmdlIGNvbnRyb2xsZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXIgfCBEYXRlIHwgU3RyaW5nfSBzdGFydCAgU3RhcnQgZGF0ZSBmb3IgdGhlIHJhbmdlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXIgfCBEYXRlIHwgU3RyaW5nfSBlbmQgICAgRW5kIGRhdGUgZm9yIHRoZSByYW5nZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtaW4gICAgTWluaW11bSB2YWx1ZSBmb3Igc3RhcnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWF4ICAgIE1heGltdW0gdmFsdWUgZm9yIGVuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSB6b29tTWluICAgIFNldCBhIG1pbmltdW0gdmFsdWUgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVuZCAtIHN0YXJ0KS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gem9vbU1heCAgICBTZXQgYSBtYXhpbXVtIHZhbHVlIGZvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbmQgLSBzdGFydCkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBtb3ZlYWJsZSBFbmFibGUgbW92aW5nIG9mIHRoZSByYW5nZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgZHJhZ2dpbmcuIFRydWUgYnkgZGVmYXVsdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gem9vbWFibGUgRW5hYmxlIHpvb21pbmcgb2YgdGhlIHJhbmdlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSBwaW5jaGluZy9zY3JvbGxpbmcuIFRydWUgYnkgZGVmYXVsdFxuICovXG5SYW5nZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgLy8gY29weSB0aGUgb3B0aW9ucyB0aGF0IHdlIGtub3dcbiAgICB2YXIgZmllbGRzID0gW1xuICAgICAgJ2RpcmVjdGlvbicsICdtaW4nLCAnbWF4JywgJ3pvb21NaW4nLCAnem9vbU1heCcsICdtb3ZlYWJsZScsICd6b29tYWJsZScsXG4gICAgICAnbW9tZW50JywgJ2FjdGl2YXRlJywgJ2hpZGRlbkRhdGVzJywgJ3pvb21LZXknXG4gICAgXTtcbiAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBpZiAoJ3N0YXJ0JyBpbiBvcHRpb25zIHx8ICdlbmQnIGluIG9wdGlvbnMpIHtcbiAgICAgIC8vIGFwcGx5IGEgbmV3IHJhbmdlLiBib3RoIHN0YXJ0IGFuZCBlbmQgYXJlIG9wdGlvbmFsXG4gICAgICB0aGlzLnNldFJhbmdlKG9wdGlvbnMuc3RhcnQsIG9wdGlvbnMuZW5kKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGRpcmVjdGlvbiBoYXMgYSB2YWxpZCB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiAgICAnaG9yaXpvbnRhbCcgb3IgJ3ZlcnRpY2FsJ1xuICovXG5mdW5jdGlvbiB2YWxpZGF0ZURpcmVjdGlvbiAoZGlyZWN0aW9uKSB7XG4gIGlmIChkaXJlY3Rpb24gIT0gJ2hvcml6b250YWwnICYmIGRpcmVjdGlvbiAhPSAndmVydGljYWwnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBkaXJlY3Rpb24gXCInICsgZGlyZWN0aW9uICsgJ1wiLiAnICtcbiAgICAgICAgJ0Nob29zZSBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSBuZXcgc3RhcnQgYW5kIGVuZCByYW5nZVxuICogQHBhcmFtIHtEYXRlIHwgTnVtYmVyIHwgU3RyaW5nfSBbc3RhcnRdXG4gKiBAcGFyYW0ge0RhdGUgfCBOdW1iZXIgfCBTdHJpbmd9IFtlbmRdXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ319IFthbmltYXRpb249ZmFsc2VdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RobHkgdG8gdGhlIG5ldyB3aW5kb3cuIEFuIG9iamVjdCBjYW4gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzICdlYXNlSW5PdXRRdWFkJy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J5VXNlcj1mYWxzZV1cbiAqXG4gKi9cblJhbmdlLnByb3RvdHlwZS5zZXRSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIGFuaW1hdGlvbiwgYnlVc2VyKSB7XG4gIGlmIChieVVzZXIgIT09IHRydWUpIHtcbiAgICBieVVzZXIgPSBmYWxzZTtcbiAgfVxuICB2YXIgZmluYWxTdGFydCA9IHN0YXJ0ICE9IHVuZGVmaW5lZCA/IHV0aWwuY29udmVydChzdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCkgOiBudWxsO1xuICB2YXIgZmluYWxFbmQgICA9IGVuZCAhPSB1bmRlZmluZWQgICA/IHV0aWwuY29udmVydChlbmQsICdEYXRlJykudmFsdWVPZigpICAgOiBudWxsO1xuICB0aGlzLl9jYW5jZWxBbmltYXRpb24oKTtcblxuICBpZiAoYW5pbWF0aW9uKSB7IC8vIHRydWUgb3IgYW4gT2JqZWN0XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgaW5pdFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICB2YXIgaW5pdEVuZCA9IHRoaXMuZW5kO1xuICAgIHZhciBkdXJhdGlvbiA9ICh0eXBlb2YgYW5pbWF0aW9uID09PSAnb2JqZWN0JyAmJiAnZHVyYXRpb24nIGluIGFuaW1hdGlvbikgPyBhbmltYXRpb24uZHVyYXRpb24gOiA1MDA7XG4gICAgdmFyIGVhc2luZ05hbWUgPSAodHlwZW9mIGFuaW1hdGlvbiA9PT0gJ29iamVjdCcgJiYgJ2Vhc2luZ0Z1bmN0aW9uJyBpbiBhbmltYXRpb24pID8gYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uIDogJ2Vhc2VJbk91dFF1YWQnO1xuICAgIHZhciBlYXNpbmdGdW5jdGlvbiA9IHV0aWwuZWFzaW5nRnVuY3Rpb25zW2Vhc2luZ05hbWVdO1xuICAgIGlmICghZWFzaW5nRnVuY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlYXNpbmcgZnVuY3Rpb24gJyArIEpTT04uc3RyaW5naWZ5KGVhc2luZ05hbWUpICsgJy4gJyArXG4gICAgICAgICAgJ0Nob29zZSBmcm9tOiAnICsgT2JqZWN0LmtleXModXRpbC5lYXNpbmdGdW5jdGlvbnMpLmpvaW4oJywgJykpO1xuICAgIH1cblxuICAgIHZhciBpbml0VGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgIHZhciBhbnlDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghbWUucHJvcHMudG91Y2guZHJhZ2dpbmcpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICB2YXIgdGltZSA9IG5vdyAtIGluaXRUaW1lO1xuICAgICAgICB2YXIgZWFzZSA9IGVhc2luZ0Z1bmN0aW9uKHRpbWUgLyBkdXJhdGlvbik7XG4gICAgICAgIHZhciBkb25lID0gdGltZSA+IGR1cmF0aW9uO1xuICAgICAgICB2YXIgcyA9IChkb25lIHx8IGZpbmFsU3RhcnQgPT09IG51bGwpID8gZmluYWxTdGFydCA6IGluaXRTdGFydCArIChmaW5hbFN0YXJ0IC0gaW5pdFN0YXJ0KSAqIGVhc2U7XG4gICAgICAgIHZhciBlID0gKGRvbmUgfHwgZmluYWxFbmQgICA9PT0gbnVsbCkgPyBmaW5hbEVuZCAgIDogaW5pdEVuZCAgICsgKGZpbmFsRW5kICAgLSBpbml0RW5kKSAgICogZWFzZTtcblxuICAgICAgICBjaGFuZ2VkID0gbWUuX2FwcGx5UmFuZ2UocywgZSk7XG4gICAgICAgIERhdGVVdGlsLnVwZGF0ZUhpZGRlbkRhdGVzKG1lLm9wdGlvbnMubW9tZW50LCBtZS5ib2R5LCBtZS5vcHRpb25zLmhpZGRlbkRhdGVzKTtcbiAgICAgICAgYW55Q2hhbmdlZCA9IGFueUNoYW5nZWQgfHwgY2hhbmdlZDtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICBtZS5ib2R5LmVtaXR0ZXIuZW1pdCgncmFuZ2VjaGFuZ2UnLCB7c3RhcnQ6IG5ldyBEYXRlKG1lLnN0YXJ0KSwgZW5kOiBuZXcgRGF0ZShtZS5lbmQpLCBieVVzZXI6YnlVc2VyfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGlmIChhbnlDaGFuZ2VkKSB7XG4gICAgICAgICAgICBtZS5ib2R5LmVtaXR0ZXIuZW1pdCgncmFuZ2VjaGFuZ2VkJywge3N0YXJ0OiBuZXcgRGF0ZShtZS5zdGFydCksIGVuZDogbmV3IERhdGUobWUuZW5kKSwgYnlVc2VyOmJ5VXNlcn0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBhbmltYXRlIHdpdGggYXMgaGlnaCBhcyBwb3NzaWJsZSBmcmFtZSByYXRlLCBsZWF2ZSAyMCBtcyBpbiBiZXR3ZWVuXG4gICAgICAgICAgLy8gZWFjaCB0byBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gYmxvY2tpbmdcbiAgICAgICAgICBtZS5hbmltYXRpb25UaW1lciA9IHNldFRpbWVvdXQobmV4dCwgMjApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBuZXh0KCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGNoYW5nZWQgPSB0aGlzLl9hcHBseVJhbmdlKGZpbmFsU3RhcnQsIGZpbmFsRW5kKTtcbiAgICBEYXRlVXRpbC51cGRhdGVIaWRkZW5EYXRlcyh0aGlzLm9wdGlvbnMubW9tZW50LCB0aGlzLmJvZHksIHRoaXMub3B0aW9ucy5oaWRkZW5EYXRlcyk7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSB7c3RhcnQ6IG5ldyBEYXRlKHRoaXMuc3RhcnQpLCBlbmQ6IG5ldyBEYXRlKHRoaXMuZW5kKSwgYnlVc2VyOmJ5VXNlcn07XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZScsIHBhcmFtcyk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZWQnLCBwYXJhbXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTdG9wIGFuIGFuaW1hdGlvblxuICogQHByaXZhdGVcbiAqL1xuUmFuZ2UucHJvdG90eXBlLl9jYW5jZWxBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFuaW1hdGlvblRpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuYW5pbWF0aW9uVGltZXIpO1xuICAgIHRoaXMuYW5pbWF0aW9uVGltZXIgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBhIG5ldyBzdGFydCBhbmQgZW5kIHJhbmdlLiBUaGlzIG1ldGhvZCBpcyB0aGUgc2FtZSBhcyBzZXRSYW5nZSwgYnV0XG4gKiBkb2VzIG5vdCB0cmlnZ2VyIGEgcmFuZ2UgY2hhbmdlIGFuZCByYW5nZSBjaGFuZ2VkIGV2ZW50LCBhbmQgaXQgcmV0dXJuc1xuICogdHJ1ZSB3aGVuIHRoZSByYW5nZSBpcyBjaGFuZ2VkXG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0XVxuICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRdXG4gKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX2FwcGx5UmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHZhciBuZXdTdGFydCA9IChzdGFydCAhPSBudWxsKSA/IHV0aWwuY29udmVydChzdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCkgOiB0aGlzLnN0YXJ0LFxuICAgICAgbmV3RW5kICAgPSAoZW5kICE9IG51bGwpICAgPyB1dGlsLmNvbnZlcnQoZW5kLCAnRGF0ZScpLnZhbHVlT2YoKSAgIDogdGhpcy5lbmQsXG4gICAgICBtYXggPSAodGhpcy5vcHRpb25zLm1heCAhPSBudWxsKSA/IHV0aWwuY29udmVydCh0aGlzLm9wdGlvbnMubWF4LCAnRGF0ZScpLnZhbHVlT2YoKSA6IG51bGwsXG4gICAgICBtaW4gPSAodGhpcy5vcHRpb25zLm1pbiAhPSBudWxsKSA/IHV0aWwuY29udmVydCh0aGlzLm9wdGlvbnMubWluLCAnRGF0ZScpLnZhbHVlT2YoKSA6IG51bGwsXG4gICAgICBkaWZmO1xuXG4gIC8vIGNoZWNrIGZvciB2YWxpZCBudW1iZXJcbiAgaWYgKGlzTmFOKG5ld1N0YXJ0KSB8fCBuZXdTdGFydCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGFydCBcIicgKyBzdGFydCArICdcIicpO1xuICB9XG4gIGlmIChpc05hTihuZXdFbmQpIHx8IG5ld0VuZCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmQgXCInICsgZW5kICsgJ1wiJyk7XG4gIH1cblxuICAvLyBwcmV2ZW50IHN0YXJ0IDwgZW5kXG4gIGlmIChuZXdFbmQgPCBuZXdTdGFydCkge1xuICAgIG5ld0VuZCA9IG5ld1N0YXJ0O1xuICB9XG5cbiAgLy8gcHJldmVudCBzdGFydCA8IG1pblxuICBpZiAobWluICE9PSBudWxsKSB7XG4gICAgaWYgKG5ld1N0YXJ0IDwgbWluKSB7XG4gICAgICBkaWZmID0gKG1pbiAtIG5ld1N0YXJ0KTtcbiAgICAgIG5ld1N0YXJ0ICs9IGRpZmY7XG4gICAgICBuZXdFbmQgKz0gZGlmZjtcblxuICAgICAgLy8gcHJldmVudCBlbmQgPiBtYXhcbiAgICAgIGlmIChtYXggIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV3RW5kID4gbWF4KSB7XG4gICAgICAgICAgbmV3RW5kID0gbWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcHJldmVudCBlbmQgPiBtYXhcbiAgaWYgKG1heCAhPT0gbnVsbCkge1xuICAgIGlmIChuZXdFbmQgPiBtYXgpIHtcbiAgICAgIGRpZmYgPSAobmV3RW5kIC0gbWF4KTtcbiAgICAgIG5ld1N0YXJ0IC09IGRpZmY7XG4gICAgICBuZXdFbmQgLT0gZGlmZjtcblxuICAgICAgLy8gcHJldmVudCBzdGFydCA8IG1pblxuICAgICAgaWYgKG1pbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZXdTdGFydCA8IG1pbikge1xuICAgICAgICAgIG5ld1N0YXJ0ID0gbWluO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcHJldmVudCAoZW5kLXN0YXJ0KSA8IHpvb21NaW5cbiAgaWYgKHRoaXMub3B0aW9ucy56b29tTWluICE9PSBudWxsKSB7XG4gICAgdmFyIHpvb21NaW4gPSBwYXJzZUZsb2F0KHRoaXMub3B0aW9ucy56b29tTWluKTtcbiAgICBpZiAoem9vbU1pbiA8IDApIHtcbiAgICAgIHpvb21NaW4gPSAwO1xuICAgIH1cbiAgICBpZiAoKG5ld0VuZCAtIG5ld1N0YXJ0KSA8IHpvb21NaW4pIHtcbiAgICAgIGlmICgodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSA9PT0gem9vbU1pbiAmJiBuZXdTdGFydCA+IHRoaXMuc3RhcnQgJiYgbmV3RW5kIDwgdGhpcy5lbmQpIHtcbiAgICAgICAgLy8gaWdub3JlIHRoaXMgYWN0aW9uLCB3ZSBhcmUgYWxyZWFkeSB6b29tZWQgdG8gdGhlIG1pbmltdW1cbiAgICAgICAgbmV3U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBuZXdFbmQgPSB0aGlzLmVuZDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB6b29tIHRvIHRoZSBtaW5pbXVtXG4gICAgICAgIGRpZmYgPSAoem9vbU1pbiAtIChuZXdFbmQgLSBuZXdTdGFydCkpO1xuICAgICAgICBuZXdTdGFydCAtPSBkaWZmIC8gMjtcbiAgICAgICAgbmV3RW5kICs9IGRpZmYgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHByZXZlbnQgKGVuZC1zdGFydCkgPiB6b29tTWF4XG4gIGlmICh0aGlzLm9wdGlvbnMuem9vbU1heCAhPT0gbnVsbCkge1xuICAgIHZhciB6b29tTWF4ID0gcGFyc2VGbG9hdCh0aGlzLm9wdGlvbnMuem9vbU1heCk7XG4gICAgaWYgKHpvb21NYXggPCAwKSB7XG4gICAgICB6b29tTWF4ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoKG5ld0VuZCAtIG5ld1N0YXJ0KSA+IHpvb21NYXgpIHtcbiAgICAgIGlmICgodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSA9PT0gem9vbU1heCAmJiBuZXdTdGFydCA8IHRoaXMuc3RhcnQgJiYgbmV3RW5kID4gdGhpcy5lbmQpIHtcbiAgICAgICAgLy8gaWdub3JlIHRoaXMgYWN0aW9uLCB3ZSBhcmUgYWxyZWFkeSB6b29tZWQgdG8gdGhlIG1heGltdW1cbiAgICAgICAgbmV3U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBuZXdFbmQgPSB0aGlzLmVuZDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB6b29tIHRvIHRoZSBtYXhpbXVtXG4gICAgICAgIGRpZmYgPSAoKG5ld0VuZCAtIG5ld1N0YXJ0KSAtIHpvb21NYXgpO1xuICAgICAgICBuZXdTdGFydCArPSBkaWZmIC8gMjtcbiAgICAgICAgbmV3RW5kIC09IGRpZmYgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjaGFuZ2VkID0gKHRoaXMuc3RhcnQgIT0gbmV3U3RhcnQgfHwgdGhpcy5lbmQgIT0gbmV3RW5kKTtcblxuICAvLyBpZiB0aGUgbmV3IHJhbmdlIGRvZXMgTk9UIG92ZXJsYXAgd2l0aCB0aGUgb2xkIHJhbmdlLCBlbWl0IGNoZWNrUmFuZ2VkSXRlbXMgdG8gYXZvaWQgbm90IHNob3dpbmcgcmFuZ2VkIGl0ZW1zIChyYW5nZWQgbWVhbmluZyBoYXMgZW5kIHRpbWUsIG5vdCBuZWNlc3NhcmlseSBvZiB0eXBlIFJhbmdlKVxuICBpZiAoISgobmV3U3RhcnQgPj0gdGhpcy5zdGFydCAmJiBuZXdTdGFydCAgIDw9IHRoaXMuZW5kKSB8fCAobmV3RW5kICAgPj0gdGhpcy5zdGFydCAmJiBuZXdFbmQgICA8PSB0aGlzLmVuZCkpICYmXG4gICAgICAhKCh0aGlzLnN0YXJ0ID49IG5ld1N0YXJ0ICYmIHRoaXMuc3RhcnQgPD0gbmV3RW5kKSAgIHx8ICh0aGlzLmVuZCA+PSBuZXdTdGFydCAgICYmIHRoaXMuZW5kIDw9IG5ld0VuZCkgKSkge1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2NoZWNrUmFuZ2VkSXRlbXMnKTtcbiAgfVxuXG4gIHRoaXMuc3RhcnQgPSBuZXdTdGFydDtcbiAgdGhpcy5lbmQgPSBuZXdFbmQ7XG4gIHJldHVybiBjaGFuZ2VkO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCByYW5nZS5cbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzXG4gKi9cblJhbmdlLnByb3RvdHlwZS5nZXRSYW5nZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgIGVuZDogdGhpcy5lbmRcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBjb252ZXJzaW9uIG9mZnNldCBhbmQgc2NhbGUgZm9yIGN1cnJlbnQgcmFuZ2UsIGJhc2VkIG9uXG4gKiB0aGUgcHJvdmlkZWQgd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICogQHJldHVybnMge3tvZmZzZXQ6IG51bWJlciwgc2NhbGU6IG51bWJlcn19IGNvbnZlcnNpb25cbiAqL1xuUmFuZ2UucHJvdG90eXBlLmNvbnZlcnNpb24gPSBmdW5jdGlvbiAod2lkdGgsIHRvdGFsSGlkZGVuKSB7XG4gIHJldHVybiBSYW5nZS5jb252ZXJzaW9uKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCB3aWR0aCwgdG90YWxIaWRkZW4pO1xufTtcblxuLyoqXG4gKiBTdGF0aWMgbWV0aG9kIHRvIGNhbGN1bGF0ZSB0aGUgY29udmVyc2lvbiBvZmZzZXQgYW5kIHNjYWxlIGZvciBhIHJhbmdlLFxuICogYmFzZWQgb24gdGhlIHByb3ZpZGVkIHN0YXJ0LCBlbmQsIGFuZCB3aWR0aFxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge051bWJlcn0gZW5kXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAqIEByZXR1cm5zIHt7b2Zmc2V0OiBudW1iZXIsIHNjYWxlOiBudW1iZXJ9fSBjb252ZXJzaW9uXG4gKi9cblJhbmdlLmNvbnZlcnNpb24gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgd2lkdGgsIHRvdGFsSGlkZGVuKSB7XG4gIGlmICh0b3RhbEhpZGRlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxIaWRkZW4gPSAwO1xuICB9XG4gIGlmICh3aWR0aCAhPSAwICYmIChlbmQgLSBzdGFydCAhPSAwKSkge1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgc2NhbGU6IHdpZHRoIC8gKGVuZCAtIHN0YXJ0IC0gdG90YWxIaWRkZW4pXG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXQ6IDAsXG4gICAgICBzY2FsZTogMVxuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnQgZHJhZ2dpbmcgaG9yaXpvbnRhbGx5IG9yIHZlcnRpY2FsbHlcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdGhpcy5kZWx0YURpZmZlcmVuY2UgPSAwO1xuICB0aGlzLnByZXZpb3VzRGVsdGEgPSAwO1xuXG4gIC8vIG9ubHkgYWxsb3cgZHJhZ2dpbmcgd2hlbiBjb25maWd1cmVkIGFzIG1vdmFibGVcbiAgaWYgKCF0aGlzLm9wdGlvbnMubW92ZWFibGUpIHJldHVybjtcblxuICAvLyBvbmx5IHN0YXJ0IGRyYWdnaW5nIHdoZW4gdGhlIG1vdXNlIGlzIGluc2lkZSB0aGUgY3VycmVudCByYW5nZVxuICBpZiAoIXRoaXMuX2lzSW5zaWRlUmFuZ2UoZXZlbnQpKSByZXR1cm47XG5cbiAgLy8gcmVmdXNlIHRvIGRyYWcgd2hlbiB3ZSB3aGVyZSBwaW5jaGluZyB0byBwcmV2ZW50IHRoZSB0aW1lbGluZSBtYWtlIGEganVtcFxuICAvLyB3aGVuIHJlbGVhc2luZyB0aGUgZmluZ2VycyBpbiBvcHBvc2l0ZSBvcmRlciBmcm9tIHRoZSB0b3VjaCBzY3JlZW5cbiAgaWYgKCF0aGlzLnByb3BzLnRvdWNoLmFsbG93RHJhZ2dpbmcpIHJldHVybjtcblxuICB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgdGhpcy5wcm9wcy50b3VjaC5lbmQgPSB0aGlzLmVuZDtcbiAgdGhpcy5wcm9wcy50b3VjaC5kcmFnZ2luZyA9IHRydWU7XG5cbiAgaWYgKHRoaXMuYm9keS5kb20ucm9vdCkge1xuICAgIHRoaXMuYm9keS5kb20ucm9vdC5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybSBkcmFnZ2luZyBvcGVyYXRpb25cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIXRoaXMucHJvcHMudG91Y2guZHJhZ2dpbmcpIHJldHVybjtcblxuICAvLyBvbmx5IGFsbG93IGRyYWdnaW5nIHdoZW4gY29uZmlndXJlZCBhcyBtb3ZhYmxlXG4gIGlmICghdGhpcy5vcHRpb25zLm1vdmVhYmxlKSByZXR1cm47XG5cbiAgLy8gVE9ETzogdGhpcyBtYXkgYmUgcmVkdW5kYW50IGluIGhhbW1lcmpzMlxuICAvLyByZWZ1c2UgdG8gZHJhZyB3aGVuIHdlIHdoZXJlIHBpbmNoaW5nIHRvIHByZXZlbnQgdGhlIHRpbWVsaW5lIG1ha2UgYSBqdW1wXG4gIC8vIHdoZW4gcmVsZWFzaW5nIHRoZSBmaW5nZXJzIGluIG9wcG9zaXRlIG9yZGVyIGZyb20gdGhlIHRvdWNoIHNjcmVlblxuICBpZiAoIXRoaXMucHJvcHMudG91Y2guYWxsb3dEcmFnZ2luZykgcmV0dXJuO1xuXG4gIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICB2YWxpZGF0ZURpcmVjdGlvbihkaXJlY3Rpb24pO1xuICB2YXIgZGVsdGEgPSAoZGlyZWN0aW9uID09ICdob3Jpem9udGFsJykgPyBldmVudC5kZWx0YVggOiBldmVudC5kZWx0YVk7XG4gIGRlbHRhIC09IHRoaXMuZGVsdGFEaWZmZXJlbmNlO1xuICB2YXIgaW50ZXJ2YWwgPSAodGhpcy5wcm9wcy50b3VjaC5lbmQgLSB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0KTtcblxuICAvLyBub3JtYWxpemUgZHJhZ2dpbmcgc3BlZWQgaWYgY3V0b3V0IGlzIGluIGJldHdlZW4uXG4gIHZhciBkdXJhdGlvbiA9IERhdGVVdGlsLmdldEhpZGRlbkR1cmF0aW9uQmV0d2Vlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgaW50ZXJ2YWwgLT0gZHVyYXRpb247XG5cbiAgdmFyIHdpZHRoID0gKGRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcpID8gdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlci53aWR0aCA6IHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXIuaGVpZ2h0O1xuICB2YXIgZGlmZlJhbmdlID0gLWRlbHRhIC8gd2lkdGggKiBpbnRlcnZhbDtcbiAgdmFyIG5ld1N0YXJ0ID0gdGhpcy5wcm9wcy50b3VjaC5zdGFydCArIGRpZmZSYW5nZTtcbiAgdmFyIG5ld0VuZCA9IHRoaXMucHJvcHMudG91Y2guZW5kICsgZGlmZlJhbmdlO1xuXG4gIC8vIHNuYXBwaW5nIHRpbWVzIGF3YXkgZnJvbSBoaWRkZW4gem9uZXNcbiAgdmFyIHNhZmVTdGFydCA9IERhdGVVdGlsLnNuYXBBd2F5RnJvbUhpZGRlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIG5ld1N0YXJ0LCB0aGlzLnByZXZpb3VzRGVsdGEtZGVsdGEsIHRydWUpO1xuICB2YXIgc2FmZUVuZCA9IERhdGVVdGlsLnNuYXBBd2F5RnJvbUhpZGRlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIG5ld0VuZCwgdGhpcy5wcmV2aW91c0RlbHRhLWRlbHRhLCB0cnVlKTtcbiAgaWYgKHNhZmVTdGFydCAhPSBuZXdTdGFydCB8fCBzYWZlRW5kICE9IG5ld0VuZCkge1xuICAgIHRoaXMuZGVsdGFEaWZmZXJlbmNlICs9IGRlbHRhO1xuICAgIHRoaXMucHJvcHMudG91Y2guc3RhcnQgPSBzYWZlU3RhcnQ7XG4gICAgdGhpcy5wcm9wcy50b3VjaC5lbmQgPSBzYWZlRW5kO1xuICAgIHRoaXMuX29uRHJhZyhldmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5wcmV2aW91c0RlbHRhID0gZGVsdGE7XG4gIHRoaXMuX2FwcGx5UmFuZ2UobmV3U3RhcnQsIG5ld0VuZCk7XG5cbiAgLy8gZmlyZSBhIHJhbmdlY2hhbmdlIGV2ZW50XG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3JhbmdlY2hhbmdlJywge1xuICAgIHN0YXJ0OiBuZXcgRGF0ZSh0aGlzLnN0YXJ0KSxcbiAgICBlbmQ6ICAgbmV3IERhdGUodGhpcy5lbmQpLFxuICAgIGJ5VXNlcjogdHJ1ZVxuICB9KTtcbn07XG5cbi8qKlxuICogU3RvcCBkcmFnZ2luZyBvcGVyYXRpb25cbiAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIXRoaXMucHJvcHMudG91Y2guZHJhZ2dpbmcpIHJldHVybjtcblxuICAvLyBvbmx5IGFsbG93IGRyYWdnaW5nIHdoZW4gY29uZmlndXJlZCBhcyBtb3ZhYmxlXG4gIGlmICghdGhpcy5vcHRpb25zLm1vdmVhYmxlKSByZXR1cm47XG5cbiAgLy8gVE9ETzogdGhpcyBtYXkgYmUgcmVkdW5kYW50IGluIGhhbW1lcmpzMlxuICAvLyByZWZ1c2UgdG8gZHJhZyB3aGVuIHdlIHdoZXJlIHBpbmNoaW5nIHRvIHByZXZlbnQgdGhlIHRpbWVsaW5lIG1ha2UgYSBqdW1wXG4gIC8vIHdoZW4gcmVsZWFzaW5nIHRoZSBmaW5nZXJzIGluIG9wcG9zaXRlIG9yZGVyIGZyb20gdGhlIHRvdWNoIHNjcmVlblxuICBpZiAoIXRoaXMucHJvcHMudG91Y2guYWxsb3dEcmFnZ2luZykgcmV0dXJuO1xuXG4gIHRoaXMucHJvcHMudG91Y2guZHJhZ2dpbmcgPSBmYWxzZTtcbiAgaWYgKHRoaXMuYm9keS5kb20ucm9vdCkge1xuICAgIHRoaXMuYm9keS5kb20ucm9vdC5zdHlsZS5jdXJzb3IgPSAnYXV0byc7XG4gIH1cblxuICAvLyBmaXJlIGEgcmFuZ2VjaGFuZ2VkIGV2ZW50XG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3JhbmdlY2hhbmdlZCcsIHtcbiAgICBzdGFydDogbmV3IERhdGUodGhpcy5zdGFydCksXG4gICAgZW5kOiAgIG5ldyBEYXRlKHRoaXMuZW5kKSxcbiAgICBieVVzZXI6IHRydWVcbiAgfSk7XG59O1xuXG4vKipcbiAqIEV2ZW50IGhhbmRsZXIgZm9yIG1vdXNlIHdoZWVsIGV2ZW50LCB1c2VkIHRvIHpvb21cbiAqIENvZGUgZnJvbSBodHRwOi8vYWRvbWFzLm9yZy9qYXZhc2NyaXB0LW1vdXNlLXdoZWVsL1xuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fb25Nb3VzZVdoZWVsID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgLy8gb25seSBhbGxvdyB6b29taW5nIHdoZW4gY29uZmlndXJlZCBhcyB6b29tYWJsZSBhbmQgbW92ZWFibGVcbiAgaWYgKCEodGhpcy5vcHRpb25zLnpvb21hYmxlICYmIHRoaXMub3B0aW9ucy5tb3ZlYWJsZSkpIHJldHVybjtcblxuICAvLyBvbmx5IHpvb20gd2hlbiB0aGUgbW91c2UgaXMgaW5zaWRlIHRoZSBjdXJyZW50IHJhbmdlXG4gIGlmICghdGhpcy5faXNJbnNpZGVSYW5nZShldmVudCkpIHJldHVybjtcbiAgXG4gIC8vIG9ubHkgem9vbSB3aGVuIHRoZSBhY2NvcmRpbmcga2V5IGlzIHByZXNzZWQgYW5kIHRoZSB6b29tS2V5IG9wdGlvbiBpcyBzZXRcbiAgaWYgKHRoaXMub3B0aW9ucy56b29tS2V5ICYmICFldmVudFt0aGlzLm9wdGlvbnMuem9vbUtleV0pIHJldHVybjtcblxuICAvLyByZXRyaWV2ZSBkZWx0YVxuICB2YXIgZGVsdGEgPSAwO1xuICBpZiAoZXZlbnQud2hlZWxEZWx0YSkgeyAvKiBJRS9PcGVyYS4gKi9cbiAgICBkZWx0YSA9IGV2ZW50LndoZWVsRGVsdGEgLyAxMjA7XG4gIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7IC8qIE1vemlsbGEgY2FzZS4gKi9cbiAgICAvLyBJbiBNb3ppbGxhLCBzaWduIG9mIGRlbHRhIGlzIGRpZmZlcmVudCB0aGFuIGluIElFLlxuICAgIC8vIEFsc28sIGRlbHRhIGlzIG11bHRpcGxlIG9mIDMuXG4gICAgZGVsdGEgPSAtZXZlbnQuZGV0YWlsIC8gMztcbiAgfVxuXG4gIC8vIElmIGRlbHRhIGlzIG5vbnplcm8sIGhhbmRsZSBpdC5cbiAgLy8gQmFzaWNhbGx5LCBkZWx0YSBpcyBub3cgcG9zaXRpdmUgaWYgd2hlZWwgd2FzIHNjcm9sbGVkIHVwLFxuICAvLyBhbmQgbmVnYXRpdmUsIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCBkb3duLlxuICBpZiAoZGVsdGEpIHtcbiAgICAvLyBwZXJmb3JtIHRoZSB6b29tIGFjdGlvbi4gRGVsdGEgaXMgbm9ybWFsbHkgMSBvciAtMVxuXG4gICAgLy8gYWRqdXN0IGEgbmVnYXRpdmUgZGVsdGEgc3VjaCB0aGF0IHpvb21pbmcgaW4gd2l0aCBkZWx0YSAwLjFcbiAgICAvLyBlcXVhbHMgem9vbWluZyBvdXQgd2l0aCBhIGRlbHRhIC0wLjFcbiAgICB2YXIgc2NhbGU7XG4gICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgc2NhbGUgPSAxIC0gKGRlbHRhIC8gNSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2NhbGUgPSAxIC8gKDEgKyAoZGVsdGEgLyA1KSkgO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBjZW50ZXIsIHRoZSBkYXRlIHRvIHpvb20gYXJvdW5kXG4gICAgdmFyIHBvaW50ZXIgPSBnZXRQb2ludGVyKHt4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZfSwgdGhpcy5ib2R5LmRvbS5jZW50ZXIpO1xuICAgIHZhciBwb2ludGVyRGF0ZSA9IHRoaXMuX3BvaW50ZXJUb0RhdGUocG9pbnRlcik7XG5cbiAgICB0aGlzLnpvb20oc2NhbGUsIHBvaW50ZXJEYXRlLCBkZWx0YSk7XG4gIH1cblxuICAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9ucyBjYXVzZWQgYnkgbW91c2Ugd2hlZWxcbiAgLy8gKGVsc2UgdGhlIHBhZ2UgYW5kIHRpbWVsaW5lIGJvdGggem9vbSBhbmQgc2Nyb2xsKVxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuLyoqXG4gKiBTdGFydCBvZiBhIHRvdWNoIGdlc3R1cmVcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fb25Ub3VjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgdGhpcy5wcm9wcy50b3VjaC5lbmQgPSB0aGlzLmVuZDtcbiAgdGhpcy5wcm9wcy50b3VjaC5hbGxvd0RyYWdnaW5nID0gdHJ1ZTtcbiAgdGhpcy5wcm9wcy50b3VjaC5jZW50ZXIgPSBudWxsO1xuICB0aGlzLnNjYWxlT2Zmc2V0ID0gMDtcbiAgdGhpcy5kZWx0YURpZmZlcmVuY2UgPSAwO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgcGluY2ggZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX29uUGluY2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gb25seSBhbGxvdyB6b29taW5nIHdoZW4gY29uZmlndXJlZCBhcyB6b29tYWJsZSBhbmQgbW92ZWFibGVcbiAgaWYgKCEodGhpcy5vcHRpb25zLnpvb21hYmxlICYmIHRoaXMub3B0aW9ucy5tb3ZlYWJsZSkpIHJldHVybjtcblxuICB0aGlzLnByb3BzLnRvdWNoLmFsbG93RHJhZ2dpbmcgPSBmYWxzZTtcblxuICBpZiAoIXRoaXMucHJvcHMudG91Y2guY2VudGVyKSB7XG4gICAgdGhpcy5wcm9wcy50b3VjaC5jZW50ZXIgPSBnZXRQb2ludGVyKGV2ZW50LmNlbnRlciwgdGhpcy5ib2R5LmRvbS5jZW50ZXIpO1xuICB9XG5cbiAgdmFyIHNjYWxlID0gMSAvIChldmVudC5zY2FsZSArIHRoaXMuc2NhbGVPZmZzZXQpO1xuICB2YXIgY2VudGVyRGF0ZSA9IHRoaXMuX3BvaW50ZXJUb0RhdGUodGhpcy5wcm9wcy50b3VjaC5jZW50ZXIpO1xuXG4gIHZhciBoaWRkZW5EdXJhdGlvbiA9IERhdGVVdGlsLmdldEhpZGRlbkR1cmF0aW9uQmV0d2Vlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgdmFyIGhpZGRlbkR1cmF0aW9uQmVmb3JlID0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUodGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLCBjZW50ZXJEYXRlKTtcbiAgdmFyIGhpZGRlbkR1cmF0aW9uQWZ0ZXIgPSBoaWRkZW5EdXJhdGlvbiAtIGhpZGRlbkR1cmF0aW9uQmVmb3JlO1xuXG4gIC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgYW5kIGVuZFxuICB2YXIgbmV3U3RhcnQgPSAoY2VudGVyRGF0ZSAtIGhpZGRlbkR1cmF0aW9uQmVmb3JlKSArICh0aGlzLnByb3BzLnRvdWNoLnN0YXJ0IC0gKGNlbnRlckRhdGUgLSBoaWRkZW5EdXJhdGlvbkJlZm9yZSkpICogc2NhbGU7XG4gIHZhciBuZXdFbmQgPSAoY2VudGVyRGF0ZSArIGhpZGRlbkR1cmF0aW9uQWZ0ZXIpICsgKHRoaXMucHJvcHMudG91Y2guZW5kIC0gKGNlbnRlckRhdGUgKyBoaWRkZW5EdXJhdGlvbkFmdGVyKSkgKiBzY2FsZTtcblxuICAvLyBzbmFwcGluZyB0aW1lcyBhd2F5IGZyb20gaGlkZGVuIHpvbmVzXG4gIHRoaXMuc3RhcnRUb0Zyb250ID0gMSAtIHNjYWxlIDw9IDA7IC8vIHVzZWQgdG8gZG8gdGhlIHJpZ2h0IGF1dG8gY29ycmVjdGlvbiB3aXRoIHBlcmlvZGljIGhpZGRlbiB0aW1lc1xuICB0aGlzLmVuZFRvRnJvbnQgPSBzY2FsZSAtIDEgPD0gMDsgICAvLyB1c2VkIHRvIGRvIHRoZSByaWdodCBhdXRvIGNvcnJlY3Rpb24gd2l0aCBwZXJpb2RpYyBoaWRkZW4gdGltZXNcblxuICB2YXIgc2FmZVN0YXJ0ID0gRGF0ZVV0aWwuc25hcEF3YXlGcm9tSGlkZGVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgbmV3U3RhcnQsIDEgLSBzY2FsZSwgdHJ1ZSk7XG4gIHZhciBzYWZlRW5kID0gRGF0ZVV0aWwuc25hcEF3YXlGcm9tSGlkZGVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgbmV3RW5kLCBzY2FsZSAtIDEsIHRydWUpO1xuICBpZiAoc2FmZVN0YXJ0ICE9IG5ld1N0YXJ0IHx8IHNhZmVFbmQgIT0gbmV3RW5kKSB7XG4gICAgdGhpcy5wcm9wcy50b3VjaC5zdGFydCA9IHNhZmVTdGFydDtcbiAgICB0aGlzLnByb3BzLnRvdWNoLmVuZCA9IHNhZmVFbmQ7XG4gICAgdGhpcy5zY2FsZU9mZnNldCA9IDEgLSBldmVudC5zY2FsZTtcbiAgICBuZXdTdGFydCA9IHNhZmVTdGFydDtcbiAgICBuZXdFbmQgPSBzYWZlRW5kO1xuICB9XG5cbiAgdGhpcy5zZXRSYW5nZShuZXdTdGFydCwgbmV3RW5kLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgdGhpcy5zdGFydFRvRnJvbnQgPSBmYWxzZTsgLy8gcmV2ZXJ0IHRvIGRlZmF1bHRcbiAgdGhpcy5lbmRUb0Zyb250ID0gdHJ1ZTsgLy8gcmV2ZXJ0IHRvIGRlZmF1bHRcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIHRoZSBtb3VzZSBmcm9tIGEgbW91c2UgZXZlbnQgaXMgaW5zaWRlIHRoZSB2aXNpYmxlIHdpbmRvdyxcbiAqIGJldHdlZW4gdGhlIGN1cnJlbnQgc3RhcnQgYW5kIGVuZCBkYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIGluc2lkZSB0aGUgdmlzaWJsZSB3aW5kb3dcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5faXNJbnNpZGVSYW5nZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIC8vIGNhbGN1bGF0ZSB0aGUgdGltZSB3aGVyZSB0aGUgbW91c2UgaXMsIGNoZWNrIHdoZXRoZXIgaW5zaWRlXG4gIC8vIGFuZCBubyBzY3JvbGwgYWN0aW9uIHNob3VsZCBoYXBwZW4uXG4gIHZhciBjbGllbnRYID0gZXZlbnQuY2VudGVyID8gZXZlbnQuY2VudGVyLnggOiBldmVudC5jbGllbnRYO1xuICB2YXIgeCA9IGNsaWVudFggLSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmJvZHkuZG9tLmNlbnRlckNvbnRhaW5lcik7XG4gIHZhciB0aW1lID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHgpO1xuXG4gIHJldHVybiB0aW1lID49IHRoaXMuc3RhcnQgJiYgdGltZSA8PSB0aGlzLmVuZDtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSB0aGUgY2VudGVyIGRhdGUgZm9yIHpvb21pbmdcbiAqIEBwYXJhbSB7e3g6IE51bWJlciwgeTogTnVtYmVyfX0gcG9pbnRlclxuICogQHJldHVybiB7bnVtYmVyfSBkYXRlXG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX3BvaW50ZXJUb0RhdGUgPSBmdW5jdGlvbiAocG9pbnRlcikge1xuICB2YXIgY29udmVyc2lvbjtcbiAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG5cbiAgdmFsaWRhdGVEaXJlY3Rpb24oZGlyZWN0aW9uKTtcblxuICBpZiAoZGlyZWN0aW9uID09ICdob3Jpem9udGFsJykge1xuICAgIHJldHVybiB0aGlzLmJvZHkudXRpbC50b1RpbWUocG9pbnRlci54KS52YWx1ZU9mKCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXIuaGVpZ2h0O1xuICAgIGNvbnZlcnNpb24gPSB0aGlzLmNvbnZlcnNpb24oaGVpZ2h0KTtcbiAgICByZXR1cm4gcG9pbnRlci55IC8gY29udmVyc2lvbi5zY2FsZSArIGNvbnZlcnNpb24ub2Zmc2V0O1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcG9pbnRlciBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgbG9jYXRpb24gb2YgdGhlIGRvbSBlbGVtZW50XG4gKiBAcGFyYW0ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHRvdWNoXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICBIVE1MIERPTSBlbGVtZW50XG4gKiBAcmV0dXJuIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSBwb2ludGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRQb2ludGVyICh0b3VjaCwgZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHg6IHRvdWNoLnggLSB1dGlsLmdldEFic29sdXRlTGVmdChlbGVtZW50KSxcbiAgICB5OiB0b3VjaC55IC0gdXRpbC5nZXRBYnNvbHV0ZVRvcChlbGVtZW50KVxuICB9O1xufVxuXG4vKipcbiAqIFpvb20gdGhlIHJhbmdlIHRoZSBnaXZlbiBzY2FsZSBpbiBvciBvdXQuIFN0YXJ0IGFuZCBlbmQgZGF0ZSB3aWxsXG4gKiBiZSBhZGp1c3RlZCwgYW5kIHRoZSB0aW1lbGluZSB3aWxsIGJlIHJlZHJhd24uIFlvdSBjYW4gb3B0aW9uYWxseSBnaXZlIGFcbiAqIGRhdGUgYXJvdW5kIHdoaWNoIHRvIHpvb20uXG4gKiBGb3IgZXhhbXBsZSwgdHJ5IHNjYWxlID0gMC45IG9yIDEuMVxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlICAgICAgU2NhbGluZyBmYWN0b3IuIFZhbHVlcyBhYm92ZSAxIHdpbGwgem9vbSBvdXQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYmVsb3cgMSB3aWxsIHpvb20gaW4uXG4gKiBAcGFyYW0ge051bWJlcn0gW2NlbnRlcl0gICBWYWx1ZSByZXByZXNlbnRpbmcgYSBkYXRlIGFyb3VuZCB3aGljaCB3aWxsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSB6b29tZWQuXG4gKi9cblJhbmdlLnByb3RvdHlwZS56b29tID0gZnVuY3Rpb24oc2NhbGUsIGNlbnRlciwgZGVsdGEpIHtcbiAgLy8gaWYgY2VudGVyRGF0ZSBpcyBub3QgcHJvdmlkZWQsIHRha2UgaXQgaGFsZiBiZXR3ZWVuIHN0YXJ0IERhdGUgYW5kIGVuZCBEYXRlXG4gIGlmIChjZW50ZXIgPT0gbnVsbCkge1xuICAgIGNlbnRlciA9ICh0aGlzLnN0YXJ0ICsgdGhpcy5lbmQpIC8gMjtcbiAgfVxuXG4gIHZhciBoaWRkZW5EdXJhdGlvbiA9IERhdGVVdGlsLmdldEhpZGRlbkR1cmF0aW9uQmV0d2Vlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgdmFyIGhpZGRlbkR1cmF0aW9uQmVmb3JlID0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUodGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LmhpZGRlbkRhdGVzLCB0aGlzLCBjZW50ZXIpO1xuICB2YXIgaGlkZGVuRHVyYXRpb25BZnRlciA9IGhpZGRlbkR1cmF0aW9uIC0gaGlkZGVuRHVyYXRpb25CZWZvcmU7XG5cbiAgLy8gY2FsY3VsYXRlIG5ldyBzdGFydCBhbmQgZW5kXG4gIHZhciBuZXdTdGFydCA9IChjZW50ZXItaGlkZGVuRHVyYXRpb25CZWZvcmUpICsgKHRoaXMuc3RhcnQgLSAoY2VudGVyLWhpZGRlbkR1cmF0aW9uQmVmb3JlKSkgKiBzY2FsZTtcbiAgdmFyIG5ld0VuZCAgID0gKGNlbnRlcitoaWRkZW5EdXJhdGlvbkFmdGVyKSArICh0aGlzLmVuZCAtIChjZW50ZXIraGlkZGVuRHVyYXRpb25BZnRlcikpICogc2NhbGU7XG5cbiAgLy8gc25hcHBpbmcgdGltZXMgYXdheSBmcm9tIGhpZGRlbiB6b25lc1xuICB0aGlzLnN0YXJ0VG9Gcm9udCA9IGRlbHRhID4gMCA/IGZhbHNlIDogdHJ1ZTsgLy8gdXNlZCB0byBkbyB0aGUgcmlnaHQgYXV0b2NvcnJlY3Rpb24gd2l0aCBwZXJpb2RpYyBoaWRkZW4gdGltZXNcbiAgdGhpcy5lbmRUb0Zyb250ID0gLWRlbHRhICA+IDAgPyBmYWxzZSA6IHRydWU7IC8vIHVzZWQgdG8gZG8gdGhlIHJpZ2h0IGF1dG9jb3JyZWN0aW9uIHdpdGggcGVyaW9kaWMgaGlkZGVuIHRpbWVzXG4gIHZhciBzYWZlU3RhcnQgPSBEYXRlVXRpbC5zbmFwQXdheUZyb21IaWRkZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCBuZXdTdGFydCwgZGVsdGEsIHRydWUpO1xuICB2YXIgc2FmZUVuZCA9IERhdGVVdGlsLnNuYXBBd2F5RnJvbUhpZGRlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIG5ld0VuZCwgLWRlbHRhLCB0cnVlKTtcbiAgaWYgKHNhZmVTdGFydCAhPSBuZXdTdGFydCB8fCBzYWZlRW5kICE9IG5ld0VuZCkge1xuICAgIG5ld1N0YXJ0ID0gc2FmZVN0YXJ0O1xuICAgIG5ld0VuZCA9IHNhZmVFbmQ7XG4gIH1cblxuICB0aGlzLnNldFJhbmdlKG5ld1N0YXJ0LCBuZXdFbmQsIGZhbHNlLCB0cnVlKTtcblxuICB0aGlzLnN0YXJ0VG9Gcm9udCA9IGZhbHNlOyAvLyByZXZlcnQgdG8gZGVmYXVsdFxuICB0aGlzLmVuZFRvRnJvbnQgPSB0cnVlOyAvLyByZXZlcnQgdG8gZGVmYXVsdFxufTtcblxuXG5cbi8qKlxuICogTW92ZSB0aGUgcmFuZ2Ugd2l0aCBhIGdpdmVuIGRlbHRhIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0LiBTdGFydCBhbmQgZW5kXG4gKiB2YWx1ZSB3aWxsIGJlIGFkanVzdGVkLiBGb3IgZXhhbXBsZSwgdHJ5IGRlbHRhID0gMC4xIG9yIC0wLjFcbiAqIEBwYXJhbSB7TnVtYmVyfSAgZGVsdGEgICAgIE1vdmluZyBhbW91bnQuIFBvc2l0aXZlIHZhbHVlIHdpbGwgbW92ZSByaWdodCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZ2F0aXZlIHZhbHVlIHdpbGwgbW92ZSBsZWZ0XG4gKi9cblJhbmdlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oZGVsdGEpIHtcbiAgLy8gem9vbSBzdGFydCBEYXRlIGFuZCBlbmQgRGF0ZSByZWxhdGl2ZSB0byB0aGUgY2VudGVyRGF0ZVxuICB2YXIgZGlmZiA9ICh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpO1xuXG4gIC8vIGFwcGx5IG5ldyB2YWx1ZXNcbiAgdmFyIG5ld1N0YXJ0ID0gdGhpcy5zdGFydCArIGRpZmYgKiBkZWx0YTtcbiAgdmFyIG5ld0VuZCA9IHRoaXMuZW5kICsgZGlmZiAqIGRlbHRhO1xuXG4gIC8vIFRPRE86IHJlY2tvbiB3aXRoIG1pbiBhbmQgbWF4IHJhbmdlXG5cbiAgdGhpcy5zdGFydCA9IG5ld1N0YXJ0O1xuICB0aGlzLmVuZCA9IG5ld0VuZDtcbn07XG5cbi8qKlxuICogTW92ZSB0aGUgcmFuZ2UgdG8gYSBuZXcgY2VudGVyIHBvaW50XG4gKiBAcGFyYW0ge051bWJlcn0gbW92ZVRvICAgICAgTmV3IGNlbnRlciBwb2ludCBvZiB0aGUgcmFuZ2VcbiAqL1xuUmFuZ2UucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uKG1vdmVUbykge1xuICB2YXIgY2VudGVyID0gKHRoaXMuc3RhcnQgKyB0aGlzLmVuZCkgLyAyO1xuXG4gIHZhciBkaWZmID0gY2VudGVyIC0gbW92ZVRvO1xuXG4gIC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgYW5kIGVuZFxuICB2YXIgbmV3U3RhcnQgPSB0aGlzLnN0YXJ0IC0gZGlmZjtcbiAgdmFyIG5ld0VuZCA9IHRoaXMuZW5kIC0gZGlmZjtcblxuICB0aGlzLnNldFJhbmdlKG5ld1N0YXJ0LCBuZXdFbmQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZTtcbiIsIi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBvcmRlcmluZyBhbmQgc3RhY2tpbmcgb2YgaXRlbXNcbnZhciBFUFNJTE9OID0gMC4wMDE7IC8vIHVzZWQgd2hlbiBjaGVja2luZyBjb2xsaXNpb25zLCB0byBwcmV2ZW50IHJvdW5kLW9mZiBlcnJvcnNcblxuLyoqXG4gKiBPcmRlciBpdGVtcyBieSB0aGVpciBzdGFydCBkYXRhXG4gKiBAcGFyYW0ge0l0ZW1bXX0gaXRlbXNcbiAqL1xuZXhwb3J0cy5vcmRlckJ5U3RhcnQgPSBmdW5jdGlvbihpdGVtcykge1xuICBpdGVtcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEuZGF0YS5zdGFydCAtIGIuZGF0YS5zdGFydDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIE9yZGVyIGl0ZW1zIGJ5IHRoZWlyIGVuZCBkYXRlLiBJZiB0aGV5IGhhdmUgbm8gZW5kIGRhdGUsIHRoZWlyIHN0YXJ0IGRhdGVcbiAqIGlzIHVzZWQuXG4gKiBAcGFyYW0ge0l0ZW1bXX0gaXRlbXNcbiAqL1xuZXhwb3J0cy5vcmRlckJ5RW5kID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgaXRlbXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBhVGltZSA9ICgnZW5kJyBpbiBhLmRhdGEpID8gYS5kYXRhLmVuZCA6IGEuZGF0YS5zdGFydCxcbiAgICAgICAgYlRpbWUgPSAoJ2VuZCcgaW4gYi5kYXRhKSA/IGIuZGF0YS5lbmQgOiBiLmRhdGEuc3RhcnQ7XG5cbiAgICByZXR1cm4gYVRpbWUgLSBiVGltZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFkanVzdCB2ZXJ0aWNhbCBwb3NpdGlvbnMgb2YgdGhlIGl0ZW1zIHN1Y2ggdGhhdCB0aGV5IGRvbid0IG92ZXJsYXAgZWFjaFxuICogb3RoZXIuXG4gKiBAcGFyYW0ge0l0ZW1bXX0gaXRlbXNcbiAqICAgICAgICAgICAgQWxsIHZpc2libGUgaXRlbXNcbiAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAqICAgICAgICAgICAgTWFyZ2lucyBiZXR3ZWVuIGl0ZW1zIGFuZCBiZXR3ZWVuIGl0ZW1zIGFuZCB0aGUgYXhpcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXVxuICogICAgICAgICAgICBJZiB0cnVlLCBhbGwgaXRlbXMgd2lsbCBiZSByZXBvc2l0aW9uZWQuIElmIGZhbHNlIChkZWZhdWx0KSwgb25seVxuICogICAgICAgICAgICBpdGVtcyBoYXZpbmcgYSB0b3A9PT1udWxsIHdpbGwgYmUgcmUtc3RhY2tlZFxuICovXG5leHBvcnRzLnN0YWNrID0gZnVuY3Rpb24oaXRlbXMsIG1hcmdpbiwgZm9yY2UpIHtcbiAgdmFyIGksIGlNYXg7XG5cbiAgaWYgKGZvcmNlKSB7XG4gICAgLy8gcmVzZXQgdG9wIHBvc2l0aW9uIG9mIGFsbCBpdGVtc1xuICAgIGZvciAoaSA9IDAsIGlNYXggPSBpdGVtcy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGl0ZW1zW2ldLnRvcCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsY3VsYXRlIG5ldywgbm9uLW92ZXJsYXBwaW5nIHBvc2l0aW9uc1xuICBmb3IgKGkgPSAwLCBpTWF4ID0gaXRlbXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICBpZiAoaXRlbS5zdGFjayAmJiBpdGVtLnRvcCA9PT0gbnVsbCkge1xuICAgICAgLy8gaW5pdGlhbGl6ZSB0b3AgcG9zaXRpb25cbiAgICAgIGl0ZW0udG9wID0gbWFyZ2luLmF4aXM7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgY2hlY2tpbmcgZm9yIG92ZXJsYXAuIHdoZW4gdGhlcmUgaXMgYSBnYXAgd2l0aG91dCBpdGVtcyxcbiAgICAgICAgLy8gICAgICAgeW91IG9ubHkgbmVlZCB0byBjaGVjayBmb3IgaXRlbXMgZnJvbSB0aGUgbmV4dCBpdGVtIG9uLCBub3QgZnJvbSB6ZXJvXG4gICAgICAgIHZhciBjb2xsaWRpbmdJdGVtID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gaXRlbXMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgIHZhciBvdGhlciA9IGl0ZW1zW2pdO1xuICAgICAgICAgIGlmIChvdGhlci50b3AgIT09IG51bGwgJiYgb3RoZXIgIT09IGl0ZW0gJiYgb3RoZXIuc3RhY2sgJiYgZXhwb3J0cy5jb2xsaXNpb24oaXRlbSwgb3RoZXIsIG1hcmdpbi5pdGVtKSkge1xuICAgICAgICAgICAgY29sbGlkaW5nSXRlbSA9IG90aGVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbGxpZGluZ0l0ZW0gIT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIGEgY29sbGlzaW9uLiBSZXBvc2l0aW9uIHRoZSBpdGVtcyBhYm92ZSB0aGUgY29sbGlkaW5nIGVsZW1lbnRcbiAgICAgICAgICBpdGVtLnRvcCA9IGNvbGxpZGluZ0l0ZW0udG9wICsgY29sbGlkaW5nSXRlbS5oZWlnaHQgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoY29sbGlkaW5nSXRlbSk7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQWRqdXN0IHZlcnRpY2FsIHBvc2l0aW9ucyBvZiB0aGUgaXRlbXMgd2l0aG91dCBzdGFja2luZyB0aGVtXG4gKiBAcGFyYW0ge0l0ZW1bXX0gaXRlbXNcbiAqICAgICAgICAgICAgQWxsIHZpc2libGUgaXRlbXNcbiAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAqICAgICAgICAgICAgTWFyZ2lucyBiZXR3ZWVuIGl0ZW1zIGFuZCBiZXR3ZWVuIGl0ZW1zIGFuZCB0aGUgYXhpcy5cbiAqL1xuZXhwb3J0cy5ub3N0YWNrID0gZnVuY3Rpb24oaXRlbXMsIG1hcmdpbiwgc3ViZ3JvdXBzKSB7XG4gIHZhciBpLCBpTWF4LCBuZXdUb3A7XG5cbiAgLy8gcmVzZXQgdG9wIHBvc2l0aW9uIG9mIGFsbCBpdGVtc1xuICBmb3IgKGkgPSAwLCBpTWF4ID0gaXRlbXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgaWYgKGl0ZW1zW2ldLmRhdGEuc3ViZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VG9wID0gbWFyZ2luLmF4aXM7XG4gICAgICBmb3IgKHZhciBzdWJncm91cCBpbiBzdWJncm91cHMpIHtcbiAgICAgICAgaWYgKHN1Ymdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShzdWJncm91cCkpIHtcbiAgICAgICAgICBpZiAoc3ViZ3JvdXBzW3N1Ymdyb3VwXS52aXNpYmxlID09IHRydWUgJiYgc3ViZ3JvdXBzW3N1Ymdyb3VwXS5pbmRleCA8IHN1Ymdyb3Vwc1tpdGVtc1tpXS5kYXRhLnN1Ymdyb3VwXS5pbmRleCkge1xuICAgICAgICAgICAgbmV3VG9wICs9IHN1Ymdyb3Vwc1tzdWJncm91cF0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpdGVtc1tpXS50b3AgPSBuZXdUb3A7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXRlbXNbaV0udG9wID0gbWFyZ2luLmF4aXM7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFRlc3QgaWYgdGhlIHR3byBwcm92aWRlZCBpdGVtcyBjb2xsaWRlXG4gKiBUaGUgaXRlbXMgbXVzdCBoYXZlIHBhcmFtZXRlcnMgbGVmdCwgd2lkdGgsIHRvcCwgYW5kIGhlaWdodC5cbiAqIEBwYXJhbSB7SXRlbX0gYSAgICAgICAgICBUaGUgZmlyc3QgaXRlbVxuICogQHBhcmFtIHtJdGVtfSBiICAgICAgICAgIFRoZSBzZWNvbmQgaXRlbVxuICogQHBhcmFtIHt7aG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyfX0gbWFyZ2luXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW0gcmVxdWlyZWQgbWFyZ2luLlxuICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgIHRydWUgaWYgYSBhbmQgYiBjb2xsaWRlLCBlbHNlIGZhbHNlXG4gKi9cbmV4cG9ydHMuY29sbGlzaW9uID0gZnVuY3Rpb24oYSwgYiwgbWFyZ2luKSB7XG4gIHJldHVybiAoKGEubGVmdCAtIG1hcmdpbi5ob3Jpem9udGFsICsgRVBTSUxPTikgICAgICAgPCAoYi5sZWZ0ICsgYi53aWR0aCkgJiZcbiAgICAgIChhLmxlZnQgKyBhLndpZHRoICsgbWFyZ2luLmhvcml6b250YWwgLSBFUFNJTE9OKSA+IGIubGVmdCAmJlxuICAgICAgKGEudG9wIC0gbWFyZ2luLnZlcnRpY2FsICsgRVBTSUxPTikgICAgICAgICAgICAgIDwgKGIudG9wICsgYi5oZWlnaHQpICYmXG4gICAgICAoYS50b3AgKyBhLmhlaWdodCArIG1hcmdpbi52ZXJ0aWNhbCAtIEVQU0lMT04pICAgPiBiLnRvcCk7XG59O1xuIiwidmFyIG1vbWVudCA9IHJlcXVpcmUoJy4uL21vZHVsZS9tb21lbnQnKTtcbnZhciBEYXRlVXRpbCA9IHJlcXVpcmUoJy4vRGF0ZVV0aWwnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciAgVGltZVN0ZXBcbiAqIFRoZSBjbGFzcyBUaW1lU3RlcCBpcyBhbiBpdGVyYXRvciBmb3IgZGF0ZXMuIFlvdSBwcm92aWRlIGEgc3RhcnQgZGF0ZSBhbmQgYW5cbiAqIGVuZCBkYXRlLiBUaGUgY2xhc3MgaXRzZWxmIGRldGVybWluZXMgdGhlIGJlc3Qgc2NhbGUgKHN0ZXAgc2l6ZSkgYmFzZWQgb24gdGhlXG4gKiBwcm92aWRlZCBzdGFydCBEYXRlLCBlbmQgRGF0ZSwgYW5kIG1pbmltdW1TdGVwLlxuICpcbiAqIElmIG1pbmltdW1TdGVwIGlzIHByb3ZpZGVkLCB0aGUgc3RlcCBzaXplIGlzIGNob3NlbiBhcyBjbG9zZSBhcyBwb3NzaWJsZVxuICogdG8gdGhlIG1pbmltdW1TdGVwIGJ1dCBsYXJnZXIgdGhhbiBtaW5pbXVtU3RlcC4gSWYgbWluaW11bVN0ZXAgaXMgbm90XG4gKiBwcm92aWRlZCwgdGhlIHNjYWxlIGlzIHNldCB0byAxIERBWS5cbiAqIFRoZSBtaW5pbXVtU3RlcCBzaG91bGQgY29ycmVzcG9uZCB3aXRoIHRoZSBvbnNjcmVlbiBzaXplIG9mIGFib3V0IDYgY2hhcmFjdGVyc1xuICpcbiAqIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gc2V0IGEgc2NhbGUgYnkgaGFuZC5cbiAqIEFmdGVyIGNyZWF0aW9uLCB5b3UgY2FuIGluaXRpYWxpemUgdGhlIGNsYXNzIGJ5IGV4ZWN1dGluZyBmaXJzdCgpLiBUaGVuIHlvdVxuICogY2FuIGl0ZXJhdGUgZnJvbSB0aGUgc3RhcnQgZGF0ZSB0byB0aGUgZW5kIGRhdGUgdmlhIG5leHQoKS4gWW91IGNhbiBjaGVjayBpZlxuICogdGhlIGVuZCBkYXRlIGlzIHJlYWNoZWQgd2l0aCB0aGUgZnVuY3Rpb24gaGFzTmV4dCgpLiBBZnRlciBlYWNoIHN0ZXAsIHlvdSBjYW5cbiAqIHJldHJpZXZlIHRoZSBjdXJyZW50IGRhdGUgdmlhIGdldEN1cnJlbnQoKS5cbiAqIFRoZSBUaW1lU3RlcCBoYXMgc2NhbGVzIHJhbmdpbmcgZnJvbSBtaWxsaXNlY29uZHMsIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLFxuICogZGF5cywgdG8geWVhcnMuXG4gKlxuICogVmVyc2lvbjogMS4yXG4gKlxuICogQHBhcmFtIHtEYXRlfSBbc3RhcnRdICAgICAgICAgVGhlIHN0YXJ0IGRhdGUsIGZvciBleGFtcGxlIG5ldyBEYXRlKDIwMTAsIDksIDIxKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgbmV3IERhdGUoMjAxMCwgOSwgMjEsIDIzLCA0NSwgMDApXG4gKiBAcGFyYW0ge0RhdGV9IFtlbmRdICAgICAgICAgICBUaGUgZW5kIGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWluaW11bVN0ZXBdIE9wdGlvbmFsLiBNaW5pbXVtIHN0ZXAgc2l6ZSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuZnVuY3Rpb24gVGltZVN0ZXAoc3RhcnQsIGVuZCwgbWluaW11bVN0ZXAsIGhpZGRlbkRhdGVzKSB7XG4gIHRoaXMubW9tZW50ID0gbW9tZW50O1xuXG4gIC8vIHZhcmlhYmxlc1xuICB0aGlzLmN1cnJlbnQgPSB0aGlzLm1vbWVudCgpO1xuICB0aGlzLl9zdGFydCA9IHRoaXMubW9tZW50KCk7XG4gIHRoaXMuX2VuZCA9IHRoaXMubW9tZW50KCk7XG5cbiAgdGhpcy5hdXRvU2NhbGUgID0gdHJ1ZTtcbiAgdGhpcy5zY2FsZSA9ICdkYXknO1xuICB0aGlzLnN0ZXAgPSAxO1xuXG4gIC8vIGluaXRpYWxpemUgdGhlIHJhbmdlXG4gIHRoaXMuc2V0UmFuZ2Uoc3RhcnQsIGVuZCwgbWluaW11bVN0ZXApO1xuXG4gIC8vIGhpZGRlbiBEYXRlcyBvcHRpb25zXG4gIHRoaXMuc3dpdGNoZWREYXkgPSBmYWxzZTtcbiAgdGhpcy5zd2l0Y2hlZE1vbnRoID0gZmFsc2U7XG4gIHRoaXMuc3dpdGNoZWRZZWFyID0gZmFsc2U7XG4gIGlmIChBcnJheS5pc0FycmF5KGhpZGRlbkRhdGVzKSkge1xuICAgIHRoaXMuaGlkZGVuRGF0ZXMgPSBoaWRkZW5EYXRlcztcbiAgfVxuICBlbHNlIGlmIChoaWRkZW5EYXRlcyAhPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmhpZGRlbkRhdGVzID0gW2hpZGRlbkRhdGVzXTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmhpZGRlbkRhdGVzID0gW107XG4gIH1cblxuICB0aGlzLmZvcm1hdCA9IFRpbWVTdGVwLkZPUk1BVDsgLy8gZGVmYXVsdCBmb3JtYXR0aW5nXG59XG5cbi8vIFRpbWUgZm9ybWF0dGluZ1xuVGltZVN0ZXAuRk9STUFUID0ge1xuICBtaW5vckxhYmVsczoge1xuICAgIG1pbGxpc2Vjb25kOidTU1MnLFxuICAgIHNlY29uZDogICAgICdzJyxcbiAgICBtaW51dGU6ICAgICAnSEg6bW0nLFxuICAgIGhvdXI6ICAgICAgICdISDptbScsXG4gICAgd2Vla2RheTogICAgJ2RkZCBEJyxcbiAgICBkYXk6ICAgICAgICAnRCcsXG4gICAgbW9udGg6ICAgICAgJ01NTScsXG4gICAgeWVhcjogICAgICAgJ1lZWVknXG4gIH0sXG4gIG1ham9yTGFiZWxzOiB7XG4gICAgbWlsbGlzZWNvbmQ6J0hIOm1tOnNzJyxcbiAgICBzZWNvbmQ6ICAgICAnRCBNTU1NIEhIOm1tJyxcbiAgICBtaW51dGU6ICAgICAnZGRkIEQgTU1NTScsXG4gICAgaG91cjogICAgICAgJ2RkZCBEIE1NTU0nLFxuICAgIHdlZWtkYXk6ICAgICdNTU1NIFlZWVknLFxuICAgIGRheTogICAgICAgICdNTU1NIFlZWVknLFxuICAgIG1vbnRoOiAgICAgICdZWVlZJyxcbiAgICB5ZWFyOiAgICAgICAnJ1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBjdXN0b20gY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIG1vbWVudC4gQ2FuIGJlIHVzZWQgdG8gc2V0IGRhdGVzXG4gKiB0byBVVEMgb3IgdG8gc2V0IGEgdXRjT2Zmc2V0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbW9tZW50XG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5zZXRNb21lbnQgPSBmdW5jdGlvbiAobW9tZW50KSB7XG4gIHRoaXMubW9tZW50ID0gbW9tZW50O1xuXG4gIC8vIHVwZGF0ZSB0aGUgZGF0ZSBwcm9wZXJ0aWVzLCBjYW4gaGF2ZSBhIG5ldyB1dGNPZmZzZXRcbiAgdGhpcy5jdXJyZW50ID0gdGhpcy5tb21lbnQodGhpcy5jdXJyZW50KTtcbiAgdGhpcy5fc3RhcnQgPSB0aGlzLm1vbWVudCh0aGlzLl9zdGFydCk7XG4gIHRoaXMuX2VuZCA9IHRoaXMubW9tZW50KHRoaXMuX2VuZCk7XG59O1xuXG4vKipcbiAqIFNldCBjdXN0b20gZm9ybWF0dGluZyBmb3IgdGhlIG1pbm9yIGFuIG1ham9yIGxhYmVscyBvZiB0aGUgVGltZVN0ZXAuXG4gKiBCb3RoIGBtaW5vckxhYmVsc2AgYW5kIGBtYWpvckxhYmVsc2AgYXJlIGFuIE9iamVjdCB3aXRoIHByb3BlcnRpZXM6XG4gKiAnbWlsbGlzZWNvbmQnLCAnc2Vjb25kJywgJ21pbnV0ZScsICdob3VyJywgJ3dlZWtkYXknLCAnZGF5JywgJ21vbnRoJywgJ3llYXInLlxuICogQHBhcmFtIHt7bWlub3JMYWJlbHM6IE9iamVjdCwgbWFqb3JMYWJlbHM6IE9iamVjdH19IGZvcm1hdFxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuc2V0Rm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICB2YXIgZGVmYXVsdEZvcm1hdCA9IHV0aWwuZGVlcEV4dGVuZCh7fSwgVGltZVN0ZXAuRk9STUFUKTtcbiAgdGhpcy5mb3JtYXQgPSB1dGlsLmRlZXBFeHRlbmQoZGVmYXVsdEZvcm1hdCwgZm9ybWF0KTtcbn07XG5cbi8qKlxuICogU2V0IGEgbmV3IHJhbmdlXG4gKiBJZiBtaW5pbXVtU3RlcCBpcyBwcm92aWRlZCwgdGhlIHN0ZXAgc2l6ZSBpcyBjaG9zZW4gYXMgY2xvc2UgYXMgcG9zc2libGVcbiAqIHRvIHRoZSBtaW5pbXVtU3RlcCBidXQgbGFyZ2VyIHRoYW4gbWluaW11bVN0ZXAuIElmIG1pbmltdW1TdGVwIGlzIG5vdFxuICogcHJvdmlkZWQsIHRoZSBzY2FsZSBpcyBzZXQgdG8gMSBEQVkuXG4gKiBUaGUgbWluaW11bVN0ZXAgc2hvdWxkIGNvcnJlc3BvbmQgd2l0aCB0aGUgb25zY3JlZW4gc2l6ZSBvZiBhYm91dCA2IGNoYXJhY3RlcnNcbiAqIEBwYXJhbSB7RGF0ZX0gW3N0YXJ0XSAgICAgIFRoZSBzdGFydCBkYXRlIGFuZCB0aW1lLlxuICogQHBhcmFtIHtEYXRlfSBbZW5kXSAgICAgICAgVGhlIGVuZCBkYXRlIGFuZCB0aW1lLlxuICogQHBhcmFtIHtpbnR9IFttaW5pbXVtU3RlcF0gT3B0aW9uYWwuIE1pbmltdW0gc3RlcCBzaXplIGluIG1pbGxpc2Vjb25kc1xuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuc2V0UmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBtaW5pbXVtU3RlcCkge1xuICBpZiAoIShzdGFydCBpbnN0YW5jZW9mIERhdGUpIHx8ICEoZW5kIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICB0aHJvdyAgXCJObyBsZWdhbCBzdGFydCBvciBlbmQgZGF0ZSBpbiBtZXRob2Qgc2V0UmFuZ2VcIjtcbiAgfVxuXG4gIHRoaXMuX3N0YXJ0ID0gKHN0YXJ0ICE9IHVuZGVmaW5lZCkgPyB0aGlzLm1vbWVudChzdGFydC52YWx1ZU9mKCkpIDogbmV3IERhdGUoKTtcbiAgdGhpcy5fZW5kID0gKGVuZCAhPSB1bmRlZmluZWQpID8gdGhpcy5tb21lbnQoZW5kLnZhbHVlT2YoKSkgOiBuZXcgRGF0ZSgpO1xuXG4gIGlmICh0aGlzLmF1dG9TY2FsZSkge1xuICAgIHRoaXMuc2V0TWluaW11bVN0ZXAobWluaW11bVN0ZXApO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgcmFuZ2UgaXRlcmF0b3IgdG8gdGhlIHN0YXJ0IGRhdGUuXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmN1cnJlbnQgPSB0aGlzLl9zdGFydC5jbG9uZSgpO1xuICB0aGlzLnJvdW5kVG9NaW5vcigpO1xufTtcblxuLyoqXG4gKiBSb3VuZCB0aGUgY3VycmVudCBkYXRlIHRvIHRoZSBmaXJzdCBtaW5vciBkYXRlIHZhbHVlXG4gKiBUaGlzIG11c3QgYmUgZXhlY3V0ZWQgb25jZSB3aGVuIHRoZSBjdXJyZW50IGRhdGUgaXMgc2V0IHRvIHN0YXJ0IERhdGVcbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLnJvdW5kVG9NaW5vciA9IGZ1bmN0aW9uKCkge1xuICAvLyByb3VuZCB0byBmbG9vclxuICAvLyBJTVBPUlRBTlQ6IHdlIGhhdmUgbm8gYnJlYWtzIGluIHRoaXMgc3dpdGNoISAodGhpcyBpcyBubyBidWcpXG4gIC8vIG5vaW5zcGVjdGlvbiBGYWxsVGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgY2FzZSAneWVhcic6XG4gICAgICB0aGlzLmN1cnJlbnQueWVhcih0aGlzLnN0ZXAgKiBNYXRoLmZsb29yKHRoaXMuY3VycmVudC55ZWFyKCkgLyB0aGlzLnN0ZXApKTtcbiAgICAgIHRoaXMuY3VycmVudC5tb250aCgwKTtcbiAgICBjYXNlICdtb250aCc6ICAgICAgICB0aGlzLmN1cnJlbnQuZGF0ZSgxKTtcbiAgICBjYXNlICdkYXknOiAgICAgICAgICAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICBjYXNlICd3ZWVrZGF5JzogICAgICB0aGlzLmN1cnJlbnQuaG91cnMoMCk7XG4gICAgY2FzZSAnaG91cic6ICAgICAgICAgdGhpcy5jdXJyZW50Lm1pbnV0ZXMoMCk7XG4gICAgY2FzZSAnbWludXRlJzogICAgICAgdGhpcy5jdXJyZW50LnNlY29uZHMoMCk7XG4gICAgY2FzZSAnc2Vjb25kJzogICAgICAgdGhpcy5jdXJyZW50Lm1pbGxpc2Vjb25kcygwKTtcbiAgICAvL2Nhc2UgJ21pbGxpc2Vjb25kJzogLy8gbm90aGluZyB0byBkbyBmb3IgbWlsbGlzZWNvbmRzXG4gIH1cblxuICBpZiAodGhpcy5zdGVwICE9IDEpIHtcbiAgICAvLyByb3VuZCBkb3duIHRvIHRoZSBmaXJzdCBtaW5vciB2YWx1ZSB0aGF0IGlzIGEgbXVsdGlwbGUgb2YgdGhlIGN1cnJlbnQgc3RlcCBzaXplXG4gICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICBjYXNlICdtaWxsaXNlY29uZCc6ICB0aGlzLmN1cnJlbnQuc3VidHJhY3QodGhpcy5jdXJyZW50Lm1pbGxpc2Vjb25kcygpICUgdGhpcy5zdGVwLCAnbWlsbGlzZWNvbmRzJyk7ICBicmVhaztcbiAgICAgIGNhc2UgJ3NlY29uZCc6ICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQuc2Vjb25kcygpICUgdGhpcy5zdGVwLCAnc2Vjb25kcycpOyBicmVhaztcbiAgICAgIGNhc2UgJ21pbnV0ZSc6ICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQubWludXRlcygpICUgdGhpcy5zdGVwLCAnbWludXRlcycpOyBicmVhaztcbiAgICAgIGNhc2UgJ2hvdXInOiAgICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQuaG91cnMoKSAlIHRoaXMuc3RlcCwgJ2hvdXJzJyk7IGJyZWFrO1xuICAgICAgY2FzZSAnd2Vla2RheSc6ICAgICAgLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgICBjYXNlICdkYXknOiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3VidHJhY3QoKHRoaXMuY3VycmVudC5kYXRlKCkgLSAxKSAlIHRoaXMuc3RlcCwgJ2RheScpOyBicmVhaztcbiAgICAgIGNhc2UgJ21vbnRoJzogICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQubW9udGgoKSAlIHRoaXMuc3RlcCwgJ21vbnRoJyk7ICBicmVhaztcbiAgICAgIGNhc2UgJ3llYXInOiAgICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQueWVhcigpICUgdGhpcy5zdGVwLCAneWVhcicpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdGhlcmUgaXMgYSBuZXh0IHN0ZXBcbiAqIEByZXR1cm4ge2Jvb2xlYW59ICB0cnVlIGlmIHRoZSBjdXJyZW50IGRhdGUgaGFzIG5vdCBwYXNzZWQgdGhlIGVuZCBkYXRlXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMuY3VycmVudC52YWx1ZU9mKCkgPD0gdGhpcy5fZW5kLnZhbHVlT2YoKSk7XG59O1xuXG4vKipcbiAqIERvIHRoZSBuZXh0IHN0ZXBcbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByZXYgPSB0aGlzLmN1cnJlbnQudmFsdWVPZigpO1xuXG4gIC8vIFR3byBjYXNlcywgbmVlZGVkIHRvIHByZXZlbnQgaXNzdWVzIHdpdGggc3dpdGNoaW5nIGRheWxpZ2h0IHNhdmluZ3NcbiAgLy8gKGVuZCBvZiBNYXJjaCBhbmQgZW5kIG9mIE9jdG9iZXIpXG4gIGlmICh0aGlzLmN1cnJlbnQubW9udGgoKSA8IDYpICAge1xuICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtaWxsaXNlY29uZCcpOyBicmVhaztcbiAgICAgIGNhc2UgJ3NlY29uZCc6ICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnc2Vjb25kJyk7IGJyZWFrO1xuICAgICAgY2FzZSAnbWludXRlJzogICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtaW51dGUnKTsgYnJlYWs7XG4gICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdob3VyJyk7XG4gICAgICAgIC8vIGluIGNhc2Ugb2Ygc2tpcHBpbmcgYW4gaG91ciBmb3IgZGF5bGlnaHQgc2F2aW5ncywgYWRqdXN0IHRoZSBob3VyIGFnYWluIChlbHNlIHlvdSBnZXQ6IDBoIDVoIDloIC4uLiBpbnN0ZWFkIG9mIDBoIDRoIDhoIC4uLilcbiAgICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIHN0aWxsIG5lZWRlZCBub3cgd2UgdXNlIHRoZSBmdW5jdGlvbiBvZiBtb21lbnQuanM/XG4gICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQuaG91cnMoKSAlIHRoaXMuc3RlcCwgJ2hvdXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd3ZWVrZGF5JzogICAgICAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICAgIGNhc2UgJ2RheSc6ICAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnZGF5Jyk7IGJyZWFrO1xuICAgICAgY2FzZSAnbW9udGgnOiAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtb250aCcpOyBicmVhaztcbiAgICAgIGNhc2UgJ3llYXInOiAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAneWVhcicpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnbWlsbGlzZWNvbmQnKTsgYnJlYWs7XG4gICAgICBjYXNlICdzZWNvbmQnOiAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ3NlY29uZCcpOyBicmVhaztcbiAgICAgIGNhc2UgJ21pbnV0ZSc6ICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnbWludXRlJyk7IGJyZWFrO1xuICAgICAgY2FzZSAnaG91cic6ICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdob3VyJyk7IGJyZWFrO1xuICAgICAgY2FzZSAnd2Vla2RheSc6ICAgICAgLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgICBjYXNlICdkYXknOiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ2RheScpOyBicmVhaztcbiAgICAgIGNhc2UgJ21vbnRoJzogICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnbW9udGgnKTsgYnJlYWs7XG4gICAgICBjYXNlICd5ZWFyJzogICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ3llYXInKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAgICAgICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5zdGVwICE9IDEpIHtcbiAgICAvLyByb3VuZCBkb3duIHRvIHRoZSBjb3JyZWN0IG1ham9yIHZhbHVlXG4gICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICBjYXNlICdtaWxsaXNlY29uZCc6ICBpZih0aGlzLmN1cnJlbnQubWlsbGlzZWNvbmRzKCkgPCB0aGlzLnN0ZXApIHRoaXMuY3VycmVudC5taWxsaXNlY29uZHMoMCk7ICBicmVhaztcbiAgICAgIGNhc2UgJ3NlY29uZCc6ICAgICAgIGlmKHRoaXMuY3VycmVudC5zZWNvbmRzKCkgPCB0aGlzLnN0ZXApIHRoaXMuY3VycmVudC5zZWNvbmRzKDApOyAgYnJlYWs7XG4gICAgICBjYXNlICdtaW51dGUnOiAgICAgICBpZih0aGlzLmN1cnJlbnQubWludXRlcygpIDwgdGhpcy5zdGVwKSB0aGlzLmN1cnJlbnQubWludXRlcygwKTsgIGJyZWFrO1xuICAgICAgY2FzZSAnaG91cic6ICAgICAgICAgaWYodGhpcy5jdXJyZW50LmhvdXJzKCkgPCB0aGlzLnN0ZXApIHRoaXMuY3VycmVudC5ob3VycygwKTsgIGJyZWFrO1xuICAgICAgY2FzZSAnd2Vla2RheSc6ICAgICAgLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgICBjYXNlICdkYXknOiAgICAgICAgICBpZih0aGlzLmN1cnJlbnQuZGF0ZSgpIDwgdGhpcy5zdGVwKzEpIHRoaXMuY3VycmVudC5kYXRlKDEpOyBicmVhaztcbiAgICAgIGNhc2UgJ21vbnRoJzogICAgICAgIGlmKHRoaXMuY3VycmVudC5tb250aCgpIDwgdGhpcy5zdGVwKSB0aGlzLmN1cnJlbnQubW9udGgoMCk7ICBicmVhaztcbiAgICAgIGNhc2UgJ3llYXInOiAgICAgICAgIGJyZWFrOyAvLyBub3RoaW5nIHRvIGRvIGZvciB5ZWFyXG4gICAgICBkZWZhdWx0OiAgICAgICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBzYWZldHkgbWVjaGFuaXNtOiBpZiBjdXJyZW50IHRpbWUgaXMgc3RpbGwgdW5jaGFuZ2VkLCBtb3ZlIHRvIHRoZSBlbmRcbiAgaWYgKHRoaXMuY3VycmVudC52YWx1ZU9mKCkgPT0gcHJldikge1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuX2VuZC5jbG9uZSgpO1xuICB9XG5cbiAgRGF0ZVV0aWwuc3RlcE92ZXJIaWRkZW5EYXRlcyh0aGlzLm1vbWVudCwgdGhpcywgcHJldik7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGRhdGV0aW1lXG4gKiBAcmV0dXJuIHtNb21lbnR9ICBjdXJyZW50IFRoZSBjdXJyZW50IGRhdGVcbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLmdldEN1cnJlbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY3VycmVudDtcbn07XG5cbi8qKlxuICogU2V0IGEgY3VzdG9tIHNjYWxlLiBBdXRvc2NhbGluZyB3aWxsIGJlIGRpc2FibGVkLlxuICogRm9yIGV4YW1wbGUgc2V0U2NhbGUoJ21pbnV0ZScsIDUpIHdpbGwgcmVzdWx0XG4gKiBpbiBtaW5vciBzdGVwcyBvZiA1IG1pbnV0ZXMsIGFuZCBtYWpvciBzdGVwcyBvZiBhbiBob3VyLlxuICpcbiAqIEBwYXJhbSB7e3NjYWxlOiBzdHJpbmcsIHN0ZXA6IG51bWJlcn19IHBhcmFtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdHdvIHByb3BlcnRpZXM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgc3RyaW5nICdzY2FsZScuIENob29zZSBmcm9tICdtaWxsaXNlY29uZCcsICdzZWNvbmQnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWludXRlJywgJ2hvdXInLCAnd2Vla2RheScsICdkYXknLCAnbW9udGgnLCAneWVhcicuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgbnVtYmVyICdzdGVwJy4gQSBzdGVwIHNpemUsIGJ5IGRlZmF1bHQgMS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hvb3NlIGZvciBleGFtcGxlIDEsIDIsIDUsIG9yIDEwLlxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuc2V0U2NhbGUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgaWYgKHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zLnNjYWxlID09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5zY2FsZSA9IHBhcmFtcy5zY2FsZTtcbiAgICB0aGlzLnN0ZXAgPSBwYXJhbXMuc3RlcCA+IDAgPyBwYXJhbXMuc3RlcCA6IDE7XG4gICAgdGhpcy5hdXRvU2NhbGUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBhdXRvc2NhbGluZ1xuICogQHBhcmFtIHtib29sZWFufSBlbmFibGUgIElmIHRydWUsIGF1dG9hc2NhbGluZyBpcyBzZXQgdHJ1ZVxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuc2V0QXV0b1NjYWxlID0gZnVuY3Rpb24gKGVuYWJsZSkge1xuICB0aGlzLmF1dG9TY2FsZSA9IGVuYWJsZTtcbn07XG5cblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IGRldGVybWluZSB0aGUgc2NhbGUgdGhhdCBiZXN0cyBmaXRzIHRoZSBwcm92aWRlZCBtaW5pbXVtIHN0ZXBcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWluaW11bVN0ZXBdICBUaGUgbWluaW11bSBzdGVwIHNpemUgaW4gbWlsbGlzZWNvbmRzXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5zZXRNaW5pbXVtU3RlcCA9IGZ1bmN0aW9uKG1pbmltdW1TdGVwKSB7XG4gIGlmIChtaW5pbXVtU3RlcCA9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvL3ZhciBiID0gYXNjICsgZHM7XG5cbiAgdmFyIHN0ZXBZZWFyICAgICAgID0gKDEwMDAgKiA2MCAqIDYwICogMjQgKiAzMCAqIDEyKTtcbiAgdmFyIHN0ZXBNb250aCAgICAgID0gKDEwMDAgKiA2MCAqIDYwICogMjQgKiAzMCk7XG4gIHZhciBzdGVwRGF5ICAgICAgICA9ICgxMDAwICogNjAgKiA2MCAqIDI0KTtcbiAgdmFyIHN0ZXBIb3VyICAgICAgID0gKDEwMDAgKiA2MCAqIDYwKTtcbiAgdmFyIHN0ZXBNaW51dGUgICAgID0gKDEwMDAgKiA2MCk7XG4gIHZhciBzdGVwU2Vjb25kICAgICA9ICgxMDAwKTtcbiAgdmFyIHN0ZXBNaWxsaXNlY29uZD0gKDEpO1xuXG4gIC8vIGZpbmQgdGhlIHNtYWxsZXN0IHN0ZXAgdGhhdCBpcyBsYXJnZXIgdGhhbiB0aGUgcHJvdmlkZWQgbWluaW11bVN0ZXBcbiAgaWYgKHN0ZXBZZWFyKjEwMDAgPiBtaW5pbXVtU3RlcCkgICAgICAgIHt0aGlzLnNjYWxlID0gJ3llYXInOyAgICAgICAgdGhpcy5zdGVwID0gMTAwMDt9XG4gIGlmIChzdGVwWWVhcio1MDAgPiBtaW5pbXVtU3RlcCkgICAgICAgICB7dGhpcy5zY2FsZSA9ICd5ZWFyJzsgICAgICAgIHRoaXMuc3RlcCA9IDUwMDt9XG4gIGlmIChzdGVwWWVhcioxMDAgPiBtaW5pbXVtU3RlcCkgICAgICAgICB7dGhpcy5zY2FsZSA9ICd5ZWFyJzsgICAgICAgIHRoaXMuc3RlcCA9IDEwMDt9XG4gIGlmIChzdGVwWWVhcio1MCA+IG1pbmltdW1TdGVwKSAgICAgICAgICB7dGhpcy5zY2FsZSA9ICd5ZWFyJzsgICAgICAgIHRoaXMuc3RlcCA9IDUwO31cbiAgaWYgKHN0ZXBZZWFyKjEwID4gbWluaW11bVN0ZXApICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ3llYXInOyAgICAgICAgdGhpcy5zdGVwID0gMTA7fVxuICBpZiAoc3RlcFllYXIqNSA+IG1pbmltdW1TdGVwKSAgICAgICAgICAge3RoaXMuc2NhbGUgPSAneWVhcic7ICAgICAgICB0aGlzLnN0ZXAgPSA1O31cbiAgaWYgKHN0ZXBZZWFyID4gbWluaW11bVN0ZXApICAgICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ3llYXInOyAgICAgICAgdGhpcy5zdGVwID0gMTt9XG4gIGlmIChzdGVwTW9udGgqMyA+IG1pbmltdW1TdGVwKSAgICAgICAgICB7dGhpcy5zY2FsZSA9ICdtb250aCc7ICAgICAgIHRoaXMuc3RlcCA9IDM7fVxuICBpZiAoc3RlcE1vbnRoID4gbWluaW11bVN0ZXApICAgICAgICAgICAge3RoaXMuc2NhbGUgPSAnbW9udGgnOyAgICAgICB0aGlzLnN0ZXAgPSAxO31cbiAgaWYgKHN0ZXBEYXkqNSA+IG1pbmltdW1TdGVwKSAgICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ2RheSc7ICAgICAgICAgdGhpcy5zdGVwID0gNTt9XG4gIGlmIChzdGVwRGF5KjIgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgICB7dGhpcy5zY2FsZSA9ICdkYXknOyAgICAgICAgIHRoaXMuc3RlcCA9IDI7fVxuICBpZiAoc3RlcERheSA+IG1pbmltdW1TdGVwKSAgICAgICAgICAgICAge3RoaXMuc2NhbGUgPSAnZGF5JzsgICAgICAgICB0aGlzLnN0ZXAgPSAxO31cbiAgaWYgKHN0ZXBEYXkvMiA+IG1pbmltdW1TdGVwKSAgICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ3dlZWtkYXknOyAgICAgdGhpcy5zdGVwID0gMTt9XG4gIGlmIChzdGVwSG91cio0ID4gbWluaW11bVN0ZXApICAgICAgICAgICB7dGhpcy5zY2FsZSA9ICdob3VyJzsgICAgICAgIHRoaXMuc3RlcCA9IDQ7fVxuICBpZiAoc3RlcEhvdXIgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgICAge3RoaXMuc2NhbGUgPSAnaG91cic7ICAgICAgICB0aGlzLnN0ZXAgPSAxO31cbiAgaWYgKHN0ZXBNaW51dGUqMTUgPiBtaW5pbXVtU3RlcCkgICAgICAgIHt0aGlzLnNjYWxlID0gJ21pbnV0ZSc7ICAgICAgdGhpcy5zdGVwID0gMTU7fVxuICBpZiAoc3RlcE1pbnV0ZSoxMCA+IG1pbmltdW1TdGVwKSAgICAgICAge3RoaXMuc2NhbGUgPSAnbWludXRlJzsgICAgICB0aGlzLnN0ZXAgPSAxMDt9XG4gIGlmIChzdGVwTWludXRlKjUgPiBtaW5pbXVtU3RlcCkgICAgICAgICB7dGhpcy5zY2FsZSA9ICdtaW51dGUnOyAgICAgIHRoaXMuc3RlcCA9IDU7fVxuICBpZiAoc3RlcE1pbnV0ZSA+IG1pbmltdW1TdGVwKSAgICAgICAgICAge3RoaXMuc2NhbGUgPSAnbWludXRlJzsgICAgICB0aGlzLnN0ZXAgPSAxO31cbiAgaWYgKHN0ZXBTZWNvbmQqMTUgPiBtaW5pbXVtU3RlcCkgICAgICAgIHt0aGlzLnNjYWxlID0gJ3NlY29uZCc7ICAgICAgdGhpcy5zdGVwID0gMTU7fVxuICBpZiAoc3RlcFNlY29uZCoxMCA+IG1pbmltdW1TdGVwKSAgICAgICAge3RoaXMuc2NhbGUgPSAnc2Vjb25kJzsgICAgICB0aGlzLnN0ZXAgPSAxMDt9XG4gIGlmIChzdGVwU2Vjb25kKjUgPiBtaW5pbXVtU3RlcCkgICAgICAgICB7dGhpcy5zY2FsZSA9ICdzZWNvbmQnOyAgICAgIHRoaXMuc3RlcCA9IDU7fVxuICBpZiAoc3RlcFNlY29uZCA+IG1pbmltdW1TdGVwKSAgICAgICAgICAge3RoaXMuc2NhbGUgPSAnc2Vjb25kJzsgICAgICB0aGlzLnN0ZXAgPSAxO31cbiAgaWYgKHN0ZXBNaWxsaXNlY29uZCoyMDAgPiBtaW5pbXVtU3RlcCkgIHt0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzsgdGhpcy5zdGVwID0gMjAwO31cbiAgaWYgKHN0ZXBNaWxsaXNlY29uZCoxMDAgPiBtaW5pbXVtU3RlcCkgIHt0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzsgdGhpcy5zdGVwID0gMTAwO31cbiAgaWYgKHN0ZXBNaWxsaXNlY29uZCo1MCA+IG1pbmltdW1TdGVwKSAgIHt0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzsgdGhpcy5zdGVwID0gNTA7fVxuICBpZiAoc3RlcE1pbGxpc2Vjb25kKjEwID4gbWluaW11bVN0ZXApICAge3RoaXMuc2NhbGUgPSAnbWlsbGlzZWNvbmQnOyB0aGlzLnN0ZXAgPSAxMDt9XG4gIGlmIChzdGVwTWlsbGlzZWNvbmQqNSA+IG1pbmltdW1TdGVwKSAgICB7dGhpcy5zY2FsZSA9ICdtaWxsaXNlY29uZCc7IHRoaXMuc3RlcCA9IDU7fVxuICBpZiAoc3RlcE1pbGxpc2Vjb25kID4gbWluaW11bVN0ZXApICAgICAge3RoaXMuc2NhbGUgPSAnbWlsbGlzZWNvbmQnOyB0aGlzLnN0ZXAgPSAxO31cbn07XG5cbi8qKlxuICogU25hcCBhIGRhdGUgdG8gYSByb3VuZGVkIHZhbHVlLlxuICogVGhlIHNuYXAgaW50ZXJ2YWxzIGFyZSBkZXBlbmRlbnQgb24gdGhlIGN1cnJlbnQgc2NhbGUgYW5kIHN0ZXAuXG4gKiBTdGF0aWMgZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSAgICB0aGUgZGF0ZSB0byBiZSBzbmFwcGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHNjYWxlIEN1cnJlbnQgc2NhbGUsIGNhbiBiZSAnbWlsbGlzZWNvbmQnLCAnc2Vjb25kJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAnbWludXRlJywgJ2hvdXInLCAnd2Vla2RheSwgJ2RheScsICdtb250aCcsICd5ZWFyJy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwICBDdXJyZW50IHN0ZXAgKDEsIDIsIDQsIDUsIC4uLlxuICogQHJldHVybiB7RGF0ZX0gc25hcHBlZERhdGVcbiAqL1xuVGltZVN0ZXAuc25hcCA9IGZ1bmN0aW9uKGRhdGUsIHNjYWxlLCBzdGVwKSB7XG4gIHZhciBjbG9uZSA9IG1vbWVudChkYXRlKTtcblxuICBpZiAoc2NhbGUgPT0gJ3llYXInKSB7XG4gICAgdmFyIHllYXIgPSBjbG9uZS55ZWFyKCkgKyBNYXRoLnJvdW5kKGNsb25lLm1vbnRoKCkgLyAxMik7XG4gICAgY2xvbmUueWVhcihNYXRoLnJvdW5kKHllYXIgLyBzdGVwKSAqIHN0ZXApO1xuICAgIGNsb25lLm1vbnRoKDApO1xuICAgIGNsb25lLmRhdGUoMCk7XG4gICAgY2xvbmUuaG91cnMoMCk7XG4gICAgY2xvbmUubWludXRlcygwKTtcbiAgICBjbG9uZS5zZWNvbmRzKDApO1xuICAgIGNsb25lLm1pbGxpc2Vjb25kcygwKTtcbiAgfVxuICBlbHNlIGlmIChzY2FsZSA9PSAnbW9udGgnKSB7XG4gICAgaWYgKGNsb25lLmRhdGUoKSA+IDE1KSB7XG4gICAgICBjbG9uZS5kYXRlKDEpO1xuICAgICAgY2xvbmUuYWRkKDEsICdtb250aCcpO1xuICAgICAgLy8gaW1wb3J0YW50OiBmaXJzdCBzZXQgRGF0ZSB0byAxLCBhZnRlciB0aGF0IGNoYW5nZSB0aGUgbW9udGguXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2xvbmUuZGF0ZSgxKTtcbiAgICB9XG5cbiAgICBjbG9uZS5ob3VycygwKTtcbiAgICBjbG9uZS5taW51dGVzKDApO1xuICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICB9XG4gIGVsc2UgaWYgKHNjYWxlID09ICdkYXknKSB7XG4gICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICBjYXNlIDU6XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGNsb25lLmhvdXJzKE1hdGgucm91bmQoY2xvbmUuaG91cnMoKSAvIDI0KSAqIDI0KTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjbG9uZS5ob3VycyhNYXRoLnJvdW5kKGNsb25lLmhvdXJzKCkgLyAxMikgKiAxMik7IGJyZWFrO1xuICAgIH1cbiAgICBjbG9uZS5taW51dGVzKDApO1xuICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICB9XG4gIGVsc2UgaWYgKHNjYWxlID09ICd3ZWVrZGF5Jykge1xuICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgY2FzZSA1OlxuICAgICAgY2FzZSAyOlxuICAgICAgICBjbG9uZS5ob3VycyhNYXRoLnJvdW5kKGNsb25lLmhvdXJzKCkgLyAxMikgKiAxMik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2xvbmUuaG91cnMoTWF0aC5yb3VuZChjbG9uZS5ob3VycygpIC8gNikgKiA2KTsgYnJlYWs7XG4gICAgfVxuICAgIGNsb25lLm1pbnV0ZXMoMCk7XG4gICAgY2xvbmUuc2Vjb25kcygwKTtcbiAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gIH1cbiAgZWxzZSBpZiAoc2NhbGUgPT0gJ2hvdXInKSB7XG4gICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGNsb25lLm1pbnV0ZXMoTWF0aC5yb3VuZChjbG9uZS5taW51dGVzKCkgLyA2MCkgKiA2MCk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2xvbmUubWludXRlcyhNYXRoLnJvdW5kKGNsb25lLm1pbnV0ZXMoKSAvIDMwKSAqIDMwKTsgYnJlYWs7XG4gICAgfVxuICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICB9IGVsc2UgaWYgKHNjYWxlID09ICdtaW51dGUnKSB7XG4gICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICBjYXNlIDE1OlxuICAgICAgY2FzZSAxMDpcbiAgICAgICAgY2xvbmUubWludXRlcyhNYXRoLnJvdW5kKGNsb25lLm1pbnV0ZXMoKSAvIDUpICogNSk7XG4gICAgICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBjbG9uZS5zZWNvbmRzKE1hdGgucm91bmQoY2xvbmUuc2Vjb25kcygpIC8gNjApICogNjApOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNsb25lLnNlY29uZHMoTWF0aC5yb3VuZChjbG9uZS5zZWNvbmRzKCkgLyAzMCkgKiAzMCk7IGJyZWFrO1xuICAgIH1cbiAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gIH1cbiAgZWxzZSBpZiAoc2NhbGUgPT0gJ3NlY29uZCcpIHtcbiAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgIGNhc2UgMTU6XG4gICAgICBjYXNlIDEwOlxuICAgICAgICBjbG9uZS5zZWNvbmRzKE1hdGgucm91bmQoY2xvbmUuc2Vjb25kcygpIC8gNSkgKiA1KTtcbiAgICAgICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgY2xvbmUubWlsbGlzZWNvbmRzKE1hdGgucm91bmQoY2xvbmUubWlsbGlzZWNvbmRzKCkgLyAxMDAwKSAqIDEwMDApOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNsb25lLm1pbGxpc2Vjb25kcyhNYXRoLnJvdW5kKGNsb25lLm1pbGxpc2Vjb25kcygpIC8gNTAwKSAqIDUwMCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChzY2FsZSA9PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgdmFyIF9zdGVwID0gc3RlcCA+IDUgPyBzdGVwIC8gMiA6IDE7XG4gICAgY2xvbmUubWlsbGlzZWNvbmRzKE1hdGgucm91bmQoY2xvbmUubWlsbGlzZWNvbmRzKCkgLyBfc3RlcCkgKiBfc3RlcCk7XG4gIH1cbiAgXG4gIHJldHVybiBjbG9uZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYSBtYWpvciB2YWx1ZSAoZm9yIGV4YW1wbGUgd2hlbiB0aGUgc3RlcFxuICogaXMgREFZLCBhIG1ham9yIHZhbHVlIGlzIGVhY2ggZmlyc3QgZGF5IG9mIHRoZSBNT05USClcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgY3VycmVudCBkYXRlIGlzIG1ham9yLCBlbHNlIGZhbHNlLlxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuaXNNYWpvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zd2l0Y2hlZFllYXIgPT0gdHJ1ZSkge1xuICAgIHRoaXMuc3dpdGNoZWRZZWFyID0gZmFsc2U7XG4gICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICBjYXNlICd5ZWFyJzpcbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIGNhc2UgJ3dlZWtkYXknOlxuICAgICAgY2FzZSAnZGF5JzpcbiAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmICh0aGlzLnN3aXRjaGVkTW9udGggPT0gdHJ1ZSkge1xuICAgIHRoaXMuc3dpdGNoZWRNb250aCA9IGZhbHNlO1xuICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgY2FzZSAnd2Vla2RheSc6XG4gICAgICBjYXNlICdkYXknOlxuICAgICAgY2FzZSAnaG91cic6XG4gICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKHRoaXMuc3dpdGNoZWREYXkgPT0gdHJ1ZSkge1xuICAgIHRoaXMuc3dpdGNoZWREYXkgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkYXRlID0gdGhpcy5tb21lbnQodGhpcy5jdXJyZW50KTtcbiAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgcmV0dXJuIChkYXRlLm1pbGxpc2Vjb25kcygpID09IDApO1xuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICByZXR1cm4gKGRhdGUuc2Vjb25kcygpID09IDApO1xuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICByZXR1cm4gKGRhdGUuaG91cnMoKSA9PSAwKSAmJiAoZGF0ZS5taW51dGVzKCkgPT0gMCk7XG4gICAgY2FzZSAnaG91cic6XG4gICAgICByZXR1cm4gKGRhdGUuaG91cnMoKSA9PSAwKTtcbiAgICBjYXNlICd3ZWVrZGF5JzogLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgY2FzZSAnZGF5JzpcbiAgICAgIHJldHVybiAoZGF0ZS5kYXRlKCkgPT0gMSk7XG4gICAgY2FzZSAnbW9udGgnOlxuICAgICAgcmV0dXJuIChkYXRlLm1vbnRoKCkgPT0gMCk7XG4gICAgY2FzZSAneWVhcic6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgZm9ybWF0dGVkIHRleHQgZm9yIHRoZSBtaW5vciBheGlzbGFiZWwsIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudFxuICogZGF0ZSBhbmQgdGhlIHNjYWxlLiBGb3IgZXhhbXBsZSB3aGVuIHNjYWxlIGlzIE1JTlVURSwgdGhlIGN1cnJlbnQgdGltZSBpc1xuICogZm9ybWF0dGVkIGFzIFwiaGg6bW1cIi5cbiAqIEBwYXJhbSB7RGF0ZX0gW2RhdGVdIGN1c3RvbSBkYXRlLiBpZiBub3QgcHJvdmlkZWQsIGN1cnJlbnQgZGF0ZSBpcyB0YWtlblxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuZ2V0TGFiZWxNaW5vciA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgaWYgKGRhdGUgPT0gdW5kZWZpbmVkKSB7XG4gICAgZGF0ZSA9IHRoaXMuY3VycmVudDtcbiAgfVxuXG4gIHZhciBmb3JtYXQgPSB0aGlzLmZvcm1hdC5taW5vckxhYmVsc1t0aGlzLnNjYWxlXTtcbiAgcmV0dXJuIChmb3JtYXQgJiYgZm9ybWF0Lmxlbmd0aCA+IDApID8gdGhpcy5tb21lbnQoZGF0ZSkuZm9ybWF0KGZvcm1hdCkgOiAnJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBmb3JtYXR0ZWQgdGV4dCBmb3IgdGhlIG1ham9yIGF4aXMgbGFiZWwsIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudFxuICogZGF0ZSBhbmQgdGhlIHNjYWxlLiBGb3IgZXhhbXBsZSB3aGVuIHNjYWxlIGlzIE1JTlVURSwgdGhlIG1ham9yIHNjYWxlIGlzXG4gKiBob3VycywgYW5kIHRoZSBob3VyIHdpbGwgYmUgZm9ybWF0dGVkIGFzIFwiaGhcIi5cbiAqIEBwYXJhbSB7RGF0ZX0gW2RhdGVdIGN1c3RvbSBkYXRlLiBpZiBub3QgcHJvdmlkZWQsIGN1cnJlbnQgZGF0ZSBpcyB0YWtlblxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuZ2V0TGFiZWxNYWpvciA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgaWYgKGRhdGUgPT0gdW5kZWZpbmVkKSB7XG4gICAgZGF0ZSA9IHRoaXMuY3VycmVudDtcbiAgfVxuXG4gIHZhciBmb3JtYXQgPSB0aGlzLmZvcm1hdC5tYWpvckxhYmVsc1t0aGlzLnNjYWxlXTtcbiAgcmV0dXJuIChmb3JtYXQgJiYgZm9ybWF0Lmxlbmd0aCA+IDApID8gdGhpcy5tb21lbnQoZGF0ZSkuZm9ybWF0KGZvcm1hdCkgOiAnJztcbn07XG5cblRpbWVTdGVwLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9tb21lbnQgPSB0aGlzLm1vbWVudDtcbiAgdmFyIG0gPSB0aGlzLm1vbWVudCh0aGlzLmN1cnJlbnQpO1xuICB2YXIgY3VycmVudCA9IG0ubG9jYWxlID8gbS5sb2NhbGUoJ2VuJykgOiBtLmxhbmcoJ2VuJyk7IC8vIG9sZCB2ZXJzaW9ucyBvZiBtb21lbnQgaGF2ZSAubGFuZygpIGZ1bmN0aW9uXG4gIHZhciBzdGVwID0gdGhpcy5zdGVwO1xuXG4gIGZ1bmN0aW9uIGV2ZW4odmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlIC8gc3RlcCAlIDIgPT0gMCkgPyAnIHZpcy1ldmVuJyA6ICcgdmlzLW9kZCc7XG4gIH1cblxuICBmdW5jdGlvbiB0b2RheShkYXRlKSB7XG4gICAgaWYgKGRhdGUuaXNTYW1lKG5ldyBEYXRlKCksICdkYXknKSkge1xuICAgICAgcmV0dXJuICcgdmlzLXRvZGF5JztcbiAgICB9XG4gICAgaWYgKGRhdGUuaXNTYW1lKF9tb21lbnQoKS5hZGQoMSwgJ2RheScpLCAnZGF5JykpIHtcbiAgICAgIHJldHVybiAnIHZpcy10b21vcnJvdyc7XG4gICAgfVxuICAgIGlmIChkYXRlLmlzU2FtZShfbW9tZW50KCkuYWRkKC0xLCAnZGF5JyksICdkYXknKSkge1xuICAgICAgcmV0dXJuICcgdmlzLXllc3RlcmRheSc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGN1cnJlbnRXZWVrKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5pc1NhbWUobmV3IERhdGUoKSwgJ3dlZWsnKSA/ICcgdmlzLWN1cnJlbnQtd2VlaycgOiAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGN1cnJlbnRNb250aChkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuaXNTYW1lKG5ldyBEYXRlKCksICdtb250aCcpID8gJyB2aXMtY3VycmVudC1tb250aCcgOiAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGN1cnJlbnRZZWFyKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5pc1NhbWUobmV3IERhdGUoKSwgJ3llYXInKSA/ICcgdmlzLWN1cnJlbnQteWVhcicgOiAnJztcbiAgfVxuXG4gIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgIHJldHVybiBldmVuKGN1cnJlbnQubWlsbGlzZWNvbmRzKCkpLnRyaW0oKTtcblxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICByZXR1cm4gZXZlbihjdXJyZW50LnNlY29uZHMoKSkudHJpbSgpO1xuXG4gICAgY2FzZSAnbWludXRlJzpcbiAgICAgIHJldHVybiBldmVuKGN1cnJlbnQubWludXRlcygpKS50cmltKCk7XG5cbiAgICBjYXNlICdob3VyJzpcbiAgICAgIHZhciBob3VycyA9IGN1cnJlbnQuaG91cnMoKTtcbiAgICAgIGlmICh0aGlzLnN0ZXAgPT0gNCkge1xuICAgICAgICBob3VycyA9IGhvdXJzICsgJy1oJyArIChob3VycyArIDQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICd2aXMtaCcgKyBob3VycyArIHRvZGF5KGN1cnJlbnQpICsgZXZlbihjdXJyZW50LmhvdXJzKCkpO1xuXG4gICAgY2FzZSAnd2Vla2RheSc6XG4gICAgICByZXR1cm4gJ3Zpcy0nICsgY3VycmVudC5mb3JtYXQoJ2RkZGQnKS50b0xvd2VyQ2FzZSgpICtcbiAgICAgICAgICB0b2RheShjdXJyZW50KSArIGN1cnJlbnRXZWVrKGN1cnJlbnQpICsgZXZlbihjdXJyZW50LmRhdGUoKSk7XG5cbiAgICBjYXNlICdkYXknOlxuICAgICAgdmFyIGRheSA9IGN1cnJlbnQuZGF0ZSgpO1xuICAgICAgdmFyIG1vbnRoID0gY3VycmVudC5mb3JtYXQoJ01NTU0nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuICd2aXMtZGF5JyArIGRheSArICcgdmlzLScgKyBtb250aCArIGN1cnJlbnRNb250aChjdXJyZW50KSArIGV2ZW4oZGF5IC0gMSk7XG5cbiAgICBjYXNlICdtb250aCc6XG4gICAgICByZXR1cm4gJ3Zpcy0nICsgY3VycmVudC5mb3JtYXQoJ01NTU0nKS50b0xvd2VyQ2FzZSgpICtcbiAgICAgICAgICBjdXJyZW50TW9udGgoY3VycmVudCkgKyBldmVuKGN1cnJlbnQubW9udGgoKSk7XG5cbiAgICBjYXNlICd5ZWFyJzpcbiAgICAgIHZhciB5ZWFyID0gY3VycmVudC55ZWFyKCk7XG4gICAgICByZXR1cm4gJ3Zpcy15ZWFyJyArIHllYXIgKyBjdXJyZW50WWVhcihjdXJyZW50KSsgZXZlbih5ZWFyKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZVN0ZXA7XG4iLCJ2YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2VtaXR0ZXItY29tcG9uZW50Jyk7XG52YXIgSGFtbWVyID0gcmVxdWlyZSgnLi4vbW9kdWxlL2hhbW1lcicpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJy4uL21vZHVsZS9tb21lbnQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIERhdGFTZXQgPSByZXF1aXJlKCcuLi9EYXRhU2V0Jyk7XG52YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuLi9EYXRhVmlldycpO1xudmFyIFJhbmdlID0gcmVxdWlyZSgnLi9SYW5nZScpO1xudmFyIENvcmUgPSByZXF1aXJlKCcuL0NvcmUnKTtcbnZhciBUaW1lQXhpcyA9IHJlcXVpcmUoJy4vY29tcG9uZW50L1RpbWVBeGlzJyk7XG52YXIgQ3VycmVudFRpbWUgPSByZXF1aXJlKCcuL2NvbXBvbmVudC9DdXJyZW50VGltZScpO1xudmFyIEN1c3RvbVRpbWUgPSByZXF1aXJlKCcuL2NvbXBvbmVudC9DdXN0b21UaW1lJyk7XG52YXIgSXRlbVNldCA9IHJlcXVpcmUoJy4vY29tcG9uZW50L0l0ZW1TZXQnKTtcblxudmFyIENvbmZpZ3VyYXRvciA9IHJlcXVpcmUoJy4uL3NoYXJlZC9Db25maWd1cmF0b3InKTtcbnZhciBWYWxpZGF0b3IgPSByZXF1aXJlKCcuLi9zaGFyZWQvVmFsaWRhdG9yJykuZGVmYXVsdDtcbnZhciBwcmludFN0eWxlID0gcmVxdWlyZSgnLi4vc2hhcmVkL1ZhbGlkYXRvcicpLnByaW50U3R5bGU7XG52YXIgYWxsT3B0aW9ucyA9IHJlcXVpcmUoJy4vb3B0aW9uc1RpbWVsaW5lJykuYWxsT3B0aW9ucztcbnZhciBjb25maWd1cmVPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zVGltZWxpbmUnKS5jb25maWd1cmVPcHRpb25zO1xuXG4vKipcbiAqIENyZWF0ZSBhIHRpbWVsaW5lIHZpc3VhbGl6YXRpb25cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IHZpcy5EYXRhVmlldyB8IEFycmF5fSBbaXRlbXNdXG4gKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgdmlzLkRhdGFWaWV3IHwgQXJyYXl9IFtncm91cHNdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBTZWUgVGltZWxpbmUuc2V0T3B0aW9ucyBmb3IgdGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDb3JlXG4gKi9cbmZ1bmN0aW9uIFRpbWVsaW5lIChjb250YWluZXIsIGl0ZW1zLCBncm91cHMsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRpbWVsaW5lKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gIH1cblxuICAvLyBpZiB0aGUgdGhpcmQgZWxlbWVudCBpcyBvcHRpb25zLCB0aGUgZm9ydGggaXMgZ3JvdXBzIChvcHRpb25hbGx5KTtcbiAgaWYgKCEoQXJyYXkuaXNBcnJheShncm91cHMpIHx8IGdyb3VwcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVZpZXcpICYmIGdyb3VwcyBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIHZhciBmb3J0aEFyZ3VtZW50ID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gZ3JvdXBzO1xuICAgIGdyb3VwcyA9IGZvcnRoQXJndW1lbnQ7XG4gIH1cblxuICB2YXIgbWUgPSB0aGlzO1xuICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIHN0YXJ0OiBudWxsLFxuICAgIGVuZDogICBudWxsLFxuXG4gICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcbiAgICB0aHJvdHRsZVJlZHJhdzogMCwgLy8gbXNcblxuICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICBheGlzOiAnYm90dG9tJywgICAvLyBheGlzIG9yaWVudGF0aW9uOiAnYm90dG9tJywgJ3RvcCcsIG9yICdib3RoJ1xuICAgICAgaXRlbTogJ2JvdHRvbScgICAgLy8gbm90IHJlbGV2YW50XG4gICAgfSxcblxuICAgIG1vbWVudDogbW9tZW50LFxuXG4gICAgd2lkdGg6IG51bGwsXG4gICAgaGVpZ2h0OiBudWxsLFxuICAgIG1heEhlaWdodDogbnVsbCxcbiAgICBtaW5IZWlnaHQ6IG51bGxcbiAgfTtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5kZWVwRXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAvLyBDcmVhdGUgdGhlIERPTSwgcHJvcHMsIGFuZCBlbWl0dGVyXG4gIHRoaXMuX2NyZWF0ZShjb250YWluZXIpO1xuXG4gIC8vIGFsbCBjb21wb25lbnRzIGxpc3RlZCBoZXJlIHdpbGwgYmUgcmVwYWludGVkIGF1dG9tYXRpY2FsbHlcbiAgdGhpcy5jb21wb25lbnRzID0gW107XG5cbiAgdGhpcy5ib2R5ID0ge1xuICAgIGRvbTogdGhpcy5kb20sXG4gICAgZG9tUHJvcHM6IHRoaXMucHJvcHMsXG4gICAgZW1pdHRlcjoge1xuICAgICAgb246IHRoaXMub24uYmluZCh0aGlzKSxcbiAgICAgIG9mZjogdGhpcy5vZmYuYmluZCh0aGlzKSxcbiAgICAgIGVtaXQ6IHRoaXMuZW1pdC5iaW5kKHRoaXMpXG4gICAgfSxcbiAgICBoaWRkZW5EYXRlczogW10sXG4gICAgdXRpbDoge1xuICAgICAgZ2V0U2NhbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1lLnRpbWVBeGlzLnN0ZXAuc2NhbGU7XG4gICAgICB9LFxuICAgICAgZ2V0U3RlcDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbWUudGltZUF4aXMuc3RlcC5zdGVwO1xuICAgICAgfSxcblxuICAgICAgdG9TY3JlZW46IG1lLl90b1NjcmVlbi5iaW5kKG1lKSxcbiAgICAgIHRvR2xvYmFsU2NyZWVuOiBtZS5fdG9HbG9iYWxTY3JlZW4uYmluZChtZSksIC8vIHRoaXMgcmVmZXJzIHRvIHRoZSByb290LndpZHRoXG4gICAgICB0b1RpbWU6IG1lLl90b1RpbWUuYmluZChtZSksXG4gICAgICB0b0dsb2JhbFRpbWUgOiBtZS5fdG9HbG9iYWxUaW1lLmJpbmQobWUpXG4gICAgfVxuICB9O1xuXG4gIC8vIHJhbmdlXG4gIHRoaXMucmFuZ2UgPSBuZXcgUmFuZ2UodGhpcy5ib2R5KTtcbiAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5yYW5nZSk7XG4gIHRoaXMuYm9keS5yYW5nZSA9IHRoaXMucmFuZ2U7XG5cbiAgLy8gdGltZSBheGlzXG4gIHRoaXMudGltZUF4aXMgPSBuZXcgVGltZUF4aXModGhpcy5ib2R5KTtcbiAgdGhpcy50aW1lQXhpczIgPSBudWxsOyAvLyB1c2VkIGluIGNhc2Ugb2Ygb3JpZW50YXRpb24gb3B0aW9uICdib3RoJ1xuICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aGlzLnRpbWVBeGlzKTtcblxuICAvLyBjdXJyZW50IHRpbWUgYmFyXG4gIHRoaXMuY3VycmVudFRpbWUgPSBuZXcgQ3VycmVudFRpbWUodGhpcy5ib2R5KTtcbiAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5jdXJyZW50VGltZSk7XG5cbiAgLy8gaXRlbSBzZXRcbiAgdGhpcy5pdGVtU2V0ID0gbmV3IEl0ZW1TZXQodGhpcy5ib2R5KTtcbiAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy5pdGVtU2V0KTtcblxuICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7ICAgICAgLy8gRGF0YVNldFxuICB0aGlzLmdyb3Vwc0RhdGEgPSBudWxsOyAgICAgLy8gRGF0YVNldFxuXG4gIHRoaXMub24oJ3RhcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIG1lLmVtaXQoJ2NsaWNrJywgbWUuZ2V0RXZlbnRQcm9wZXJ0aWVzKGV2ZW50KSlcbiAgfSk7XG4gIHRoaXMub24oJ2RvdWJsZXRhcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIG1lLmVtaXQoJ2RvdWJsZUNsaWNrJywgbWUuZ2V0RXZlbnRQcm9wZXJ0aWVzKGV2ZW50KSlcbiAgfSk7XG4gIHRoaXMuZG9tLnJvb3Qub25jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIG1lLmVtaXQoJ2NvbnRleHRtZW51JywgbWUuZ2V0RXZlbnRQcm9wZXJ0aWVzKGV2ZW50KSlcbiAgfTtcblxuICAvLyBhcHBseSBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gSU1QT1JUQU5UOiBUSElTIEhBUFBFTlMgQkVGT1JFIFNFVCBJVEVNUyFcbiAgaWYgKGdyb3Vwcykge1xuICAgIHRoaXMuc2V0R3JvdXBzKGdyb3Vwcyk7XG4gIH1cblxuICAvLyBjcmVhdGUgaXRlbXNldFxuICBpZiAoaXRlbXMpIHtcbiAgICB0aGlzLnNldEl0ZW1zKGl0ZW1zKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLl9yZWRyYXcoKTtcbiAgfVxufVxuXG4vLyBFeHRlbmQgdGhlIGZ1bmN0aW9uYWxpdHkgZnJvbSBDb3JlXG5UaW1lbGluZS5wcm90b3R5cGUgPSBuZXcgQ29yZSgpO1xuXG4vKipcbiAqIExvYWQgYSBjb25maWd1cmF0b3JcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5fY3JlYXRlQ29uZmlndXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IENvbmZpZ3VyYXRvcih0aGlzLCB0aGlzLmRvbS5jb250YWluZXIsIGNvbmZpZ3VyZU9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBGb3JjZSBhIHJlZHJhdy4gVGhlIHNpemUgb2YgYWxsIGl0ZW1zIHdpbGwgYmUgcmVjYWxjdWxhdGVkLlxuICogQ2FuIGJlIHVzZWZ1bCB0byBtYW51YWxseSByZWRyYXcgd2hlbiBvcHRpb24gYXV0b1Jlc2l6ZT1mYWxzZSBhbmQgdGhlIHdpbmRvd1xuICogaGFzIGJlZW4gcmVzaXplZCwgb3Igd2hlbiB0aGUgaXRlbXMgQ1NTIGhhcyBiZWVuIGNoYW5nZWQuXG4gKlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiB3aWxsIGJlIG92ZXJyaWRkZW4gb24gY29uc3RydWN0aW9uIHdpdGggYSB0cm90dGxlZCB2ZXJzaW9uXG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5tYXJrRGlydHkoe3JlZnJlc2hJdGVtczogdHJ1ZX0pO1xuICB0aGlzLl9yZWRyYXcoKTtcbn07XG5cblRpbWVsaW5lLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gdmFsaWRhdGUgb3B0aW9uc1xuICBsZXQgZXJyb3JGb3VuZCA9IFZhbGlkYXRvci52YWxpZGF0ZShvcHRpb25zLCBhbGxPcHRpb25zKTtcbiAgaWYgKGVycm9yRm91bmQgPT09IHRydWUpIHtcbiAgICBjb25zb2xlLmxvZygnJWNFcnJvcnMgaGF2ZSBiZWVuIGZvdW5kIGluIHRoZSBzdXBwbGllZCBvcHRpb25zIG9iamVjdC4nLCBwcmludFN0eWxlKTtcbiAgfVxuXG4gIENvcmUucHJvdG90eXBlLnNldE9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAoJ3R5cGUnIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy50eXBlICE9PSB0aGlzLm9wdGlvbnMudHlwZSkge1xuICAgICAgdGhpcy5vcHRpb25zLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cbiAgICAgIC8vIGZvcmNlIHJlY3JlYXRpb24gb2YgYWxsIGl0ZW1zXG4gICAgICB2YXIgaXRlbXNEYXRhID0gdGhpcy5pdGVtc0RhdGE7XG4gICAgICBpZiAoaXRlbXNEYXRhKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnNldEl0ZW1zKG51bGwpOyAgICAgICAgICAvLyByZW1vdmUgYWxsXG4gICAgICAgIHRoaXMuc2V0SXRlbXMoaXRlbXNEYXRhKTsgICAgIC8vIGFkZCBhbGxcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTsgLy8gcmVzdG9yZSBzZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGl0ZW1zXG4gKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgQXJyYXkgfCBudWxsfSBpdGVtc1xuICovXG5UaW1lbGluZS5wcm90b3R5cGUuc2V0SXRlbXMgPSBmdW5jdGlvbihpdGVtcykge1xuICB2YXIgaW5pdGlhbExvYWQgPSAodGhpcy5pdGVtc0RhdGEgPT0gbnVsbCk7XG5cbiAgLy8gY29udmVydCB0byB0eXBlIERhdGFTZXQgd2hlbiBuZWVkZWRcbiAgdmFyIG5ld0RhdGFTZXQ7XG4gIGlmICghaXRlbXMpIHtcbiAgICBuZXdEYXRhU2V0ID0gbnVsbDtcbiAgfVxuICBlbHNlIGlmIChpdGVtcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgaXRlbXMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIG5ld0RhdGFTZXQgPSBpdGVtcztcbiAgfVxuICBlbHNlIHtcbiAgICAvLyB0dXJuIGFuIGFycmF5IGludG8gYSBkYXRhc2V0XG4gICAgbmV3RGF0YVNldCA9IG5ldyBEYXRhU2V0KGl0ZW1zLCB7XG4gICAgICB0eXBlOiB7XG4gICAgICAgIHN0YXJ0OiAnRGF0ZScsXG4gICAgICAgIGVuZDogJ0RhdGUnXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBzZXQgaXRlbXNcbiAgdGhpcy5pdGVtc0RhdGEgPSBuZXdEYXRhU2V0O1xuICB0aGlzLml0ZW1TZXQgJiYgdGhpcy5pdGVtU2V0LnNldEl0ZW1zKG5ld0RhdGFTZXQpO1xuXG4gIGlmIChpbml0aWFsTG9hZCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhcnQgIT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0YXJ0ID09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMuZW5kID09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldEl0ZW1SYW5nZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLm9wdGlvbnMuc3RhcnQgIT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnN0YXJ0IDogcmFuZ2UubWluO1xuICAgICAgdmFyIGVuZCAgID0gdGhpcy5vcHRpb25zLmVuZCAhPSB1bmRlZmluZWQgICA/IHRoaXMub3B0aW9ucy5lbmQgICA6IHJhbmdlLm1heDtcblxuICAgICAgdGhpcy5zZXRXaW5kb3coc3RhcnQsIGVuZCwge2FuaW1hdGlvbjogZmFsc2V9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmZpdCh7YW5pbWF0aW9uOiBmYWxzZX0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgZ3JvdXBzXG4gKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgQXJyYXl9IGdyb3Vwc1xuICovXG5UaW1lbGluZS5wcm90b3R5cGUuc2V0R3JvdXBzID0gZnVuY3Rpb24oZ3JvdXBzKSB7XG4gIC8vIGNvbnZlcnQgdG8gdHlwZSBEYXRhU2V0IHdoZW4gbmVlZGVkXG4gIHZhciBuZXdEYXRhU2V0O1xuICBpZiAoIWdyb3Vwcykge1xuICAgIG5ld0RhdGFTZXQgPSBudWxsO1xuICB9XG4gIGVsc2UgaWYgKGdyb3VwcyBpbnN0YW5jZW9mIERhdGFTZXQgfHwgZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICBuZXdEYXRhU2V0ID0gZ3JvdXBzO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIHR1cm4gYW4gYXJyYXkgaW50byBhIGRhdGFzZXRcbiAgICBuZXdEYXRhU2V0ID0gbmV3IERhdGFTZXQoZ3JvdXBzKTtcbiAgfVxuXG4gIHRoaXMuZ3JvdXBzRGF0YSA9IG5ld0RhdGFTZXQ7XG4gIHRoaXMuaXRlbVNldC5zZXRHcm91cHMobmV3RGF0YVNldCk7XG59O1xuXG4vKipcbiAqIFNldCBib3RoIGl0ZW1zIGFuZCBncm91cHMgaW4gb25lIGdvXG4gKiBAcGFyYW0ge3tpdGVtczogQXJyYXkgfCB2aXMuRGF0YVNldCwgZ3JvdXBzOiBBcnJheSB8IHZpcy5EYXRhU2V0fX0gZGF0YVxuICovXG5UaW1lbGluZS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIGlmIChkYXRhICYmIGRhdGEuZ3JvdXBzKSB7XG4gICAgdGhpcy5zZXRHcm91cHMoZGF0YS5ncm91cHMpO1xuICB9XG5cbiAgaWYgKGRhdGEgJiYgZGF0YS5pdGVtcykge1xuICAgIHRoaXMuc2V0SXRlbXMoZGF0YS5pdGVtcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IHNlbGVjdGVkIGl0ZW1zIGJ5IHRoZWlyIGlkLiBSZXBsYWNlcyB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAqIFVua25vd24gaWQncyBhcmUgc2lsZW50bHkgaWdub3JlZC5cbiAqIEBwYXJhbSB7c3RyaW5nW10gfCBzdHJpbmd9IFtpZHNdICBBbiBhcnJheSB3aXRoIHplcm8gb3IgbW9yZSBpZCdzIG9mIHRoZSBpdGVtcyB0byBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLiBJZiBpZHMgaXMgYW4gZW1wdHkgYXJyYXksIGFsbCBpdGVtcyB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5zZWxlY3RlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgZm9jdXM6IGJvb2xlYW5gXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUsIGZvY3VzIHdpbGwgYmUgc2V0IHRvIHRoZSBzZWxlY3RlZCBpdGVtKHMpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFuaW1hdGlvbjogYm9vbGVhbiB8IHtkdXJhdGlvbjogbnVtYmVyLCBlYXNpbmdGdW5jdGlvbjogc3RyaW5nfWBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCB0byBzcGVjaWZ5IGR1cmF0aW9uIGFuZCBlYXNpbmcgZnVuY3Rpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IGFwcGxpY2FibGUgd2hlbiBvcHRpb24gZm9jdXMgaXMgdHJ1ZS5cbiAqL1xuVGltZWxpbmUucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKGlkcywgb3B0aW9ucykge1xuICB0aGlzLml0ZW1TZXQgJiYgdGhpcy5pdGVtU2V0LnNldFNlbGVjdGlvbihpZHMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZm9jdXMpIHtcbiAgICB0aGlzLmZvY3VzKGlkcywgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBzZWxlY3RlZCBpdGVtcyBieSB0aGVpciBpZFxuICogQHJldHVybiB7QXJyYXl9IGlkcyAgVGhlIGlkcyBvZiB0aGUgc2VsZWN0ZWQgaXRlbXNcbiAqL1xuVGltZWxpbmUucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5nZXRTZWxlY3Rpb24oKSB8fCBbXTtcbn07XG5cbi8qKlxuICogQWRqdXN0IHRoZSB2aXNpYmxlIHdpbmRvdyBzdWNoIHRoYXQgdGhlIHNlbGVjdGVkIGl0ZW0gKG9yIG11bHRpcGxlIGl0ZW1zKVxuICogYXJlIGNlbnRlcmVkIG9uIHNjcmVlbi5cbiAqIEBwYXJhbSB7U3RyaW5nIHwgU3RyaW5nW119IGlkICAgICBBbiBpdGVtIGlkIG9yIGFycmF5IHdpdGggaXRlbSBpZHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5pbWF0aW9uOiBib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9YFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMsIGFuZCBkZWZhdWx0IGVhc2luZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKGlkLCBvcHRpb25zKSB7XG4gIGlmICghdGhpcy5pdGVtc0RhdGEgfHwgaWQgPT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgdmFyIGlkcyA9IEFycmF5LmlzQXJyYXkoaWQpID8gaWQgOiBbaWRdO1xuXG4gIC8vIGdldCB0aGUgc3BlY2lmaWVkIGl0ZW0ocylcbiAgdmFyIGl0ZW1zRGF0YSA9IHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKS5nZXQoaWRzLCB7XG4gICAgdHlwZToge1xuICAgICAgc3RhcnQ6ICdEYXRlJyxcbiAgICAgIGVuZDogJ0RhdGUnXG4gICAgfVxuICB9KTtcblxuICAvLyBjYWxjdWxhdGUgbWluaW11bSBzdGFydCBhbmQgbWF4aW11bSBlbmQgb2Ygc3BlY2lmaWVkIGl0ZW1zXG4gIHZhciBzdGFydCA9IG51bGw7XG4gIHZhciBlbmQgPSBudWxsO1xuICBpdGVtc0RhdGEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbURhdGEpIHtcbiAgICB2YXIgcyA9IGl0ZW1EYXRhLnN0YXJ0LnZhbHVlT2YoKTtcbiAgICB2YXIgZSA9ICdlbmQnIGluIGl0ZW1EYXRhID8gaXRlbURhdGEuZW5kLnZhbHVlT2YoKSA6IGl0ZW1EYXRhLnN0YXJ0LnZhbHVlT2YoKTtcblxuICAgIGlmIChzdGFydCA9PT0gbnVsbCB8fCBzIDwgc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gcztcbiAgICB9XG5cbiAgICBpZiAoZW5kID09PSBudWxsIHx8IGUgPiBlbmQpIHtcbiAgICAgIGVuZCA9IGU7XG4gICAgfVxuICB9KTtcblxuICBpZiAoc3RhcnQgIT09IG51bGwgJiYgZW5kICE9PSBudWxsKSB7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBuZXcgbWlkZGxlIGFuZCBpbnRlcnZhbCBmb3IgdGhlIHdpbmRvd1xuICAgIHZhciBtaWRkbGUgPSAoc3RhcnQgKyBlbmQpIC8gMjtcbiAgICB2YXIgaW50ZXJ2YWwgPSBNYXRoLm1heCgodGhpcy5yYW5nZS5lbmQgLSB0aGlzLnJhbmdlLnN0YXJ0KSwgKGVuZCAtIHN0YXJ0KSAqIDEuMSk7XG5cbiAgICB2YXIgYW5pbWF0aW9uID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb24gIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmFuaW1hdGlvbiA6IHRydWU7XG4gICAgdGhpcy5yYW5nZS5zZXRSYW5nZShtaWRkbGUgLSBpbnRlcnZhbCAvIDIsIG1pZGRsZSArIGludGVydmFsIC8gMiwgYW5pbWF0aW9uKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgVGltZWxpbmUgd2luZG93IHN1Y2ggdGhhdCBpdCBmaXRzIGFsbCBpdGVtc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFuaW1hdGlvbjogYm9vbGVhbiB8IHtkdXJhdGlvbjogbnVtYmVyLCBlYXNpbmdGdW5jdGlvbjogc3RyaW5nfWBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCB0byBzcGVjaWZ5IGR1cmF0aW9uIGFuZCBlYXNpbmcgZnVuY3Rpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICovXG5UaW1lbGluZS5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGFuaW1hdGlvbiA9IChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5hbmltYXRpb24gOiB0cnVlO1xuICB2YXIgcmFuZ2UgPSB0aGlzLmdldEl0ZW1SYW5nZSgpO1xuICB0aGlzLnJhbmdlLnNldFJhbmdlKHJhbmdlLm1pbiwgcmFuZ2UubWF4LCBhbmltYXRpb24pO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIHJhbmdlIG9mIHRoZSBpdGVtcywgdGFraW5nIGludG8gYWNjb3VudCB0aGVpciBhY3R1YWwgd2lkdGhcbiAqIGFuZCBhIG1hcmdpbiBvZiAxMCBwaXhlbHMgb24gYm90aCBzaWRlcy5cbiAqIEByZXR1cm4ge3ttaW46IERhdGUgfCBudWxsLCBtYXg6IERhdGUgfCBudWxsfX1cbiAqL1xuVGltZWxpbmUucHJvdG90eXBlLmdldEl0ZW1SYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gZ2V0IGEgcm91Z2ggYXBwcm94aW1hdGlvbiBmb3IgdGhlIHJhbmdlIGJhc2VkIG9uIHRoZSBpdGVtcyBzdGFydCBhbmQgZW5kIGRhdGVzXG4gIHZhciByYW5nZSA9IHRoaXMuZ2V0RGF0YVJhbmdlKCk7XG4gIHZhciBtaW4gPSByYW5nZS5taW47XG4gIHZhciBtYXggPSByYW5nZS5tYXg7XG4gIHZhciBtaW5JdGVtID0gbnVsbDtcbiAgdmFyIG1heEl0ZW0gPSBudWxsO1xuXG4gIGlmIChtaW4gIT0gbnVsbCAmJiBtYXggIT0gbnVsbCkge1xuICAgIHZhciBpbnRlcnZhbCA9IChtYXggLSBtaW4pOyAvLyBtc1xuICAgIGlmIChpbnRlcnZhbCA8PSAwKSB7XG4gICAgICBpbnRlcnZhbCA9IDEwO1xuICAgIH1cbiAgICB2YXIgZmFjdG9yID0gaW50ZXJ2YWwgLyB0aGlzLnByb3BzLmNlbnRlci53aWR0aDtcblxuICAgIGZ1bmN0aW9uIGdldFN0YXJ0KGl0ZW0pIHtcbiAgICAgIHJldHVybiB1dGlsLmNvbnZlcnQoaXRlbS5kYXRhLnN0YXJ0LCAnRGF0ZScpLnZhbHVlT2YoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVuZChpdGVtKSB7XG4gICAgICB2YXIgZW5kID0gaXRlbS5kYXRhLmVuZCAhPSB1bmRlZmluZWQgPyBpdGVtLmRhdGEuZW5kIDogaXRlbS5kYXRhLnN0YXJ0O1xuICAgICAgcmV0dXJuIHV0aWwuY29udmVydChlbmQsICdEYXRlJykudmFsdWVPZigpO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGF0ZSBvZiB0aGUgbGVmdCBzaWRlIGFuZCByaWdodCBzaWRlIG9mIHRoZSBpdGVtcyBnaXZlblxuICAgIHV0aWwuZm9yRWFjaCh0aGlzLml0ZW1TZXQuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpdGVtLnNob3coKTtcblxuICAgICAgdmFyIHN0YXJ0ID0gZ2V0U3RhcnQoaXRlbSk7XG4gICAgICB2YXIgZW5kID0gZ2V0RW5kKGl0ZW0pO1xuXG4gICAgICB2YXIgbGVmdCAgPSBuZXcgRGF0ZShzdGFydCAtIChpdGVtLmdldFdpZHRoTGVmdCgpICsgMTApICogZmFjdG9yKTtcbiAgICAgIHZhciByaWdodCA9IG5ldyBEYXRlKGVuZCAgICsgKGl0ZW0uZ2V0V2lkdGhSaWdodCgpICsgMTApICogZmFjdG9yKTtcblxuICAgICAgaWYgKGxlZnQgPCBtaW4pIHtcbiAgICAgICAgbWluID0gbGVmdDtcbiAgICAgICAgbWluSXRlbSA9IGl0ZW07XG4gICAgICB9XG4gICAgICBpZiAocmlnaHQgPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gcmlnaHQ7XG4gICAgICAgIG1heEl0ZW0gPSBpdGVtO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICBpZiAobWluSXRlbSAmJiBtYXhJdGVtKSB7XG4gICAgICB2YXIgbGhzID0gbWluSXRlbS5nZXRXaWR0aExlZnQoKSArIDEwO1xuICAgICAgdmFyIHJocyA9IG1heEl0ZW0uZ2V0V2lkdGhSaWdodCgpICsgMTA7XG4gICAgICB2YXIgZGVsdGEgPSB0aGlzLnByb3BzLmNlbnRlci53aWR0aCAtIGxocyAtIHJoczsgIC8vIHB4XG5cbiAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgbWluID0gZ2V0U3RhcnQobWluSXRlbSkgLSBsaHMgKiBpbnRlcnZhbCAvIGRlbHRhOyAvLyBtc1xuICAgICAgICBtYXggPSBnZXRFbmQobWF4SXRlbSkgICArIHJocyAqIGludGVydmFsIC8gZGVsdGE7IC8vIG1zXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGwsXG4gICAgbWF4OiBtYXggIT0gbnVsbCA/IG5ldyBEYXRlKG1heCkgOiBudWxsXG4gIH1cbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBkYXRhIHJhbmdlIG9mIHRoZSBpdGVtcyBzdGFydCBhbmQgZW5kIGRhdGVzXG4gKiBAcmV0dXJucyB7e21pbjogRGF0ZSB8IG51bGwsIG1heDogRGF0ZSB8IG51bGx9fVxuICovXG5UaW1lbGluZS5wcm90b3R5cGUuZ2V0RGF0YVJhbmdlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtaW4gPSBudWxsO1xuICB2YXIgbWF4ID0gbnVsbDtcblxuICB2YXIgZGF0YXNldCA9IHRoaXMuaXRlbXNEYXRhICYmIHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKTtcbiAgaWYgKGRhdGFzZXQpIHtcbiAgICBkYXRhc2V0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBzdGFydCA9IHV0aWwuY29udmVydChpdGVtLnN0YXJ0LCAnRGF0ZScpLnZhbHVlT2YoKTtcbiAgICAgIHZhciBlbmQgICA9IHV0aWwuY29udmVydChpdGVtLmVuZCAhPSB1bmRlZmluZWQgPyBpdGVtLmVuZCA6IGl0ZW0uc3RhcnQsICdEYXRlJykudmFsdWVPZigpO1xuICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBzdGFydCA8IG1pbikge1xuICAgICAgICBtaW4gPSBzdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChtYXggPT09IG51bGwgfHwgZW5kID4gbWF4KSB7XG4gICAgICAgIG1heCA9IHN0YXJ0O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGwsXG4gICAgbWF4OiBtYXggIT0gbnVsbCA/IG5ldyBEYXRlKG1heCkgOiBudWxsXG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGUgVGltZWxpbmUgcmVsYXRlZCBpbmZvcm1hdGlvbiBmcm9tIGFuIGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCByZWxhdGVkIGluZm9ybWF0aW9uLCBsaWtlIG9uIHdoaWNoIGFyZWFcbiAqICAgICAgICAgICAgICAgICAgVGhlIGV2ZW50IGhhcHBlbmVkLCB3aGV0aGVyIGNsaWNrZWQgb24gYW4gaXRlbSwgZXRjLlxuICovXG5UaW1lbGluZS5wcm90b3R5cGUuZ2V0RXZlbnRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBjbGllbnRYID0gZXZlbnQuY2VudGVyID8gZXZlbnQuY2VudGVyLnggOiBldmVudC5jbGllbnRYO1xuICB2YXIgY2xpZW50WSA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci55IDogZXZlbnQuY2xpZW50WTtcbiAgdmFyIHggPSBjbGllbnRYIC0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQodGhpcy5kb20uY2VudGVyQ29udGFpbmVyKTtcbiAgdmFyIHkgPSBjbGllbnRZIC0gdXRpbC5nZXRBYnNvbHV0ZVRvcCh0aGlzLmRvbS5jZW50ZXJDb250YWluZXIpO1xuXG4gIHZhciBpdGVtICA9IHRoaXMuaXRlbVNldC5pdGVtRnJvbVRhcmdldChldmVudCk7XG4gIHZhciBncm91cCA9IHRoaXMuaXRlbVNldC5ncm91cEZyb21UYXJnZXQoZXZlbnQpO1xuICB2YXIgY3VzdG9tVGltZSA9IEN1c3RvbVRpbWUuY3VzdG9tVGltZUZyb21UYXJnZXQoZXZlbnQpO1xuXG4gIHZhciBzbmFwID0gdGhpcy5pdGVtU2V0Lm9wdGlvbnMuc25hcCB8fCBudWxsO1xuICB2YXIgc2NhbGUgPSB0aGlzLmJvZHkudXRpbC5nZXRTY2FsZSgpO1xuICB2YXIgc3RlcCA9IHRoaXMuYm9keS51dGlsLmdldFN0ZXAoKTtcbiAgdmFyIHRpbWUgPSB0aGlzLl90b1RpbWUoeCk7XG4gIHZhciBzbmFwcGVkVGltZSA9IHNuYXAgPyBzbmFwKHRpbWUsIHNjYWxlLCBzdGVwKSA6IHRpbWU7XG5cbiAgdmFyIGVsZW1lbnQgPSB1dGlsLmdldFRhcmdldChldmVudCk7XG4gIHZhciB3aGF0ID0gbnVsbDtcbiAgaWYgKGl0ZW0gIT0gbnVsbCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3doYXQgPSAnaXRlbSc7fVxuICBlbHNlIGlmIChjdXN0b21UaW1lICE9IG51bGwpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7d2hhdCA9ICdjdXN0b20tdGltZSc7fVxuICBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLnRpbWVBeGlzLmRvbS5mb3JlZ3JvdW5kKSkgICAgICB7d2hhdCA9ICdheGlzJzt9XG4gIGVsc2UgaWYgKHRoaXMudGltZUF4aXMyICYmIHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMudGltZUF4aXMyLmRvbS5mb3JlZ3JvdW5kKSkge3doYXQgPSAnYXhpcyc7fVxuICBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLml0ZW1TZXQuZG9tLmxhYmVsU2V0KSkgICAgICAgICB7d2hhdCA9ICdncm91cC1sYWJlbCc7fVxuICBlbHNlIGlmICh1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLmN1cnJlbnRUaW1lLmJhcikpICAgICAgICAgICAgICB7d2hhdCA9ICdjdXJyZW50LXRpbWUnO31cbiAgZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5kb20uY2VudGVyKSkgICAgICAgICAgICAgICAgICAge3doYXQgPSAnYmFja2dyb3VuZCc7fVxuXG4gIHJldHVybiB7XG4gICAgZXZlbnQ6IGV2ZW50LFxuICAgIGl0ZW06IGl0ZW0gPyBpdGVtLmlkIDogbnVsbCxcbiAgICBncm91cDogZ3JvdXAgPyBncm91cC5ncm91cElkIDogbnVsbCxcbiAgICB3aGF0OiB3aGF0LFxuICAgIHBhZ2VYOiBldmVudC5zcmNFdmVudCA/IGV2ZW50LnNyY0V2ZW50LnBhZ2VYIDogZXZlbnQucGFnZVgsXG4gICAgcGFnZVk6IGV2ZW50LnNyY0V2ZW50ID8gZXZlbnQuc3JjRXZlbnQucGFnZVkgOiBldmVudC5wYWdlWSxcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgdGltZTogdGltZSxcbiAgICBzbmFwcGVkVGltZTogc25hcHBlZFRpbWVcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lbGluZTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIEdyb3VwID0gcmVxdWlyZSgnLi9Hcm91cCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBCYWNrZ3JvdW5kR3JvdXBcbiAqIEBwYXJhbSB7TnVtYmVyIHwgU3RyaW5nfSBncm91cElkXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtJdGVtU2V0fSBpdGVtU2V0XG4gKi9cbmZ1bmN0aW9uIEJhY2tncm91bmRHcm91cCAoZ3JvdXBJZCwgZGF0YSwgaXRlbVNldCkge1xuICBHcm91cC5jYWxsKHRoaXMsIGdyb3VwSWQsIGRhdGEsIGl0ZW1TZXQpO1xuXG4gIHRoaXMud2lkdGggPSAwO1xuICB0aGlzLmhlaWdodCA9IDA7XG4gIHRoaXMudG9wID0gMDtcbiAgdGhpcy5sZWZ0ID0gMDtcbn1cblxuQmFja2dyb3VuZEdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3JvdXAucHJvdG90eXBlKTtcblxuLyoqXG4gKiBSZXBhaW50IHRoaXMgZ3JvdXBcbiAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2VcbiAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3RhY2s9ZmFsc2VdICBGb3JjZSByZXN0YWNraW5nIG9mIGFsbCBpdGVtc1xuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBncm91cCBpcyByZXNpemVkXG4gKi9cbkJhY2tncm91bmRHcm91cC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24ocmFuZ2UsIG1hcmdpbiwgcmVzdGFjaykge1xuICB2YXIgcmVzaXplZCA9IGZhbHNlO1xuXG4gIHRoaXMudmlzaWJsZUl0ZW1zID0gdGhpcy5fdXBkYXRlVmlzaWJsZUl0ZW1zKHRoaXMub3JkZXJlZEl0ZW1zLCB0aGlzLnZpc2libGVJdGVtcywgcmFuZ2UpO1xuXG4gIC8vIGNhbGN1bGF0ZSBhY3R1YWwgc2l6ZVxuICB0aGlzLndpZHRoID0gdGhpcy5kb20uYmFja2dyb3VuZC5vZmZzZXRXaWR0aDtcblxuICAvLyBhcHBseSBuZXcgaGVpZ2h0IChqdXN0IGFsd2F5cyB6ZXJvIGZvciBCYWNrZ3JvdW5kR3JvdXBcbiAgdGhpcy5kb20uYmFja2dyb3VuZC5zdHlsZS5oZWlnaHQgID0gJzAnO1xuXG4gIC8vIHVwZGF0ZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBpdGVtcyBhZnRlciB0aGV5IGFyZSByZS1zdGFja2VkIGFuZCB0aGUgaGVpZ2h0IG9mIHRoZSBncm91cCBpcyBjYWxjdWxhdGVkXG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMudmlzaWJsZUl0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHRoaXMudmlzaWJsZUl0ZW1zW2ldO1xuICAgIGl0ZW0ucmVwb3NpdGlvblkobWFyZ2luKTtcbiAgfVxuXG4gIHJldHVybiByZXNpemVkO1xufTtcblxuLyoqXG4gKiBTaG93IHRoaXMgZ3JvdXA6IGF0dGFjaCB0byB0aGUgRE9NXG4gKi9cbkJhY2tncm91bmRHcm91cC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZG9tLmJhY2tncm91bmQucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuaXRlbVNldC5kb20uYmFja2dyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrZ3JvdW5kR3JvdXA7XG4iLCIvKipcbiAqIFByb3RvdHlwZSBmb3IgdmlzdWFsIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7e2RvbTogT2JqZWN0LCBkb21Qcm9wczogT2JqZWN0LCBlbWl0dGVyOiBFbWl0dGVyLCByYW5nZTogUmFuZ2V9fSBbYm9keV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqL1xuZnVuY3Rpb24gQ29tcG9uZW50IChib2R5LCBvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG51bGw7XG4gIHRoaXMucHJvcHMgPSBudWxsO1xufVxuXG4vKipcbiAqIFNldCBvcHRpb25zIGZvciB0aGUgY29tcG9uZW50LiBUaGUgbmV3IG9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgaW50byB0aGVcbiAqIGN1cnJlbnQgb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAvLyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIGNvbXBvbmVudFxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIGNvbXBvbmVudC4gQ2xlYW51cCBET00gYW5kIGV2ZW50IGxpc3RlbmVyc1xuICovXG5Db21wb25lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgLy8gc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBjb21wb25lbnRcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZCBzaW5jZSB0aGUgbGFzdCB0aW1lIF9pc1Jlc2l6ZWQoKSB3YXNcbiAqIGNhbGxlZC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5faXNSZXNpemVkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNpemVkID0gKHRoaXMucHJvcHMuX3ByZXZpb3VzV2lkdGggIT09IHRoaXMucHJvcHMud2lkdGggfHxcbiAgICAgIHRoaXMucHJvcHMuX3ByZXZpb3VzSGVpZ2h0ICE9PSB0aGlzLnByb3BzLmhlaWdodCk7XG5cbiAgdGhpcy5wcm9wcy5fcHJldmlvdXNXaWR0aCA9IHRoaXMucHJvcHMud2lkdGg7XG4gIHRoaXMucHJvcHMuX3ByZXZpb3VzSGVpZ2h0ID0gdGhpcy5wcm9wcy5oZWlnaHQ7XG5cbiAgcmV0dXJuIHJlc2l6ZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudDtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlL21vbWVudCcpO1xudmFyIGxvY2FsZXMgPSByZXF1aXJlKCcuLi9sb2NhbGVzJyk7XG5cbi8qKlxuICogQSBjdXJyZW50IHRpbWUgYmFyXG4gKiBAcGFyYW0ge3tyYW5nZTogUmFuZ2UsIGRvbTogT2JqZWN0LCBkb21Qcm9wczogT2JqZWN0fX0gYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgQXZhaWxhYmxlIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gW3Nob3dDdXJyZW50VGltZV1cbiAqIEBjb25zdHJ1Y3RvciBDdXJyZW50VGltZVxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIEN1cnJlbnRUaW1lIChib2R5LCBvcHRpb25zKSB7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgc2hvd0N1cnJlbnRUaW1lOiB0cnVlLFxuXG4gICAgbW9tZW50OiBtb21lbnQsXG4gICAgbG9jYWxlczogbG9jYWxlcyxcbiAgICBsb2NhbGU6ICdlbidcbiAgfTtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICB0aGlzLm9mZnNldCA9IDA7XG5cbiAgdGhpcy5fY3JlYXRlKCk7XG5cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xufVxuXG5DdXJyZW50VGltZS5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBIVE1MIERPTSBmb3IgdGhlIGN1cnJlbnQgdGltZSBiYXJcbiAqIEBwcml2YXRlXG4gKi9cbkN1cnJlbnRUaW1lLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgYmFyLmNsYXNzTmFtZSA9ICd2aXMtY3VycmVudC10aW1lJztcbiAgYmFyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgYmFyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICBiYXIuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gIHRoaXMuYmFyID0gYmFyO1xufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBDdXJyZW50VGltZSBiYXJcbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMub3B0aW9ucy5zaG93Q3VycmVudFRpbWUgPSBmYWxzZTtcbiAgdGhpcy5yZWRyYXcoKTsgLy8gd2lsbCByZW1vdmUgdGhlIGJhciBmcm9tIHRoZSBET00gYW5kIHN0b3AgcmVmcmVzaGluZ1xuXG4gIHRoaXMuYm9keSA9IG51bGw7XG59O1xuXG4vKipcbiAqIFNldCBvcHRpb25zIGZvciB0aGUgY29tcG9uZW50LiBPcHRpb25zIHdpbGwgYmUgbWVyZ2VkIGluIGN1cnJlbnQgb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICBBdmFpbGFibGUgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB7Ym9vbGVhbn0gW3Nob3dDdXJyZW50VGltZV1cbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgLy8gY29weSBhbGwgb3B0aW9ucyB0aGF0IHdlIGtub3dcbiAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ3Nob3dDdXJyZW50VGltZScsICdtb21lbnQnLCAnbG9jYWxlJywgJ2xvY2FsZXMnXSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBjb21wb25lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLnNob3dDdXJyZW50VGltZSkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRWZXJ0aWNhbDtcbiAgICBpZiAodGhpcy5iYXIucGFyZW50Tm9kZSAhPSBwYXJlbnQpIHtcbiAgICAgIC8vIGF0dGFjaCB0byB0aGUgZG9tXG4gICAgICBpZiAodGhpcy5iYXIucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmJhci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYmFyKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmJhcik7XG5cbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gdGhpcy5vcHRpb25zLm1vbWVudChuZXcgRGF0ZSgpLnZhbHVlT2YoKSArIHRoaXMub2Zmc2V0KTtcbiAgICB2YXIgeCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKG5vdyk7XG5cbiAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgaWYgKCFsb2NhbGUpIHtcbiAgICAgIGlmICghdGhpcy53YXJuZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IG9wdGlvbnMubG9jYWxlc1tcXCcnICsgdGhpcy5vcHRpb25zLmxvY2FsZSArICdcXCddIG5vdCBmb3VuZC4gU2VlIGh0dHA6Ly92aXNqcy5vcmcvZG9jcy90aW1lbGluZS5odG1sI0xvY2FsaXphdGlvbicpO1xuICAgICAgICB0aGlzLndhcm5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1snZW4nXTsgLy8gZmFsbCBiYWNrIG9uIGVuZ2xpc2ggd2hlbiBub3QgYXZhaWxhYmxlXG4gICAgfVxuICAgIHZhciB0aXRsZSA9IGxvY2FsZS5jdXJyZW50ICsgJyAnICsgbG9jYWxlLnRpbWUgKyAnOiAnICsgbm93LmZvcm1hdCgnZGRkZCwgTU1NTSBEbyBZWVlZLCBIOm1tOnNzJyk7XG4gICAgdGl0bGUgPSB0aXRsZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRpdGxlLnN1YnN0cmluZygxKTtcblxuICAgIHRoaXMuYmFyLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICB0aGlzLmJhci50aXRsZSA9IHRpdGxlO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIHJlbW92ZSB0aGUgbGluZSBmcm9tIHRoZSBET01cbiAgICBpZiAodGhpcy5iYXIucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5iYXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmJhcik7XG4gICAgfVxuICAgIHRoaXMuc3RvcCgpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBTdGFydCBhdXRvIHJlZnJlc2hpbmcgdGhlIGN1cnJlbnQgdGltZSBiYXJcbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgICBtZS5zdG9wKCk7XG5cbiAgICAvLyBkZXRlcm1pbmUgaW50ZXJ2YWwgdG8gcmVmcmVzaFxuICAgIHZhciBzY2FsZSA9IG1lLmJvZHkucmFuZ2UuY29udmVyc2lvbihtZS5ib2R5LmRvbVByb3BzLmNlbnRlci53aWR0aCkuc2NhbGU7XG4gICAgdmFyIGludGVydmFsID0gMSAvIHNjYWxlIC8gMTA7XG4gICAgaWYgKGludGVydmFsIDwgMzApICAgaW50ZXJ2YWwgPSAzMDtcbiAgICBpZiAoaW50ZXJ2YWwgPiAxMDAwKSBpbnRlcnZhbCA9IDEwMDA7XG5cbiAgICBtZS5yZWRyYXcoKTtcblxuICAgIC8vIHN0YXJ0IGEgcmVuZGVyVGltZXIgdG8gYWRqdXN0IGZvciB0aGUgbmV3IHRpbWVcbiAgICBtZS5jdXJyZW50VGltZVRpbWVyID0gc2V0VGltZW91dCh1cGRhdGUsIGludGVydmFsKTtcbiAgfVxuXG4gIHVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBTdG9wIGF1dG8gcmVmcmVzaGluZyB0aGUgY3VycmVudCB0aW1lIGJhclxuICovXG5DdXJyZW50VGltZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jdXJyZW50VGltZVRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5jdXJyZW50VGltZVRpbWVyKTtcbiAgICBkZWxldGUgdGhpcy5jdXJyZW50VGltZVRpbWVyO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBhIGN1cnJlbnQgdGltZS4gVGhpcyBjYW4gYmUgdXNlZCBmb3IgZXhhbXBsZSB0byBlbnN1cmUgdGhhdCBhIGNsaWVudCdzXG4gKiB0aW1lIGlzIHN5bmNocm9uaXplZCB3aXRoIGEgc2hhcmVkIHNlcnZlciB0aW1lLlxuICogQHBhcmFtIHtEYXRlIHwgU3RyaW5nIHwgTnVtYmVyfSB0aW1lICAgICBBIERhdGUsIHVuaXggdGltZXN0YW1wLCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJU08gZGF0ZSBzdHJpbmcuXG4gKi9cbkN1cnJlbnRUaW1lLnByb3RvdHlwZS5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgdmFyIHQgPSB1dGlsLmNvbnZlcnQodGltZSwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gIHZhciBub3cgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgdGhpcy5vZmZzZXQgPSB0IC0gbm93O1xuICB0aGlzLnJlZHJhdygpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdGltZS5cbiAqIEByZXR1cm4ge0RhdGV9IFJldHVybnMgdGhlIGN1cnJlbnQgdGltZS5cbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLmdldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgRGF0ZShuZXcgRGF0ZSgpLnZhbHVlT2YoKSArIHRoaXMub2Zmc2V0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3VycmVudFRpbWU7XG4iLCJ2YXIgSGFtbWVyID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlL2hhbW1lcicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGUvbW9tZW50Jyk7XG52YXIgbG9jYWxlcyA9IHJlcXVpcmUoJy4uL2xvY2FsZXMnKTtcblxuLyoqXG4gKiBBIGN1c3RvbSB0aW1lIGJhclxuICogQHBhcmFtIHt7cmFuZ2U6IFJhbmdlLCBkb206IE9iamVjdH19IGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIEF2YWlsYWJsZSBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlciB8IHN0cmluZ30gaWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGxvY2FsZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGxvY2FsZVxuICogQGNvbnN0cnVjdG9yIEN1c3RvbVRpbWVcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbmZ1bmN0aW9uIEN1c3RvbVRpbWUgKGJvZHksIG9wdGlvbnMpIHtcbiAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb21lbnQ6IG1vbWVudCxcbiAgICBsb2NhbGVzOiBsb2NhbGVzLFxuICAgIGxvY2FsZTogJ2VuJyxcbiAgICBpZDogdW5kZWZpbmVkLFxuICAgIHRpdGxlOiB1bmRlZmluZWRcbiAgfTtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMudGltZSkge1xuICAgIHRoaXMuY3VzdG9tVGltZSA9IG9wdGlvbnMudGltZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmN1c3RvbVRpbWUgPSBuZXcgRGF0ZSgpO1xuICB9XG5cbiAgdGhpcy5ldmVudFBhcmFtcyA9IHt9OyAvLyBzdG9yZXMgc3RhdGUgcGFyYW1ldGVycyB3aGlsZSBkcmFnZ2luZyB0aGUgYmFyXG5cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIGNyZWF0ZSB0aGUgRE9NXG4gIHRoaXMuX2NyZWF0ZSgpO1xufVxuXG5DdXN0b21UaW1lLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBTZXQgb3B0aW9ucyBmb3IgdGhlIGNvbXBvbmVudC4gT3B0aW9ucyB3aWxsIGJlIG1lcmdlZCBpbiBjdXJyZW50IG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgQXZhaWxhYmxlIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyIHwgc3RyaW5nfSBpZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbG9jYWxlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbG9jYWxlXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgLy8gY29weSBhbGwgb3B0aW9ucyB0aGF0IHdlIGtub3dcbiAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ21vbWVudCcsICdsb2NhbGUnLCAnbG9jYWxlcycsICdpZCddLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgRE9NIGZvciB0aGUgY3VzdG9tIHRpbWVcbiAqIEBwcml2YXRlXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBiYXJbJ2N1c3RvbS10aW1lJ10gPSB0aGlzO1xuICBiYXIuY2xhc3NOYW1lID0gJ3Zpcy1jdXN0b20tdGltZSAnICsgKHRoaXMub3B0aW9ucy5pZCB8fCAnJyk7XG4gIGJhci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGJhci5zdHlsZS50b3AgPSAnMHB4JztcbiAgYmFyLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgdGhpcy5iYXIgPSBiYXI7XG5cbiAgdmFyIGRyYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZHJhZy5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIGRyYWcuc3R5bGUudG9wID0gJzBweCc7XG4gIGRyYWcuc3R5bGUubGVmdCA9ICctMTBweCc7XG4gIGRyYWcuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICBkcmFnLnN0eWxlLndpZHRoID0gJzIwcHgnO1xuICBiYXIuYXBwZW5kQ2hpbGQoZHJhZyk7XG5cbiAgLy8gYXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xuICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIoZHJhZyk7XG4gIHRoaXMuaGFtbWVyLm9uKCdwYW5zdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0LmJpbmQodGhpcykpO1xuICB0aGlzLmhhbW1lci5vbigncGFubW92ZScsICB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKSk7XG4gIHRoaXMuaGFtbWVyLm9uKCdwYW5lbmQnLCAgIHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5oYW1tZXIuZ2V0KCdwYW4nKS5zZXQoe3RocmVzaG9sZDo1LCBkaXJlY3Rpb246MzB9KTsgLy8gMzAgaXMgQUxMX0RJUkVDVElPTlMgaW4gaGFtbWVyLlxufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBDdXN0b21UaW1lIGJhclxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhpZGUoKTtcblxuICB0aGlzLmhhbW1lci5kZXN0cm95KCk7XG4gIHRoaXMuaGFtbWVyID0gbnVsbDtcblxuICB0aGlzLmJvZHkgPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBjb21wb25lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kVmVydGljYWw7XG4gIGlmICh0aGlzLmJhci5wYXJlbnROb2RlICE9IHBhcmVudCkge1xuICAgIC8vIGF0dGFjaCB0byB0aGUgZG9tXG4gICAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuYmFyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iYXIpO1xuICAgIH1cbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5iYXIpO1xuICB9XG5cbiAgdmFyIHggPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbih0aGlzLmN1c3RvbVRpbWUpO1xuXG4gIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgaWYgKCFsb2NhbGUpIHtcbiAgICBpZiAoIXRoaXMud2FybmVkKSB7XG4gICAgICBjb25zb2xlLmxvZygnV0FSTklORzogb3B0aW9ucy5sb2NhbGVzW1xcJycgKyB0aGlzLm9wdGlvbnMubG9jYWxlICsgJ1xcJ10gbm90IGZvdW5kLiBTZWUgaHR0cDovL3Zpc2pzLm9yZy9kb2NzL3RpbWVsaW5lLmh0bWwjTG9jYWxpemF0aW9uJyk7XG4gICAgICB0aGlzLndhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddOyAvLyBmYWxsIGJhY2sgb24gZW5nbGlzaCB3aGVuIG5vdCBhdmFpbGFibGVcbiAgfVxuXG4gIHZhciB0aXRsZSA9IHRoaXMub3B0aW9ucy50aXRsZTtcbiAgLy8gVG8gaGlkZSB0aGUgdGl0bGUgY29tcGxldGVseSB1c2UgZW1wdHkgc3RyaW5nICcnLlxuICBpZiAodGl0bGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRpdGxlID0gbG9jYWxlLnRpbWUgKyAnOiAnICsgdGhpcy5vcHRpb25zLm1vbWVudCh0aGlzLmN1c3RvbVRpbWUpLmZvcm1hdCgnZGRkZCwgTU1NTSBEbyBZWVlZLCBIOm1tOnNzJyk7XG4gICAgdGl0bGUgPSB0aXRsZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRpdGxlLnN1YnN0cmluZygxKTtcbiAgfVxuXG4gIHRoaXMuYmFyLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgdGhpcy5iYXIudGl0bGUgPSB0aXRsZTtcblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgQ3VzdG9tVGltZSBmcm9tIHRoZSBET01cbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gcmVtb3ZlIHRoZSBsaW5lIGZyb20gdGhlIERPTVxuICBpZiAodGhpcy5iYXIucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuYmFyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iYXIpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBjdXN0b20gdGltZS5cbiAqIEBwYXJhbSB7RGF0ZSB8IG51bWJlciB8IHN0cmluZ30gdGltZVxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5zZXRDdXN0b21UaW1lID0gZnVuY3Rpb24odGltZSkge1xuICB0aGlzLmN1c3RvbVRpbWUgPSB1dGlsLmNvbnZlcnQodGltZSwgJ0RhdGUnKTtcbiAgdGhpcy5yZWRyYXcoKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGN1cnJlbnQgY3VzdG9tIHRpbWUuXG4gKiBAcmV0dXJuIHtEYXRlfSBjdXN0b21UaW1lXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLmdldEN1c3RvbVRpbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuY3VzdG9tVGltZS52YWx1ZU9mKCkpO1xufTtcblxuLyoqXG4gICogU2V0IGN1c3RvbSB0aXRsZS5cbiAgKiBAcGFyYW0ge0RhdGUgfCBudW1iZXIgfCBzdHJpbmd9IHRpdGxlXG4gICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5zZXRDdXN0b21UaXRsZSA9IGZ1bmN0aW9uKHRpdGxlKSB7XG4gIHRoaXMub3B0aW9ucy50aXRsZSA9IHRpdGxlO1xufTtcblxuLyoqXG4gKiBTdGFydCBtb3ZpbmcgaG9yaXpvbnRhbGx5XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdGhpcy5ldmVudFBhcmFtcy5kcmFnZ2luZyA9IHRydWU7XG4gIHRoaXMuZXZlbnRQYXJhbXMuY3VzdG9tVGltZSA9IHRoaXMuY3VzdG9tVGltZTtcblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBtb3Zpbmcgb3BlcmF0aW5nLlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLmV2ZW50UGFyYW1zLmRyYWdnaW5nKSByZXR1cm47XG5cbiAgdmFyIHggPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbih0aGlzLmV2ZW50UGFyYW1zLmN1c3RvbVRpbWUpICsgZXZlbnQuZGVsdGFYO1xuICB2YXIgdGltZSA9IHRoaXMuYm9keS51dGlsLnRvVGltZSh4KTtcblxuICB0aGlzLnNldEN1c3RvbVRpbWUodGltZSk7XG5cbiAgLy8gZmlyZSBhIHRpbWVjaGFuZ2UgZXZlbnRcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgndGltZWNoYW5nZScsIHtcbiAgICBpZDogdGhpcy5vcHRpb25zLmlkLFxuICAgIHRpbWU6IG5ldyBEYXRlKHRoaXMuY3VzdG9tVGltZS52YWx1ZU9mKCkpXG4gIH0pO1xuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufTtcblxuLyoqXG4gKiBTdG9wIG1vdmluZyBvcGVyYXRpbmcuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIXRoaXMuZXZlbnRQYXJhbXMuZHJhZ2dpbmcpIHJldHVybjtcblxuICAvLyBmaXJlIGEgdGltZWNoYW5nZWQgZXZlbnRcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgndGltZWNoYW5nZWQnLCB7XG4gICAgaWQ6IHRoaXMub3B0aW9ucy5pZCxcbiAgICB0aW1lOiBuZXcgRGF0ZSh0aGlzLmN1c3RvbVRpbWUudmFsdWVPZigpKVxuICB9KTtcblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG5cbi8qKlxuICogRmluZCBhIGN1c3RvbSB0aW1lIGZyb20gYW4gZXZlbnQgdGFyZ2V0OlxuICogc2VhcmNoZXMgZm9yIHRoZSBhdHRyaWJ1dGUgJ2N1c3RvbS10aW1lJyBpbiB0aGUgZXZlbnQgdGFyZ2V0J3MgZWxlbWVudCB0cmVlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybiB7Q3VzdG9tVGltZSB8IG51bGx9IGN1c3RvbVRpbWVcbiAqL1xuQ3VzdG9tVGltZS5jdXN0b21UaW1lRnJvbVRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIHdoaWxlICh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KCdjdXN0b20tdGltZScpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0WydjdXN0b20tdGltZSddO1xuICAgIH1cbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDdXN0b21UaW1lO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgc3RhY2sgPSByZXF1aXJlKCcuLi9TdGFjaycpO1xudmFyIFJhbmdlSXRlbSA9IHJlcXVpcmUoJy4vaXRlbS9SYW5nZUl0ZW0nKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgR3JvdXBcbiAqIEBwYXJhbSB7TnVtYmVyIHwgU3RyaW5nfSBncm91cElkXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtJdGVtU2V0fSBpdGVtU2V0XG4gKi9cbmZ1bmN0aW9uIEdyb3VwIChncm91cElkLCBkYXRhLCBpdGVtU2V0KSB7XG4gIHRoaXMuZ3JvdXBJZCA9IGdyb3VwSWQ7XG4gIHRoaXMuc3ViZ3JvdXBzID0ge307XG4gIHRoaXMuc3ViZ3JvdXBJbmRleCA9IDA7XG4gIHRoaXMuc3ViZ3JvdXBPcmRlcmVyID0gZGF0YSAmJiBkYXRhLnN1Ymdyb3VwT3JkZXI7XG4gIHRoaXMuaXRlbVNldCA9IGl0ZW1TZXQ7XG5cbiAgdGhpcy5kb20gPSB7fTtcbiAgdGhpcy5wcm9wcyA9IHtcbiAgICBsYWJlbDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9XG4gIH07XG4gIHRoaXMuY2xhc3NOYW1lID0gbnVsbDtcblxuICB0aGlzLml0ZW1zID0ge307ICAgICAgICAvLyBpdGVtcyBmaWx0ZXJlZCBieSBncm91cElkIG9mIHRoaXMgZ3JvdXBcbiAgdGhpcy52aXNpYmxlSXRlbXMgPSBbXTsgLy8gaXRlbXMgY3VycmVudGx5IHZpc2libGUgaW4gd2luZG93XG4gIHRoaXMub3JkZXJlZEl0ZW1zID0ge1xuICAgIGJ5U3RhcnQ6IFtdLFxuICAgIGJ5RW5kOiBbXVxuICB9O1xuICB0aGlzLmNoZWNrUmFuZ2VkSXRlbXMgPSBmYWxzZTsgLy8gbmVlZGVkIHRvIHJlZnJlc2ggdGhlIHJhbmdlZCBpdGVtcyBpZiB0aGUgd2luZG93IGlzIHByb2dyYW1hdGljYWxseSBjaGFuZ2VkIHdpdGggTk8gb3ZlcmxhcC5cbiAgdmFyIG1lID0gdGhpcztcbiAgdGhpcy5pdGVtU2V0LmJvZHkuZW1pdHRlci5vbihcImNoZWNrUmFuZ2VkSXRlbXNcIiwgZnVuY3Rpb24gKCkge1xuICAgIG1lLmNoZWNrUmFuZ2VkSXRlbXMgPSB0cnVlO1xuICB9KVxuXG4gIHRoaXMuX2NyZWF0ZSgpO1xuXG4gIHRoaXMuc2V0RGF0YShkYXRhKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgRE9NIGVsZW1lbnRzIGZvciB0aGUgZ3JvdXBcbiAqIEBwcml2YXRlXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBpZiAodGhpcy5pdGVtU2V0Lm9wdGlvbnMuZ3JvdXBFZGl0YWJsZS5vcmRlcikge1xuXHQgIGxhYmVsLmNsYXNzTmFtZSA9ICd2aXMtbGFiZWwgZHJhZ2dhYmxlJztcbiAgfSBlbHNlIHtcblx0ICBsYWJlbC5jbGFzc05hbWUgPSAndmlzLWxhYmVsJztcbiAgfVxuICB0aGlzLmRvbS5sYWJlbCA9IGxhYmVsO1xuXG4gIHZhciBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBpbm5lci5jbGFzc05hbWUgPSAndmlzLWlubmVyJztcbiAgbGFiZWwuYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICB0aGlzLmRvbS5pbm5lciA9IGlubmVyO1xuXG4gIHZhciBmb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGZvcmVncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy1ncm91cCc7XG4gIGZvcmVncm91bmRbJ3RpbWVsaW5lLWdyb3VwJ10gPSB0aGlzO1xuICB0aGlzLmRvbS5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZDtcblxuICB0aGlzLmRvbS5iYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmJhY2tncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy1ncm91cCc7XG5cbiAgdGhpcy5kb20uYXhpcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5heGlzLmNsYXNzTmFtZSA9ICd2aXMtZ3JvdXAnO1xuXG4gIC8vIGNyZWF0ZSBhIGhpZGRlbiBtYXJrZXIgdG8gZGV0ZWN0IHdoZW4gdGhlIFRpbWVsaW5lcyBjb250YWluZXIgaXMgYXR0YWNoZWRcbiAgLy8gdG8gdGhlIERPTSwgb3IgdGhlIHN0eWxlIG9mIGEgcGFyZW50IG9mIHRoZSBUaW1lbGluZSBpcyBjaGFuZ2VkIGZyb21cbiAgLy8gZGlzcGxheTpub25lIGlzIGNoYW5nZWQgdG8gdmlzaWJsZS5cbiAgdGhpcy5kb20ubWFya2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLm1hcmtlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIHRoaXMuZG9tLm1hcmtlci5pbm5lckhUTUwgPSAnPyc7XG4gIHRoaXMuZG9tLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5kb20ubWFya2VyKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBncm91cCBkYXRhIGZvciB0aGlzIGdyb3VwXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgIEdyb3VwIGRhdGEsIGNhbiBjb250YWluIHByb3BlcnRpZXMgY29udGVudCBhbmQgY2xhc3NOYW1lXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAvLyB1cGRhdGUgY29udGVudHNcbiAgdmFyIGNvbnRlbnQ7XG4gIGlmICh0aGlzLml0ZW1TZXQub3B0aW9ucyAmJiB0aGlzLml0ZW1TZXQub3B0aW9ucy5ncm91cFRlbXBsYXRlKSB7XG4gICAgY29udGVudCA9IHRoaXMuaXRlbVNldC5vcHRpb25zLmdyb3VwVGVtcGxhdGUoZGF0YSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgY29udGVudCA9IGRhdGEgJiYgZGF0YS5jb250ZW50O1xuICB9XG5cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgdGhpcy5kb20uaW5uZXIuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgd2hpbGUgKHRoaXMuZG9tLmlubmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHRoaXMuZG9tLmlubmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmlubmVyLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB0aGlzLmRvbS5pbm5lci5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgfVxuICBlbHNlIGlmIChjb250ZW50ICE9PSB1bmRlZmluZWQgJiYgY29udGVudCAhPT0gbnVsbCkge1xuICAgIHRoaXMuZG9tLmlubmVyLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5kb20uaW5uZXIuaW5uZXJIVE1MID0gdGhpcy5ncm91cElkIHx8ICcnOyAvLyBncm91cElkIGNhbiBiZSBudWxsXG4gIH1cblxuICAvLyB1cGRhdGUgdGl0bGVcbiAgdGhpcy5kb20ubGFiZWwudGl0bGUgPSBkYXRhICYmIGRhdGEudGl0bGUgfHwgJyc7XG5cbiAgaWYgKCF0aGlzLmRvbS5pbm5lci5maXJzdENoaWxkKSB7XG4gICAgdXRpbC5hZGRDbGFzc05hbWUodGhpcy5kb20uaW5uZXIsICd2aXMtaGlkZGVuJyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdXRpbC5yZW1vdmVDbGFzc05hbWUodGhpcy5kb20uaW5uZXIsICd2aXMtaGlkZGVuJyk7XG4gIH1cblxuICAvLyB1cGRhdGUgY2xhc3NOYW1lXG4gIHZhciBjbGFzc05hbWUgPSBkYXRhICYmIGRhdGEuY2xhc3NOYW1lIHx8IG51bGw7XG4gIGlmIChjbGFzc05hbWUgIT0gdGhpcy5jbGFzc05hbWUpIHtcbiAgICBpZiAodGhpcy5jbGFzc05hbWUpIHtcbiAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmxhYmVsLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5mb3JlZ3JvdW5kLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5iYWNrZ3JvdW5kLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5heGlzLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmxhYmVsLCBjbGFzc05hbWUpO1xuICAgIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmZvcmVncm91bmQsIGNsYXNzTmFtZSk7XG4gICAgdXRpbC5hZGRDbGFzc05hbWUodGhpcy5kb20uYmFja2dyb3VuZCwgY2xhc3NOYW1lKTtcbiAgICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5heGlzLCBjbGFzc05hbWUpO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICB9XG5cbiAgLy8gdXBkYXRlIHN0eWxlXG4gIGlmICh0aGlzLnN0eWxlKSB7XG4gICAgdXRpbC5yZW1vdmVDc3NUZXh0KHRoaXMuZG9tLmxhYmVsLCB0aGlzLnN0eWxlKTtcbiAgICB0aGlzLnN0eWxlID0gbnVsbDtcbiAgfVxuICBpZiAoZGF0YSAmJiBkYXRhLnN0eWxlKSB7XG4gICAgdXRpbC5hZGRDc3NUZXh0KHRoaXMuZG9tLmxhYmVsLCBkYXRhLnN0eWxlKTtcbiAgICB0aGlzLnN0eWxlID0gZGF0YS5zdHlsZTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBncm91cCBsYWJlbFxuICogQHJldHVybiB7bnVtYmVyfSB3aWR0aFxuICovXG5Hcm91cC5wcm90b3R5cGUuZ2V0TGFiZWxXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wcm9wcy5sYWJlbC53aWR0aDtcbn07XG5cblxuLyoqXG4gKiBSZXBhaW50IHRoaXMgZ3JvdXBcbiAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2VcbiAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3RhY2s9ZmFsc2VdICBGb3JjZSByZXN0YWNraW5nIG9mIGFsbCBpdGVtc1xuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBncm91cCBpcyByZXNpemVkXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbihyYW5nZSwgbWFyZ2luLCByZXN0YWNrKSB7XG4gIHZhciByZXNpemVkID0gZmFsc2U7XG5cbiAgLy8gZm9yY2UgcmVjYWxjdWxhdGlvbiBvZiB0aGUgaGVpZ2h0IG9mIHRoZSBpdGVtcyB3aGVuIHRoZSBtYXJrZXIgaGVpZ2h0IGNoYW5nZWRcbiAgLy8gKGR1ZSB0byB0aGUgVGltZWxpbmUgYmVpbmcgYXR0YWNoZWQgdG8gdGhlIERPTSBvciBjaGFuZ2VkIGZyb20gZGlzcGxheTpub25lIHRvIHZpc2libGUpXG4gIHZhciBtYXJrZXJIZWlnaHQgPSB0aGlzLmRvbS5tYXJrZXIuY2xpZW50SGVpZ2h0O1xuICBpZiAobWFya2VySGVpZ2h0ICE9IHRoaXMubGFzdE1hcmtlckhlaWdodCkge1xuICAgIHRoaXMubGFzdE1hcmtlckhlaWdodCA9IG1hcmtlckhlaWdodDtcblxuICAgIHV0aWwuZm9yRWFjaCh0aGlzLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaXRlbS5kaXJ0eSA9IHRydWU7XG4gICAgICBpZiAoaXRlbS5kaXNwbGF5ZWQpIGl0ZW0ucmVkcmF3KCk7XG4gICAgfSk7XG5cbiAgICByZXN0YWNrID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIHJlcG9zaXRpb24gdmlzaWJsZSBpdGVtcyB2ZXJ0aWNhbGx5XG4gIGlmICh0eXBlb2YgdGhpcy5pdGVtU2V0Lm9wdGlvbnMub3JkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBhIGN1c3RvbSBvcmRlciBmdW5jdGlvblxuXG4gICAgaWYgKHJlc3RhY2spIHtcbiAgICAgIC8vIGJydXRlIGZvcmNlIHJlc3RhY2sgb2YgYWxsIGl0ZW1zXG5cbiAgICAgIC8vIHNob3cgYWxsIGl0ZW1zXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIGxpbWl0U2l6ZSA9IGZhbHNlO1xuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbS5kaXNwbGF5ZWQpIHtcbiAgICAgICAgICBpdGVtLnJlZHJhdygpO1xuICAgICAgICAgIG1lLnZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0ucmVwb3NpdGlvblgobGltaXRTaXplKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBvcmRlciBhbGwgaXRlbXMgYW5kIGZvcmNlIGEgcmVzdGFja2luZ1xuICAgICAgdmFyIGN1c3RvbU9yZGVyZWRJdGVtcyA9IHRoaXMub3JkZXJlZEl0ZW1zLmJ5U3RhcnQuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBtZS5pdGVtU2V0Lm9wdGlvbnMub3JkZXIoYS5kYXRhLCBiLmRhdGEpO1xuICAgICAgfSk7XG4gICAgICBzdGFjay5zdGFjayhjdXN0b21PcmRlcmVkSXRlbXMsIG1hcmdpbiwgdHJ1ZSAvKiByZXN0YWNrPXRydWUgKi8pO1xuICAgIH1cblxuICAgIHRoaXMudmlzaWJsZUl0ZW1zID0gdGhpcy5fdXBkYXRlVmlzaWJsZUl0ZW1zKHRoaXMub3JkZXJlZEl0ZW1zLCB0aGlzLnZpc2libGVJdGVtcywgcmFuZ2UpO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIG5vIGN1c3RvbSBvcmRlciBmdW5jdGlvbiwgbGF6eSBzdGFja2luZ1xuICAgIHRoaXMudmlzaWJsZUl0ZW1zID0gdGhpcy5fdXBkYXRlVmlzaWJsZUl0ZW1zKHRoaXMub3JkZXJlZEl0ZW1zLCB0aGlzLnZpc2libGVJdGVtcywgcmFuZ2UpO1xuXG4gICAgaWYgKHRoaXMuaXRlbVNldC5vcHRpb25zLnN0YWNrKSB7IC8vIFRPRE86IHVnbHkgd2F5IHRvIGFjY2VzcyBvcHRpb25zLi4uXG4gICAgICBzdGFjay5zdGFjayh0aGlzLnZpc2libGVJdGVtcywgbWFyZ2luLCByZXN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIG5vIHN0YWNraW5nXG4gICAgICBzdGFjay5ub3N0YWNrKHRoaXMudmlzaWJsZUl0ZW1zLCBtYXJnaW4sIHRoaXMuc3ViZ3JvdXBzKTtcbiAgICB9XG4gIH1cblxuICAvLyByZWNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBncm91cFxuICB2YXIgaGVpZ2h0ID0gdGhpcy5fY2FsY3VsYXRlSGVpZ2h0KG1hcmdpbik7XG5cbiAgLy8gY2FsY3VsYXRlIGFjdHVhbCBzaXplIGFuZCBwb3NpdGlvblxuICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMuZG9tLmZvcmVncm91bmQ7XG4gIHRoaXMudG9wID0gZm9yZWdyb3VuZC5vZmZzZXRUb3A7XG4gIHRoaXMubGVmdCA9IGZvcmVncm91bmQub2Zmc2V0TGVmdDtcbiAgdGhpcy53aWR0aCA9IGZvcmVncm91bmQub2Zmc2V0V2lkdGg7XG4gIHJlc2l6ZWQgPSB1dGlsLnVwZGF0ZVByb3BlcnR5KHRoaXMsICdoZWlnaHQnLCBoZWlnaHQpIHx8IHJlc2l6ZWQ7XG5cbiAgLy8gcmVjYWxjdWxhdGUgc2l6ZSBvZiBsYWJlbFxuICByZXNpemVkID0gdXRpbC51cGRhdGVQcm9wZXJ0eSh0aGlzLnByb3BzLmxhYmVsLCAnd2lkdGgnLCB0aGlzLmRvbS5pbm5lci5jbGllbnRXaWR0aCkgfHwgcmVzaXplZDtcbiAgcmVzaXplZCA9IHV0aWwudXBkYXRlUHJvcGVydHkodGhpcy5wcm9wcy5sYWJlbCwgJ2hlaWdodCcsIHRoaXMuZG9tLmlubmVyLmNsaWVudEhlaWdodCkgfHwgcmVzaXplZDtcblxuICAvLyBhcHBseSBuZXcgaGVpZ2h0XG4gIHRoaXMuZG9tLmJhY2tncm91bmQuc3R5bGUuaGVpZ2h0ICA9IGhlaWdodCArICdweCc7XG4gIHRoaXMuZG9tLmZvcmVncm91bmQuc3R5bGUuaGVpZ2h0ICA9IGhlaWdodCArICdweCc7XG4gIHRoaXMuZG9tLmxhYmVsLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgLy8gdXBkYXRlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIGl0ZW1zIGFmdGVyIHRoZXkgYXJlIHJlLXN0YWNrZWQgYW5kIHRoZSBoZWlnaHQgb2YgdGhlIGdyb3VwIGlzIGNhbGN1bGF0ZWRcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy52aXNpYmxlSXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIHZhciBpdGVtID0gdGhpcy52aXNpYmxlSXRlbXNbaV07XG4gICAgaXRlbS5yZXBvc2l0aW9uWShtYXJnaW4pO1xuICB9XG5cbiAgcmV0dXJuIHJlc2l6ZWQ7XG59O1xuXG4vKipcbiAqIHJlY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2YgdGhlIGdyb3VwXG4gKiBAcGFyYW0ge3tpdGVtOiB7aG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyfSwgYXhpczogbnVtYmVyfX0gbWFyZ2luXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBoZWlnaHRcbiAqIEBwcml2YXRlXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5fY2FsY3VsYXRlSGVpZ2h0ID0gZnVuY3Rpb24gKG1hcmdpbikge1xuICAvLyByZWNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBncm91cFxuICB2YXIgaGVpZ2h0O1xuICB2YXIgdmlzaWJsZUl0ZW1zID0gdGhpcy52aXNpYmxlSXRlbXM7XG4gIC8vdmFyIHZpc2libGVTdWJncm91cHMgPSBbXTtcbiAgLy90aGlzLnZpc2libGVTdWJncm91cHMgPSAwO1xuICB0aGlzLnJlc2V0U3ViZ3JvdXBzKCk7XG4gIHZhciBtZSA9IHRoaXM7XG4gIGlmICh2aXNpYmxlSXRlbXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBtaW4gPSB2aXNpYmxlSXRlbXNbMF0udG9wO1xuICAgIHZhciBtYXggPSB2aXNpYmxlSXRlbXNbMF0udG9wICsgdmlzaWJsZUl0ZW1zWzBdLmhlaWdodDtcbiAgICB1dGlsLmZvckVhY2godmlzaWJsZUl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgbWluID0gTWF0aC5taW4obWluLCBpdGVtLnRvcCk7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIChpdGVtLnRvcCArIGl0ZW0uaGVpZ2h0KSk7XG4gICAgICBpZiAoaXRlbS5kYXRhLnN1Ymdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWUuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0uaGVpZ2h0ID0gTWF0aC5tYXgobWUuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0uaGVpZ2h0LGl0ZW0uaGVpZ2h0KTtcbiAgICAgICAgbWUuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0udmlzaWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG1pbiA+IG1hcmdpbi5heGlzKSB7XG4gICAgICAvLyB0aGVyZSBpcyBhbiBlbXB0eSBnYXAgYmV0d2VlbiB0aGUgbG93ZXN0IGl0ZW0gYW5kIHRoZSBheGlzXG4gICAgICB2YXIgb2Zmc2V0ID0gbWluIC0gbWFyZ2luLmF4aXM7XG4gICAgICBtYXggLT0gb2Zmc2V0O1xuICAgICAgdXRpbC5mb3JFYWNoKHZpc2libGVJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaXRlbS50b3AgLT0gb2Zmc2V0O1xuICAgICAgfSk7XG4gICAgfVxuICAgIGhlaWdodCA9IG1heCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsIC8gMjtcbiAgfVxuICBlbHNlIHtcbiAgICBoZWlnaHQgPSAwO1xuICB9XG4gIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgdGhpcy5wcm9wcy5sYWJlbC5oZWlnaHQpO1xuXG4gIHJldHVybiBoZWlnaHQ7XG59O1xuXG4vKipcbiAqIFNob3cgdGhpcyBncm91cDogYXR0YWNoIHRvIHRoZSBET01cbiAqL1xuR3JvdXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmRvbS5sYWJlbC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5pdGVtU2V0LmRvbS5sYWJlbFNldC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5sYWJlbCk7XG4gIH1cblxuICBpZiAoIXRoaXMuZG9tLmZvcmVncm91bmQucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuaXRlbVNldC5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5mb3JlZ3JvdW5kKTtcbiAgfVxuXG4gIGlmICghdGhpcy5kb20uYmFja2dyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5pdGVtU2V0LmRvbS5iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuZG9tLmJhY2tncm91bmQpO1xuICB9XG5cbiAgaWYgKCF0aGlzLmRvbS5heGlzLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLml0ZW1TZXQuZG9tLmF4aXMuYXBwZW5kQ2hpbGQodGhpcy5kb20uYXhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogSGlkZSB0aGlzIGdyb3VwOiByZW1vdmUgZnJvbSB0aGUgRE9NXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsYWJlbCA9IHRoaXMuZG9tLmxhYmVsO1xuICBpZiAobGFiZWwucGFyZW50Tm9kZSkge1xuICAgIGxhYmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGFiZWwpO1xuICB9XG5cbiAgdmFyIGZvcmVncm91bmQgPSB0aGlzLmRvbS5mb3JlZ3JvdW5kO1xuICBpZiAoZm9yZWdyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgZm9yZWdyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZvcmVncm91bmQpO1xuICB9XG5cbiAgdmFyIGJhY2tncm91bmQgPSB0aGlzLmRvbS5iYWNrZ3JvdW5kO1xuICBpZiAoYmFja2dyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgYmFja2dyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJhY2tncm91bmQpO1xuICB9XG5cbiAgdmFyIGF4aXMgPSB0aGlzLmRvbS5heGlzO1xuICBpZiAoYXhpcy5wYXJlbnROb2RlKSB7XG4gICAgYXhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGF4aXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEFkZCBhbiBpdGVtIHRvIHRoZSBncm91cFxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpdGVtKSB7XG4gIHRoaXMuaXRlbXNbaXRlbS5pZF0gPSBpdGVtO1xuICBpdGVtLnNldFBhcmVudCh0aGlzKTtcblxuICAvLyBhZGQgdG9cbiAgaWYgKGl0ZW0uZGF0YS5zdWJncm91cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXSA9IHtoZWlnaHQ6MCwgdmlzaWJsZTogZmFsc2UsIGluZGV4OnRoaXMuc3ViZ3JvdXBJbmRleCwgaXRlbXM6IFtdfTtcbiAgICAgIHRoaXMuc3ViZ3JvdXBJbmRleCsrO1xuICAgIH1cbiAgICB0aGlzLnN1Ymdyb3Vwc1tpdGVtLmRhdGEuc3ViZ3JvdXBdLml0ZW1zLnB1c2goaXRlbSk7XG4gIH1cbiAgdGhpcy5vcmRlclN1Ymdyb3VwcygpO1xuXG4gIGlmICh0aGlzLnZpc2libGVJdGVtcy5pbmRleE9mKGl0ZW0pID09IC0xKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5pdGVtU2V0LmJvZHkucmFuZ2U7IC8vIFRPRE86IG5vdCBuaWNlIGFjY2Vzc2luZyB0aGUgcmFuZ2UgbGlrZSB0aGlzXG4gICAgdGhpcy5fY2hlY2tJZlZpc2libGUoaXRlbSwgdGhpcy52aXNpYmxlSXRlbXMsIHJhbmdlKTtcbiAgfVxufTtcblxuR3JvdXAucHJvdG90eXBlLm9yZGVyU3ViZ3JvdXBzID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnN1Ymdyb3VwT3JkZXJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNvcnRBcnJheSA9IFtdO1xuICAgIGlmICh0eXBlb2YgdGhpcy5zdWJncm91cE9yZGVyZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAodmFyIHN1Ymdyb3VwIGluIHRoaXMuc3ViZ3JvdXBzKSB7XG4gICAgICAgIHNvcnRBcnJheS5wdXNoKHtzdWJncm91cDogc3ViZ3JvdXAsIHNvcnRGaWVsZDogdGhpcy5zdWJncm91cHNbc3ViZ3JvdXBdLml0ZW1zWzBdLmRhdGFbdGhpcy5zdWJncm91cE9yZGVyZXJdfSlcbiAgICAgIH1cbiAgICAgIHNvcnRBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnNvcnRGaWVsZCAtIGIuc29ydEZpZWxkO1xuICAgICAgfSlcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuc3ViZ3JvdXBPcmRlcmVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZvciAodmFyIHN1Ymdyb3VwIGluIHRoaXMuc3ViZ3JvdXBzKSB7XG4gICAgICAgIHNvcnRBcnJheS5wdXNoKHRoaXMuc3ViZ3JvdXBzW3N1Ymdyb3VwXS5pdGVtc1swXS5kYXRhKTtcbiAgICAgIH1cbiAgICAgIHNvcnRBcnJheS5zb3J0KHRoaXMuc3ViZ3JvdXBPcmRlcmVyKTtcbiAgICB9XG5cbiAgICBpZiAoc29ydEFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc29ydEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuc3ViZ3JvdXBzW3NvcnRBcnJheVtpXS5zdWJncm91cF0uaW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuR3JvdXAucHJvdG90eXBlLnJlc2V0U3ViZ3JvdXBzID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIHN1Ymdyb3VwIGluIHRoaXMuc3ViZ3JvdXBzKSB7XG4gICAgaWYgKHRoaXMuc3ViZ3JvdXBzLmhhc093blByb3BlcnR5KHN1Ymdyb3VwKSkge1xuICAgICAgdGhpcy5zdWJncm91cHNbc3ViZ3JvdXBdLnZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgZ3JvdXBcbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICovXG5Hcm91cC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBkZWxldGUgdGhpcy5pdGVtc1tpdGVtLmlkXTtcbiAgaXRlbS5zZXRQYXJlbnQobnVsbCk7XG5cbiAgLy8gcmVtb3ZlIGZyb20gdmlzaWJsZSBpdGVtc1xuICB2YXIgaW5kZXggPSB0aGlzLnZpc2libGVJdGVtcy5pbmRleE9mKGl0ZW0pO1xuICBpZiAoaW5kZXggIT0gLTEpIHRoaXMudmlzaWJsZUl0ZW1zLnNwbGljZShpbmRleCwgMSk7XG5cbiAgaWYoaXRlbS5kYXRhLnN1Ymdyb3VwICE9PSB1bmRlZmluZWQpe1xuICAgIHZhciBzdWJncm91cCA9IHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF07XG4gICAgaWYgKHN1Ymdyb3VwKXtcbiAgICAgIHZhciBpdGVtSW5kZXggPSBzdWJncm91cC5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgc3ViZ3JvdXAuaXRlbXMuc3BsaWNlKGl0ZW1JbmRleCwxKTtcbiAgICAgIGlmICghc3ViZ3JvdXAuaXRlbXMubGVuZ3RoKXtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF07XG4gICAgICAgIHRoaXMuc3ViZ3JvdXBJbmRleC0tO1xuICAgICAgfVxuICAgICAgdGhpcy5vcmRlclN1Ymdyb3VwcygpO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgRGF0YVNldFxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5yZW1vdmVGcm9tRGF0YVNldCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdGhpcy5pdGVtU2V0LnJlbW92ZUl0ZW0oaXRlbS5pZCk7XG59O1xuXG5cbi8qKlxuICogUmVvcmRlciB0aGUgaXRlbXNcbiAqL1xuR3JvdXAucHJvdG90eXBlLm9yZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhcnJheSA9IHV0aWwudG9BcnJheSh0aGlzLml0ZW1zKTtcbiAgdmFyIHN0YXJ0QXJyYXkgPSBbXTtcbiAgdmFyIGVuZEFycmF5ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJheVtpXS5kYXRhLmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmRBcnJheS5wdXNoKGFycmF5W2ldKTtcbiAgICB9XG4gICAgc3RhcnRBcnJheS5wdXNoKGFycmF5W2ldKTtcbiAgfVxuICB0aGlzLm9yZGVyZWRJdGVtcyA9IHtcbiAgICBieVN0YXJ0OiBzdGFydEFycmF5LFxuICAgIGJ5RW5kOiBlbmRBcnJheVxuICB9O1xuXG4gIHN0YWNrLm9yZGVyQnlTdGFydCh0aGlzLm9yZGVyZWRJdGVtcy5ieVN0YXJ0KTtcbiAgc3RhY2sub3JkZXJCeUVuZCh0aGlzLm9yZGVyZWRJdGVtcy5ieUVuZCk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIHRoZSB2aXNpYmxlIGl0ZW1zXG4gKiBAcGFyYW0ge3tieVN0YXJ0OiBJdGVtW10sIGJ5RW5kOiBJdGVtW119fSBvcmRlcmVkSXRlbXMgICBBbGwgaXRlbXMgb3JkZXJlZCBieSBzdGFydCBkYXRlIGFuZCBieSBlbmQgZGF0ZVxuICogQHBhcmFtIHtJdGVtW119IHZpc2libGVJdGVtcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHByZXZpb3VzbHkgdmlzaWJsZSBpdGVtcy5cbiAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgICAgICAgICAgICAgIFZpc2libGUgcmFuZ2VcbiAqIEByZXR1cm4ge0l0ZW1bXX0gdmlzaWJsZUl0ZW1zICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBuZXcgdmlzaWJsZSBpdGVtcy5cbiAqIEBwcml2YXRlXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5fdXBkYXRlVmlzaWJsZUl0ZW1zID0gZnVuY3Rpb24ob3JkZXJlZEl0ZW1zLCBvbGRWaXNpYmxlSXRlbXMsIHJhbmdlKSB7XG4gIHZhciB2aXNpYmxlSXRlbXMgPSBbXTtcbiAgdmFyIHZpc2libGVJdGVtc0xvb2t1cCA9IHt9OyAvLyB3ZSBrZWVwIHRoaXMgdG8gcXVpY2tseSBsb29rIHVwIGlmIGFuIGl0ZW0gYWxyZWFkeSBleGlzdHMgaW4gdGhlIGxpc3Qgd2l0aG91dCB1c2luZyBpbmRleE9mIG9uIHZpc2libGVJdGVtc1xuICB2YXIgaW50ZXJ2YWwgPSAocmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQpIC8gNDtcbiAgdmFyIGxvd2VyQm91bmQgPSByYW5nZS5zdGFydCAtIGludGVydmFsO1xuICB2YXIgdXBwZXJCb3VuZCA9IHJhbmdlLmVuZCArIGludGVydmFsO1xuICB2YXIgaXRlbSwgaTtcblxuICAvLyB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZG8gdGhlIGJpbmFyeSBzZWFyY2guXG4gIHZhciBzZWFyY2hGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICAgICAgKHZhbHVlIDwgbG93ZXJCb3VuZCkgIHtyZXR1cm4gLTE7fVxuICAgIGVsc2UgaWYgKHZhbHVlIDw9IHVwcGVyQm91bmQpIHtyZXR1cm4gIDA7fVxuICAgIGVsc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHtyZXR1cm4gIDE7fVxuICB9XG5cbiAgLy8gZmlyc3QgY2hlY2sgaWYgdGhlIGl0ZW1zIHRoYXQgd2VyZSBpbiB2aWV3IHByZXZpb3VzbHkgYXJlIHN0aWxsIGluIHZpZXcuXG4gIC8vIElNUE9SVEFOVDogdGhpcyBoYW5kbGVzIHRoZSBjYXNlIGZvciB0aGUgaXRlbXMgd2l0aCBzdGFydGRhdGUgYmVmb3JlIHRoZSB3aW5kb3cgYW5kIGVuZGRhdGUgYWZ0ZXIgdGhlIHdpbmRvdyFcbiAgLy8gYWxzbyBjbGVhbnMgdXAgaW52aXNpYmxlIGl0ZW1zLlxuICBpZiAob2xkVmlzaWJsZUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2xkVmlzaWJsZUl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9jaGVja0lmVmlzaWJsZVdpdGhSZWZlcmVuY2Uob2xkVmlzaWJsZUl0ZW1zW2ldLCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgcmFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHdlIGRvIGEgYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGl0ZW1zIHRoYXQgaGF2ZSBvbmx5IHN0YXJ0IHZhbHVlcy5cbiAgdmFyIGluaXRpYWxQb3NCeVN0YXJ0ID0gdXRpbC5iaW5hcnlTZWFyY2hDdXN0b20ob3JkZXJlZEl0ZW1zLmJ5U3RhcnQsIHNlYXJjaEZ1bmN0aW9uLCAnZGF0YScsJ3N0YXJ0Jyk7XG5cbiAgLy8gdHJhY2UgdGhlIHZpc2libGUgaXRlbXMgZnJvbSB0aGUgaW5pdGFsIHN0YXJ0IHBvcyBib3RoIHdheXMgdW50aWwgYW4gaW52aXNpYmxlIGl0ZW0gaXMgZm91bmQsIHdlIG9ubHkgbG9vayBhdCB0aGUgc3RhcnQgdmFsdWVzLlxuICB0aGlzLl90cmFjZVZpc2libGUoaW5pdGlhbFBvc0J5U3RhcnQsIG9yZGVyZWRJdGVtcy5ieVN0YXJ0LCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gKGl0ZW0uZGF0YS5zdGFydCA8IGxvd2VyQm91bmQgfHwgaXRlbS5kYXRhLnN0YXJ0ID4gdXBwZXJCb3VuZCk7XG4gIH0pO1xuXG4gIC8vIGlmIHRoZSB3aW5kb3cgaGFzIGNoYW5nZWQgcHJvZ3JhbW1hdGljYWxseSB3aXRob3V0IG92ZXJsYXBwaW5nIHRoZSBvbGQgd2luZG93LCB0aGUgcmFuZ2VkIGl0ZW1zIHdpdGggc3RhcnQgPCBsb3dlckJvdW5kIGFuZCBlbmQgPiB1cHBlcmJvdW5kIGFyZSBub3Qgc2hvd24uXG4gIC8vIFdlIHRoZXJlZm9yZSBoYXZlIHRvIGJydXRlIGZvcmNlIGNoZWNrIGFsbCBpdGVtcyBpbiB0aGUgYnlFbmQgbGlzdFxuICBpZiAodGhpcy5jaGVja1JhbmdlZEl0ZW1zID09IHRydWUpIHtcbiAgICB0aGlzLmNoZWNrUmFuZ2VkSXRlbXMgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3JkZXJlZEl0ZW1zLmJ5RW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9jaGVja0lmVmlzaWJsZVdpdGhSZWZlcmVuY2Uob3JkZXJlZEl0ZW1zLmJ5RW5kW2ldLCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgcmFuZ2UpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyB3ZSBkbyBhIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpdGVtcyB0aGF0IGhhdmUgZGVmaW5lZCBlbmQgdGltZXMuXG4gICAgdmFyIGluaXRpYWxQb3NCeUVuZCA9IHV0aWwuYmluYXJ5U2VhcmNoQ3VzdG9tKG9yZGVyZWRJdGVtcy5ieUVuZCwgc2VhcmNoRnVuY3Rpb24sICdkYXRhJywnZW5kJyk7XG5cbiAgICAvLyB0cmFjZSB0aGUgdmlzaWJsZSBpdGVtcyBmcm9tIHRoZSBpbml0YWwgc3RhcnQgcG9zIGJvdGggd2F5cyB1bnRpbCBhbiBpbnZpc2libGUgaXRlbSBpcyBmb3VuZCwgd2Ugb25seSBsb29rIGF0IHRoZSBlbmQgdmFsdWVzLlxuICAgIHRoaXMuX3RyYWNlVmlzaWJsZShpbml0aWFsUG9zQnlFbmQsIG9yZGVyZWRJdGVtcy5ieUVuZCwgdmlzaWJsZUl0ZW1zLCB2aXNpYmxlSXRlbXNMb29rdXAsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gKGl0ZW0uZGF0YS5lbmQgPCBsb3dlckJvdW5kIHx8IGl0ZW0uZGF0YS5lbmQgPiB1cHBlckJvdW5kKTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgLy8gZmluYWxseSwgd2UgcmVwb3NpdGlvbiBhbGwgdGhlIHZpc2libGUgaXRlbXMuXG4gIGZvciAoaSA9IDA7IGkgPCB2aXNpYmxlSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICBpdGVtID0gdmlzaWJsZUl0ZW1zW2ldO1xuICAgIGlmICghaXRlbS5kaXNwbGF5ZWQpIGl0ZW0uc2hvdygpO1xuICAgIC8vIHJlcG9zaXRpb24gaXRlbSBob3Jpem9udGFsbHlcbiAgICBpdGVtLnJlcG9zaXRpb25YKCk7XG4gIH1cblxuICAvLyBkZWJ1Z1xuICAvL2NvbnNvbGUubG9nKFwibmV3IGxpbmVcIilcbiAgLy9pZiAodGhpcy5ncm91cElkID09IG51bGwpIHtcbiAgLy8gIGZvciAoaSA9IDA7IGkgPCBvcmRlcmVkSXRlbXMuYnlTdGFydC5sZW5ndGg7IGkrKykge1xuICAvLyAgICBpdGVtID0gb3JkZXJlZEl0ZW1zLmJ5U3RhcnRbaV0uZGF0YTtcbiAgLy8gICAgY29uc29sZS5sb2coJ3N0YXJ0JyxpLGluaXRpYWxQb3NCeVN0YXJ0LCBpdGVtLnN0YXJ0LnZhbHVlT2YoKSwgaXRlbS5jb250ZW50LCBpdGVtLnN0YXJ0ID49IGxvd2VyQm91bmQgJiYgaXRlbS5zdGFydCA8PSB1cHBlckJvdW5kLGkgPT0gaW5pdGlhbFBvc0J5U3RhcnQgPyBcIjwtLS0tLS0tLS0tLS0tLS0tLS0tIEhFUkVFRUVcIiA6IFwiXCIpXG4gIC8vICB9XG4gIC8vICBmb3IgKGkgPSAwOyBpIDwgb3JkZXJlZEl0ZW1zLmJ5RW5kLmxlbmd0aDsgaSsrKSB7XG4gIC8vICAgIGl0ZW0gPSBvcmRlcmVkSXRlbXMuYnlFbmRbaV0uZGF0YTtcbiAgLy8gICAgY29uc29sZS5sb2coJ3JhbmdlRW5kJyxpLGluaXRpYWxQb3NCeUVuZCwgaXRlbS5lbmQudmFsdWVPZigpLCBpdGVtLmNvbnRlbnQsIGl0ZW0uZW5kID49IHJhbmdlLnN0YXJ0ICYmIGl0ZW0uZW5kIDw9IHJhbmdlLmVuZCxpID09IGluaXRpYWxQb3NCeUVuZCA/IFwiPC0tLS0tLS0tLS0tLS0tLS0tLS0gSEVSRUVFRVwiIDogXCJcIilcbiAgLy8gIH1cbiAgLy99XG5cbiAgcmV0dXJuIHZpc2libGVJdGVtcztcbn07XG5cbkdyb3VwLnByb3RvdHlwZS5fdHJhY2VWaXNpYmxlID0gZnVuY3Rpb24gKGluaXRpYWxQb3MsIGl0ZW1zLCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgYnJlYWtDb25kaXRpb24pIHtcbiAgdmFyIGl0ZW07XG4gIHZhciBpO1xuXG4gIGlmIChpbml0aWFsUG9zICE9IC0xKSB7XG4gICAgZm9yIChpID0gaW5pdGlhbFBvczsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGlmIChicmVha0NvbmRpdGlvbihpdGVtKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodmlzaWJsZUl0ZW1zTG9va3VwW2l0ZW0uaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPSB0cnVlO1xuICAgICAgICAgIHZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gaW5pdGlhbFBvcyArIDE7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgaWYgKGJyZWFrQ29uZGl0aW9uKGl0ZW0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZpc2libGVJdGVtc0xvb2t1cFtpdGVtLmlkXSA9IHRydWU7XG4gICAgICAgICAgdmlzaWJsZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIHRoaXMgZnVuY3Rpb24gaXMgdmVyeSBzaW1pbGFyIHRvIHRoZSBfY2hlY2tJZkludmlzaWJsZSgpIGJ1dCBpdCBkb2VzIG5vdFxuICogcmV0dXJuIGJvb2xlYW5zLCBoaWRlcyB0aGUgaXRlbSBpZiBpdCBzaG91bGQgbm90IGJlIHNlZW4gYW5kIGFsd2F5cyBhZGRzIHRvXG4gKiB0aGUgdmlzaWJsZUl0ZW1zLlxuICogdGhpcyBvbmUgaXMgZm9yIGJydXRlIGZvcmNpbmcgYW5kIGhpZGluZy5cbiAqXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7QXJyYXl9IHZpc2libGVJdGVtc1xuICogQHBhcmFtIHt7c3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyfX0gcmFuZ2VcbiAqIEBwcml2YXRlXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5fY2hlY2tJZlZpc2libGUgPSBmdW5jdGlvbihpdGVtLCB2aXNpYmxlSXRlbXMsIHJhbmdlKSB7XG4gICAgaWYgKGl0ZW0uaXNWaXNpYmxlKHJhbmdlKSkge1xuICAgICAgaWYgKCFpdGVtLmRpc3BsYXllZCkgaXRlbS5zaG93KCk7XG4gICAgICAvLyByZXBvc2l0aW9uIGl0ZW0gaG9yaXpvbnRhbGx5XG4gICAgICBpdGVtLnJlcG9zaXRpb25YKCk7XG4gICAgICB2aXNpYmxlSXRlbXMucHVzaChpdGVtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoaXRlbS5kaXNwbGF5ZWQpIGl0ZW0uaGlkZSgpO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiB0aGlzIGZ1bmN0aW9uIGlzIHZlcnkgc2ltaWxhciB0byB0aGUgX2NoZWNrSWZJbnZpc2libGUoKSBidXQgaXQgZG9lcyBub3RcbiAqIHJldHVybiBib29sZWFucywgaGlkZXMgdGhlIGl0ZW0gaWYgaXQgc2hvdWxkIG5vdCBiZSBzZWVuIGFuZCBhbHdheXMgYWRkcyB0b1xuICogdGhlIHZpc2libGVJdGVtcy5cbiAqIHRoaXMgb25lIGlzIGZvciBicnV0ZSBmb3JjaW5nIGFuZCBoaWRpbmcuXG4gKlxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge0FycmF5fSB2aXNpYmxlSXRlbXNcbiAqIEBwYXJhbSB7e3N0YXJ0Om51bWJlciwgZW5kOm51bWJlcn19IHJhbmdlXG4gKiBAcHJpdmF0ZVxuICovXG5Hcm91cC5wcm90b3R5cGUuX2NoZWNrSWZWaXNpYmxlV2l0aFJlZmVyZW5jZSA9IGZ1bmN0aW9uKGl0ZW0sIHZpc2libGVJdGVtcywgdmlzaWJsZUl0ZW1zTG9va3VwLCByYW5nZSkge1xuICBpZiAoaXRlbS5pc1Zpc2libGUocmFuZ2UpKSB7XG4gICAgaWYgKHZpc2libGVJdGVtc0xvb2t1cFtpdGVtLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPSB0cnVlO1xuICAgICAgdmlzaWJsZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmIChpdGVtLmRpc3BsYXllZCkgaXRlbS5oaWRlKCk7XG4gIH1cbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwO1xuIiwidmFyIEhhbW1lciA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZS9oYW1tZXInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIERhdGFTZXQgPSByZXF1aXJlKCcuLi8uLi9EYXRhU2V0Jyk7XG52YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuLi8uLi9EYXRhVmlldycpO1xudmFyIFRpbWVTdGVwID0gcmVxdWlyZSgnLi4vVGltZVN0ZXAnKTtcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuL0NvbXBvbmVudCcpO1xudmFyIEdyb3VwID0gcmVxdWlyZSgnLi9Hcm91cCcpO1xudmFyIEJhY2tncm91bmRHcm91cCA9IHJlcXVpcmUoJy4vQmFja2dyb3VuZEdyb3VwJyk7XG52YXIgQm94SXRlbSA9IHJlcXVpcmUoJy4vaXRlbS9Cb3hJdGVtJyk7XG52YXIgUG9pbnRJdGVtID0gcmVxdWlyZSgnLi9pdGVtL1BvaW50SXRlbScpO1xudmFyIFJhbmdlSXRlbSA9IHJlcXVpcmUoJy4vaXRlbS9SYW5nZUl0ZW0nKTtcbnZhciBCYWNrZ3JvdW5kSXRlbSA9IHJlcXVpcmUoJy4vaXRlbS9CYWNrZ3JvdW5kSXRlbScpO1xuXG5cbnZhciBVTkdST1VQRUQgPSAnX191bmdyb3VwZWRfXyc7ICAgLy8gcmVzZXJ2ZWQgZ3JvdXAgaWQgZm9yIHVuZ3JvdXBlZCBpdGVtc1xudmFyIEJBQ0tHUk9VTkQgPSAnX19iYWNrZ3JvdW5kX18nOyAvLyByZXNlcnZlZCBncm91cCBpZCBmb3IgYmFja2dyb3VuZCBpdGVtcyB3aXRob3V0IGdyb3VwXG5cbi8qKlxuICogQW4gSXRlbVNldCBob2xkcyBhIHNldCBvZiBpdGVtcyBhbmQgcmFuZ2VzIHdoaWNoIGNhbiBiZSBkaXNwbGF5ZWQgaW4gYVxuICogcmFuZ2UuIFRoZSB3aWR0aCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBwYXJlbnQgb2YgdGhlIEl0ZW1TZXQsIGFuZCB0aGUgaGVpZ2h0XG4gKiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBzaXplIG9mIHRoZSBpdGVtcy5cbiAqIEBwYXJhbSB7e2RvbTogT2JqZWN0LCBkb21Qcm9wczogT2JqZWN0LCBlbWl0dGVyOiBFbWl0dGVyLCByYW5nZTogUmFuZ2V9fSBib2R5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgU2VlIEl0ZW1TZXQuc2V0T3B0aW9ucyBmb3IgdGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQGNvbnN0cnVjdG9yIEl0ZW1TZXRcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5mdW5jdGlvbiBJdGVtU2V0KGJvZHksIG9wdGlvbnMpIHtcbiAgdGhpcy5ib2R5ID0gYm9keTtcblxuICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIHR5cGU6IG51bGwsICAvLyAnYm94JywgJ3BvaW50JywgJ3JhbmdlJywgJ2JhY2tncm91bmQnXG4gICAgb3JpZW50YXRpb246IHtcbiAgICAgIGl0ZW06ICdib3R0b20nICAgLy8gaXRlbSBvcmllbnRhdGlvbjogJ3RvcCcgb3IgJ2JvdHRvbSdcbiAgICB9LFxuICAgIGFsaWduOiAnYXV0bycsIC8vIGFsaWdubWVudCBvZiBib3ggaXRlbXNcbiAgICBzdGFjazogdHJ1ZSxcbiAgICBncm91cE9yZGVyU3dhcDogZnVuY3Rpb24oZnJvbUdyb3VwLCB0b0dyb3VwLCBncm91cHMpIHtcbiAgICBcdHZhciB0YXJnZXRPcmRlciA9IHRvR3JvdXAub3JkZXI7XG4gICAgXHR0b0dyb3VwLm9yZGVyID0gZnJvbUdyb3VwLm9yZGVyO1xuICAgIFx0ZnJvbUdyb3VwLm9yZGVyID0gdGFyZ2V0T3JkZXI7XG4gICAgfSxcbiAgICBncm91cE9yZGVyOiAnb3JkZXInLFxuXG4gICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICBtdWx0aXNlbGVjdDogZmFsc2UsXG5cbiAgICBlZGl0YWJsZToge1xuICAgICAgdXBkYXRlVGltZTogZmFsc2UsXG4gICAgICB1cGRhdGVHcm91cDogZmFsc2UsXG4gICAgICBhZGQ6IGZhbHNlLFxuICAgICAgcmVtb3ZlOiBmYWxzZVxuICAgIH0sXG5cbiAgICBncm91cEVkaXRhYmxlOiB7XG4gICAgICBvcmRlcjogZmFsc2UsXG4gICAgICBhZGQ6IGZhbHNlLFxuICAgICAgcmVtb3ZlOiBmYWxzZVxuICAgIH0sICAgIFxuICAgIFxuICAgIHNuYXA6IFRpbWVTdGVwLnNuYXAsXG5cbiAgICBvbkFkZDogZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICB9LFxuICAgIG9uVXBkYXRlOiBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgIH0sXG4gICAgb25Nb3ZlOiBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgIH0sXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgfSxcbiAgICBvbk1vdmluZzogZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICB9LFxuICAgIG9uQWRkR3JvdXA6IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgfSxcbiAgICBvbk1vdmVHcm91cDogZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICB9LFxuICAgIG9uUmVtb3ZlR3JvdXA6IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgfSxcblxuICAgIG1hcmdpbjoge1xuICAgICAgaXRlbToge1xuICAgICAgICBob3Jpem9udGFsOiAxMCxcbiAgICAgICAgdmVydGljYWw6IDEwXG4gICAgICB9LFxuICAgICAgYXhpczogMjBcbiAgICB9XG4gIH07XG5cbiAgLy8gb3B0aW9ucyBpcyBzaGFyZWQgYnkgdGhpcyBJdGVtU2V0IGFuZCBhbGwgaXRzIGl0ZW1zXG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAvLyBvcHRpb25zIGZvciBnZXR0aW5nIGl0ZW1zIGZyb20gdGhlIERhdGFTZXQgd2l0aCB0aGUgY29ycmVjdCB0eXBlXG4gIHRoaXMuaXRlbU9wdGlvbnMgPSB7XG4gICAgdHlwZToge3N0YXJ0OiAnRGF0ZScsIGVuZDogJ0RhdGUnfVxuICB9O1xuXG4gIHRoaXMuY29udmVyc2lvbiA9IHtcbiAgICB0b1NjcmVlbjogYm9keS51dGlsLnRvU2NyZWVuLFxuICAgIHRvVGltZTogYm9keS51dGlsLnRvVGltZVxuICB9O1xuICB0aGlzLmRvbSA9IHt9O1xuICB0aGlzLnByb3BzID0ge307XG4gIHRoaXMuaGFtbWVyID0gbnVsbDtcblxuICB2YXIgbWUgPSB0aGlzO1xuICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7ICAgIC8vIERhdGFTZXRcbiAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDsgICAvLyBEYXRhU2V0XG5cbiAgLy8gbGlzdGVuZXJzIGZvciB0aGUgRGF0YVNldCBvZiB0aGUgaXRlbXNcbiAgdGhpcy5pdGVtTGlzdGVuZXJzID0ge1xuICAgICdhZGQnOiBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgIG1lLl9vbkFkZChwYXJhbXMuaXRlbXMpO1xuICAgIH0sXG4gICAgJ3VwZGF0ZSc6IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgbWUuX29uVXBkYXRlKHBhcmFtcy5pdGVtcyk7XG4gICAgfSxcbiAgICAncmVtb3ZlJzogZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICBtZS5fb25SZW1vdmUocGFyYW1zLml0ZW1zKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gbGlzdGVuZXJzIGZvciB0aGUgRGF0YVNldCBvZiB0aGUgZ3JvdXBzXG4gIHRoaXMuZ3JvdXBMaXN0ZW5lcnMgPSB7XG4gICAgJ2FkZCc6IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgbWUuX29uQWRkR3JvdXBzKHBhcmFtcy5pdGVtcyk7XG4gICAgfSxcbiAgICAndXBkYXRlJzogZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICBtZS5fb25VcGRhdGVHcm91cHMocGFyYW1zLml0ZW1zKTtcbiAgICB9LFxuICAgICdyZW1vdmUnOiBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgIG1lLl9vblJlbW92ZUdyb3VwcyhwYXJhbXMuaXRlbXMpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLml0ZW1zID0ge307ICAgICAgLy8gb2JqZWN0IHdpdGggYW4gSXRlbSBmb3IgZXZlcnkgZGF0YSBpdGVtXG4gIHRoaXMuZ3JvdXBzID0ge307ICAgICAvLyBHcm91cCBvYmplY3QgZm9yIGV2ZXJ5IGdyb3VwXG4gIHRoaXMuZ3JvdXBJZHMgPSBbXTtcblxuICB0aGlzLnNlbGVjdGlvbiA9IFtdOyAgLy8gbGlzdCB3aXRoIHRoZSBpZHMgb2YgYWxsIHNlbGVjdGVkIG5vZGVzXG4gIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7IC8vIGlmIHRydWUsIGFsbCBpdGVtcyB3aWxsIGJlIHJlc3RhY2tlZCBvbiBuZXh0IHJlZHJhd1xuXG4gIHRoaXMudG91Y2hQYXJhbXMgPSB7fTsgLy8gc3RvcmVzIHByb3BlcnRpZXMgd2hpbGUgZHJhZ2dpbmdcbiAgdGhpcy5ncm91cFRvdWNoUGFyYW1zID0ge307XG4gIC8vIGNyZWF0ZSB0aGUgSFRNTCBET01cblxuICB0aGlzLl9jcmVhdGUoKTtcblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG59XG5cbkl0ZW1TZXQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4vLyBhdmFpbGFibGUgaXRlbSB0eXBlcyB3aWxsIGJlIHJlZ2lzdGVyZWQgaGVyZVxuSXRlbVNldC50eXBlcyA9IHtcbiAgYmFja2dyb3VuZDogQmFja2dyb3VuZEl0ZW0sXG4gIGJveDogQm94SXRlbSxcbiAgcmFuZ2U6IFJhbmdlSXRlbSxcbiAgcG9pbnQ6IFBvaW50SXRlbVxufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIEhUTUwgRE9NIGZvciB0aGUgSXRlbVNldFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtaXRlbXNldCc7XG4gIGZyYW1lWyd0aW1lbGluZS1pdGVtc2V0J10gPSB0aGlzO1xuICB0aGlzLmRvbS5mcmFtZSA9IGZyYW1lO1xuXG4gIC8vIGNyZWF0ZSBiYWNrZ3JvdW5kIHBhbmVsXG4gIHZhciBiYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGJhY2tncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy1iYWNrZ3JvdW5kJztcbiAgZnJhbWUuYXBwZW5kQ2hpbGQoYmFja2dyb3VuZCk7XG4gIHRoaXMuZG9tLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuXG4gIC8vIGNyZWF0ZSBmb3JlZ3JvdW5kIHBhbmVsXG4gIHZhciBmb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGZvcmVncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy1mb3JlZ3JvdW5kJztcbiAgZnJhbWUuYXBwZW5kQ2hpbGQoZm9yZWdyb3VuZCk7XG4gIHRoaXMuZG9tLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kO1xuXG4gIC8vIGNyZWF0ZSBheGlzIHBhbmVsXG4gIHZhciBheGlzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGF4aXMuY2xhc3NOYW1lID0gJ3Zpcy1heGlzJztcbiAgdGhpcy5kb20uYXhpcyA9IGF4aXM7XG5cbiAgLy8gY3JlYXRlIGxhYmVsc2V0XG4gIHZhciBsYWJlbFNldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBsYWJlbFNldC5jbGFzc05hbWUgPSAndmlzLWxhYmVsc2V0JztcbiAgdGhpcy5kb20ubGFiZWxTZXQgPSBsYWJlbFNldDtcblxuICAvLyBjcmVhdGUgdW5ncm91cGVkIEdyb3VwXG4gIHRoaXMuX3VwZGF0ZVVuZ3JvdXBlZCgpO1xuXG4gIC8vIGNyZWF0ZSBiYWNrZ3JvdW5kIEdyb3VwXG4gIHZhciBiYWNrZ3JvdW5kR3JvdXAgPSBuZXcgQmFja2dyb3VuZEdyb3VwKEJBQ0tHUk9VTkQsIG51bGwsIHRoaXMpO1xuICBiYWNrZ3JvdW5kR3JvdXAuc2hvdygpO1xuICB0aGlzLmdyb3Vwc1tCQUNLR1JPVU5EXSA9IGJhY2tncm91bmRHcm91cDtcblxuICAvLyBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzXG4gIC8vIE5vdGU6IHdlIGJpbmQgdG8gdGhlIGNlbnRlckNvbnRhaW5lciBmb3IgdGhlIGNhc2Ugd2hlcmUgdGhlIGhlaWdodFxuICAvLyAgICAgICBvZiB0aGUgY2VudGVyIGNvbnRhaW5lciBpcyBsYXJnZXIgdGhhbiBvZiB0aGUgSXRlbVNldCwgc28gd2VcbiAgLy8gICAgICAgY2FuIGNsaWNrIGluIHRoZSBlbXB0eSBhcmVhIHRvIGNyZWF0ZSBhIG5ldyBpdGVtIG9yIGRlc2VsZWN0IGFuIGl0ZW0uXG4gIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLmJvZHkuZG9tLmNlbnRlckNvbnRhaW5lcik7XG5cbiAgLy8gZHJhZyBpdGVtcyB3aGVuIHNlbGVjdGVkXG4gIHRoaXMuaGFtbWVyLm9uKCdoYW1tZXIuaW5wdXQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaXNGaXJzdCkge1xuICAgICAgdGhpcy5fb25Ub3VjaChldmVudCk7XG4gICAgfVxuICB9LmJpbmQodGhpcykpO1xuICB0aGlzLmhhbW1lci5vbigncGFuc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5oYW1tZXIub24oJ3Bhbm1vdmUnLCAgdGhpcy5fb25EcmFnLmJpbmQodGhpcykpO1xuICB0aGlzLmhhbW1lci5vbigncGFuZW5kJywgICB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKSk7XG4gIHRoaXMuaGFtbWVyLmdldCgncGFuJykuc2V0KHt0aHJlc2hvbGQ6NSwgZGlyZWN0aW9uOjMwfSk7IC8vIDMwIGlzIEFMTF9ESVJFQ1RJT05TIGluIGhhbW1lci5cblxuICAvLyBzaW5nbGUgc2VsZWN0IChvciB1bnNlbGVjdCkgd2hlbiB0YXBwaW5nIGFuIGl0ZW1cbiAgdGhpcy5oYW1tZXIub24oJ3RhcCcsICB0aGlzLl9vblNlbGVjdEl0ZW0uYmluZCh0aGlzKSk7XG5cbiAgLy8gbXVsdGkgc2VsZWN0IHdoZW4gaG9sZGluZyBtb3VzZS90b3VjaCwgb3Igb24gY3RybCtjbGlja1xuICB0aGlzLmhhbW1lci5vbigncHJlc3MnLCB0aGlzLl9vbk11bHRpU2VsZWN0SXRlbS5iaW5kKHRoaXMpKTtcblxuICAvLyBhZGQgaXRlbSBvbiBkb3VibGV0YXBcbiAgdGhpcy5oYW1tZXIub24oJ2RvdWJsZXRhcCcsIHRoaXMuX29uQWRkSXRlbS5iaW5kKHRoaXMpKTtcblxuICB0aGlzLmdyb3VwSGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLmJvZHkuZG9tLmxlZnRDb250YWluZXIpO1xuICB0aGlzLmdyb3VwSGFtbWVyLm9uKCdwYW5zdGFydCcsIHRoaXMuX29uR3JvdXBEcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gIHRoaXMuZ3JvdXBIYW1tZXIub24oJ3Bhbm1vdmUnLCAgdGhpcy5fb25Hcm91cERyYWcuYmluZCh0aGlzKSk7XG4gIHRoaXMuZ3JvdXBIYW1tZXIub24oJ3BhbmVuZCcsICAgdGhpcy5fb25Hcm91cERyYWdFbmQuYmluZCh0aGlzKSk7XG4gIHRoaXMuZ3JvdXBIYW1tZXIuZ2V0KCdwYW4nKS5zZXQoe3RocmVzaG9sZDo1LCBkaXJlY3Rpb246MzB9KTtcbiAgXG4gIC8vIGF0dGFjaCB0byB0aGUgRE9NXG4gIHRoaXMuc2hvdygpO1xufTtcblxuLyoqXG4gKiBTZXQgb3B0aW9ucyBmb3IgdGhlIEl0ZW1TZXQuIEV4aXN0aW5nIG9wdGlvbnMgd2lsbCBiZSBleHRlbmRlZC9vdmVyd3JpdHRlbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBhdmFpbGFibGU6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IHR5cGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB0eXBlIGZvciB0aGUgaXRlbXMuIENob29zZSBmcm9tICdib3gnXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkZWZhdWx0KSwgJ3BvaW50JywgJ3JhbmdlJywgb3IgJ2JhY2tncm91bmQnLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCBzdHlsZSBjYW4gYmUgb3ZlcndyaXR0ZW4gYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kaXZpZHVhbCBpdGVtcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gYWxpZ25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxpZ25tZW50IGZvciB0aGUgaXRlbXMsIG9ubHkgYXBwbGljYWJsZSBmb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQm94SXRlbS4gQ2hvb3NlICdjZW50ZXInIChkZWZhdWx0KSwgJ2xlZnQnLCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmlnaHQnLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBvcmllbnRhdGlvbi5pdGVtXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9yaWVudGF0aW9uIG9mIHRoZSBpdGVtIHNldC4gQ2hvb3NlICd0b3AnIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdib3R0b20nIChkZWZhdWx0KS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Z1bmN0aW9ufSBncm91cE9yZGVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgc29ydGluZyBmdW5jdGlvbiBmb3Igb3JkZXJpbmcgZ3JvdXBzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBzdGFja1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgaXRlbXMgd2lsbCBiZSBzdGFja2VkIG9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCBvZiBlYWNoIG90aGVyLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXJnaW4uYXhpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXJnaW4gYmV0d2VlbiB0aGUgYXhpcyBhbmQgdGhlIGl0ZW1zIGluIHBpeGVscy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyAyMC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWFyZ2luLml0ZW0uaG9yaXpvbnRhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIb3Jpem9udGFsIG1hcmdpbiBiZXR3ZWVuIGl0ZW1zIGluIHBpeGVscy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyAxMC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWFyZ2luLml0ZW0udmVydGljYWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVydGljYWwgTWFyZ2luIGJldHdlZW4gaXRlbXMgaW4gcGl4ZWxzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGlzIDEwLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXJnaW4uaXRlbVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXJnaW4gYmV0d2VlbiBpdGVtcyBpbiBwaXhlbHMgaW4gYm90aCBob3Jpem9udGFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB2ZXJ0aWNhbCBkaXJlY3Rpb24uIERlZmF1bHQgaXMgMTAuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1hcmdpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXQgbWFyZ2luIGZvciBib3RoIGF4aXMgYW5kIGl0ZW1zIGluIHBpeGVscy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IHNlbGVjdGFibGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIGl0ZW1zIGNhbiBiZSBzZWxlY3RlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IG11bHRpc2VsZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUsIG11bHRpcGxlIGl0ZW1zIGNhbiBiZSBzZWxlY3RlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmFsc2UgYnkgZGVmYXVsdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IGVkaXRhYmxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldCBhbGwgZWRpdGFibGUgb3B0aW9ucyB0byB0cnVlIG9yIGZhbHNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBlZGl0YWJsZS51cGRhdGVUaW1lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsbG93IGRyYWdnaW5nIGFuIGl0ZW0gdG8gYW4gb3RoZXIgbW9tZW50IGluIHRpbWVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IGVkaXRhYmxlLnVwZGF0ZUdyb3VwXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsbG93IGRyYWdnaW5nIGFuIGl0ZW0gdG8gYW4gb3RoZXIgZ3JvdXBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IGVkaXRhYmxlLmFkZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbGxvdyBjcmVhdGluZyBuZXcgaXRlbXMgb24gZG91YmxlIHRhcFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gZWRpdGFibGUucmVtb3ZlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsbG93IHJlbW92aW5nIGl0ZW1zIGJ5IGNsaWNraW5nIHRoZSBkZWxldGUgYnV0dG9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCByaWdodCBvZiBhIHNlbGVjdGVkIGl0ZW0uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtGdW5jdGlvbihpdGVtOiBJdGVtLCBjYWxsYmFjazogRnVuY3Rpb24pfSBvbkFkZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgd2hlbiBhbiBpdGVtIGlzIGFib3V0IHRvIGJlIGFkZGVkOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuIHRoZSB1c2VyIGRvdWJsZSB0YXBzIGFuIGVtcHR5IHNwYWNlIGluIHRoZSBUaW1lbGluZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Z1bmN0aW9uKGl0ZW06IEl0ZW0sIGNhbGxiYWNrOiBGdW5jdGlvbil9IG9uVXBkYXRlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIGZpcmVkIHdoZW4gYW4gaXRlbSBpcyBhYm91dCB0byBiZSB1cGRhdGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIGZ1bmN0aW9uIHR5cGljYWxseSBoYXMgdG8gc2hvdyBhIGRpYWxvZyB3aGVyZSB0aGUgdXNlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgdGhlIGl0ZW0uIElmIG5vdCBpbXBsZW1lbnRlZCwgbm90aGluZyBoYXBwZW5zLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7RnVuY3Rpb24oaXRlbTogSXRlbSwgY2FsbGJhY2s6IEZ1bmN0aW9uKX0gb25Nb3ZlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gYW4gaXRlbSBoYXMgYmVlbiBtb3ZlZC4gSWYgbm90IGltcGxlbWVudGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbW92ZSBhY3Rpb24gd2lsbCBiZSBhY2NlcHRlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Z1bmN0aW9uKGl0ZW06IEl0ZW0sIGNhbGxiYWNrOiBGdW5jdGlvbil9IG9uUmVtb3ZlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gYW4gaXRlbSBpcyBhYm91dCB0byBiZSBkZWxldGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBub3QgaW1wbGVtZW50ZWQsIHRoZSBpdGVtIHdpbGwgYmUgYWx3YXlzIHJlbW92ZWQuXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgLy8gY29weSBhbGwgb3B0aW9ucyB0aGF0IHdlIGtub3dcbiAgICB2YXIgZmllbGRzID0gWyd0eXBlJywgJ2FsaWduJywgJ29yZGVyJywgJ3N0YWNrJywgJ3NlbGVjdGFibGUnLCAnbXVsdGlzZWxlY3QnLCAnZ3JvdXBPcmRlcicsICdkYXRhQXR0cmlidXRlcycsICd0ZW1wbGF0ZScsICdncm91cFRlbXBsYXRlJywgJ2hpZGUnLCAnc25hcCcsICdncm91cE9yZGVyU3dhcCddO1xuICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmICgnb3JpZW50YXRpb24nIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gPSBvcHRpb25zLm9yaWVudGF0aW9uID09PSAndG9wJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ29iamVjdCcgJiYgJ2l0ZW0nIGluIG9wdGlvbnMub3JpZW50YXRpb24pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gPSBvcHRpb25zLm9yaWVudGF0aW9uLml0ZW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCdtYXJnaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXJnaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXJnaW4uYXhpcyA9IG9wdGlvbnMubWFyZ2luO1xuICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0uaG9yaXpvbnRhbCA9IG9wdGlvbnMubWFyZ2luO1xuICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0udmVydGljYWwgPSBvcHRpb25zLm1hcmdpbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLm1hcmdpbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWydheGlzJ10sIHRoaXMub3B0aW9ucy5tYXJnaW4sIG9wdGlvbnMubWFyZ2luKTtcbiAgICAgICAgaWYgKCdpdGVtJyBpbiBvcHRpb25zLm1hcmdpbikge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXJnaW4uaXRlbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tYXJnaW4uaXRlbS5ob3Jpem9udGFsID0gb3B0aW9ucy5tYXJnaW4uaXRlbTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tYXJnaW4uaXRlbS52ZXJ0aWNhbCA9IG9wdGlvbnMubWFyZ2luLml0ZW07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLm1hcmdpbi5pdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJ10sIHRoaXMub3B0aW9ucy5tYXJnaW4uaXRlbSwgb3B0aW9ucy5tYXJnaW4uaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCdlZGl0YWJsZScgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmVkaXRhYmxlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgID0gb3B0aW9ucy5lZGl0YWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZUdyb3VwID0gb3B0aW9ucy5lZGl0YWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLmFkZCAgICAgICAgID0gb3B0aW9ucy5lZGl0YWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnJlbW92ZSAgICAgID0gb3B0aW9ucy5lZGl0YWJsZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmVkaXRhYmxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ3VwZGF0ZVRpbWUnLCAndXBkYXRlR3JvdXAnLCAnYWRkJywgJ3JlbW92ZSddLCB0aGlzLm9wdGlvbnMuZWRpdGFibGUsIG9wdGlvbnMuZWRpdGFibGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoJ2dyb3VwRWRpdGFibGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ncm91cEVkaXRhYmxlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmdyb3VwRWRpdGFibGUub3JkZXIgID0gb3B0aW9ucy5ncm91cEVkaXRhYmxlO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZ3JvdXBFZGl0YWJsZS5hZGQgICAgPSBvcHRpb25zLmdyb3VwRWRpdGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLnJlbW92ZSA9IG9wdGlvbnMuZ3JvdXBFZGl0YWJsZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmdyb3VwRWRpdGFibGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnb3JkZXInLCAnYWRkJywgJ3JlbW92ZSddLCB0aGlzLm9wdGlvbnMuZ3JvdXBFZGl0YWJsZSwgb3B0aW9ucy5ncm91cEVkaXRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxsYmFjayBmdW5jdGlvbnNcbiAgICB2YXIgYWRkQ2FsbGJhY2sgPSAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBmbiA9IG9wdGlvbnNbbmFtZV07XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgaWYgKCEoZm4gaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbiAnICsgbmFtZSArICcgbXVzdCBiZSBhIGZ1bmN0aW9uICcgKyBuYW1lICsgJyhpdGVtLCBjYWxsYmFjayknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbbmFtZV0gPSBmbjtcbiAgICAgIH1cbiAgICB9KS5iaW5kKHRoaXMpO1xuICAgIFsnb25BZGQnLCAnb25VcGRhdGUnLCAnb25SZW1vdmUnLCAnb25Nb3ZlJywgJ29uTW92aW5nJywgJ29uQWRkR3JvdXAnLCAnb25Nb3ZlR3JvdXAnLCAnb25SZW1vdmVHcm91cCddLmZvckVhY2goYWRkQ2FsbGJhY2spO1xuXG4gICAgLy8gZm9yY2UgdGhlIGl0ZW1TZXQgdG8gcmVmcmVzaDogb3B0aW9ucyBsaWtlIG9yaWVudGF0aW9uIGFuZCBtYXJnaW5zIG1heSBiZSBjaGFuZ2VkXG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYXJrIHRoZSBJdGVtU2V0IGRpcnR5IHNvIGl0IHdpbGwgcmVmcmVzaCBldmVyeXRoaW5nIHdpdGggbmV4dCByZWRyYXcuXG4gKiBPcHRpb25hbGx5LCBhbGwgaXRlbXMgY2FuIGJlIG1hcmtlZCBhcyBkaXJ0eSBhbmQgYmUgcmVmcmVzaGVkLlxuICogQHBhcmFtIHt7cmVmcmVzaEl0ZW1zOiBib29sZWFufX0gW29wdGlvbnNdXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLm1hcmtEaXJ0eSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5ncm91cElkcyA9IFtdO1xuICB0aGlzLnN0YWNrRGlydHkgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVmcmVzaEl0ZW1zKSB7XG4gICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpdGVtLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIGlmIChpdGVtLmRpc3BsYXllZCkgaXRlbS5yZWRyYXcoKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBJdGVtU2V0XG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5oaWRlKCk7XG4gIHRoaXMuc2V0SXRlbXMobnVsbCk7XG4gIHRoaXMuc2V0R3JvdXBzKG51bGwpO1xuXG4gIHRoaXMuaGFtbWVyID0gbnVsbDtcblxuICB0aGlzLmJvZHkgPSBudWxsO1xuICB0aGlzLmNvbnZlcnNpb24gPSBudWxsO1xufTtcblxuLyoqXG4gKiBIaWRlIHRoZSBjb21wb25lbnQgZnJvbSB0aGUgRE9NXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gcmVtb3ZlIHRoZSBmcmFtZSBjb250YWluaW5nIHRoZSBpdGVtc1xuICBpZiAodGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuZG9tLmZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZnJhbWUpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHRoZSBheGlzIHdpdGggZG90c1xuICBpZiAodGhpcy5kb20uYXhpcy5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5kb20uYXhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmF4aXMpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHRoZSBsYWJlbHNldCBjb250YWluaW5nIGFsbCBncm91cCBsYWJlbHNcbiAgaWYgKHRoaXMuZG9tLmxhYmVsU2V0LnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmRvbS5sYWJlbFNldC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmxhYmVsU2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBTaG93IHRoZSBjb21wb25lbnQgaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSB2aXNpYmxlKS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAvLyBzaG93IGZyYW1lIGNvbnRhaW5pbmcgdGhlIGl0ZW1zXG4gIGlmICghdGhpcy5kb20uZnJhbWUucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuYm9keS5kb20uY2VudGVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgfVxuXG4gIC8vIHNob3cgYXhpcyB3aXRoIGRvdHNcbiAgaWYgKCF0aGlzLmRvbS5heGlzLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5heGlzKTtcbiAgfVxuXG4gIC8vIHNob3cgbGFiZWxzZXQgY29udGFpbmluZyBsYWJlbHNcbiAgaWYgKCF0aGlzLmRvbS5sYWJlbFNldC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5ib2R5LmRvbS5sZWZ0LmFwcGVuZENoaWxkKHRoaXMuZG9tLmxhYmVsU2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgc2VsZWN0ZWQgaXRlbXMgYnkgdGhlaXIgaWQuIFJlcGxhY2VzIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICogVW5rbm93biBpZCdzIGFyZSBzaWxlbnRseSBpZ25vcmVkLlxuICogQHBhcmFtIHtzdHJpbmdbXSB8IHN0cmluZ30gW2lkc10gQW4gYXJyYXkgd2l0aCB6ZXJvIG9yIG1vcmUgaWQncyBvZiB0aGUgaXRlbXMgdG8gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLCBvciBhIHNpbmdsZSBpdGVtIGlkLiBJZiBpZHMgaXMgdW5kZWZpbmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhbiBlbXB0eSBhcnJheSwgYWxsIGl0ZW1zIHdpbGwgYmUgdW5zZWxlY3RlZC5cbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oaWRzKSB7XG4gIHZhciBpLCBpaSwgaWQsIGl0ZW07XG5cbiAgaWYgKGlkcyA9PSB1bmRlZmluZWQpIGlkcyA9IFtdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoaWRzKSkgaWRzID0gW2lkc107XG5cbiAgLy8gdW5zZWxlY3QgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zXG4gIGZvciAoaSA9IDAsIGlpID0gdGhpcy5zZWxlY3Rpb24ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlkID0gdGhpcy5zZWxlY3Rpb25baV07XG4gICAgaXRlbSA9IHRoaXMuaXRlbXNbaWRdO1xuICAgIGlmIChpdGVtKSBpdGVtLnVuc2VsZWN0KCk7XG4gIH1cblxuICAvLyBzZWxlY3QgaXRlbXNcbiAgdGhpcy5zZWxlY3Rpb24gPSBbXTtcbiAgZm9yIChpID0gMCwgaWkgPSBpZHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlkID0gaWRzW2ldO1xuICAgIGl0ZW0gPSB0aGlzLml0ZW1zW2lkXTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdGhpcy5zZWxlY3Rpb24ucHVzaChpZCk7XG4gICAgICBpdGVtLnNlbGVjdCgpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNlbGVjdGVkIGl0ZW1zIGJ5IHRoZWlyIGlkXG4gKiBAcmV0dXJuIHtBcnJheX0gaWRzICBUaGUgaWRzIG9mIHRoZSBzZWxlY3RlZCBpdGVtc1xuICovXG5JdGVtU2V0LnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmNvbmNhdChbXSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaWQncyBvZiB0aGUgY3VycmVudGx5IHZpc2libGUgaXRlbXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBpZHMgb2YgdGhlIHZpc2libGUgaXRlbXNcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuZ2V0VmlzaWJsZUl0ZW1zID0gZnVuY3Rpb24oKSB7XG4gIHZhciByYW5nZSA9IHRoaXMuYm9keS5yYW5nZS5nZXRSYW5nZSgpO1xuICB2YXIgbGVmdCAgPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihyYW5nZS5zdGFydCk7XG4gIHZhciByaWdodCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKHJhbmdlLmVuZCk7XG5cbiAgdmFyIGlkcyA9IFtdO1xuICBmb3IgKHZhciBncm91cElkIGluIHRoaXMuZ3JvdXBzKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXBzLmhhc093blByb3BlcnR5KGdyb3VwSWQpKSB7XG4gICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICAgIHZhciByYXdWaXNpYmxlSXRlbXMgPSBncm91cC52aXNpYmxlSXRlbXM7XG5cbiAgICAgIC8vIGZpbHRlciB0aGUgXCJyYXdcIiBzZXQgd2l0aCB2aXNpYmxlSXRlbXMgaW50byBhIHNldCB3aGljaCBpcyByZWFsbHlcbiAgICAgIC8vIHZpc2libGUgYnkgcGl4ZWxzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd1Zpc2libGVJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IHJhd1Zpc2libGVJdGVtc1tpXTtcbiAgICAgICAgLy8gVE9ETzogYWxzbyBjaGVjayB3aGV0aGVyIHZpc2libGUgdmVydGljYWxseVxuICAgICAgICBpZiAoKGl0ZW0ubGVmdCA8IHJpZ2h0KSAmJiAoaXRlbS5sZWZ0ICsgaXRlbS53aWR0aCA+IGxlZnQpKSB7XG4gICAgICAgICAgaWRzLnB1c2goaXRlbS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaWRzO1xufTtcblxuLyoqXG4gKiBEZXNlbGVjdCBhIHNlbGVjdGVkIGl0ZW1cbiAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBpZFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX2Rlc2VsZWN0ID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBzZWxlY3Rpb24ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlmIChzZWxlY3Rpb25baV0gPT0gaWQpIHsgLy8gbm9uLXN0cmljdCBjb21wYXJpc29uIVxuICAgICAgc2VsZWN0aW9uLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBjb21wb25lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtYXJnaW4gPSB0aGlzLm9wdGlvbnMubWFyZ2luLFxuICAgICAgcmFuZ2UgPSB0aGlzLmJvZHkucmFuZ2UsXG4gICAgICBhc1NpemUgPSB1dGlsLm9wdGlvbi5hc1NpemUsXG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgb3JpZW50YXRpb24gPSBvcHRpb25zLm9yaWVudGF0aW9uLml0ZW0sXG4gICAgICByZXNpemVkID0gZmFsc2UsXG4gICAgICBmcmFtZSA9IHRoaXMuZG9tLmZyYW1lO1xuXG4gIC8vIHJlY2FsY3VsYXRlIGFic29sdXRlIHBvc2l0aW9uIChiZWZvcmUgcmVkcmF3aW5nIGdyb3VwcylcbiAgdGhpcy5wcm9wcy50b3AgPSB0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCArIHRoaXMuYm9keS5kb21Qcm9wcy5ib3JkZXIudG9wO1xuICB0aGlzLnByb3BzLmxlZnQgPSB0aGlzLmJvZHkuZG9tUHJvcHMubGVmdC53aWR0aCArIHRoaXMuYm9keS5kb21Qcm9wcy5ib3JkZXIubGVmdDtcblxuICAvLyB1cGRhdGUgY2xhc3MgbmFtZVxuICBmcmFtZS5jbGFzc05hbWUgPSAndmlzLWl0ZW1zZXQnO1xuXG4gIC8vIHJlb3JkZXIgdGhlIGdyb3VwcyAoaWYgbmVlZGVkKVxuICByZXNpemVkID0gdGhpcy5fb3JkZXJHcm91cHMoKSB8fCByZXNpemVkO1xuXG4gIC8vIGNoZWNrIHdoZXRoZXIgem9vbWVkIChpbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byByZS1zdGFjayBldmVyeXRoaW5nKVxuICAvLyBUT0RPOiB3b3VsZCBiZSBuaWNlciB0byBnZXQgdGhpcyBhcyBhIHRyaWdnZXIgZnJvbSBSYW5nZVxuICB2YXIgdmlzaWJsZUludGVydmFsID0gcmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQ7XG4gIHZhciB6b29tZWQgPSAodmlzaWJsZUludGVydmFsICE9IHRoaXMubGFzdFZpc2libGVJbnRlcnZhbCkgfHwgKHRoaXMucHJvcHMud2lkdGggIT0gdGhpcy5wcm9wcy5sYXN0V2lkdGgpO1xuICBpZiAoem9vbWVkKSB0aGlzLnN0YWNrRGlydHkgPSB0cnVlO1xuICB0aGlzLmxhc3RWaXNpYmxlSW50ZXJ2YWwgPSB2aXNpYmxlSW50ZXJ2YWw7XG4gIHRoaXMucHJvcHMubGFzdFdpZHRoID0gdGhpcy5wcm9wcy53aWR0aDtcblxuICB2YXIgcmVzdGFjayA9IHRoaXMuc3RhY2tEaXJ0eTtcbiAgdmFyIGZpcnN0R3JvdXAgPSB0aGlzLl9maXJzdEdyb3VwKCk7XG4gIHZhciBmaXJzdE1hcmdpbiA9IHtcbiAgICBpdGVtOiBtYXJnaW4uaXRlbSxcbiAgICBheGlzOiBtYXJnaW4uYXhpc1xuICB9O1xuICB2YXIgbm9uRmlyc3RNYXJnaW4gPSB7XG4gICAgaXRlbTogbWFyZ2luLml0ZW0sXG4gICAgYXhpczogbWFyZ2luLml0ZW0udmVydGljYWwgLyAyXG4gIH07XG4gIHZhciBoZWlnaHQgPSAwO1xuICB2YXIgbWluSGVpZ2h0ID0gbWFyZ2luLmF4aXMgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcblxuICAvLyByZWRyYXcgdGhlIGJhY2tncm91bmQgZ3JvdXBcbiAgdGhpcy5ncm91cHNbQkFDS0dST1VORF0ucmVkcmF3KHJhbmdlLCBub25GaXJzdE1hcmdpbiwgcmVzdGFjayk7XG5cbiAgLy8gcmVkcmF3IGFsbCByZWd1bGFyIGdyb3Vwc1xuICB1dGlsLmZvckVhY2godGhpcy5ncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgIHZhciBncm91cE1hcmdpbiA9IChncm91cCA9PSBmaXJzdEdyb3VwKSA/IGZpcnN0TWFyZ2luIDogbm9uRmlyc3RNYXJnaW47XG4gICAgdmFyIGdyb3VwUmVzaXplZCA9IGdyb3VwLnJlZHJhdyhyYW5nZSwgZ3JvdXBNYXJnaW4sIHJlc3RhY2spO1xuICAgIHJlc2l6ZWQgPSBncm91cFJlc2l6ZWQgfHwgcmVzaXplZDtcbiAgICBoZWlnaHQgKz0gZ3JvdXAuaGVpZ2h0O1xuICB9KTtcbiAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBtaW5IZWlnaHQpO1xuICB0aGlzLnN0YWNrRGlydHkgPSBmYWxzZTtcblxuICAvLyB1cGRhdGUgZnJhbWUgaGVpZ2h0XG4gIGZyYW1lLnN0eWxlLmhlaWdodCAgPSBhc1NpemUoaGVpZ2h0KTtcblxuICAvLyBjYWxjdWxhdGUgYWN0dWFsIHNpemVcbiAgdGhpcy5wcm9wcy53aWR0aCA9IGZyYW1lLm9mZnNldFdpZHRoO1xuICB0aGlzLnByb3BzLmhlaWdodCA9IGhlaWdodDtcblxuICAvLyByZXBvc2l0aW9uIGF4aXNcbiAgdGhpcy5kb20uYXhpcy5zdHlsZS50b3AgPSBhc1NpemUoKG9yaWVudGF0aW9uID09ICd0b3AnKSA/XG4gICAgICAodGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQgKyB0aGlzLmJvZHkuZG9tUHJvcHMuYm9yZGVyLnRvcCkgOlxuICAgICAgKHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0ICsgdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQpKTtcbiAgdGhpcy5kb20uYXhpcy5zdHlsZS5sZWZ0ID0gJzAnO1xuXG4gIC8vIGNoZWNrIGlmIHRoaXMgY29tcG9uZW50IGlzIHJlc2l6ZWRcbiAgcmVzaXplZCA9IHRoaXMuX2lzUmVzaXplZCgpIHx8IHJlc2l6ZWQ7XG5cbiAgcmV0dXJuIHJlc2l6ZWQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZmlyc3QgZ3JvdXAsIGFsaWduZWQgd2l0aCB0aGUgYXhpc1xuICogQHJldHVybiB7R3JvdXAgfCBudWxsfSBmaXJzdEdyb3VwXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fZmlyc3RHcm91cCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlyc3RHcm91cEluZGV4ID0gKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtID09ICd0b3AnKSA/IDAgOiAodGhpcy5ncm91cElkcy5sZW5ndGggLSAxKTtcbiAgdmFyIGZpcnN0R3JvdXBJZCA9IHRoaXMuZ3JvdXBJZHNbZmlyc3RHcm91cEluZGV4XTtcbiAgdmFyIGZpcnN0R3JvdXAgPSB0aGlzLmdyb3Vwc1tmaXJzdEdyb3VwSWRdIHx8IHRoaXMuZ3JvdXBzW1VOR1JPVVBFRF07XG5cbiAgcmV0dXJuIGZpcnN0R3JvdXAgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIG9yIGRlbGV0ZSB0aGUgZ3JvdXAgaG9sZGluZyBhbGwgdW5ncm91cGVkIGl0ZW1zLiBUaGlzIGdyb3VwIGlzIHVzZWQgd2hlblxuICogdGhlcmUgYXJlIG5vIGdyb3VwcyBzcGVjaWZpZWQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl91cGRhdGVVbmdyb3VwZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHVuZ3JvdXBlZCA9IHRoaXMuZ3JvdXBzW1VOR1JPVVBFRF07XG4gIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5ncm91cHNbQkFDS0dST1VORF07XG4gIHZhciBpdGVtLCBpdGVtSWQ7XG5cbiAgaWYgKHRoaXMuZ3JvdXBzRGF0YSkge1xuICAgIC8vIHJlbW92ZSB0aGUgZ3JvdXAgaG9sZGluZyBhbGwgdW5ncm91cGVkIGl0ZW1zXG4gICAgaWYgKHVuZ3JvdXBlZCkge1xuICAgICAgdW5ncm91cGVkLmhpZGUoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1tVTkdST1VQRURdO1xuXG4gICAgICBmb3IgKGl0ZW1JZCBpbiB0aGlzLml0ZW1zKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zLmhhc093blByb3BlcnR5KGl0ZW1JZCkpIHtcbiAgICAgICAgICBpdGVtID0gdGhpcy5pdGVtc1tpdGVtSWRdO1xuICAgICAgICAgIGl0ZW0ucGFyZW50ICYmIGl0ZW0ucGFyZW50LnJlbW92ZShpdGVtKTtcbiAgICAgICAgICB2YXIgZ3JvdXBJZCA9IHRoaXMuX2dldEdyb3VwSWQoaXRlbS5kYXRhKTtcbiAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICAgICAgICBncm91cCAmJiBncm91cC5hZGQoaXRlbSkgfHwgaXRlbS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gY3JlYXRlIGEgZ3JvdXAgaG9sZGluZyBhbGwgKHVuZmlsdGVyZWQpIGl0ZW1zXG4gICAgaWYgKCF1bmdyb3VwZWQpIHtcbiAgICAgIHZhciBpZCA9IG51bGw7XG4gICAgICB2YXIgZGF0YSA9IG51bGw7XG4gICAgICB1bmdyb3VwZWQgPSBuZXcgR3JvdXAoaWQsIGRhdGEsIHRoaXMpO1xuICAgICAgdGhpcy5ncm91cHNbVU5HUk9VUEVEXSA9IHVuZ3JvdXBlZDtcblxuICAgICAgZm9yIChpdGVtSWQgaW4gdGhpcy5pdGVtcykge1xuICAgICAgICBpZiAodGhpcy5pdGVtcy5oYXNPd25Qcm9wZXJ0eShpdGVtSWQpKSB7XG4gICAgICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbaXRlbUlkXTtcbiAgICAgICAgICB1bmdyb3VwZWQuYWRkKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVuZ3JvdXBlZC5zaG93KCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZWxlbWVudCBmb3IgdGhlIGxhYmVsc2V0XG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gbGFiZWxTZXRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuZ2V0TGFiZWxTZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZG9tLmxhYmVsU2V0O1xufTtcblxuLyoqXG4gKiBTZXQgaXRlbXNcbiAqIEBwYXJhbSB7dmlzLkRhdGFTZXQgfCBudWxsfSBpdGVtc1xuICovXG5JdGVtU2V0LnByb3RvdHlwZS5zZXRJdGVtcyA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gIHZhciBtZSA9IHRoaXMsXG4gICAgICBpZHMsXG4gICAgICBvbGRJdGVtc0RhdGEgPSB0aGlzLml0ZW1zRGF0YTtcblxuICAvLyByZXBsYWNlIHRoZSBkYXRhc2V0XG4gIGlmICghaXRlbXMpIHtcbiAgICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7XG4gIH1cbiAgZWxzZSBpZiAoaXRlbXMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGl0ZW1zIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICB0aGlzLml0ZW1zRGF0YSA9IGl0ZW1zO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBEYXRhU2V0IG9yIERhdGFWaWV3Jyk7XG4gIH1cblxuICBpZiAob2xkSXRlbXNEYXRhKSB7XG4gICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBvbGQgZGF0YXNldFxuICAgIHV0aWwuZm9yRWFjaCh0aGlzLml0ZW1MaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgIG9sZEl0ZW1zRGF0YS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICB9KTtcblxuICAgIC8vIHJlbW92ZSBhbGwgZHJhd24gaXRlbXNcbiAgICBpZHMgPSBvbGRJdGVtc0RhdGEuZ2V0SWRzKCk7XG4gICAgdGhpcy5fb25SZW1vdmUoaWRzKTtcbiAgfVxuXG4gIGlmICh0aGlzLml0ZW1zRGF0YSkge1xuICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbUxpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgbWUuaXRlbXNEYXRhLm9uKGV2ZW50LCBjYWxsYmFjaywgaWQpO1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGFsbCBuZXcgaXRlbXNcbiAgICBpZHMgPSB0aGlzLml0ZW1zRGF0YS5nZXRJZHMoKTtcbiAgICB0aGlzLl9vbkFkZChpZHMpO1xuXG4gICAgLy8gdXBkYXRlIHRoZSBncm91cCBob2xkaW5nIGFsbCB1bmdyb3VwZWQgaXRlbXNcbiAgICB0aGlzLl91cGRhdGVVbmdyb3VwZWQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgaXRlbXNcbiAqIEByZXR1cm5zIHt2aXMuRGF0YVNldCB8IG51bGx9XG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLmdldEl0ZW1zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLml0ZW1zRGF0YTtcbn07XG5cbi8qKlxuICogU2V0IGdyb3Vwc1xuICogQHBhcmFtIHt2aXMuRGF0YVNldH0gZ3JvdXBzXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLnNldEdyb3VwcyA9IGZ1bmN0aW9uKGdyb3Vwcykge1xuICB2YXIgbWUgPSB0aGlzLFxuICAgICAgaWRzO1xuXG4gIC8vIHVuc3Vic2NyaWJlIGZyb20gY3VycmVudCBkYXRhc2V0XG4gIGlmICh0aGlzLmdyb3Vwc0RhdGEpIHtcbiAgICB1dGlsLmZvckVhY2godGhpcy5ncm91cExpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgbWUuZ3JvdXBzRGF0YS5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICB9KTtcblxuICAgIC8vIHJlbW92ZSBhbGwgZHJhd24gZ3JvdXBzXG4gICAgaWRzID0gdGhpcy5ncm91cHNEYXRhLmdldElkcygpO1xuICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG51bGw7XG4gICAgdGhpcy5fb25SZW1vdmVHcm91cHMoaWRzKTsgLy8gbm90ZTogdGhpcyB3aWxsIGNhdXNlIGEgcmVkcmF3XG4gIH1cblxuICAvLyByZXBsYWNlIHRoZSBkYXRhc2V0XG4gIGlmICghZ3JvdXBzKSB7XG4gICAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDtcbiAgfVxuICBlbHNlIGlmIChncm91cHMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGdyb3VwcyBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgdGhpcy5ncm91cHNEYXRhID0gZ3JvdXBzO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBEYXRhU2V0IG9yIERhdGFWaWV3Jyk7XG4gIH1cblxuICBpZiAodGhpcy5ncm91cHNEYXRhKSB7XG4gICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICB1dGlsLmZvckVhY2godGhpcy5ncm91cExpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgbWUuZ3JvdXBzRGF0YS5vbihldmVudCwgY2FsbGJhY2ssIGlkKTtcbiAgICB9KTtcblxuICAgIC8vIGRyYXcgYWxsIG1zXG4gICAgaWRzID0gdGhpcy5ncm91cHNEYXRhLmdldElkcygpO1xuICAgIHRoaXMuX29uQWRkR3JvdXBzKGlkcyk7XG4gIH1cblxuICAvLyB1cGRhdGUgdGhlIGdyb3VwIGhvbGRpbmcgYWxsIHVuZ3JvdXBlZCBpdGVtc1xuICB0aGlzLl91cGRhdGVVbmdyb3VwZWQoKTtcblxuICAvLyB1cGRhdGUgdGhlIG9yZGVyIG9mIGFsbCBpdGVtcyBpbiBlYWNoIGdyb3VwXG4gIHRoaXMuX29yZGVyKCk7XG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywge3F1ZXVlOiB0cnVlfSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBncm91cHNcbiAqIEByZXR1cm5zIHt2aXMuRGF0YVNldCB8IG51bGx9IGdyb3Vwc1xuICovXG5JdGVtU2V0LnByb3RvdHlwZS5nZXRHcm91cHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZ3JvdXBzRGF0YTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gYnkgaXRzIGlkXG4gKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gaWRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBpdGVtID0gdGhpcy5pdGVtc0RhdGEuZ2V0KGlkKSxcbiAgICAgIGRhdGFzZXQgPSB0aGlzLml0ZW1zRGF0YS5nZXREYXRhU2V0KCk7XG5cbiAgaWYgKGl0ZW0pIHtcbiAgICAvLyBjb25maXJtIGRlbGV0aW9uXG4gICAgdGhpcy5vcHRpb25zLm9uUmVtb3ZlKGl0ZW0sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICAvLyByZW1vdmUgYnkgaWQgaGVyZSwgaXQgaXMgcG9zc2libGUgdGhhdCBhbiBpdGVtIGhhcyBubyBpZCBkZWZpbmVkXG4gICAgICAgIC8vIGl0c2VsZiwgc28gYmV0dGVyIG5vdCBkZWxldGUgYnkgdGhlIGl0ZW0gaXRzZWxmXG4gICAgICAgIGRhdGFzZXQucmVtb3ZlKGlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHRpbWUgb2YgYW4gaXRlbSBiYXNlZCBvbiBpdCdzIGRhdGEgYW5kIG9wdGlvbnMudHlwZVxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW1EYXRhXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fZ2V0VHlwZSA9IGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICByZXR1cm4gaXRlbURhdGEudHlwZSB8fCB0aGlzLm9wdGlvbnMudHlwZSB8fCAoaXRlbURhdGEuZW5kID8gJ3JhbmdlJyA6ICdib3gnKTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGdyb3VwIGlkIGZvciBhbiBpdGVtXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbURhdGFcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGdyb3VwSWRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9nZXRHcm91cElkID0gZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG4gIHZhciB0eXBlID0gdGhpcy5fZ2V0VHlwZShpdGVtRGF0YSk7XG4gIGlmICh0eXBlID09ICdiYWNrZ3JvdW5kJyAmJiBpdGVtRGF0YS5ncm91cCA9PSB1bmRlZmluZWQpIHtcbiAgIHJldHVybiBCQUNLR1JPVU5EO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmdyb3Vwc0RhdGEgPyBpdGVtRGF0YS5ncm91cCA6IFVOR1JPVVBFRDtcbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgdXBkYXRlZCBpdGVtc1xuICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vblVwZGF0ZSA9IGZ1bmN0aW9uKGlkcykge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtRGF0YSA9IG1lLml0ZW1zRGF0YS5nZXQoaWQsIG1lLml0ZW1PcHRpb25zKTtcbiAgICB2YXIgaXRlbSA9IG1lLml0ZW1zW2lkXTtcbiAgICB2YXIgdHlwZSA9IG1lLl9nZXRUeXBlKGl0ZW1EYXRhKTtcblxuICAgIHZhciBjb25zdHJ1Y3RvciA9IEl0ZW1TZXQudHlwZXNbdHlwZV07XG4gICAgdmFyIHNlbGVjdGVkO1xuXG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIC8vIHVwZGF0ZSBpdGVtXG4gICAgICBpZiAoIWNvbnN0cnVjdG9yIHx8ICEoaXRlbSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSkge1xuICAgICAgICAvLyBpdGVtIHR5cGUgaGFzIGNoYW5nZWQsIGRlbGV0ZSB0aGUgaXRlbSBhbmQgcmVjcmVhdGUgaXRcbiAgICAgICAgc2VsZWN0ZWQgPSBpdGVtLnNlbGVjdGVkOyAvLyBwcmVzZXJ2ZSBzZWxlY3Rpb24gb2YgdGhpcyBpdGVtXG4gICAgICAgIG1lLl9yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICBpdGVtID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtZS5fdXBkYXRlSXRlbShpdGVtLCBpdGVtRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICAvLyBjcmVhdGUgaXRlbVxuICAgICAgaWYgKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGl0ZW0gPSBuZXcgY29uc3RydWN0b3IoaXRlbURhdGEsIG1lLmNvbnZlcnNpb24sIG1lLm9wdGlvbnMpO1xuICAgICAgICBpdGVtLmlkID0gaWQ7IC8vIFRPRE86IG5vdCBzbyBuaWNlIHNldHRpbmcgaWQgYWZ0ZXJ3YXJkc1xuICAgICAgICBtZS5fYWRkSXRlbShpdGVtKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb24ucHVzaChpZCk7XG4gICAgICAgICAgaXRlbS5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZSA9PSAncmFuZ2VvdmVyZmxvdycpIHtcbiAgICAgICAgLy8gVE9ETzogZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS4wIChvciAzLjAuMD8pLiBjbGVhbnVwIHNvbWUgZGF5XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0l0ZW0gdHlwZSBcInJhbmdlb3ZlcmZsb3dcIiBpcyBkZXByZWNhdGVkLiBVc2UgY3NzIHN0eWxpbmcgaW5zdGVhZDogJyArXG4gICAgICAgICAgICAnLnZpcy1pdGVtLnZpcy1yYW5nZSAudmlzLWl0ZW0tY29udGVudCB7b3ZlcmZsb3c6IHZpc2libGU7fScpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gaXRlbSB0eXBlIFwiJyArIHR5cGUgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgdGhpcy5fb3JkZXIoKTtcbiAgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTsgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHtxdWV1ZTogdHJ1ZX0pO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgYWRkZWQgaXRlbXNcbiAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICogQHByb3RlY3RlZFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25BZGQgPSBJdGVtU2V0LnByb3RvdHlwZS5fb25VcGRhdGU7XG5cbi8qKlxuICogSGFuZGxlIHJlbW92ZWQgaXRlbXNcbiAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICogQHByb3RlY3RlZFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25SZW1vdmUgPSBmdW5jdGlvbihpZHMpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIG1lID0gdGhpcztcbiAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBtZS5pdGVtc1tpZF07XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNvdW50Kys7XG4gICAgICBtZS5fcmVtb3ZlSXRlbShpdGVtKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChjb3VudCkge1xuICAgIC8vIHVwZGF0ZSBvcmRlclxuICAgIHRoaXMuX29yZGVyKCk7XG4gICAgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTsgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywge3F1ZXVlOiB0cnVlfSk7XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBvcmRlciBvZiBpdGVtIGluIGFsbCBncm91cHNcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vcmRlciA9IGZ1bmN0aW9uKCkge1xuICAvLyByZW9yZGVyIHRoZSBpdGVtcyBpbiBhbGwgZ3JvdXBzXG4gIC8vIFRPRE86IG9wdGltaXphdGlvbjogb25seSByZW9yZGVyIGdyb3VwcyBhZmZlY3RlZCBieSB0aGUgY2hhbmdlZCBpdGVtc1xuICB1dGlsLmZvckVhY2godGhpcy5ncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgIGdyb3VwLm9yZGVyKCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgdXBkYXRlZCBncm91cHNcbiAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uVXBkYXRlR3JvdXBzID0gZnVuY3Rpb24oaWRzKSB7XG4gIHRoaXMuX29uQWRkR3JvdXBzKGlkcyk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBjaGFuZ2VkIGdyb3VwcyAoYWRkZWQgb3IgdXBkYXRlZClcbiAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uQWRkR3JvdXBzID0gZnVuY3Rpb24oaWRzKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGdyb3VwRGF0YSA9IG1lLmdyb3Vwc0RhdGEuZ2V0KGlkKTtcbiAgICB2YXIgZ3JvdXAgPSBtZS5ncm91cHNbaWRdO1xuXG4gICAgaWYgKCFncm91cCkge1xuICAgICAgLy8gY2hlY2sgZm9yIHJlc2VydmVkIGlkc1xuICAgICAgaWYgKGlkID09IFVOR1JPVVBFRCB8fCBpZCA9PSBCQUNLR1JPVU5EKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBncm91cCBpZC4gJyArIGlkICsgJyBpcyBhIHJlc2VydmVkIGlkLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ3JvdXBPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShtZS5vcHRpb25zKTtcbiAgICAgIHV0aWwuZXh0ZW5kKGdyb3VwT3B0aW9ucywge1xuICAgICAgICBoZWlnaHQ6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBncm91cCA9IG5ldyBHcm91cChpZCwgZ3JvdXBEYXRhLCBtZSk7XG4gICAgICBtZS5ncm91cHNbaWRdID0gZ3JvdXA7XG5cbiAgICAgIC8vIGFkZCBpdGVtcyB3aXRoIHRoaXMgZ3JvdXBJZCB0byB0aGUgbmV3IGdyb3VwXG4gICAgICBmb3IgKHZhciBpdGVtSWQgaW4gbWUuaXRlbXMpIHtcbiAgICAgICAgaWYgKG1lLml0ZW1zLmhhc093blByb3BlcnR5KGl0ZW1JZCkpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IG1lLml0ZW1zW2l0ZW1JZF07XG4gICAgICAgICAgaWYgKGl0ZW0uZGF0YS5ncm91cCA9PSBpZCkge1xuICAgICAgICAgICAgZ3JvdXAuYWRkKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBncm91cC5vcmRlcigpO1xuICAgICAgZ3JvdXAuc2hvdygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZSBncm91cFxuICAgICAgZ3JvdXAuc2V0RGF0YShncm91cERhdGEpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywge3F1ZXVlOiB0cnVlfSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSByZW1vdmVkIGdyb3Vwc1xuICogQHBhcmFtIHtOdW1iZXJbXX0gaWRzXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25SZW1vdmVHcm91cHMgPSBmdW5jdGlvbihpZHMpIHtcbiAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZ3JvdXAgPSBncm91cHNbaWRdO1xuXG4gICAgaWYgKGdyb3VwKSB7XG4gICAgICBncm91cC5oaWRlKCk7XG4gICAgICBkZWxldGUgZ3JvdXBzW2lkXTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMubWFya0RpcnR5KCk7XG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywge3F1ZXVlOiB0cnVlfSk7XG59O1xuXG4vKipcbiAqIFJlb3JkZXIgdGhlIGdyb3VwcyBpZiBuZWVkZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGNoYW5nZWRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vcmRlckdyb3VwcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZ3JvdXBzRGF0YSkge1xuICAgIC8vIHJlb3JkZXIgdGhlIGdyb3Vwc1xuICAgIHZhciBncm91cElkcyA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoe1xuICAgICAgb3JkZXI6IHRoaXMub3B0aW9ucy5ncm91cE9yZGVyXG4gICAgfSk7XG5cbiAgICB2YXIgY2hhbmdlZCA9ICF1dGlsLmVxdWFsQXJyYXkoZ3JvdXBJZHMsIHRoaXMuZ3JvdXBJZHMpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAvLyBoaWRlIGFsbCBncm91cHMsIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBET01cbiAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcbiAgICAgIGdyb3VwSWRzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICAgICAgZ3JvdXBzW2dyb3VwSWRdLmhpZGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBzaG93IHRoZSBncm91cHMgYWdhaW4sIGF0dGFjaCB0aGVtIHRvIHRoZSBET00gaW4gY29ycmVjdCBvcmRlclxuICAgICAgZ3JvdXBJZHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXBJZCkge1xuICAgICAgICBncm91cHNbZ3JvdXBJZF0uc2hvdygpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZ3JvdXBJZHMgPSBncm91cElkcztcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGEgbmV3IGl0ZW1cbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX2FkZEl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gIHRoaXMuaXRlbXNbaXRlbS5pZF0gPSBpdGVtO1xuXG4gIC8vIGFkZCB0byBncm91cFxuICB2YXIgZ3JvdXBJZCA9IHRoaXMuX2dldEdyb3VwSWQoaXRlbS5kYXRhKTtcbiAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gIGlmIChncm91cCkgZ3JvdXAuYWRkKGl0ZW0pO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgYW4gZXhpc3RpbmcgaXRlbVxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbURhdGFcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl91cGRhdGVJdGVtID0gZnVuY3Rpb24oaXRlbSwgaXRlbURhdGEpIHtcbiAgdmFyIG9sZEdyb3VwSWQgPSBpdGVtLmRhdGEuZ3JvdXA7XG4gIHZhciBvbGRTdWJHcm91cElkID0gaXRlbS5kYXRhLnN1Ymdyb3VwO1xuXG4gIC8vIHVwZGF0ZSB0aGUgaXRlbXMgZGF0YSAod2lsbCByZWRyYXcgdGhlIGl0ZW0gd2hlbiBkaXNwbGF5ZWQpXG4gIGl0ZW0uc2V0RGF0YShpdGVtRGF0YSk7XG5cbiAgLy8gdXBkYXRlIGdyb3VwXG4gIGlmIChvbGRHcm91cElkICE9IGl0ZW0uZGF0YS5ncm91cCB8fCBvbGRTdWJHcm91cElkICE9IGl0ZW0uZGF0YS5zdWJncm91cCkge1xuICAgIHZhciBvbGRHcm91cCA9IHRoaXMuZ3JvdXBzW29sZEdyb3VwSWRdO1xuICAgIGlmIChvbGRHcm91cCkgb2xkR3JvdXAucmVtb3ZlKGl0ZW0pO1xuXG4gICAgdmFyIGdyb3VwSWQgPSB0aGlzLl9nZXRHcm91cElkKGl0ZW0uZGF0YSk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gICAgaWYgKGdyb3VwKSBncm91cC5hZGQoaXRlbSk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVsZXRlIGFuIGl0ZW0gZnJvbSB0aGUgSXRlbVNldDogcmVtb3ZlIGl0IGZyb20gdGhlIERPTSwgZnJvbSB0aGUgbWFwXG4gKiB3aXRoIGl0ZW1zLCBhbmQgZnJvbSB0aGUgbWFwIHdpdGggdmlzaWJsZSBpdGVtcywgYW5kIGZyb20gdGhlIHNlbGVjdGlvblxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgLy8gcmVtb3ZlIGZyb20gRE9NXG4gIGl0ZW0uaGlkZSgpO1xuXG4gIC8vIHJlbW92ZSBmcm9tIGl0ZW1zXG4gIGRlbGV0ZSB0aGlzLml0ZW1zW2l0ZW0uaWRdO1xuXG4gIC8vIHJlbW92ZSBmcm9tIHNlbGVjdGlvblxuICB2YXIgaW5kZXggPSB0aGlzLnNlbGVjdGlvbi5pbmRleE9mKGl0ZW0uaWQpO1xuICBpZiAoaW5kZXggIT0gLTEpIHRoaXMuc2VsZWN0aW9uLnNwbGljZShpbmRleCwgMSk7XG5cbiAgLy8gcmVtb3ZlIGZyb20gZ3JvdXBcbiAgaXRlbS5wYXJlbnQgJiYgaXRlbS5wYXJlbnQucmVtb3ZlKGl0ZW0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgaXRlbXMgYmVpbmcgYSByYW5nZSAoaGF2aW5nIGFuIGVuZCBkYXRlKVxuICogQHBhcmFtIGFycmF5XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fY29uc3RydWN0QnlFbmRBcnJheSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gIHZhciBlbmRBcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV0gaW5zdGFuY2VvZiBSYW5nZUl0ZW0pIHtcbiAgICAgIGVuZEFycmF5LnB1c2goYXJyYXlbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kQXJyYXk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBjbGlja2VkIGl0ZW0gb24gdG91Y2gsIGJlZm9yZSBkcmFnU3RhcnQgaXMgaW5pdGlhdGVkLlxuICpcbiAqIGRyYWdTdGFydCBpcyBpbml0aWF0ZWQgZnJvbSBhIG1vdXNlbW92ZSBldmVudCwgQUZURVIgdGhlIG1vdXNlL3RvdWNoIGlzXG4gKiBhbHJlYWR5IG1vdmluZy4gVGhlcmVmb3JlLCB0aGUgbW91c2UvdG91Y2ggY2FuIHNvbWV0aW1lcyBiZSBhYm92ZSBhbiBvdGhlclxuICogRE9NIGVsZW1lbnQgdGhhbiB0aGUgaXRlbSBpdHNlbGYuXG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vblRvdWNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIHN0b3JlIHRoZSB0b3VjaGVkIGl0ZW0sIHVzZWQgaW4gX29uRHJhZ1N0YXJ0XG4gIHRoaXMudG91Y2hQYXJhbXMuaXRlbSA9IHRoaXMuaXRlbUZyb21UYXJnZXQoZXZlbnQpO1xuICB0aGlzLnRvdWNoUGFyYW1zLmRyYWdMZWZ0SXRlbSA9IGV2ZW50LnRhcmdldC5kcmFnTGVmdEl0ZW0gfHwgZmFsc2U7XG4gIHRoaXMudG91Y2hQYXJhbXMuZHJhZ1JpZ2h0SXRlbSA9IGV2ZW50LnRhcmdldC5kcmFnUmlnaHRJdGVtIHx8IGZhbHNlO1xuICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA9IG51bGw7XG59O1xuXG5cbi8qKlxuICogR2l2ZW4gYW4gZ3JvdXAgaWQsIHJldHVybnMgdGhlIGluZGV4IGl0IGhhcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZ3JvdXBJRFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX2dldEdyb3VwSW5kZXggPSBmdW5jdGlvbihncm91cElkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChncm91cElkID09IHRoaXMuZ3JvdXBJZHNbaV0pXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0IGRyYWdnaW5nIHRoZSBzZWxlY3RlZCBldmVudHNcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLnRvdWNoUGFyYW1zLml0ZW0gfHwgbnVsbDtcbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIHByb3BzO1xuXG4gIGlmIChpdGVtICYmIGl0ZW0uc2VsZWN0ZWQpIHtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgJiZcbiAgICAgICAgIXRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCAmJlxuICAgICAgICAhaXRlbS5lZGl0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG92ZXJyaWRlIG9wdGlvbnMuZWRpdGFibGVcbiAgICBpZiAoaXRlbS5lZGl0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZHJhZ0xlZnRJdGVtID0gdGhpcy50b3VjaFBhcmFtcy5kcmFnTGVmdEl0ZW07XG4gICAgdmFyIGRyYWdSaWdodEl0ZW0gPSB0aGlzLnRvdWNoUGFyYW1zLmRyYWdSaWdodEl0ZW07XG5cbiAgICBpZiAoZHJhZ0xlZnRJdGVtKSB7XG4gICAgICBwcm9wcyA9IHtcbiAgICAgICAgaXRlbTogZHJhZ0xlZnRJdGVtLFxuICAgICAgICBpbml0aWFsWDogZXZlbnQuY2VudGVyLngsXG4gICAgICAgIGRyYWdMZWZ0OiAgdHJ1ZSxcbiAgICAgICAgZGF0YTogdGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtLmRhdGEpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA9IFtwcm9wc107XG4gICAgfVxuICAgIGVsc2UgaWYgKGRyYWdSaWdodEl0ZW0pIHtcbiAgICAgIHByb3BzID0ge1xuICAgICAgICBpdGVtOiBkcmFnUmlnaHRJdGVtLFxuICAgICAgICBpbml0aWFsWDogZXZlbnQuY2VudGVyLngsXG4gICAgICAgIGRyYWdSaWdodDogdHJ1ZSxcbiAgICAgICAgZGF0YTogdGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtLmRhdGEpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA9IFtwcm9wc107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy50b3VjaFBhcmFtcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuXG4gICAgICB2YXIgYmFzZUdyb3VwSW5kZXggPSB0aGlzLl9nZXRHcm91cEluZGV4KGl0ZW0uZGF0YS5ncm91cCk7XG5cbiAgICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gdGhpcy5nZXRTZWxlY3Rpb24oKS5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBpdGVtID0gbWUuaXRlbXNbaWRdO1xuICAgICAgICB2YXIgZ3JvdXBJbmRleCA9IG1lLl9nZXRHcm91cEluZGV4KGl0ZW0uZGF0YS5ncm91cCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICBpbml0aWFsWDogZXZlbnQuY2VudGVyLngsXG4gICAgICAgICAgZ3JvdXBPZmZzZXQ6IGJhc2VHcm91cEluZGV4LWdyb3VwSW5kZXgsXG4gICAgICAgICAgZGF0YTogdGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtLmRhdGEpXG4gICAgICAgIH07XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG4gIGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lZGl0YWJsZS5hZGQgJiYgKGV2ZW50LnNyY0V2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc3JjRXZlbnQubWV0YUtleSkpIHtcbiAgICAvLyBjcmVhdGUgYSBuZXcgcmFuZ2UgaXRlbSB3aGVuIGRyYWdnaW5nIHdpdGggY3RybCBrZXkgZG93blxuICAgIHRoaXMuX29uRHJhZ1N0YXJ0QWRkSXRlbShldmVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnQgY3JlYXRpbmcgYSBuZXcgcmFuZ2UgaXRlbSBieSBkcmFnZ2luZy5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25EcmFnU3RhcnRBZGRJdGVtID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBzbmFwID0gdGhpcy5vcHRpb25zLnNuYXAgfHwgbnVsbDtcbiAgdmFyIHhBYnMgPSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmRvbS5mcmFtZSk7XG4gIHZhciB4ID0gZXZlbnQuY2VudGVyLnggLSB4QWJzIC0gMTA7ICAvLyBtaW51cyAxMCB0byBjb21wZW5zYXRlIGZvciB0aGUgZHJhZyBzdGFydGluZyBhcyBzb29uIGFzIHlvdSd2ZSBtb3ZlZCAxMHB4XG4gIHZhciB0aW1lID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHgpO1xuICB2YXIgc2NhbGUgPSB0aGlzLmJvZHkudXRpbC5nZXRTY2FsZSgpO1xuICB2YXIgc3RlcCA9IHRoaXMuYm9keS51dGlsLmdldFN0ZXAoKTtcbiAgdmFyIHN0YXJ0ID0gc25hcCA/IHNuYXAodGltZSwgc2NhbGUsIHN0ZXApIDogc3RhcnQ7XG4gIHZhciBlbmQgPSBzdGFydDtcblxuICB2YXIgaXRlbURhdGEgPSB7XG4gICAgdHlwZTogJ3JhbmdlJyxcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmQsXG4gICAgY29udGVudDogJ25ldyBpdGVtJ1xuICB9O1xuXG4gIHZhciBpZCA9IHV0aWwucmFuZG9tVVVJRCgpO1xuICBpdGVtRGF0YVt0aGlzLml0ZW1zRGF0YS5fZmllbGRJZF0gPSBpZDtcblxuICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwRnJvbVRhcmdldChldmVudCk7XG4gIGlmIChncm91cCkge1xuICAgIGl0ZW1EYXRhLmdyb3VwID0gZ3JvdXAuZ3JvdXBJZDtcbiAgfVxuXG4gIHZhciBuZXdJdGVtID0gbmV3IFJhbmdlSXRlbShpdGVtRGF0YSwgdGhpcy5jb252ZXJzaW9uLCB0aGlzLm9wdGlvbnMpO1xuICBuZXdJdGVtLmlkID0gaWQ7IC8vIFRPRE86IG5vdCBzbyBuaWNlIHNldHRpbmcgaWQgYWZ0ZXJ3YXJkc1xuICBuZXdJdGVtLmRhdGEgPSB0aGlzLl9jbG9uZUl0ZW1EYXRhKGl0ZW1EYXRhKTtcbiAgdGhpcy5fYWRkSXRlbShuZXdJdGVtKTtcblxuICB2YXIgcHJvcHMgPSB7XG4gICAgaXRlbTogbmV3SXRlbSxcbiAgICBkcmFnUmlnaHQ6IHRydWUsXG4gICAgaW5pdGlhbFg6IGV2ZW50LmNlbnRlci54LFxuICAgIGRhdGE6IG5ld0l0ZW0uZGF0YVxuICB9O1xuICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA9IFtwcm9wc107XG5cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuXG4vKipcbiAqIERyYWcgc2VsZWN0ZWQgaXRlbXNcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICh0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcykge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgc25hcCA9IHRoaXMub3B0aW9ucy5zbmFwIHx8IG51bGw7XG4gICAgdmFyIHhPZmZzZXQgPSB0aGlzLmJvZHkuZG9tLnJvb3Qub2Zmc2V0TGVmdCArIHRoaXMuYm9keS5kb21Qcm9wcy5sZWZ0LndpZHRoO1xuICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS51dGlsLmdldFNjYWxlKCk7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLmJvZHkudXRpbC5nZXRTdGVwKCk7XG5cbiAgICAvL29ubHkgY2FsY3VsYXRlIHRoZSBuZXcgZ3JvdXAgZm9yIHRoZSBpdGVtIHRoYXQncyBhY3R1YWxseSBkcmFnZ2VkXG4gICAgdmFyIHNlbGVjdGVkSXRlbSA9IHRoaXMudG91Y2hQYXJhbXMuc2VsZWN0ZWRJdGVtO1xuICAgIHZhciB1cGRhdGVHcm91cEFsbG93ZWQgPSBtZS5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZUdyb3VwO1xuICAgIHZhciBuZXdHcm91cEJhc2UgPSBudWxsO1xuICAgIGlmICh1cGRhdGVHcm91cEFsbG93ZWQgJiYgc2VsZWN0ZWRJdGVtKSB7XG4gICAgICBpZiAoc2VsZWN0ZWRJdGVtLmRhdGEuZ3JvdXAgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGRyYWcgZnJvbSBvbmUgZ3JvdXAgdG8gYW5vdGhlclxuICAgICAgICB2YXIgZ3JvdXAgPSBtZS5ncm91cEZyb21UYXJnZXQoZXZlbnQpO1xuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAvL3dlIGtub3cgdGhlIG9mZnNldCBmb3IgYWxsIGl0ZW1zLCBzbyB0aGUgbmV3IGdyb3VwIGZvciBhbGwgaXRlbXNcbiAgICAgICAgICAvL3dpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcyBvbmUuXG4gICAgICAgICAgbmV3R3JvdXBCYXNlID0gdGhpcy5fZ2V0R3JvdXBJbmRleChncm91cC5ncm91cElkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1vdmVcbiAgICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBtZS5ib2R5LnV0aWwudG9UaW1lKGV2ZW50LmNlbnRlci54IC0geE9mZnNldCk7XG4gICAgICB2YXIgaW5pdGlhbCA9IG1lLmJvZHkudXRpbC50b1RpbWUocHJvcHMuaW5pdGlhbFggLSB4T2Zmc2V0KTtcbiAgICAgIHZhciBvZmZzZXQgPSBjdXJyZW50IC0gaW5pdGlhbDsgLy8gbXNcblxuICAgICAgdmFyIGl0ZW1EYXRhID0gdGhpcy5fY2xvbmVJdGVtRGF0YShwcm9wcy5pdGVtLmRhdGEpOyAvLyBjbG9uZSB0aGUgZGF0YVxuICAgICAgaWYgKHByb3BzLml0ZW0uZWRpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZVRpbWVBbGxvd2VkID0gbWUub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lIHx8XG4gICAgICAgICAgcHJvcHMuaXRlbS5lZGl0YWJsZSA9PT0gdHJ1ZTtcblxuICAgICAgaWYgKHVwZGF0ZVRpbWVBbGxvd2VkKSB7XG4gICAgICAgIGlmIChwcm9wcy5kcmFnTGVmdCkge1xuICAgICAgICAgIC8vIGRyYWcgbGVmdCBzaWRlIG9mIGEgcmFuZ2UgaXRlbVxuICAgICAgICAgIGlmIChpdGVtRGF0YS5zdGFydCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBpbml0aWFsU3RhcnQgPSB1dGlsLmNvbnZlcnQocHJvcHMuZGF0YS5zdGFydCwgJ0RhdGUnKTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGluaXRpYWxTdGFydC52YWx1ZU9mKCkgKyBvZmZzZXQpO1xuICAgICAgICAgICAgLy8gVE9ETzogcGFzcyBhIE1vbWVudCBpbnN0ZWFkIG9mIGEgRGF0ZSB0byBzbmFwKCkuIChCcmVha2luZyBjaGFuZ2UpXG4gICAgICAgICAgICBpdGVtRGF0YS5zdGFydCA9IHNuYXAgPyBzbmFwKHN0YXJ0LCBzY2FsZSwgc3RlcCkgOiBzdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvcHMuZHJhZ1JpZ2h0KSB7XG4gICAgICAgICAgLy8gZHJhZyByaWdodCBzaWRlIG9mIGEgcmFuZ2UgaXRlbVxuICAgICAgICAgIGlmIChpdGVtRGF0YS5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbEVuZCA9IHV0aWwuY29udmVydChwcm9wcy5kYXRhLmVuZCwgJ0RhdGUnKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBuZXcgRGF0ZShpbml0aWFsRW5kLnZhbHVlT2YoKSArIG9mZnNldCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGEgTW9tZW50IGluc3RlYWQgb2YgYSBEYXRlIHRvIHNuYXAoKS4gKEJyZWFraW5nIGNoYW5nZSlcbiAgICAgICAgICAgIGl0ZW1EYXRhLmVuZCA9IHNuYXAgPyBzbmFwKGVuZCwgc2NhbGUsIHN0ZXApIDogZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBkcmFnIGJvdGggc3RhcnQgYW5kIGVuZFxuICAgICAgICAgIGlmIChpdGVtRGF0YS5zdGFydCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBpbml0aWFsU3RhcnQgPSB1dGlsLmNvbnZlcnQocHJvcHMuZGF0YS5zdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZShpbml0aWFsU3RhcnQgKyBvZmZzZXQpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbURhdGEuZW5kICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgaW5pdGlhbEVuZCA9IHV0aWwuY29udmVydChwcm9wcy5kYXRhLmVuZCwgJ0RhdGUnKTtcbiAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uICA9IGluaXRpYWxFbmQudmFsdWVPZigpIC0gaW5pdGlhbFN0YXJ0LnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGEgTW9tZW50IGluc3RlYWQgb2YgYSBEYXRlIHRvIHNuYXAoKS4gKEJyZWFraW5nIGNoYW5nZSlcbiAgICAgICAgICAgICAgaXRlbURhdGEuc3RhcnQgPSBzbmFwID8gc25hcChzdGFydCwgc2NhbGUsIHN0ZXApIDogc3RhcnQ7XG4gICAgICAgICAgICAgIGl0ZW1EYXRhLmVuZCAgID0gbmV3IERhdGUoaXRlbURhdGEuc3RhcnQudmFsdWVPZigpICsgZHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFRPRE86IHBhc3MgYSBNb21lbnQgaW5zdGVhZCBvZiBhIERhdGUgdG8gc25hcCgpLiAoQnJlYWtpbmcgY2hhbmdlKVxuICAgICAgICAgICAgICBpdGVtRGF0YS5zdGFydCA9IHNuYXAgPyBzbmFwKHN0YXJ0LCBzY2FsZSwgc3RlcCkgOiBzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZUdyb3VwQWxsb3dlZCA9IG1lLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgfHxcbiAgICAgICAgICBwcm9wcy5pdGVtLmVkaXRhYmxlID09PSB0cnVlO1xuXG4gICAgICBpZiAodXBkYXRlR3JvdXBBbGxvd2VkICYmICghcHJvcHMuZHJhZ0xlZnQgJiYgIXByb3BzLmRyYWdSaWdodCkgJiYgbmV3R3JvdXBCYXNlIT1udWxsKSB7XG4gICAgICAgIGlmIChpdGVtRGF0YS5ncm91cCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbmV3T2Zmc2V0ID0gbmV3R3JvdXBCYXNlIC0gcHJvcHMuZ3JvdXBPZmZzZXQ7XG5cbiAgICAgICAgICAvL21ha2Ugc3VyZSB3ZSBzdGF5IGluIGJvdW5kc1xuICAgICAgICAgIG5ld09mZnNldCA9IE1hdGgubWF4KDAsIG5ld09mZnNldCk7XG4gICAgICAgICAgbmV3T2Zmc2V0ID0gTWF0aC5taW4obWUuZ3JvdXBJZHMubGVuZ3RoLTEsIG5ld09mZnNldCk7XG5cbiAgICAgICAgICBpdGVtRGF0YS5ncm91cCA9IG1lLmdyb3VwSWRzW25ld09mZnNldF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY29uZmlybSBtb3ZpbmcgdGhlIGl0ZW1cbiAgICAgIGl0ZW1EYXRhID0gdGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtRGF0YSk7ICAvLyBjb252ZXJ0IHN0YXJ0IGFuZCBlbmQgdG8gdGhlIGNvcnJlY3QgdHlwZVxuICAgICAgbWUub3B0aW9ucy5vbk1vdmluZyhpdGVtRGF0YSwgZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG4gICAgICAgIGlmIChpdGVtRGF0YSkge1xuICAgICAgICAgIHByb3BzLml0ZW0uc2V0RGF0YSh0aGlzLl9jbG9uZUl0ZW1EYXRhKGl0ZW1EYXRhLCAnRGF0ZScpKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTsgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogTW92ZSBhbiBpdGVtIHRvIGFub3RoZXIgZ3JvdXBcbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGdyb3VwSWRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9tb3ZlVG9Hcm91cCA9IGZ1bmN0aW9uKGl0ZW0sIGdyb3VwSWQpIHtcbiAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gIGlmIChncm91cCAmJiBncm91cC5ncm91cElkICE9IGl0ZW0uZGF0YS5ncm91cCkge1xuICAgIHZhciBvbGRHcm91cCA9IGl0ZW0ucGFyZW50O1xuICAgIG9sZEdyb3VwLnJlbW92ZShpdGVtKTtcbiAgICBvbGRHcm91cC5vcmRlcigpO1xuICAgIGdyb3VwLmFkZChpdGVtKTtcbiAgICBncm91cC5vcmRlcigpO1xuXG4gICAgaXRlbS5kYXRhLmdyb3VwID0gZ3JvdXAuZ3JvdXBJZDtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmQgb2YgZHJhZ2dpbmcgc2VsZWN0ZWQgaXRlbXNcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICh0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcykge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgZGF0YXNldCA9IHRoaXMuaXRlbXNEYXRhLmdldERhdGFTZXQoKTtcbiAgICB2YXIgaXRlbVByb3BzID0gdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgO1xuICAgIHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzID0gbnVsbDtcblxuICAgIGl0ZW1Qcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgdmFyIGlkID0gcHJvcHMuaXRlbS5pZDtcbiAgICAgIHZhciBleGlzdHMgPSBtZS5pdGVtc0RhdGEuZ2V0KGlkLCBtZS5pdGVtT3B0aW9ucykgIT0gbnVsbDtcblxuICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgLy8gYWRkIGEgbmV3IGl0ZW1cbiAgICAgICAgbWUub3B0aW9ucy5vbkFkZChwcm9wcy5pdGVtLmRhdGEsIGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgICAgIG1lLl9yZW1vdmVJdGVtKHByb3BzLml0ZW0pOyAvLyByZW1vdmUgdGVtcG9yYXJ5IGl0ZW1cbiAgICAgICAgICBpZiAoaXRlbURhdGEpIHtcbiAgICAgICAgICAgIG1lLml0ZW1zRGF0YS5nZXREYXRhU2V0KCkuYWRkKGl0ZW1EYXRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBmb3JjZSByZS1zdGFja2luZyBvZiBhbGwgaXRlbXMgbmV4dCByZWRyYXdcbiAgICAgICAgICBtZS5zdGFja0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICBtZS5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZSBleGlzdGluZyBpdGVtXG4gICAgICAgIHZhciBpdGVtRGF0YSA9IHRoaXMuX2Nsb25lSXRlbURhdGEocHJvcHMuaXRlbS5kYXRhKTsgLy8gY29udmVydCBzdGFydCBhbmQgZW5kIHRvIHRoZSBjb3JyZWN0IHR5cGVcbiAgICAgICAgbWUub3B0aW9ucy5vbk1vdmUoaXRlbURhdGEsIGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgICAgIGlmIChpdGVtRGF0YSkge1xuICAgICAgICAgICAgLy8gYXBwbHkgY2hhbmdlc1xuICAgICAgICAgICAgaXRlbURhdGFbZGF0YXNldC5fZmllbGRJZF0gPSBpZDsgLy8gZW5zdXJlIHRoZSBpdGVtIGNvbnRhaW5zIGl0cyBpZCAoY2FuIGJlIHVuZGVmaW5lZClcbiAgICAgICAgICAgIGRhdGFzZXQudXBkYXRlKGl0ZW1EYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHZhbHVlc1xuICAgICAgICAgICAgcHJvcHMuaXRlbS5zZXREYXRhKHByb3BzLmRhdGEpO1xuXG4gICAgICAgICAgICBtZS5zdGFja0RpcnR5ID0gdHJ1ZTsgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gICAgICAgICAgICBtZS5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG59O1xuXG5JdGVtU2V0LnByb3RvdHlwZS5fb25Hcm91cERyYWdTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRpZiAodGhpcy5vcHRpb25zLmdyb3VwRWRpdGFibGUub3JkZXIpIHtcblx0XHR0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAgPSB0aGlzLmdyb3VwRnJvbVRhcmdldChldmVudCk7XG5cdFx0XG5cdFx0aWYgKHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cCkge1xuXHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcblx0XHRcdHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5vcmlnaW5hbE9yZGVyID0gdGhpcy5ncm91cHNEYXRhLmdldElkcyh7XG5cdFx0XHQgICAgb3JkZXI6IHRoaXMub3B0aW9ucy5ncm91cE9yZGVyXG5cdFx0ICAgIH0pO1xuXHRcdH1cblx0fVxufVxuXG5JdGVtU2V0LnByb3RvdHlwZS5fb25Hcm91cERyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0aWYgKHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLm9yZGVyICYmIHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cCkge1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFxuXHRcdC8vIGRyYWcgZnJvbSBvbmUgZ3JvdXAgdG8gYW5vdGhlclxuXHRcdHZhciBncm91cCA9IHRoaXMuZ3JvdXBGcm9tVGFyZ2V0KGV2ZW50KTtcblx0XHRcblx0XHQvLyB0cnkgdG8gYXZvaWQgdG9nZ2xpbmcgd2hlbiBncm91cHMgZGlmZmVyIGluIGhlaWdodFxuXHRcdGlmIChncm91cCAmJiBncm91cC5oZWlnaHQgIT0gdGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwLmhlaWdodCkge1xuXHRcdFx0dmFyIG1vdmluZ1VwID0gKGdyb3VwLnRvcCA8IHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cC50b3ApO1xuXHRcdFx0dmFyIGNsaWVudFkgPSBldmVudC5jZW50ZXIgPyBldmVudC5jZW50ZXIueSA6IGV2ZW50LmNsaWVudFk7XG5cdFx0XHR2YXIgdGFyZ2V0R3JvdXBUb3AgPSB1dGlsLmdldEFic29sdXRlVG9wKGdyb3VwLmRvbS5mb3JlZ3JvdW5kKTtcblx0XHRcdHZhciBkcmFnZ2VkR3JvdXBIZWlnaHQgPSB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAuaGVpZ2h0O1xuXHRcdFx0aWYgKG1vdmluZ1VwKSB7XG5cdFx0XHRcdC8vIHNraXAgc3dhcHBpbmcgdGhlIGdyb3VwcyB3aGVuIHRoZSBkcmFnZ2VkIGdyb3VwIGlzIG5vdCBiZWxvdyBjbGllbnRZIGFmdGVyd2FyZHNcblx0XHRcdFx0aWYgKHRhcmdldEdyb3VwVG9wICsgZHJhZ2dlZEdyb3VwSGVpZ2h0IDwgY2xpZW50WSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHRhcmdldEdyb3VwSGVpZ2h0ID0gZ3JvdXAuaGVpZ2h0O1xuXHRcdFx0XHQvLyBza2lwIHN3YXBwaW5nIHRoZSBncm91cHMgd2hlbiB0aGUgZHJhZ2dlZCBncm91cCBpcyBub3QgYmVsb3cgY2xpZW50WSBhZnRlcndhcmRzXG5cdFx0XHRcdGlmICh0YXJnZXRHcm91cFRvcCArIHRhcmdldEdyb3VwSGVpZ2h0IC0gZHJhZ2dlZEdyb3VwSGVpZ2h0ID4gY2xpZW50WSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRpZiAoZ3JvdXAgJiYgZ3JvdXAgIT0gdGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwKSB7XG5cdFx0XHR2YXIgZ3JvdXBzRGF0YSA9IHRoaXMuZ3JvdXBzRGF0YTtcblx0XHRcdHZhciB0YXJnZXRHcm91cCA9IGdyb3Vwc0RhdGEuZ2V0KGdyb3VwLmdyb3VwSWQpO1xuXHRcdFx0dmFyIGRyYWdnZWRHcm91cCA9IGdyb3Vwc0RhdGEuZ2V0KHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cC5ncm91cElkKTtcblx0XHRcdFxuXHRcdFx0Ly8gc3dpdGNoIGdyb3Vwc1xuXHRcdFx0aWYgKGRyYWdnZWRHcm91cCAmJiB0YXJnZXRHcm91cCkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMuZ3JvdXBPcmRlclN3YXAoZHJhZ2dlZEdyb3VwLCB0YXJnZXRHcm91cCwgdGhpcy5ncm91cHNEYXRhKTtcblx0XHRcdFx0dGhpcy5ncm91cHNEYXRhLnVwZGF0ZShkcmFnZ2VkR3JvdXApO1xuXHRcdFx0XHR0aGlzLmdyb3Vwc0RhdGEudXBkYXRlKHRhcmdldEdyb3VwKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gZmV0Y2ggY3VycmVudCBvcmRlciBvZiBncm91cHNcblx0XHRcdHZhciBuZXdPcmRlciA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoe1xuXHRcdFx0ICAgIG9yZGVyOiB0aGlzLm9wdGlvbnMuZ3JvdXBPcmRlclxuXHRcdCAgICB9KTtcblx0XHRcdFxuXHRcdFx0Ly8gaW4gY2FzZSBvZiBjaGFuZ2VzIHNpbmNlIF9vbkdyb3VwRHJhZ1N0YXJ0XG5cdFx0XHRpZiAoIXV0aWwuZXF1YWxBcnJheShuZXdPcmRlciwgdGhpcy5ncm91cFRvdWNoUGFyYW1zLm9yaWdpbmFsT3JkZXIpKSB7XG5cdFx0XHRcdHZhciBncm91cHNEYXRhID0gdGhpcy5ncm91cHNEYXRhO1xuXHRcdFx0XHR2YXIgb3JpZ09yZGVyID0gdGhpcy5ncm91cFRvdWNoUGFyYW1zLm9yaWdpbmFsT3JkZXI7XG5cdFx0XHRcdHZhciBkcmFnZ2VkSWQgPSB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAuZ3JvdXBJZDtcblx0XHRcdFx0dmFyIG51bUdyb3VwcyA9IE1hdGgubWluKG9yaWdPcmRlci5sZW5ndGgsIG5ld09yZGVyLmxlbmd0aCk7XG5cdFx0XHRcdHZhciBjdXJQb3MgPSAwO1xuXHRcdFx0XHR2YXIgbmV3T2Zmc2V0ID0gMDtcblx0XHRcdFx0dmFyIG9yZ09mZnNldCA9IDA7XG5cdFx0XHRcdHdoaWxlIChjdXJQb3MgPCBudW1Hcm91cHMpIHtcblx0XHRcdFx0XHQvLyBhcyBsb25nIGFzIHRoZSBncm91cHMgYXJlIHdoZXJlIHRoZXkgc2hvdWxkIGJlIHN0ZXAgZG93biBhbG9uZyB0aGUgZ3JvdXBzIG9yZGVyXG5cdFx0XHRcdFx0d2hpbGUgKChjdXJQb3MrbmV3T2Zmc2V0KSA8IG51bUdyb3VwcyBcblx0XHRcdFx0XHRcdCYmIChjdXJQb3Mrb3JnT2Zmc2V0KSA8IG51bUdyb3VwcyBcblx0XHRcdFx0XHRcdCYmIG5ld09yZGVyW2N1clBvcytuZXdPZmZzZXRdID09IG9yaWdPcmRlcltjdXJQb3Mrb3JnT2Zmc2V0XSkge1xuXHRcdFx0XHRcdFx0Y3VyUG9zKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIGFsbCBva1xuXHRcdFx0XHRcdGlmIChjdXJQb3MrbmV3T2Zmc2V0ID49IG51bUdyb3Vwcykge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIG5vdCBhbGwgb2tcblx0XHRcdFx0XHQvLyBpZiBkcmFnZ2VkIGdyb3VwIHdhcyBtb3ZlIHVwd2FyZHMgZXZlcnl0aGluZyBiZWxvdyBzaG91bGQgaGF2ZSBhbiBvZmZzZXRcblx0XHRcdFx0XHRpZiAobmV3T3JkZXJbY3VyUG9zK25ld09mZnNldF0gPT0gZHJhZ2dlZElkKSB7XG5cdFx0XHRcdFx0XHRuZXdPZmZzZXQgPSAxO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGlmIGRyYWdnZWQgZ3JvdXAgd2FzIG1vdmUgZG93bndhcmRzIGV2ZXJ5dGhpbmcgYWJvdmUgc2hvdWxkIGhhdmUgYW4gb2Zmc2V0XG5cdFx0XHRcdFx0ZWxzZSBpZiAob3JpZ09yZGVyW2N1clBvcytvcmdPZmZzZXRdID09IGRyYWdnZWRJZCkge1xuXHRcdFx0XHRcdFx0b3JnT2Zmc2V0ID0gMTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH0gXG5cdFx0XHRcdFx0Ly8gZm91bmQgYSBncm91cCAoYXBhcnQgZnJvbSBkcmFnZ2VkIGdyb3VwKSB0aGF0IGhhcyB0aGUgd3JvbmcgcG9zaXRpb24gLT4gc3dpdGNoIHdpdGggdGhlIFxuXHRcdFx0XHRcdC8vIGdyb3VwIGF0IHRoZSBwb3NpdGlvbiB3aGVyZSBvdGhlciBvbmUgc2hvdWxkIGJlLCBmaXggaW5kZXggYXJyYXlzIGFuZCBjb250aW51ZVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIHNsaXBwZWRQb3NpdGlvbiA9IG5ld09yZGVyLmluZGV4T2Yob3JpZ09yZGVyW2N1clBvcytvcmdPZmZzZXRdKVxuXHRcdFx0XHRcdFx0dmFyIHN3aXRjaEdyb3VwID0gZ3JvdXBzRGF0YS5nZXQobmV3T3JkZXJbY3VyUG9zK25ld09mZnNldF0pO1xuXHRcdFx0XHRcdFx0dmFyIHNob3VsZEJlR3JvdXAgPSBncm91cHNEYXRhLmdldChvcmlnT3JkZXJbY3VyUG9zK29yZ09mZnNldF0pO1xuXHRcdFx0XHRcdFx0dGhpcy5vcHRpb25zLmdyb3VwT3JkZXJTd2FwKHN3aXRjaEdyb3VwLCBzaG91bGRCZUdyb3VwLCBncm91cHNEYXRhKTtcblx0XHRcdFx0XHRcdGdyb3Vwc0RhdGEudXBkYXRlKHN3aXRjaEdyb3VwKTtcblx0XHRcdFx0XHRcdGdyb3Vwc0RhdGEudXBkYXRlKHNob3VsZEJlR3JvdXApO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR2YXIgc3dpdGNoR3JvdXBJZCA9IG5ld09yZGVyW2N1clBvcytuZXdPZmZzZXRdO1xuXHRcdFx0XHRcdFx0bmV3T3JkZXJbY3VyUG9zK25ld09mZnNldF0gPSBvcmlnT3JkZXJbY3VyUG9zK29yZ09mZnNldF07XG5cdFx0XHRcdFx0XHRuZXdPcmRlcltzbGlwcGVkUG9zaXRpb25dID0gc3dpdGNoR3JvdXBJZDtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Y3VyUG9zKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9XG5cdH1cbn1cblxuSXRlbVNldC5wcm90b3R5cGUuX29uR3JvdXBEcmFnRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdGlmICh0aGlzLm9wdGlvbnMuZ3JvdXBFZGl0YWJsZS5vcmRlciAmJiB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXApIHtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcblx0XHQvLyB1cGRhdGUgZXhpc3RpbmcgZ3JvdXBcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpZCA9IG1lLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAuZ3JvdXBJZDtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdyb3Vwc0RhdGEuZ2V0RGF0YVNldCgpO1xuICAgICAgICB2YXIgZ3JvdXBEYXRhID0gdXRpbC5leHRlbmQoe30sIGRhdGFzZXQuZ2V0KGlkKSk7IC8vIGNsb25lIHRoZSBkYXRhXG4gICAgICAgIG1lLm9wdGlvbnMub25Nb3ZlR3JvdXAoZ3JvdXBEYXRhLCBmdW5jdGlvbiAoZ3JvdXBEYXRhKSB7XG4gICAgICAgICAgaWYgKGdyb3VwRGF0YSkge1xuICAgICAgICAgICAgLy8gYXBwbHkgY2hhbmdlc1xuICAgICAgICBcdGdyb3VwRGF0YVtkYXRhc2V0Ll9maWVsZElkXSA9IGlkOyAvLyBlbnN1cmUgdGhlIGdyb3VwIGNvbnRhaW5zIGl0cyBpZCAoY2FuIGJlIHVuZGVmaW5lZClcbiAgICAgICAgICAgIGRhdGFzZXQudXBkYXRlKGdyb3VwRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICBcdCAgXG4gICAgICAgIFx0Ly8gZmV0Y2ggY3VycmVudCBvcmRlciBvZiBncm91cHNcbiAgXHRcdFx0dmFyIG5ld09yZGVyID0gZGF0YXNldC5nZXRJZHMoe1xuICBcdFx0XHQgICAgb3JkZXI6IG1lLm9wdGlvbnMuZ3JvdXBPcmRlclxuICBcdFx0ICAgIH0pO1xuICAgICAgICBcdCAgXG4gICAgICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIG9yZGVyXG4gICAgICAgIFx0aWYgKCF1dGlsLmVxdWFsQXJyYXkobmV3T3JkZXIsIG1lLmdyb3VwVG91Y2hQYXJhbXMub3JpZ2luYWxPcmRlcikpIHtcbiAgICAgICAgXHRcdHZhciBvcmlnT3JkZXIgPSBtZS5ncm91cFRvdWNoUGFyYW1zLm9yaWdpbmFsT3JkZXI7XG4gIFx0XHRcdFx0dmFyIG51bUdyb3VwcyA9IE1hdGgubWluKG9yaWdPcmRlci5sZW5ndGgsIG5ld09yZGVyLmxlbmd0aCk7XG4gIFx0XHRcdFx0dmFyIGN1clBvcyA9IDA7XG4gIFx0XHRcdFx0d2hpbGUgKGN1clBvcyA8IG51bUdyb3Vwcykge1xuICBcdFx0XHRcdFx0Ly8gYXMgbG9uZyBhcyB0aGUgZ3JvdXBzIGFyZSB3aGVyZSB0aGV5IHNob3VsZCBiZSBzdGVwIGRvd24gYWxvbmcgdGhlIGdyb3VwcyBvcmRlclxuICBcdFx0XHRcdFx0d2hpbGUgKGN1clBvcyA8IG51bUdyb3VwcyAmJiBuZXdPcmRlcltjdXJQb3NdID09IG9yaWdPcmRlcltjdXJQb3NdKSB7XG4gIFx0XHRcdFx0XHQgICAgY3VyUG9zKys7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcbiAgXHRcdFx0XHRcdC8vIGFsbCBva1xuICBcdFx0XHRcdFx0aWYgKGN1clBvcyA+PSBudW1Hcm91cHMpIHtcbiAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcbiAgXHRcdFx0XHRcdC8vIGZvdW5kIGEgZ3JvdXAgdGhhdCBoYXMgdGhlIHdyb25nIHBvc2l0aW9uIC0+IHN3aXRjaCB3aXRoIHRoZSBcbiAgXHRcdFx0XHRcdC8vIGdyb3VwIGF0IHRoZSBwb3NpdGlvbiB3aGVyZSBvdGhlciBvbmUgc2hvdWxkIGJlLCBmaXggaW5kZXggYXJyYXlzIGFuZCBjb250aW51ZVxuICBcdFx0XHRcdFx0dmFyIHNsaXBwZWRQb3NpdGlvbiA9IG5ld09yZGVyLmluZGV4T2Yob3JpZ09yZGVyW2N1clBvc10pXG4gIFx0XHRcdFx0XHR2YXIgc3dpdGNoR3JvdXAgPSBkYXRhc2V0LmdldChuZXdPcmRlcltjdXJQb3NdKTtcbiAgXHRcdFx0XHRcdHZhciBzaG91bGRCZUdyb3VwID0gZGF0YXNldC5nZXQob3JpZ09yZGVyW2N1clBvc10pO1xuICBcdFx0XHRcdFx0bWUub3B0aW9ucy5ncm91cE9yZGVyU3dhcChzd2l0Y2hHcm91cCwgc2hvdWxkQmVHcm91cCwgZGF0YXNldCk7XG4gIFx0XHRcdFx0XHRncm91cHNEYXRhLnVwZGF0ZShzd2l0Y2hHcm91cCk7XG5cdFx0XHRcdFx0Z3JvdXBzRGF0YS51cGRhdGUoc2hvdWxkQmVHcm91cCk7XG4gIFx0XHRcdFx0XHRcdFxuICBcdFx0XHRcdFx0dmFyIHN3aXRjaEdyb3VwSWQgPSBuZXdPcmRlcltjdXJQb3NdO1xuICBcdFx0XHRcdFx0bmV3T3JkZXJbY3VyUG9zXSA9IG9yaWdPcmRlcltjdXJQb3NdO1xuICBcdFx0XHRcdFx0bmV3T3JkZXJbc2xpcHBlZFBvc2l0aW9uXSA9IHN3aXRjaEdyb3VwSWQ7XG4gIFx0XHRcdFx0XHRcdFxuICBcdFx0XHRcdFx0Y3VyUG9zKys7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgbWUuYm9keS5lbWl0dGVyLmVtaXQoJ2dyb3VwRHJhZ2dlZCcsIHsgZ3JvdXBJZDogaWQgfSk7XG5cdH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgc2VsZWN0aW5nL2Rlc2VsZWN0aW5nIGFuIGl0ZW0gd2hlbiB0YXBwaW5nIGl0XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uU2VsZWN0SXRlbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5zZWxlY3RhYmxlKSByZXR1cm47XG5cbiAgdmFyIGN0cmxLZXkgID0gZXZlbnQuc3JjRXZlbnQgJiYgKGV2ZW50LnNyY0V2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc3JjRXZlbnQubWV0YUtleSk7XG4gIHZhciBzaGlmdEtleSA9IGV2ZW50LnNyY0V2ZW50ICYmIGV2ZW50LnNyY0V2ZW50LnNoaWZ0S2V5O1xuICBpZiAoY3RybEtleSB8fCBzaGlmdEtleSkge1xuICAgIHRoaXMuX29uTXVsdGlTZWxlY3RJdGVtKGV2ZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb2xkU2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuICB2YXIgaXRlbSA9IHRoaXMuaXRlbUZyb21UYXJnZXQoZXZlbnQpO1xuICB2YXIgc2VsZWN0aW9uID0gaXRlbSA/IFtpdGVtLmlkXSA6IFtdO1xuICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuXG4gIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG4gIC8vIGVtaXQgYSBzZWxlY3QgZXZlbnQsXG4gIC8vIGV4Y2VwdCB3aGVuIG9sZCBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIG5ldyBzZWxlY3Rpb24gaXMgc3RpbGwgZW1wdHlcbiAgaWYgKG5ld1NlbGVjdGlvbi5sZW5ndGggPiAwIHx8IG9sZFNlbGVjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnc2VsZWN0Jywge1xuICAgICAgaXRlbXM6IG5ld1NlbGVjdGlvbixcbiAgICAgIGV2ZW50OiBldmVudFxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZSBjcmVhdGlvbiBhbmQgdXBkYXRlcyBvZiBhbiBpdGVtIG9uIGRvdWJsZSB0YXBcbiAqIEBwYXJhbSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uQWRkSXRlbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5zZWxlY3RhYmxlKSByZXR1cm47XG4gIGlmICghdGhpcy5vcHRpb25zLmVkaXRhYmxlLmFkZCkgcmV0dXJuO1xuXG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciBzbmFwID0gdGhpcy5vcHRpb25zLnNuYXAgfHwgbnVsbDtcbiAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICBpZiAoaXRlbSkge1xuICAgIC8vIHVwZGF0ZSBpdGVtXG5cbiAgICAvLyBleGVjdXRlIGFzeW5jIGhhbmRsZXIgdG8gdXBkYXRlIHRoZSBpdGVtIChvciBjYW5jZWwgaXQpXG4gICAgdmFyIGl0ZW1EYXRhID0gbWUuaXRlbXNEYXRhLmdldChpdGVtLmlkKTsgLy8gZ2V0IGEgY2xvbmUgb2YgdGhlIGRhdGEgZnJvbSB0aGUgZGF0YXNldFxuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShpdGVtRGF0YSwgZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG4gICAgICBpZiAoaXRlbURhdGEpIHtcbiAgICAgICAgbWUuaXRlbXNEYXRhLmdldERhdGFTZXQoKS51cGRhdGUoaXRlbURhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIGFkZCBpdGVtXG4gICAgdmFyIHhBYnMgPSB1dGlsLmdldEFic29sdXRlTGVmdCh0aGlzLmRvbS5mcmFtZSk7XG4gICAgdmFyIHggPSBldmVudC5jZW50ZXIueCAtIHhBYnM7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHgpO1xuICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS51dGlsLmdldFNjYWxlKCk7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLmJvZHkudXRpbC5nZXRTdGVwKCk7XG5cbiAgICB2YXIgbmV3SXRlbURhdGEgPSB7XG4gICAgICBzdGFydDogc25hcCA/IHNuYXAoc3RhcnQsIHNjYWxlLCBzdGVwKSA6IHN0YXJ0LFxuICAgICAgY29udGVudDogJ25ldyBpdGVtJ1xuICAgIH07XG5cbiAgICAvLyB3aGVuIGRlZmF1bHQgdHlwZSBpcyBhIHJhbmdlLCBhZGQgYSBkZWZhdWx0IGVuZCBkYXRlIHRvIHRoZSBuZXcgaXRlbVxuICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gJ3JhbmdlJykge1xuICAgICAgdmFyIGVuZCA9IHRoaXMuYm9keS51dGlsLnRvVGltZSh4ICsgdGhpcy5wcm9wcy53aWR0aCAvIDUpO1xuICAgICAgbmV3SXRlbURhdGEuZW5kID0gc25hcCA/IHNuYXAoZW5kLCBzY2FsZSwgc3RlcCkgOiBlbmQ7XG4gICAgfVxuXG4gICAgbmV3SXRlbURhdGFbdGhpcy5pdGVtc0RhdGEuX2ZpZWxkSWRdID0gdXRpbC5yYW5kb21VVUlEKCk7XG5cbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwRnJvbVRhcmdldChldmVudCk7XG4gICAgaWYgKGdyb3VwKSB7XG4gICAgICBuZXdJdGVtRGF0YS5ncm91cCA9IGdyb3VwLmdyb3VwSWQ7XG4gICAgfVxuXG4gICAgLy8gZXhlY3V0ZSBhc3luYyBoYW5kbGVyIHRvIGN1c3RvbWl6ZSAob3IgY2FuY2VsKSBhZGRpbmcgYW4gaXRlbVxuICAgIG5ld0l0ZW1EYXRhID0gdGhpcy5fY2xvbmVJdGVtRGF0YShuZXdJdGVtRGF0YSk7ICAgICAvLyBjb252ZXJ0IHN0YXJ0IGFuZCBlbmQgdG8gdGhlIGNvcnJlY3QgdHlwZVxuICAgIHRoaXMub3B0aW9ucy5vbkFkZChuZXdJdGVtRGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIG1lLml0ZW1zRGF0YS5nZXREYXRhU2V0KCkuYWRkKGl0ZW0pO1xuICAgICAgICAvLyBUT0RPOiBuZWVkIHRvIHRyaWdnZXIgYSByZWRyYXc/XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlIHNlbGVjdGluZy9kZXNlbGVjdGluZyBtdWx0aXBsZSBpdGVtcyB3aGVuIGhvbGRpbmcgYW4gaXRlbVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vbk11bHRpU2VsZWN0SXRlbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5zZWxlY3RhYmxlKSByZXR1cm47XG5cbiAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcblxuICBpZiAoaXRlbSkge1xuICAgIC8vIG11bHRpIHNlbGVjdCBpdGVtcyAoaWYgYWxsb3dlZClcblxuICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLm9wdGlvbnMubXVsdGlzZWxlY3RcbiAgICAgID8gdGhpcy5nZXRTZWxlY3Rpb24oKSAvLyB0YWtlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICA6IFtdOyAgICAgICAgICAgICAgICAgLy8gZGVzZWxlY3QgY3VycmVudCBzZWxlY3Rpb25cblxuICAgIHZhciBzaGlmdEtleSA9IGV2ZW50LnNyY0V2ZW50ICYmIGV2ZW50LnNyY0V2ZW50LnNoaWZ0S2V5IHx8IGZhbHNlO1xuXG4gICAgaWYgKHNoaWZ0S2V5ICYmIHRoaXMub3B0aW9ucy5tdWx0aXNlbGVjdCkge1xuICAgICAgLy8gc2VsZWN0IGFsbCBpdGVtcyBiZXR3ZWVuIHRoZSBvbGQgc2VsZWN0aW9uIGFuZCB0aGUgdGFwcGVkIGl0ZW1cblxuICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgIHNlbGVjdGlvbi5wdXNoKGl0ZW0uaWQpO1xuICAgICAgdmFyIHJhbmdlID0gSXRlbVNldC5fZ2V0SXRlbVJhbmdlKHRoaXMuaXRlbXNEYXRhLmdldChzZWxlY3Rpb24sIHRoaXMuaXRlbU9wdGlvbnMpKTtcblxuICAgICAgLy8gc2VsZWN0IGFsbCBpdGVtcyB3aXRoaW4gdGhlIHNlbGVjdGlvbiByYW5nZVxuICAgICAgc2VsZWN0aW9uID0gW107XG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLml0ZW1zKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIHZhciBfaXRlbSA9IHRoaXMuaXRlbXNbaWRdO1xuICAgICAgICAgIHZhciBzdGFydCA9IF9pdGVtLmRhdGEuc3RhcnQ7XG4gICAgICAgICAgdmFyIGVuZCA9IChfaXRlbS5kYXRhLmVuZCAhPT0gdW5kZWZpbmVkKSA/IF9pdGVtLmRhdGEuZW5kIDogc3RhcnQ7XG5cbiAgICAgICAgICBpZiAoc3RhcnQgPj0gcmFuZ2UubWluICYmXG4gICAgICAgICAgICAgIGVuZCA8PSByYW5nZS5tYXggJiZcbiAgICAgICAgICAgICAgIShfaXRlbSBpbnN0YW5jZW9mIEJhY2tncm91bmRJdGVtKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uLnB1c2goX2l0ZW0uaWQpOyAvLyBkbyBub3QgdXNlIGlkIGJ1dCBpdGVtLmlkLCBpZCBpdHNlbGYgaXMgc3RyaW5naWZpZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBhZGQvcmVtb3ZlIHRoaXMgaXRlbSBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgdmFyIGluZGV4ID0gc2VsZWN0aW9uLmluZGV4T2YoaXRlbS5pZCk7XG4gICAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgICAgLy8gaXRlbSBpcyBub3QgeWV0IHNlbGVjdGVkIC0+IHNlbGVjdCBpdFxuICAgICAgICBzZWxlY3Rpb24ucHVzaChpdGVtLmlkKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBpdGVtIGlzIGFscmVhZHkgc2VsZWN0ZWQgLT4gZGVzZWxlY3QgaXRcbiAgICAgICAgc2VsZWN0aW9uLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcblxuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3NlbGVjdCcsIHtcbiAgICAgIGl0ZW1zOiB0aGlzLmdldFNlbGVjdGlvbigpLFxuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSB0aW1lIHJhbmdlIG9mIGEgbGlzdCBvZiBpdGVtc1xuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gaXRlbXNEYXRhXG4gKiBAcmV0dXJuIHt7bWluOiBEYXRlLCBtYXg6IERhdGV9fSBSZXR1cm5zIHRoZSByYW5nZSBvZiB0aGUgcHJvdmlkZWQgaXRlbXNcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQuX2dldEl0ZW1SYW5nZSA9IGZ1bmN0aW9uKGl0ZW1zRGF0YSkge1xuICB2YXIgbWF4ID0gbnVsbDtcbiAgdmFyIG1pbiA9IG51bGw7XG5cbiAgaXRlbXNEYXRhLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAobWluID09IG51bGwgfHwgZGF0YS5zdGFydCA8IG1pbikge1xuICAgICAgbWluID0gZGF0YS5zdGFydDtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAobWF4ID09IG51bGwgfHwgZGF0YS5lbmQgPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gZGF0YS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKG1heCA9PSBudWxsIHx8IGRhdGEuc3RhcnQgPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gZGF0YS5zdGFydDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXhcbiAgfVxufTtcblxuLyoqXG4gKiBGaW5kIGFuIGl0ZW0gZnJvbSBhbiBldmVudCB0YXJnZXQ6XG4gKiBzZWFyY2hlcyBmb3IgdGhlIGF0dHJpYnV0ZSAndGltZWxpbmUtaXRlbScgaW4gdGhlIGV2ZW50IHRhcmdldCdzIGVsZW1lbnQgdHJlZVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge0l0ZW0gfCBudWxsfSBpdGVtXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLml0ZW1Gcm9tVGFyZ2V0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgd2hpbGUgKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkoJ3RpbWVsaW5lLWl0ZW0nKSkge1xuICAgICAgcmV0dXJuIHRhcmdldFsndGltZWxpbmUtaXRlbSddO1xuICAgIH1cbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBHcm91cCBmcm9tIGFuIGV2ZW50IHRhcmdldDpcbiAqIHNlYXJjaGVzIGZvciB0aGUgYXR0cmlidXRlICd0aW1lbGluZS1ncm91cCcgaW4gdGhlIGV2ZW50IHRhcmdldCdzIGVsZW1lbnQgdHJlZVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge0dyb3VwIHwgbnVsbH0gZ3JvdXBcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuZ3JvdXBGcm9tVGFyZ2V0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIGNsaWVudFkgPSBldmVudC5jZW50ZXIgPyBldmVudC5jZW50ZXIueSA6IGV2ZW50LmNsaWVudFk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncm91cElkID0gdGhpcy5ncm91cElkc1tpXTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3Vwc1tncm91cElkXTtcbiAgICB2YXIgZm9yZWdyb3VuZCA9IGdyb3VwLmRvbS5mb3JlZ3JvdW5kO1xuICAgIHZhciB0b3AgPSB1dGlsLmdldEFic29sdXRlVG9wKGZvcmVncm91bmQpO1xuICAgIGlmIChjbGllbnRZID4gdG9wICYmIGNsaWVudFkgPCB0b3AgKyBmb3JlZ3JvdW5kLm9mZnNldEhlaWdodCkge1xuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9PT0gJ3RvcCcpIHtcbiAgICAgIGlmIChpID09PSB0aGlzLmdyb3VwSWRzLmxlbmd0aCAtIDEgJiYgY2xpZW50WSA+IHRvcCkge1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGkgPT09IDAgJiYgY2xpZW50WSA8IHRvcCArIGZvcmVncm91bmQub2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogRmluZCB0aGUgSXRlbVNldCBmcm9tIGFuIGV2ZW50IHRhcmdldDpcbiAqIHNlYXJjaGVzIGZvciB0aGUgYXR0cmlidXRlICd0aW1lbGluZS1pdGVtc2V0JyBpbiB0aGUgZXZlbnQgdGFyZ2V0J3MgZWxlbWVudCB0cmVlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybiB7SXRlbVNldCB8IG51bGx9IGl0ZW1cbiAqL1xuSXRlbVNldC5pdGVtU2V0RnJvbVRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIHdoaWxlICh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KCd0aW1lbGluZS1pdGVtc2V0JykpIHtcbiAgICAgIHJldHVybiB0YXJnZXRbJ3RpbWVsaW5lLWl0ZW1zZXQnXTtcbiAgICB9XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xvbmUgdGhlIGRhdGEgb2YgYW4gaXRlbSwgYW5kIFwibm9ybWFsaXplXCIgaXQ6IGNvbnZlcnQgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZVxuICogdG8gdGhlIHR5cGUgKERhdGUsIE1vbWVudCwgLi4uKSBjb25maWd1cmVkIGluIHRoZSBEYXRhU2V0LiBJZiBub3QgY29uZmlndXJlZCxcbiAqIHN0YXJ0IGFuZCBlbmQgYXJlIGNvbnZlcnRlZCB0byBEYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW1EYXRhLCB0eXBpY2FsbHkgYGl0ZW0uZGF0YWBcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gIE9wdGlvbmFsIERhdGUgdHlwZS4gSWYgbm90IHByb3ZpZGVkLCB0aGUgdHlwZSBmcm9tIHRoZSBEYXRhU2V0IGlzIHRha2VuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZWQgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fY2xvbmVJdGVtRGF0YSA9IGZ1bmN0aW9uIChpdGVtRGF0YSwgdHlwZSkge1xuICB2YXIgY2xvbmUgPSB1dGlsLmV4dGVuZCh7fSwgaXRlbURhdGEpO1xuXG4gIGlmICghdHlwZSkge1xuICAgIC8vIGNvbnZlcnQgc3RhcnQgYW5kIGVuZCBkYXRlIHRvIHRoZSB0eXBlIChEYXRlLCBNb21lbnQsIC4uLikgY29uZmlndXJlZCBpbiB0aGUgRGF0YVNldFxuICAgIHR5cGUgPSB0aGlzLml0ZW1zRGF0YS5nZXREYXRhU2V0KCkuX29wdGlvbnMudHlwZTtcbiAgfVxuXG4gIGlmIChjbG9uZS5zdGFydCAhPSB1bmRlZmluZWQpIHtcbiAgICBjbG9uZS5zdGFydCA9IHV0aWwuY29udmVydChjbG9uZS5zdGFydCwgdHlwZSAmJiB0eXBlLnN0YXJ0IHx8ICdEYXRlJyk7XG4gIH1cbiAgaWYgKGNsb25lLmVuZCAhPSB1bmRlZmluZWQpIHtcbiAgICBjbG9uZS5lbmQgPSB1dGlsLmNvbnZlcnQoY2xvbmUuZW5kICwgdHlwZSAmJiB0eXBlLmVuZCB8fCAnRGF0ZScpO1xuICB9XG5cbiAgcmV0dXJuIGNsb25lO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJdGVtU2V0O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKTtcbnZhciBUaW1lU3RlcCA9IHJlcXVpcmUoJy4uL1RpbWVTdGVwJyk7XG52YXIgRGF0ZVV0aWwgPSByZXF1aXJlKCcuLi9EYXRlVXRpbCcpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZS9tb21lbnQnKTtcblxuLyoqXG4gKiBBIGhvcml6b250YWwgdGltZSBheGlzXG4gKiBAcGFyYW0ge3tkb206IE9iamVjdCwgZG9tUHJvcHM6IE9iamVjdCwgZW1pdHRlcjogRW1pdHRlciwgcmFuZ2U6IFJhbmdlfX0gYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgU2VlIFRpbWVBeGlzLnNldE9wdGlvbnMgZm9yIHRoZSBhdmFpbGFibGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuXG4gKiBAY29uc3RydWN0b3IgVGltZUF4aXNcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5mdW5jdGlvbiBUaW1lQXhpcyAoYm9keSwgb3B0aW9ucykge1xuICB0aGlzLmRvbSA9IHtcbiAgICBmb3JlZ3JvdW5kOiBudWxsLFxuICAgIGxpbmVzOiBbXSxcbiAgICBtYWpvclRleHRzOiBbXSxcbiAgICBtaW5vclRleHRzOiBbXSxcbiAgICByZWR1bmRhbnQ6IHtcbiAgICAgIGxpbmVzOiBbXSxcbiAgICAgIG1ham9yVGV4dHM6IFtdLFxuICAgICAgbWlub3JUZXh0czogW11cbiAgICB9XG4gIH07XG4gIHRoaXMucHJvcHMgPSB7XG4gICAgcmFuZ2U6IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiAwLFxuICAgICAgbWluaW11bVN0ZXA6IDBcbiAgICB9LFxuICAgIGxpbmVUb3A6IDBcbiAgfTtcblxuICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICBheGlzOiAnYm90dG9tJ1xuICAgIH0sICAvLyBheGlzIG9yaWVudGF0aW9uOiAndG9wJyBvciAnYm90dG9tJ1xuICAgIHNob3dNaW5vckxhYmVsczogdHJ1ZSxcbiAgICBzaG93TWFqb3JMYWJlbHM6IHRydWUsXG4gICAgZm9ybWF0OiBUaW1lU3RlcC5GT1JNQVQsXG4gICAgbW9tZW50OiBtb21lbnQsXG4gICAgdGltZUF4aXM6IG51bGxcbiAgfTtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgLy8gY3JlYXRlIHRoZSBIVE1MIERPTVxuICB0aGlzLl9jcmVhdGUoKTtcblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG59XG5cblRpbWVBeGlzLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBTZXQgb3B0aW9ucyBmb3IgdGhlIFRpbWVBeGlzLlxuICogUGFyYW1ldGVycyB3aWxsIGJlIG1lcmdlZCBpbiBjdXJyZW50IG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gW29yaWVudGF0aW9uLmF4aXNdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IFtzaG93TWlub3JMYWJlbHNdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IFtzaG93TWFqb3JMYWJlbHNdXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIC8vIGNvcHkgYWxsIG9wdGlvbnMgdGhhdCB3ZSBrbm93XG4gICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoW1xuICAgICAgJ3Nob3dNaW5vckxhYmVscycsXG4gICAgICAnc2hvd01ham9yTGFiZWxzJyxcbiAgICAgICdoaWRkZW5EYXRlcycsXG4gICAgICAndGltZUF4aXMnLFxuICAgICAgJ21vbWVudCdcbiAgICBdLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgLy8gZGVlcCBjb3B5IHRoZSBmb3JtYXQgb3B0aW9uc1xuICAgIHV0aWwuc2VsZWN0aXZlRGVlcEV4dGVuZChbJ2Zvcm1hdCddLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCdvcmllbnRhdGlvbicgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9yaWVudGF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyA9IG9wdGlvbnMub3JpZW50YXRpb247XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ29iamVjdCcgJiYgJ2F4aXMnIGluIG9wdGlvbnMub3JpZW50YXRpb24pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgPSBvcHRpb25zLm9yaWVudGF0aW9uLmF4aXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgbG9jYWxlIHRvIG1vbWVudC5qc1xuICAgIC8vIFRPRE86IG5vdCBzbyBuaWNlLCB0aGlzIGlzIGFwcGxpZWQgZ2xvYmFsbHkgdG8gbW9tZW50LmpzXG4gICAgaWYgKCdsb2NhbGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgbW9tZW50LmxvY2FsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBtb21lbnQuanMgMi44LjErXG4gICAgICAgIG1vbWVudC5sb2NhbGUob3B0aW9ucy5sb2NhbGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1vbWVudC5sYW5nKG9wdGlvbnMubG9jYWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBIVE1MIERPTSBmb3IgdGhlIFRpbWVBeGlzXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZG9tLmZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIHRoaXMuZG9tLmZvcmVncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy10aW1lLWF4aXMgdmlzLWZvcmVncm91bmQnO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtdGltZS1heGlzIHZpcy1iYWNrZ3JvdW5kJztcbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgVGltZUF4aXNcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgLy8gcmVtb3ZlIGZyb20gRE9NXG4gIGlmICh0aGlzLmRvbS5mb3JlZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZm9yZWdyb3VuZCk7XG4gIH1cbiAgaWYgKHRoaXMuZG9tLmJhY2tncm91bmQucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kKTtcbiAgfVxuXG4gIHRoaXMuYm9keSA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICovXG5UaW1lQXhpcy5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMuZG9tLmZvcmVncm91bmQ7XG4gIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5kb20uYmFja2dyb3VuZDtcblxuICAvLyBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgcGFyZW50IERPTSBlbGVtZW50IChkZXBlbmRpbmcgb24gb3B0aW9uIG9yaWVudGF0aW9uKVxuICB2YXIgcGFyZW50ID0gKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID09ICd0b3AnKSA/IHRoaXMuYm9keS5kb20udG9wIDogdGhpcy5ib2R5LmRvbS5ib3R0b207XG4gIHZhciBwYXJlbnRDaGFuZ2VkID0gKGZvcmVncm91bmQucGFyZW50Tm9kZSAhPT0gcGFyZW50KTtcblxuICAvLyBjYWxjdWxhdGUgY2hhcmFjdGVyIHdpZHRoIGFuZCBoZWlnaHRcbiAgdGhpcy5fY2FsY3VsYXRlQ2hhclNpemUoKTtcblxuICAvLyBUT0RPOiByZWNhbGN1bGF0ZSBzaXplcyBvbmx5IG5lZWRlZCB3aGVuIHBhcmVudCBpcyByZXNpemVkIG9yIG9wdGlvbnMgaXMgY2hhbmdlZFxuICB2YXIgc2hvd01pbm9yTGFiZWxzID0gdGhpcy5vcHRpb25zLnNob3dNaW5vckxhYmVscyAmJiB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyAhPT0gJ25vbmUnO1xuICB2YXIgc2hvd01ham9yTGFiZWxzID0gdGhpcy5vcHRpb25zLnNob3dNYWpvckxhYmVscyAmJiB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyAhPT0gJ25vbmUnO1xuXG4gIC8vIGRldGVybWluZSB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZWxlbWVucyBmb3IgdGhlIGF4aXNcbiAgcHJvcHMubWlub3JMYWJlbEhlaWdodCA9IHNob3dNaW5vckxhYmVscyA/IHByb3BzLm1pbm9yQ2hhckhlaWdodCA6IDA7XG4gIHByb3BzLm1ham9yTGFiZWxIZWlnaHQgPSBzaG93TWFqb3JMYWJlbHMgPyBwcm9wcy5tYWpvckNoYXJIZWlnaHQgOiAwO1xuICBwcm9wcy5oZWlnaHQgPSBwcm9wcy5taW5vckxhYmVsSGVpZ2h0ICsgcHJvcHMubWFqb3JMYWJlbEhlaWdodDtcbiAgcHJvcHMud2lkdGggPSBmb3JlZ3JvdW5kLm9mZnNldFdpZHRoO1xuXG4gIHByb3BzLm1pbm9yTGluZUhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5yb290LmhlaWdodCAtIHByb3BzLm1ham9yTGFiZWxIZWlnaHQgLVxuICAgICAgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID09ICd0b3AnID8gdGhpcy5ib2R5LmRvbVByb3BzLmJvdHRvbS5oZWlnaHQgOiB0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCk7XG4gIHByb3BzLm1pbm9yTGluZVdpZHRoID0gMTsgLy8gVE9ETzogcmVhbGx5IGNhbGN1bGF0ZSB3aWR0aFxuICBwcm9wcy5tYWpvckxpbmVIZWlnaHQgPSBwcm9wcy5taW5vckxpbmVIZWlnaHQgKyBwcm9wcy5tYWpvckxhYmVsSGVpZ2h0O1xuICBwcm9wcy5tYWpvckxpbmVXaWR0aCA9IDE7IC8vIFRPRE86IHJlYWxseSBjYWxjdWxhdGUgd2lkdGhcblxuICAvLyAgdGFrZSBmb3JlZ3JvdW5kIGFuZCBiYWNrZ3JvdW5kIG9mZmxpbmUgd2hpbGUgdXBkYXRpbmcgKGlzIGFsbW9zdCB0d2ljZSBhcyBmYXN0KVxuICB2YXIgZm9yZWdyb3VuZE5leHRTaWJsaW5nID0gZm9yZWdyb3VuZC5uZXh0U2libGluZztcbiAgdmFyIGJhY2tncm91bmROZXh0U2libGluZyA9IGJhY2tncm91bmQubmV4dFNpYmxpbmc7XG4gIGZvcmVncm91bmQucGFyZW50Tm9kZSAmJiBmb3JlZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZm9yZWdyb3VuZCk7XG4gIGJhY2tncm91bmQucGFyZW50Tm9kZSAmJiBiYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYmFja2dyb3VuZCk7XG5cbiAgZm9yZWdyb3VuZC5zdHlsZS5oZWlnaHQgPSB0aGlzLnByb3BzLmhlaWdodCArICdweCc7XG5cbiAgdGhpcy5fcmVwYWludExhYmVscygpO1xuXG4gIC8vIHB1dCBET00gb25saW5lIGFnYWluIChhdCB0aGUgc2FtZSBwbGFjZSlcbiAgaWYgKGZvcmVncm91bmROZXh0U2libGluZykge1xuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZm9yZWdyb3VuZCwgZm9yZWdyb3VuZE5leHRTaWJsaW5nKTtcbiAgfVxuICBlbHNlIHtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZm9yZWdyb3VuZClcbiAgfVxuICBpZiAoYmFja2dyb3VuZE5leHRTaWJsaW5nKSB7XG4gICAgdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kVmVydGljYWwuaW5zZXJ0QmVmb3JlKGJhY2tncm91bmQsIGJhY2tncm91bmROZXh0U2libGluZyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kVmVydGljYWwuYXBwZW5kQ2hpbGQoYmFja2dyb3VuZClcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9pc1Jlc2l6ZWQoKSB8fCBwYXJlbnRDaGFuZ2VkO1xufTtcblxuLyoqXG4gKiBSZXBhaW50IG1ham9yIGFuZCBtaW5vciB0ZXh0IGxhYmVscyBhbmQgdmVydGljYWwgZ3JpZCBsaW5lc1xuICogQHByaXZhdGVcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLl9yZXBhaW50TGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcztcblxuICAvLyBjYWxjdWxhdGUgcmFuZ2UgYW5kIHN0ZXAgKHN0ZXAgc3VjaCB0aGF0IHdlIGhhdmUgc3BhY2UgZm9yIDcgY2hhcmFjdGVycyBwZXIgbGFiZWwpXG4gIHZhciBzdGFydCA9IHV0aWwuY29udmVydCh0aGlzLmJvZHkucmFuZ2Uuc3RhcnQsICdOdW1iZXInKTtcbiAgdmFyIGVuZCA9IHV0aWwuY29udmVydCh0aGlzLmJvZHkucmFuZ2UuZW5kLCAnTnVtYmVyJyk7XG4gIHZhciB0aW1lTGFiZWxzaXplID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKCh0aGlzLnByb3BzLm1pbm9yQ2hhcldpZHRoIHx8IDEwKSAqIDcpLnZhbHVlT2YoKTtcbiAgdmFyIG1pbmltdW1TdGVwID0gdGltZUxhYmVsc2l6ZSAtIERhdGVVdGlsLmdldEhpZGRlbkR1cmF0aW9uQmVmb3JlKHRoaXMub3B0aW9ucy5tb21lbnQsIHRoaXMuYm9keS5oaWRkZW5EYXRlcywgdGhpcy5ib2R5LnJhbmdlLCB0aW1lTGFiZWxzaXplKTtcbiAgbWluaW11bVN0ZXAgLT0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKDApLnZhbHVlT2YoKTtcblxuICB2YXIgc3RlcCA9IG5ldyBUaW1lU3RlcChuZXcgRGF0ZShzdGFydCksIG5ldyBEYXRlKGVuZCksIG1pbmltdW1TdGVwLCB0aGlzLmJvZHkuaGlkZGVuRGF0ZXMpO1xuICBzdGVwLnNldE1vbWVudCh0aGlzLm9wdGlvbnMubW9tZW50KTtcbiAgaWYgKHRoaXMub3B0aW9ucy5mb3JtYXQpIHtcbiAgICBzdGVwLnNldEZvcm1hdCh0aGlzLm9wdGlvbnMuZm9ybWF0KTtcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLnRpbWVBeGlzKSB7XG4gICAgc3RlcC5zZXRTY2FsZSh0aGlzLm9wdGlvbnMudGltZUF4aXMpO1xuICB9XG4gIHRoaXMuc3RlcCA9IHN0ZXA7XG5cbiAgLy8gTW92ZSBhbGwgRE9NIGVsZW1lbnRzIHRvIGEgXCJyZWR1bmRhbnRcIiBsaXN0LCB3aGVyZSB0aGV5XG4gIC8vIGNhbiBiZSBwaWNrZWQgZm9yIHJlLXVzZSwgYW5kIGNsZWFyIHRoZSBsaXN0cyB3aXRoIGxpbmVzIGFuZCB0ZXh0cy5cbiAgLy8gQXQgdGhlIGVuZCBvZiB0aGUgZnVuY3Rpb24gX3JlcGFpbnRMYWJlbHMsIGxlZnQgb3ZlciBlbGVtZW50cyB3aWxsIGJlIGNsZWFuZWQgdXBcbiAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICBkb20ucmVkdW5kYW50LmxpbmVzID0gZG9tLmxpbmVzO1xuICBkb20ucmVkdW5kYW50Lm1ham9yVGV4dHMgPSBkb20ubWFqb3JUZXh0cztcbiAgZG9tLnJlZHVuZGFudC5taW5vclRleHRzID0gZG9tLm1pbm9yVGV4dHM7XG4gIGRvbS5saW5lcyA9IFtdO1xuICBkb20ubWFqb3JUZXh0cyA9IFtdO1xuICBkb20ubWlub3JUZXh0cyA9IFtdO1xuXG4gIHZhciBjdXJyZW50O1xuICB2YXIgbmV4dDtcbiAgdmFyIHg7XG4gIHZhciB4TmV4dDtcbiAgdmFyIGlzTWFqb3I7XG4gIHZhciB3aWR0aDtcbiAgdmFyIGxpbmU7XG4gIHZhciBsYWJlbE1pbm9yO1xuICB2YXIgeEZpcnN0TWFqb3JMYWJlbCA9IHVuZGVmaW5lZDtcbiAgdmFyIG1heCA9IDA7XG4gIHZhciBjbGFzc05hbWU7XG5cbiAgc3RlcC5zdGFydCgpO1xuICBuZXh0ID0gc3RlcC5nZXRDdXJyZW50KCk7XG4gIHhOZXh0ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4obmV4dCk7XG4gIHdoaWxlIChzdGVwLmhhc05leHQoKSAmJiBtYXggPCAxMDAwKSB7XG4gICAgbWF4Kys7XG5cbiAgICBpc01ham9yID0gc3RlcC5pc01ham9yKCk7XG4gICAgY2xhc3NOYW1lID0gc3RlcC5nZXRDbGFzc05hbWUoKTtcbiAgICBsYWJlbE1pbm9yID0gc3RlcC5nZXRMYWJlbE1pbm9yKCk7XG5cbiAgICBjdXJyZW50ID0gbmV4dDtcbiAgICB4ID0geE5leHQ7XG5cbiAgICBzdGVwLm5leHQoKTtcbiAgICBuZXh0ID0gc3RlcC5nZXRDdXJyZW50KCk7XG4gICAgeE5leHQgPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihuZXh0KTtcblxuICAgIHdpZHRoID0geE5leHQgLSB4O1xuICAgIHZhciBsYWJlbEZpdHMgPSAobGFiZWxNaW5vci5sZW5ndGggKyAxKSAqIHRoaXMucHJvcHMubWlub3JDaGFyV2lkdGggPCB3aWR0aDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd01pbm9yTGFiZWxzICYmIGxhYmVsRml0cykge1xuICAgICAgdGhpcy5fcmVwYWludE1pbm9yVGV4dCh4LCBsYWJlbE1pbm9yLCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaXNNYWpvciAmJiB0aGlzLm9wdGlvbnMuc2hvd01ham9yTGFiZWxzKSB7XG4gICAgICBpZiAoeCA+IDApIHtcbiAgICAgICAgaWYgKHhGaXJzdE1ham9yTGFiZWwgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgeEZpcnN0TWFqb3JMYWJlbCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVwYWludE1ham9yVGV4dCh4LCBzdGVwLmdldExhYmVsTWFqb3IoKSwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgICBsaW5lID0gdGhpcy5fcmVwYWludE1ham9yTGluZSh4LCB3aWR0aCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGxhYmVsRml0cykge1xuICAgICAgICBsaW5lID0gdGhpcy5fcmVwYWludE1pbm9yTGluZSh4LCB3aWR0aCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICBsaW5lLnN0eWxlLndpZHRoID0gKHBhcnNlSW50IChsaW5lLnN0eWxlLndpZHRoKSArIHdpZHRoKSArICdweCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNyZWF0ZSBhIG1ham9yIGxhYmVsIG9uIHRoZSBsZWZ0IHdoZW4gbmVlZGVkXG4gIGlmICh0aGlzLm9wdGlvbnMuc2hvd01ham9yTGFiZWxzKSB7XG4gICAgdmFyIGxlZnRUaW1lID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKDApLFxuICAgICAgICBsZWZ0VGV4dCA9IHN0ZXAuZ2V0TGFiZWxNYWpvcihsZWZ0VGltZSksXG4gICAgICAgIHdpZHRoVGV4dCA9IGxlZnRUZXh0Lmxlbmd0aCAqICh0aGlzLnByb3BzLm1ham9yQ2hhcldpZHRoIHx8IDEwKSArIDEwOyAvLyB1cHBlciBib3VuZCBlc3RpbWF0aW9uXG5cbiAgICBpZiAoeEZpcnN0TWFqb3JMYWJlbCA9PSB1bmRlZmluZWQgfHwgd2lkdGhUZXh0IDwgeEZpcnN0TWFqb3JMYWJlbCkge1xuICAgICAgdGhpcy5fcmVwYWludE1ham9yVGV4dCgwLCBsZWZ0VGV4dCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW51cCBsZWZ0b3ZlciBET00gZWxlbWVudHMgZnJvbSB0aGUgcmVkdW5kYW50IGxpc3RcbiAgdXRpbC5mb3JFYWNoKHRoaXMuZG9tLnJlZHVuZGFudCwgZnVuY3Rpb24gKGFycikge1xuICAgIHdoaWxlIChhcnIubGVuZ3RoKSB7XG4gICAgICB2YXIgZWxlbSA9IGFyci5wb3AoKTtcbiAgICAgIGlmIChlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICBlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbWlub3IgbGFiZWwgZm9yIHRoZSBheGlzIGF0IHBvc2l0aW9uIHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtTdHJpbmd9IG9yaWVudGF0aW9uICAgXCJ0b3BcIiBvciBcImJvdHRvbVwiIChkZWZhdWx0KVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IG9mIHRoZSBjcmVhdGVkIGxhYmVsXG4gKiBAcHJpdmF0ZVxuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuX3JlcGFpbnRNaW5vclRleHQgPSBmdW5jdGlvbiAoeCwgdGV4dCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSkge1xuICAvLyByZXVzZSByZWR1bmRhbnQgbGFiZWxcbiAgdmFyIGxhYmVsID0gdGhpcy5kb20ucmVkdW5kYW50Lm1pbm9yVGV4dHMuc2hpZnQoKTtcblxuICBpZiAoIWxhYmVsKSB7XG4gICAgLy8gY3JlYXRlIG5ldyBsYWJlbFxuICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbGFiZWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgdGhpcy5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gIH1cbiAgdGhpcy5kb20ubWlub3JUZXh0cy5wdXNoKGxhYmVsKTtcblxuICBsYWJlbC5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSA9IHRleHQ7XG5cbiAgbGFiZWwuc3R5bGUudG9wID0gKG9yaWVudGF0aW9uID09ICd0b3AnKSA/ICh0aGlzLnByb3BzLm1ham9yTGFiZWxIZWlnaHQgKyAncHgnKSA6ICcwJztcbiAgbGFiZWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICBsYWJlbC5jbGFzc05hbWUgPSAndmlzLXRleHQgdmlzLW1pbm9yICcgKyBjbGFzc05hbWU7XG4gIC8vbGFiZWwudGl0bGUgPSB0aXRsZTsgIC8vIFRPRE86IHRoaXMgaXMgYSBoZWF2eSBvcGVyYXRpb25cblxuICByZXR1cm4gbGFiZWw7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIE1ham9yIGxhYmVsIGZvciB0aGUgYXhpcyBhdCBwb3NpdGlvbiB4XG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcmllbnRhdGlvbiAgIFwidG9wXCIgb3IgXCJib3R0b21cIiAoZGVmYXVsdClcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCBvZiB0aGUgY3JlYXRlZCBsYWJlbFxuICogQHByaXZhdGVcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLl9yZXBhaW50TWFqb3JUZXh0ID0gZnVuY3Rpb24gKHgsIHRleHQsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpIHtcbiAgLy8gcmV1c2UgcmVkdW5kYW50IGxhYmVsXG4gIHZhciBsYWJlbCA9IHRoaXMuZG9tLnJlZHVuZGFudC5tYWpvclRleHRzLnNoaWZ0KCk7XG5cbiAgaWYgKCFsYWJlbCkge1xuICAgIC8vIGNyZWF0ZSBsYWJlbFxuICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBsYWJlbC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgfVxuICB0aGlzLmRvbS5tYWpvclRleHRzLnB1c2gobGFiZWwpO1xuXG4gIGxhYmVsLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlID0gdGV4dDtcbiAgbGFiZWwuY2xhc3NOYW1lID0gJ3Zpcy10ZXh0IHZpcy1tYWpvciAnICsgY2xhc3NOYW1lO1xuICAvL2xhYmVsLnRpdGxlID0gdGl0bGU7IC8vIFRPRE86IHRoaXMgaXMgYSBoZWF2eSBvcGVyYXRpb25cblxuICBsYWJlbC5zdHlsZS50b3AgPSAob3JpZW50YXRpb24gPT0gJ3RvcCcpID8gJzAnIDogKHRoaXMucHJvcHMubWlub3JMYWJlbEhlaWdodCAgKyAncHgnKTtcbiAgbGFiZWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuXG4gIHJldHVybiBsYWJlbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbWlub3IgbGluZSBmb3IgdGhlIGF4aXMgYXQgcG9zaXRpb24geFxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtTdHJpbmd9IG9yaWVudGF0aW9uICAgXCJ0b3BcIiBvciBcImJvdHRvbVwiIChkZWZhdWx0KVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgY3JlYXRlZCBsaW5lXG4gKiBAcHJpdmF0ZVxuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuX3JlcGFpbnRNaW5vckxpbmUgPSBmdW5jdGlvbiAoeCwgd2lkdGgsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpIHtcbiAgLy8gcmV1c2UgcmVkdW5kYW50IGxpbmVcbiAgdmFyIGxpbmUgPSB0aGlzLmRvbS5yZWR1bmRhbnQubGluZXMuc2hpZnQoKTtcbiAgaWYgKCFsaW5lKSB7XG4gICAgLy8gY3JlYXRlIHZlcnRpY2FsIGxpbmVcbiAgICBsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZC5hcHBlbmRDaGlsZChsaW5lKTtcbiAgfVxuICB0aGlzLmRvbS5saW5lcy5wdXNoKGxpbmUpO1xuXG4gIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gIGlmIChvcmllbnRhdGlvbiA9PSAndG9wJykge1xuICAgIGxpbmUuc3R5bGUudG9wID0gcHJvcHMubWFqb3JMYWJlbEhlaWdodCArICdweCc7XG4gIH1cbiAgZWxzZSB7XG4gICAgbGluZS5zdHlsZS50b3AgPSB0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gIH1cbiAgbGluZS5zdHlsZS5oZWlnaHQgPSBwcm9wcy5taW5vckxpbmVIZWlnaHQgKyAncHgnO1xuICBsaW5lLnN0eWxlLmxlZnQgPSAoeCAtIHByb3BzLm1pbm9yTGluZVdpZHRoIC8gMikgKyAncHgnO1xuICBsaW5lLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXG4gIGxpbmUuY2xhc3NOYW1lID0gJ3Zpcy1ncmlkIHZpcy12ZXJ0aWNhbCB2aXMtbWlub3IgJyArIGNsYXNzTmFtZTtcblxuICByZXR1cm4gbGluZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgTWFqb3IgbGluZSBmb3IgdGhlIGF4aXMgYXQgcG9zaXRpb24geFxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtTdHJpbmd9IG9yaWVudGF0aW9uICAgXCJ0b3BcIiBvciBcImJvdHRvbVwiIChkZWZhdWx0KVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgY3JlYXRlZCBsaW5lXG4gKiBAcHJpdmF0ZVxuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuX3JlcGFpbnRNYWpvckxpbmUgPSBmdW5jdGlvbiAoeCwgd2lkdGgsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpIHtcbiAgLy8gcmV1c2UgcmVkdW5kYW50IGxpbmVcbiAgdmFyIGxpbmUgPSB0aGlzLmRvbS5yZWR1bmRhbnQubGluZXMuc2hpZnQoKTtcbiAgaWYgKCFsaW5lKSB7XG4gICAgLy8gY3JlYXRlIHZlcnRpY2FsIGxpbmVcbiAgICBsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZC5hcHBlbmRDaGlsZChsaW5lKTtcbiAgfVxuICB0aGlzLmRvbS5saW5lcy5wdXNoKGxpbmUpO1xuXG4gIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gIGlmIChvcmllbnRhdGlvbiA9PSAndG9wJykge1xuICAgIGxpbmUuc3R5bGUudG9wID0gJzAnO1xuICB9XG4gIGVsc2Uge1xuICAgIGxpbmUuc3R5bGUudG9wID0gdGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICB9XG4gIGxpbmUuc3R5bGUubGVmdCA9ICh4IC0gcHJvcHMubWFqb3JMaW5lV2lkdGggLyAyKSArICdweCc7XG4gIGxpbmUuc3R5bGUuaGVpZ2h0ID0gcHJvcHMubWFqb3JMaW5lSGVpZ2h0ICsgJ3B4JztcbiAgbGluZS5zdHlsZS53aWR0aCA9IHdpZHRoICArICdweCc7XG5cbiAgbGluZS5jbGFzc05hbWUgPSAndmlzLWdyaWQgdmlzLXZlcnRpY2FsIHZpcy1tYWpvciAnICsgY2xhc3NOYW1lO1xuXG4gIHJldHVybiBsaW5lO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIHNpemUgb2YgdGV4dCBvbiB0aGUgYXhpcyAoYm90aCBtYWpvciBhbmQgbWlub3IgYXhpcykuXG4gKiBUaGUgc2l6ZSBpcyBjYWxjdWxhdGVkIG9ubHkgb25jZSBhbmQgdGhlbiBjYWNoZWQgaW4gdGhpcy5wcm9wcy5cbiAqIEBwcml2YXRlXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5fY2FsY3VsYXRlQ2hhclNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIE5vdGU6IFdlIGNhbGN1bGF0ZSBjaGFyIHNpemUgd2l0aCBldmVyeSByZWRyYXcuIFNpemUgbWF5IGNoYW5nZSwgZm9yXG4gIC8vIGV4YW1wbGUgd2hlbiBhbnkgb2YgdGhlIHRpbWVsaW5lcyBwYXJlbnRzIGhhZCBkaXNwbGF5Om5vbmUgZm9yIGV4YW1wbGUuXG5cbiAgLy8gZGV0ZXJtaW5lIHRoZSBjaGFyIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIG1pbm9yIGF4aXNcbiAgaWYgKCF0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yKSB7XG4gICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IuY2xhc3NOYW1lID0gJ3Zpcy10ZXh0IHZpcy1taW5vciB2aXMtbWVhc3VyZSc7XG4gICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcwJykpO1xuICAgIHRoaXMuZG9tLmZvcmVncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vcik7XG4gIH1cbiAgdGhpcy5wcm9wcy5taW5vckNoYXJIZWlnaHQgPSB0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yLmNsaWVudEhlaWdodDtcbiAgdGhpcy5wcm9wcy5taW5vckNoYXJXaWR0aCA9IHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IuY2xpZW50V2lkdGg7XG5cbiAgLy8gZGV0ZXJtaW5lIHRoZSBjaGFyIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIG1ham9yIGF4aXNcbiAgaWYgKCF0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yKSB7XG4gICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3IuY2xhc3NOYW1lID0gJ3Zpcy10ZXh0IHZpcy1tYWpvciB2aXMtbWVhc3VyZSc7XG4gICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcwJykpO1xuICAgIHRoaXMuZG9tLmZvcmVncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvcik7XG4gIH1cbiAgdGhpcy5wcm9wcy5tYWpvckNoYXJIZWlnaHQgPSB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yLmNsaWVudEhlaWdodDtcbiAgdGhpcy5wcm9wcy5tYWpvckNoYXJXaWR0aCA9IHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3IuY2xpZW50V2lkdGg7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVBeGlzO1xuIiwidmFyIEhhbW1lciA9IHJlcXVpcmUoJy4uLy4uLy4uL21vZHVsZS9oYW1tZXInKTtcbnZhciBJdGVtID0gcmVxdWlyZSgnLi9JdGVtJyk7XG52YXIgQmFja2dyb3VuZEdyb3VwID0gcmVxdWlyZSgnLi4vQmFja2dyb3VuZEdyb3VwJyk7XG52YXIgUmFuZ2VJdGVtID0gcmVxdWlyZSgnLi9SYW5nZUl0ZW0nKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgQmFja2dyb3VuZEl0ZW1cbiAqIEBleHRlbmRzIEl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgc3RhcnQsIGVuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCwgY2xhc3NOYW1lLlxuICogQHBhcmFtIHt7dG9TY3JlZW46IGZ1bmN0aW9uLCB0b1RpbWU6IGZ1bmN0aW9ufX0gY29udmVyc2lvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVyc2lvbiBmdW5jdGlvbnMgZnJvbSB0aW1lIHRvIHNjcmVlbiBhbmQgdmljZSB2ZXJzYVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXNjcmliZSBvcHRpb25zXG4gKi9cbi8vIFRPRE86IGltcGxlbWVudCBzdXBwb3J0IGZvciB0aGUgQmFja2dyb3VuZEl0ZW0ganVzdCBoYXZpbmcgYSBzdGFydCwgdGhlbiBiZWluZyBkaXNwbGF5ZWQgYXMgYSBzb3J0IG9mIGFuIGFubm90YXRpb25cbmZ1bmN0aW9uIEJhY2tncm91bmRJdGVtIChkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHRoaXMucHJvcHMgPSB7XG4gICAgY29udGVudDoge1xuICAgICAgd2lkdGg6IDBcbiAgICB9XG4gIH07XG4gIHRoaXMub3ZlcmZsb3cgPSBmYWxzZTsgLy8gaWYgY29udGVudHMgY2FuIG92ZXJmbG93IChjc3Mgc3R5bGluZyksIHRoaXMgZmxhZyBpcyBzZXQgdG8gdHJ1ZVxuXG4gIC8vIHZhbGlkYXRlIGRhdGFcbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5zdGFydCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJzdGFydFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YS5pZCk7XG4gICAgfVxuICAgIGlmIChkYXRhLmVuZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJlbmRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEuaWQpO1xuICAgIH1cbiAgfVxuXG4gIEl0ZW0uY2FsbCh0aGlzLCBkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKTtcbn1cblxuQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlID0gbmV3IEl0ZW0gKG51bGwsIG51bGwsIG51bGwpO1xuXG5CYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUuYmFzZUNsYXNzTmFtZSA9ICd2aXMtaXRlbSB2aXMtYmFja2dyb3VuZCc7XG5CYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUuc3RhY2sgPSBmYWxzZTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoaXMgaXRlbSBpcyB2aXNpYmxlIGluc2lkZSBnaXZlbiByYW5nZVxuICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZpc2libGVcbiAqL1xuQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gIC8vIGRldGVybWluZSB2aXNpYmlsaXR5XG4gIHJldHVybiAodGhpcy5kYXRhLnN0YXJ0IDwgcmFuZ2UuZW5kKSAmJiAodGhpcy5kYXRhLmVuZCA+IHJhbmdlLnN0YXJ0KTtcbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgaXRlbVxuICovXG5CYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgaWYgKCFkb20pIHtcbiAgICAvLyBjcmVhdGUgRE9NXG4gICAgdGhpcy5kb20gPSB7fTtcbiAgICBkb20gPSB0aGlzLmRvbTtcblxuICAgIC8vIGJhY2tncm91bmQgYm94XG4gICAgZG9tLmJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8vIGNsYXNzTmFtZSBpcyB1cGRhdGVkIGluIHJlZHJhdygpXG5cbiAgICAvLyBmcmFtZSBib3ggKHRvIHByZXZlbnQgdGhlIGl0ZW0gY29udGVudHMgZnJvbSBvdmVyZmxvd2luZ1xuICAgIGRvbS5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbS5mcmFtZS5jbGFzc05hbWUgPSAndmlzLWl0ZW0tb3ZlcmZsb3cnO1xuICAgIGRvbS5ib3guYXBwZW5kQ2hpbGQoZG9tLmZyYW1lKTtcblxuICAgIC8vIGNvbnRlbnRzIGJveFxuICAgIGRvbS5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9tLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLWNvbnRlbnQnO1xuICAgIGRvbS5mcmFtZS5hcHBlbmRDaGlsZChkb20uY29udGVudCk7XG5cbiAgICAvLyBOb3RlOiB3ZSBkbyBOT1QgYXR0YWNoIHRoaXMgaXRlbSBhcyBhdHRyaWJ1dGUgdG8gdGhlIERPTSxcbiAgICAvLyAgICAgICBzdWNoIHRoYXQgYmFja2dyb3VuZCBpdGVtcyBjYW5ub3QgYmUgc2VsZWN0ZWRcbiAgICAvL2RvbS5ib3hbJ3RpbWVsaW5lLWl0ZW0nXSA9IHRoaXM7XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGFwcGVuZCBET00gdG8gcGFyZW50IERPTVxuICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IG5vIHBhcmVudCBhdHRhY2hlZCcpO1xuICB9XG4gIGlmICghZG9tLmJveC5wYXJlbnROb2RlKSB7XG4gICAgdmFyIGJhY2tncm91bmQgPSB0aGlzLnBhcmVudC5kb20uYmFja2dyb3VuZDtcbiAgICBpZiAoIWJhY2tncm91bmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBwYXJlbnQgaGFzIG5vIGJhY2tncm91bmQgY29udGFpbmVyIGVsZW1lbnQnKTtcbiAgICB9XG4gICAgYmFja2dyb3VuZC5hcHBlbmRDaGlsZChkb20uYm94KTtcbiAgfVxuICB0aGlzLmRpc3BsYXllZCA9IHRydWU7XG5cbiAgLy8gVXBkYXRlIERPTSB3aGVuIGl0ZW0gaXMgbWFya2VkIGRpcnR5LiBBbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eSB3aGVuOlxuICAvLyAtIHRoZSBpdGVtIGlzIG5vdCB5ZXQgcmVuZGVyZWRcbiAgLy8gLSB0aGUgaXRlbSdzIGRhdGEgaXMgY2hhbmdlZFxuICAvLyAtIHRoZSBpdGVtIGlzIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICB0aGlzLl91cGRhdGVDb250ZW50cyh0aGlzLmRvbS5jb250ZW50KTtcbiAgICB0aGlzLl91cGRhdGVUaXRsZSh0aGlzLmRvbS5jb250ZW50KTtcbiAgICB0aGlzLl91cGRhdGVEYXRhQXR0cmlidXRlcyh0aGlzLmRvbS5jb250ZW50KTtcbiAgICB0aGlzLl91cGRhdGVTdHlsZSh0aGlzLmRvbS5ib3gpO1xuXG4gICAgLy8gdXBkYXRlIGNsYXNzXG4gICAgdmFyIGNsYXNzTmFtZSA9ICh0aGlzLmRhdGEuY2xhc3NOYW1lID8gKCcgJyArIHRoaXMuZGF0YS5jbGFzc05hbWUpIDogJycpICtcbiAgICAgICAgKHRoaXMuc2VsZWN0ZWQgPyAnIHZpcy1zZWxlY3RlZCcgOiAnJyk7XG4gICAgZG9tLmJveC5jbGFzc05hbWUgPSB0aGlzLmJhc2VDbGFzc05hbWUgKyBjbGFzc05hbWU7XG5cbiAgICAvLyBkZXRlcm1pbmUgZnJvbSBjc3Mgd2hldGhlciB0aGlzIGJveCBoYXMgb3ZlcmZsb3dcbiAgICB0aGlzLm92ZXJmbG93ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tLmNvbnRlbnQpLm92ZXJmbG93ICE9PSAnaGlkZGVuJztcblxuICAgIC8vIHJlY2FsY3VsYXRlIHNpemVcbiAgICB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGggPSB0aGlzLmRvbS5jb250ZW50Lm9mZnNldFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDsgLy8gc2V0IGhlaWdodCB6ZXJvLCBzbyB0aGlzIGl0ZW0gd2lsbCBiZSBpZ25vcmVkIHdoZW4gc3RhY2tpbmcgaXRlbXNcblxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBTaG93IHRoZSBpdGVtIGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSkuIFRoZSBpdGVtcyBET00gd2lsbFxuICogYmUgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAqL1xuQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLnNob3cgPSBSYW5nZUl0ZW0ucHJvdG90eXBlLnNob3c7XG5cbi8qKlxuICogSGlkZSB0aGUgaXRlbSBmcm9tIHRoZSBET00gKHdoZW4gdmlzaWJsZSlcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAqL1xuQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLmhpZGUgPSBSYW5nZUl0ZW0ucHJvdG90eXBlLmhpZGU7XG5cbi8qKlxuICogUmVwb3NpdGlvbiB0aGUgaXRlbSBob3Jpem9udGFsbHlcbiAqIEBPdmVycmlkZVxuICovXG5CYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblggPSBSYW5nZUl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YO1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gdmVydGljYWxseVxuICogQE92ZXJyaWRlXG4gKi9cbkJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWSA9IGZ1bmN0aW9uKG1hcmdpbikge1xuICB2YXIgb25Ub3AgPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9PT0gJ3RvcCc7XG4gIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUudG9wID0gb25Ub3AgPyAnJyA6ICcwJztcbiAgdGhpcy5kb20uY29udGVudC5zdHlsZS5ib3R0b20gPSBvblRvcCA/ICcwJyA6ICcnO1xuICB2YXIgaGVpZ2h0O1xuXG4gIC8vIHNwZWNpYWwgcG9zaXRpb25pbmcgZm9yIHN1Ymdyb3Vwc1xuICBpZiAodGhpcy5kYXRhLnN1Ymdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIGNhbGN1bGF0aW5nIHRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIHN1Ymdyb3VwcyBoZXJlIGZvciBldmVyeSBCYWNrZ3JvdW5kSXRlbSwgY2FsY3VsYXRlIHRoZSB0b3Agb2YgdGhlIHN1Ymdyb3VwIG9uY2UgaW4gSXRlbXNldFxuXG4gICAgdmFyIGl0ZW1TdWJncm91cCA9IHRoaXMuZGF0YS5zdWJncm91cDtcbiAgICB2YXIgc3ViZ3JvdXBzID0gdGhpcy5wYXJlbnQuc3ViZ3JvdXBzO1xuICAgIHZhciBzdWJncm91cEluZGV4ID0gc3ViZ3JvdXBzW2l0ZW1TdWJncm91cF0uaW5kZXg7XG4gICAgLy8gaWYgdGhlIG9yaWVudGF0aW9uIGlzIHRvcCwgd2UgbmVlZCB0byB0YWtlIHRoZSBkaWZmZXJlbmNlIGluIGhlaWdodCBpbnRvIGFjY291bnQuXG4gICAgaWYgKG9uVG9wID09IHRydWUpIHtcbiAgICAgIC8vIHRoZSBmaXJzdCBzdWJncm91cCB3aWxsIGhhdmUgdG8gYWNjb3VudCBmb3IgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHRvcCB0byB0aGUgZmlyc3QgaXRlbS5cbiAgICAgIGhlaWdodCA9IHRoaXMucGFyZW50LnN1Ymdyb3Vwc1tpdGVtU3ViZ3JvdXBdLmhlaWdodCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuICAgICAgaGVpZ2h0ICs9IHN1Ymdyb3VwSW5kZXggPT0gMCA/IG1hcmdpbi5heGlzIC0gMC41Km1hcmdpbi5pdGVtLnZlcnRpY2FsIDogMDtcbiAgICAgIHZhciBuZXdUb3AgPSB0aGlzLnBhcmVudC50b3A7XG4gICAgICBmb3IgKHZhciBzdWJncm91cCBpbiBzdWJncm91cHMpIHtcbiAgICAgICAgaWYgKHN1Ymdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShzdWJncm91cCkpIHtcbiAgICAgICAgICBpZiAoc3ViZ3JvdXBzW3N1Ymdyb3VwXS52aXNpYmxlID09IHRydWUgJiYgc3ViZ3JvdXBzW3N1Ymdyb3VwXS5pbmRleCA8IHN1Ymdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIG5ld1RvcCArPSBzdWJncm91cHNbc3ViZ3JvdXBdLmhlaWdodCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0aGUgb3RoZXJzIHdpbGwgaGF2ZSB0byBiZSBvZmZzZXQgZG93bndhcmRzIHdpdGggdGhpcyBzYW1lIGRpc3RhbmNlLlxuICAgICAgbmV3VG9wICs9IHN1Ymdyb3VwSW5kZXggIT0gMCA/IG1hcmdpbi5heGlzIC0gMC41ICogbWFyZ2luLml0ZW0udmVydGljYWwgOiAwO1xuICAgICAgdGhpcy5kb20uYm94LnN0eWxlLnRvcCA9IG5ld1RvcCArICdweCc7XG4gICAgICB0aGlzLmRvbS5ib3guc3R5bGUuYm90dG9tID0gJyc7XG4gICAgfVxuICAgIC8vIGFuZCB3aGVuIHRoZSBvcmllbnRhdGlvbiBpcyBib3R0b206XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VG9wID0gdGhpcy5wYXJlbnQudG9wO1xuICAgICAgdmFyIHRvdGFsSGVpZ2h0ID0gMDtcbiAgICAgIGZvciAodmFyIHN1Ymdyb3VwIGluIHN1Ymdyb3Vwcykge1xuICAgICAgICBpZiAoc3ViZ3JvdXBzLmhhc093blByb3BlcnR5KHN1Ymdyb3VwKSkge1xuICAgICAgICAgIGlmIChzdWJncm91cHNbc3ViZ3JvdXBdLnZpc2libGUgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG5ld0hlaWdodCA9IHN1Ymdyb3Vwc1tzdWJncm91cF0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICAgICAgICB0b3RhbEhlaWdodCArPSBuZXdIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoc3ViZ3JvdXBzW3N1Ymdyb3VwXS5pbmRleCA+IHN1Ymdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgICAgbmV3VG9wICs9IG5ld0hlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhlaWdodCA9IHRoaXMucGFyZW50LnN1Ymdyb3Vwc1tpdGVtU3ViZ3JvdXBdLmhlaWdodCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuICAgICAgdGhpcy5kb20uYm94LnN0eWxlLnRvcCA9ICh0aGlzLnBhcmVudC5oZWlnaHQgLSB0b3RhbEhlaWdodCArIG5ld1RvcCkgKyAncHgnO1xuICAgICAgdGhpcy5kb20uYm94LnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgIH1cbiAgfVxuICAvLyBhbmQgaW4gdGhlIGNhc2Ugb2Ygbm8gc3ViZ3JvdXBzOlxuICBlbHNlIHtcbiAgICAvLyB3ZSB3YW50IGJhY2tncm91bmRzIHdpdGggZ3JvdXBzIHRvIG9ubHkgc2hvdyBpbiBncm91cHMuXG4gICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgQmFja2dyb3VuZEdyb3VwKSB7XG4gICAgICAvLyBpZiB0aGUgaXRlbSBpcyBub3QgaW4gYSBncm91cDpcbiAgICAgIGhlaWdodCA9IE1hdGgubWF4KHRoaXMucGFyZW50LmhlaWdodCxcbiAgICAgICAgICB0aGlzLnBhcmVudC5pdGVtU2V0LmJvZHkuZG9tUHJvcHMuY2VudGVyLmhlaWdodCxcbiAgICAgICAgICB0aGlzLnBhcmVudC5pdGVtU2V0LmJvZHkuZG9tUHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCk7XG4gICAgICB0aGlzLmRvbS5ib3guc3R5bGUudG9wID0gb25Ub3AgPyAnMCcgOiAnJztcbiAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5ib3R0b20gPSBvblRvcCA/ICcnIDogJzAnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlaWdodCA9IHRoaXMucGFyZW50LmhlaWdodDtcbiAgICAgIC8vIHNhbWUgYWxpZ25tZW50IGZvciBpdGVtcyB3aGVuIG9yaWVudGF0aW9uIGlzIHRvcCBvciBib3R0b21cbiAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS50b3AgPSB0aGlzLnBhcmVudC50b3AgKyAncHgnO1xuICAgICAgdGhpcy5kb20uYm94LnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgIH1cbiAgfVxuICB0aGlzLmRvbS5ib3guc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2dyb3VuZEl0ZW07XG4iLCJ2YXIgSXRlbSA9IHJlcXVpcmUoJy4vSXRlbScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIEJveEl0ZW1cbiAqIEBleHRlbmRzIEl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgc3RhcnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsIGNsYXNzTmFtZS5cbiAqIEBwYXJhbSB7e3RvU2NyZWVuOiBmdW5jdGlvbiwgdG9UaW1lOiBmdW5jdGlvbn19IGNvbnZlcnNpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnZlcnNpb24gZnVuY3Rpb25zIGZyb20gdGltZSB0byBzY3JlZW4gYW5kIHZpY2UgdmVyc2FcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVzY3JpYmUgYXZhaWxhYmxlIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gQm94SXRlbSAoZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucykge1xuICB0aGlzLnByb3BzID0ge1xuICAgIGRvdDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9LFxuICAgIGxpbmU6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfVxuICB9O1xuXG4gIC8vIHZhbGlkYXRlIGRhdGFcbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5zdGFydCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJzdGFydFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgSXRlbS5jYWxsKHRoaXMsIGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpO1xufVxuXG5Cb3hJdGVtLnByb3RvdHlwZSA9IG5ldyBJdGVtIChudWxsLCBudWxsLCBudWxsKTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoaXMgaXRlbSBpcyB2aXNpYmxlIGluc2lkZSBnaXZlbiByYW5nZVxuICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZpc2libGVcbiAqL1xuQm94SXRlbS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgLy8gZGV0ZXJtaW5lIHZpc2liaWxpdHlcbiAgLy8gVE9ETzogYWNjb3VudCBmb3IgdGhlIHJlYWwgd2lkdGggb2YgdGhlIGl0ZW0uIFJpZ2h0IG5vdyB3ZSBqdXN0IGFkZCAxLzQgdG8gdGhlIHdpbmRvd1xuICB2YXIgaW50ZXJ2YWwgPSAocmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQpIC8gNDtcbiAgcmV0dXJuICh0aGlzLmRhdGEuc3RhcnQgPiByYW5nZS5zdGFydCAtIGludGVydmFsKSAmJiAodGhpcy5kYXRhLnN0YXJ0IDwgcmFuZ2UuZW5kICsgaW50ZXJ2YWwpO1xufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBpdGVtXG4gKi9cbkJveEl0ZW0ucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZG9tID0gdGhpcy5kb207XG4gIGlmICghZG9tKSB7XG4gICAgLy8gY3JlYXRlIERPTVxuICAgIHRoaXMuZG9tID0ge307XG4gICAgZG9tID0gdGhpcy5kb207XG5cbiAgICAvLyBjcmVhdGUgbWFpbiBib3hcbiAgICBkb20uYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG5cbiAgICAvLyBjb250ZW50cyBib3ggKGluc2lkZSB0aGUgYmFja2dyb3VuZCBib3gpLiB1c2VkIGZvciBtYWtpbmcgbWFyZ2luc1xuICAgIGRvbS5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgZG9tLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLWNvbnRlbnQnO1xuICAgIGRvbS5ib3guYXBwZW5kQ2hpbGQoZG9tLmNvbnRlbnQpO1xuXG4gICAgLy8gbGluZSB0byBheGlzXG4gICAgZG9tLmxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICBkb20ubGluZS5jbGFzc05hbWUgPSAndmlzLWxpbmUnO1xuXG4gICAgLy8gZG90IG9uIGF4aXNcbiAgICBkb20uZG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgZG9tLmRvdC5jbGFzc05hbWUgPSAndmlzLWRvdCc7XG5cbiAgICAvLyBhdHRhY2ggdGhpcyBpdGVtIGFzIGF0dHJpYnV0ZVxuICAgIGRvbS5ib3hbJ3RpbWVsaW5lLWl0ZW0nXSA9IHRoaXM7XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGFwcGVuZCBET00gdG8gcGFyZW50IERPTVxuICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IG5vIHBhcmVudCBhdHRhY2hlZCcpO1xuICB9XG4gIGlmICghZG9tLmJveC5wYXJlbnROb2RlKSB7XG4gICAgdmFyIGZvcmVncm91bmQgPSB0aGlzLnBhcmVudC5kb20uZm9yZWdyb3VuZDtcbiAgICBpZiAoIWZvcmVncm91bmQpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBwYXJlbnQgaGFzIG5vIGZvcmVncm91bmQgY29udGFpbmVyIGVsZW1lbnQnKTtcbiAgICBmb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGRvbS5ib3gpO1xuICB9XG4gIGlmICghZG9tLmxpbmUucGFyZW50Tm9kZSkge1xuICAgIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5wYXJlbnQuZG9tLmJhY2tncm91bmQ7XG4gICAgaWYgKCFiYWNrZ3JvdW5kKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogcGFyZW50IGhhcyBubyBiYWNrZ3JvdW5kIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgYmFja2dyb3VuZC5hcHBlbmRDaGlsZChkb20ubGluZSk7XG4gIH1cbiAgaWYgKCFkb20uZG90LnBhcmVudE5vZGUpIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMucGFyZW50LmRvbS5heGlzO1xuICAgIGlmICghYmFja2dyb3VuZCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IHBhcmVudCBoYXMgbm8gYXhpcyBjb250YWluZXIgZWxlbWVudCcpO1xuICAgIGF4aXMuYXBwZW5kQ2hpbGQoZG9tLmRvdCk7XG4gIH1cbiAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuXG4gIC8vIFVwZGF0ZSBET00gd2hlbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eS4gQW4gaXRlbSBpcyBtYXJrZWQgZGlydHkgd2hlbjpcbiAgLy8gLSB0aGUgaXRlbSBpcyBub3QgeWV0IHJlbmRlcmVkXG4gIC8vIC0gdGhlIGl0ZW0ncyBkYXRhIGlzIGNoYW5nZWRcbiAgLy8gLSB0aGUgaXRlbSBpcyBzZWxlY3RlZC9kZXNlbGVjdGVkXG4gIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgdGhpcy5fdXBkYXRlQ29udGVudHModGhpcy5kb20uY29udGVudCk7XG4gICAgdGhpcy5fdXBkYXRlVGl0bGUodGhpcy5kb20uYm94KTtcbiAgICB0aGlzLl91cGRhdGVEYXRhQXR0cmlidXRlcyh0aGlzLmRvbS5ib3gpO1xuICAgIHRoaXMuX3VwZGF0ZVN0eWxlKHRoaXMuZG9tLmJveCk7XG5cbiAgICB2YXIgZWRpdGFibGUgPSAodGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgfHwgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRhYmxlID09PSB0cnVlKSAmJlxuICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdGFibGUgIT09IGZhbHNlO1xuXG4gICAgLy8gdXBkYXRlIGNsYXNzXG4gICAgdmFyIGNsYXNzTmFtZSA9ICh0aGlzLmRhdGEuY2xhc3NOYW1lPyAnICcgKyB0aGlzLmRhdGEuY2xhc3NOYW1lIDogJycpICtcbiAgICAgICAgKHRoaXMuc2VsZWN0ZWQgPyAnIHZpcy1zZWxlY3RlZCcgOiAnJykgKyBcbiAgICAgICAgKGVkaXRhYmxlID8gJyB2aXMtZWRpdGFibGUnIDogJyB2aXMtcmVhZG9ubHknKTtcbiAgICBkb20uYm94LmNsYXNzTmFtZSA9ICd2aXMtaXRlbSB2aXMtYm94JyArIGNsYXNzTmFtZTtcbiAgICBkb20ubGluZS5jbGFzc05hbWUgPSAndmlzLWl0ZW0gdmlzLWxpbmUnICsgY2xhc3NOYW1lO1xuICAgIGRvbS5kb3QuY2xhc3NOYW1lICA9ICd2aXMtaXRlbSB2aXMtZG90JyArIGNsYXNzTmFtZTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIHNpemVcbiAgICB0aGlzLnByb3BzLmRvdC5oZWlnaHQgPSBkb20uZG90Lm9mZnNldEhlaWdodDtcbiAgICB0aGlzLnByb3BzLmRvdC53aWR0aCA9IGRvbS5kb3Qub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5wcm9wcy5saW5lLndpZHRoID0gZG9tLmxpbmUub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy53aWR0aCA9IGRvbS5ib3gub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBkb20uYm94Lm9mZnNldEhlaWdodDtcblxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuXG4gIHRoaXMuX3JlcGFpbnREZWxldGVCdXR0b24oZG9tLmJveCk7XG59O1xuXG4vKipcbiAqIFNob3cgdGhlIGl0ZW0gaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSBkaXNwbGF5ZWQpLiBUaGUgaXRlbXMgRE9NIHdpbGxcbiAqIGJlIGNyZWF0ZWQgd2hlbiBuZWVkZWQuXG4gKi9cbkJveEl0ZW0ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmRpc3BsYXllZCkge1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH1cbn07XG5cbi8qKlxuICogSGlkZSB0aGUgaXRlbSBmcm9tIHRoZSBET00gKHdoZW4gdmlzaWJsZSlcbiAqL1xuQm94SXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICB2YXIgZG9tID0gdGhpcy5kb207XG5cbiAgICBpZiAoZG9tLmJveC5wYXJlbnROb2RlKSAgIGRvbS5ib3gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20uYm94KTtcbiAgICBpZiAoZG9tLmxpbmUucGFyZW50Tm9kZSkgIGRvbS5saW5lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tLmxpbmUpO1xuICAgIGlmIChkb20uZG90LnBhcmVudE5vZGUpICAgZG9tLmRvdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbS5kb3QpO1xuXG4gICAgdGhpcy5kaXNwbGF5ZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIGhvcml6b250YWxseVxuICogQE92ZXJyaWRlXG4gKi9cbkJveEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFydCA9IHRoaXMuY29udmVyc2lvbi50b1NjcmVlbih0aGlzLmRhdGEuc3RhcnQpO1xuICB2YXIgYWxpZ24gPSB0aGlzLm9wdGlvbnMuYWxpZ247XG4gIHZhciBsZWZ0O1xuXG4gIC8vIGNhbGN1bGF0ZSBsZWZ0IHBvc2l0aW9uIG9mIHRoZSBib3hcbiAgaWYgKGFsaWduID09ICdyaWdodCcpIHtcbiAgICB0aGlzLmxlZnQgPSBzdGFydCAtIHRoaXMud2lkdGg7XG4gIH1cbiAgZWxzZSBpZiAoYWxpZ24gPT0gJ2xlZnQnKSB7XG4gICAgdGhpcy5sZWZ0ID0gc3RhcnQ7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZGVmYXVsdCBvciAnY2VudGVyJ1xuICAgIHRoaXMubGVmdCA9IHN0YXJ0IC0gdGhpcy53aWR0aCAvIDI7XG4gIH1cblxuICAvLyByZXBvc2l0aW9uIGJveFxuICB0aGlzLmRvbS5ib3guc3R5bGUubGVmdCA9IHRoaXMubGVmdCArICdweCc7XG5cbiAgLy8gcmVwb3NpdGlvbiBsaW5lXG4gIHRoaXMuZG9tLmxpbmUuc3R5bGUubGVmdCA9IChzdGFydCAtIHRoaXMucHJvcHMubGluZS53aWR0aCAvIDIpICsgJ3B4JztcblxuICAvLyByZXBvc2l0aW9uIGRvdFxuICB0aGlzLmRvbS5kb3Quc3R5bGUubGVmdCA9IChzdGFydCAtIHRoaXMucHJvcHMuZG90LndpZHRoIC8gMikgKyAncHgnO1xufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIHZlcnRpY2FsbHlcbiAqIEBPdmVycmlkZVxuICovXG5Cb3hJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbTtcbiAgdmFyIGJveCA9IHRoaXMuZG9tLmJveDtcbiAgdmFyIGxpbmUgPSB0aGlzLmRvbS5saW5lO1xuICB2YXIgZG90ID0gdGhpcy5kb20uZG90O1xuXG4gIGlmIChvcmllbnRhdGlvbiA9PSAndG9wJykge1xuICAgIGJveC5zdHlsZS50b3AgICAgID0gKHRoaXMudG9wIHx8IDApICsgJ3B4JztcblxuICAgIGxpbmUuc3R5bGUudG9wICAgID0gJzAnO1xuICAgIGxpbmUuc3R5bGUuaGVpZ2h0ID0gKHRoaXMucGFyZW50LnRvcCArIHRoaXMudG9wICsgMSkgKyAncHgnO1xuICAgIGxpbmUuc3R5bGUuYm90dG9tID0gJyc7XG4gIH1cbiAgZWxzZSB7IC8vIG9yaWVudGF0aW9uICdib3R0b20nXG4gICAgdmFyIGl0ZW1TZXRIZWlnaHQgPSB0aGlzLnBhcmVudC5pdGVtU2V0LnByb3BzLmhlaWdodDsgLy8gVE9ETzogdGhpcyBpcyBuYXN0eVxuICAgIHZhciBsaW5lSGVpZ2h0ID0gaXRlbVNldEhlaWdodCAtIHRoaXMucGFyZW50LnRvcCAtIHRoaXMucGFyZW50LmhlaWdodCArIHRoaXMudG9wO1xuXG4gICAgYm94LnN0eWxlLnRvcCAgICAgPSAodGhpcy5wYXJlbnQuaGVpZ2h0IC0gdGhpcy50b3AgLSB0aGlzLmhlaWdodCB8fCAwKSArICdweCc7XG4gICAgbGluZS5zdHlsZS50b3AgICAgPSAoaXRlbVNldEhlaWdodCAtIGxpbmVIZWlnaHQpICsgJ3B4JztcbiAgICBsaW5lLnN0eWxlLmJvdHRvbSA9ICcwJztcbiAgfVxuXG4gIGRvdC5zdHlsZS50b3AgPSAoLXRoaXMucHJvcHMuZG90LmhlaWdodCAvIDIpICsgJ3B4Jztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgaXRlbSBsZWZ0IGZyb20gaXRzIHN0YXJ0IGRhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuQm94SXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy53aWR0aCAvIDI7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGl0ZW0gcmlnaHQgZnJvbSBpdHMgc3RhcnQgZGF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5Cb3hJdGVtLnByb3RvdHlwZS5nZXRXaWR0aFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy53aWR0aCAvIDI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJveEl0ZW07XG4iLCJ2YXIgSGFtbWVyID0gcmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlL2hhbW1lcicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIEl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIChvcHRpb25hbCkgcGFyYW1ldGVycyB0eXBlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQsIGVuZCwgY29udGVudCwgZ3JvdXAsIGNsYXNzTmFtZS5cbiAqIEBwYXJhbSB7e3RvU2NyZWVuOiBmdW5jdGlvbiwgdG9UaW1lOiBmdW5jdGlvbn19IGNvbnZlcnNpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnZlcnNpb24gZnVuY3Rpb25zIGZyb20gdGltZSB0byBzY3JlZW4gYW5kIHZpY2UgdmVyc2FcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVzY3JpYmUgYXZhaWxhYmxlIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gSXRlbSAoZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucykge1xuICB0aGlzLmlkID0gbnVsbDtcbiAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmRvbSA9IG51bGw7XG4gIHRoaXMuY29udmVyc2lvbiA9IGNvbnZlcnNpb24gfHwge307XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc3BsYXllZCA9IGZhbHNlO1xuICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICB0aGlzLnRvcCA9IG51bGw7XG4gIHRoaXMubGVmdCA9IG51bGw7XG4gIHRoaXMud2lkdGggPSBudWxsO1xuICB0aGlzLmhlaWdodCA9IG51bGw7XG5cbiAgdGhpcy5lZGl0YWJsZSA9IG51bGw7XG4gIGlmICh0aGlzLmRhdGEgJiYgXG4gICAgICB0aGlzLmRhdGEuaGFzT3duUHJvcGVydHkoJ2VkaXRhYmxlJykgJiYgXG4gICAgICB0eXBlb2YgdGhpcy5kYXRhLmVkaXRhYmxlID09PSAnYm9vbGVhbicpIHtcbiAgICB0aGlzLmVkaXRhYmxlID0gZGF0YS5lZGl0YWJsZTtcbiAgfVxufVxuXG5JdGVtLnByb3RvdHlwZS5zdGFjayA9IHRydWU7XG5cbi8qKlxuICogU2VsZWN0IGN1cnJlbnQgaXRlbVxuICovXG5JdGVtLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0cnVlO1xuICBpZiAodGhpcy5kaXNwbGF5ZWQpIHRoaXMucmVkcmF3KCk7XG59O1xuXG4vKipcbiAqIFVuc2VsZWN0IGN1cnJlbnQgaXRlbVxuICovXG5JdGVtLnByb3RvdHlwZS51bnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlydHkgPSB0cnVlO1xuICBpZiAodGhpcy5kaXNwbGF5ZWQpIHRoaXMucmVkcmF3KCk7XG59O1xuXG4vKipcbiAqIFNldCBkYXRhIGZvciB0aGUgaXRlbS4gRXhpc3RpbmcgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIFRoZSBpZCBzaG91bGQgbm90XG4gKiBiZSBjaGFuZ2VkLiBXaGVuIHRoZSBpdGVtIGlzIGRpc3BsYXllZCwgaXQgd2lsbCBiZSByZWRyYXduIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqL1xuSXRlbS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIGdyb3VwQ2hhbmdlZCA9IGRhdGEuZ3JvdXAgIT0gdW5kZWZpbmVkICYmIHRoaXMuZGF0YS5ncm91cCAhPSBkYXRhLmdyb3VwO1xuICBpZiAoZ3JvdXBDaGFuZ2VkKSB7XG4gICAgdGhpcy5wYXJlbnQuaXRlbVNldC5fbW92ZVRvR3JvdXAodGhpcywgZGF0YS5ncm91cCk7XG4gIH1cblxuICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSgnZWRpdGFibGUnKSAmJiB0eXBlb2YgZGF0YS5lZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdGhpcy5lZGl0YWJsZSA9IGRhdGEuZWRpdGFibGU7XG4gIH1cblxuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgaWYgKHRoaXMuZGlzcGxheWVkKSB0aGlzLnJlZHJhdygpO1xufTtcblxuLyoqXG4gKiBTZXQgYSBwYXJlbnQgZm9yIHRoZSBpdGVtXG4gKiBAcGFyYW0ge0l0ZW1TZXQgfCBHcm91cH0gcGFyZW50XG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uKHBhcmVudCkge1xuICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICB0aGlzLmhpZGUoKTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoaXMgaXRlbSBpcyB2aXNpYmxlIGluc2lkZSBnaXZlbiByYW5nZVxuICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZpc2libGVcbiAqL1xuSXRlbS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IEl0ZW0gaW1wbGVtZW50YXRpb25zXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2hvdyB0aGUgSXRlbSBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpXG4gKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBIaWRlIHRoZSBJdGVtIGZyb20gdGhlIERPTSAod2hlbiB2aXNpYmxlKVxuICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICovXG5JdGVtLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgaXRlbVxuICovXG5JdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgLy8gc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBpdGVtXG59O1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIEl0ZW0gaG9yaXpvbnRhbGx5XG4gKi9cbkl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YID0gZnVuY3Rpb24oKSB7XG4gIC8vIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgaXRlbVxufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBJdGVtIHZlcnRpY2FsbHlcbiAqL1xuSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblkgPSBmdW5jdGlvbigpIHtcbiAgLy8gc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBpdGVtXG59O1xuXG4vKipcbiAqIFJlcGFpbnQgYSBkZWxldGUgYnV0dG9uIG9uIHRoZSB0b3AgcmlnaHQgb2YgdGhlIGl0ZW0gd2hlbiB0aGUgaXRlbSBpcyBzZWxlY3RlZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYW5jaG9yXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkl0ZW0ucHJvdG90eXBlLl9yZXBhaW50RGVsZXRlQnV0dG9uID0gZnVuY3Rpb24gKGFuY2hvcikge1xuICB2YXIgZWRpdGFibGUgPSAodGhpcy5vcHRpb25zLmVkaXRhYmxlLnJlbW92ZSB8fCBcbiAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5lZGl0YWJsZSA9PT0gdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmVkaXRhYmxlICE9PSBmYWxzZTtcblxuICBpZiAodGhpcy5zZWxlY3RlZCAmJiBlZGl0YWJsZSAmJiAhdGhpcy5kb20uZGVsZXRlQnV0dG9uKSB7XG4gICAgLy8gY3JlYXRlIGFuZCBzaG93IGJ1dHRvblxuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICB2YXIgZGVsZXRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVsZXRlQnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtZGVsZXRlJztcbiAgICBkZWxldGVCdXR0b24udGl0bGUgPSAnRGVsZXRlIHRoaXMgaXRlbSc7XG5cbiAgICAvLyBUT0RPOiBiZSBhYmxlIHRvIGRlc3Ryb3kgdGhlIGRlbGV0ZSBidXR0b25cbiAgICBuZXcgSGFtbWVyKGRlbGV0ZUJ1dHRvbikub24oJ3RhcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBtZS5wYXJlbnQucmVtb3ZlRnJvbURhdGFTZXQobWUpO1xuICAgIH0pO1xuXG4gICAgYW5jaG9yLmFwcGVuZENoaWxkKGRlbGV0ZUJ1dHRvbik7XG4gICAgdGhpcy5kb20uZGVsZXRlQnV0dG9uID0gZGVsZXRlQnV0dG9uO1xuICB9XG4gIGVsc2UgaWYgKCF0aGlzLnNlbGVjdGVkICYmIHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbikge1xuICAgIC8vIHJlbW92ZSBidXR0b25cbiAgICBpZiAodGhpcy5kb20uZGVsZXRlQnV0dG9uLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbik7XG4gICAgfVxuICAgIHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbiA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IEhUTUwgY29udGVudHMgZm9yIHRoZSBpdGVtXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICBIVE1MIGVsZW1lbnQgdG8gZmlsbCB3aXRoIHRoZSBjb250ZW50c1xuICogQHByaXZhdGVcbiAqL1xuSXRlbS5wcm90b3R5cGUuX3VwZGF0ZUNvbnRlbnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGNvbnRlbnQ7XG4gIGlmICh0aGlzLm9wdGlvbnMudGVtcGxhdGUpIHtcbiAgICB2YXIgaXRlbURhdGEgPSB0aGlzLnBhcmVudC5pdGVtU2V0Lml0ZW1zRGF0YS5nZXQodGhpcy5pZCk7IC8vIGdldCBhIGNsb25lIG9mIHRoZSBkYXRhIGZyb20gdGhlIGRhdGFzZXRcbiAgICBjb250ZW50ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlKGl0ZW1EYXRhKTtcbiAgfVxuICBlbHNlIHtcbiAgICBjb250ZW50ID0gdGhpcy5kYXRhLmNvbnRlbnQ7XG4gIH1cblxuICB2YXIgY2hhbmdlZCA9IHRoaXMuX2NvbnRlbnRUb1N0cmluZyh0aGlzLmNvbnRlbnQpICE9PSB0aGlzLl9jb250ZW50VG9TdHJpbmcoY29udGVudCk7XG4gIGlmIChjaGFuZ2VkKSB7XG4gICAgLy8gb25seSByZXBsYWNlIHRoZSBjb250ZW50IHdoZW4gY2hhbmdlZFxuICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnJztcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRlbnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKCEodGhpcy5kYXRhLnR5cGUgPT0gJ2JhY2tncm91bmQnICYmIHRoaXMuZGF0YS5jb250ZW50ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJjb250ZW50XCIgbWlzc2luZyBpbiBpdGVtICcgKyB0aGlzLmlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBIVE1MIGNvbnRlbnRzIGZvciB0aGUgaXRlbVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICAgSFRNTCBlbGVtZW50IHRvIGZpbGwgd2l0aCB0aGUgY29udGVudHNcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW0ucHJvdG90eXBlLl91cGRhdGVUaXRsZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIGlmICh0aGlzLmRhdGEudGl0bGUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQudGl0bGUgPSB0aGlzLmRhdGEudGl0bGUgfHwgJyc7XG4gIH1cbiAgZWxzZSB7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3Zpcy10aXRsZScpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2Nlc3MgZGF0YUF0dHJpYnV0ZXMgdGltZWxpbmUgb3B0aW9uIGFuZCBzZXQgYXMgZGF0YS0gYXR0cmlidXRlcyBvbiBkb20uY29udGVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICAgSFRNTCBlbGVtZW50IHRvIHdoaWNoIHRoZSBhdHRyaWJ1dGVzIHdpbGwgYmUgYXR0YWNoZWRcbiAqIEBwcml2YXRlXG4gKi9cbiBJdGVtLnByb3RvdHlwZS5fdXBkYXRlRGF0YUF0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZGF0YUF0dHJpYnV0ZXMgJiYgdGhpcy5vcHRpb25zLmRhdGFBdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLmRhdGFBdHRyaWJ1dGVzKSkge1xuICAgICAgYXR0cmlidXRlcyA9IHRoaXMub3B0aW9ucy5kYXRhQXR0cmlidXRlcztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLmRhdGFBdHRyaWJ1dGVzID09ICdhbGwnKSB7XG4gICAgICBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXModGhpcy5kYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLmRhdGFbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLScgKyBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtJyArIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgY3VzdG9tIHN0eWxlcyBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIGVsZW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW0ucHJvdG90eXBlLl91cGRhdGVTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgLy8gcmVtb3ZlIG9sZCBzdHlsZXNcbiAgaWYgKHRoaXMuc3R5bGUpIHtcbiAgICB1dGlsLnJlbW92ZUNzc1RleHQoZWxlbWVudCwgdGhpcy5zdHlsZSk7XG4gICAgdGhpcy5zdHlsZSA9IG51bGw7XG4gIH1cblxuICAvLyBhcHBlbmQgbmV3IHN0eWxlc1xuICBpZiAodGhpcy5kYXRhLnN0eWxlKSB7XG4gICAgdXRpbC5hZGRDc3NUZXh0KGVsZW1lbnQsIHRoaXMuZGF0YS5zdHlsZSk7XG4gICAgdGhpcy5zdHlsZSA9IHRoaXMuZGF0YS5zdHlsZTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGl0ZW1zIGNvbnRlbnRzXG4gKiBAcGFyYW0ge3N0cmluZyB8IEVsZW1lbnQgfCB1bmRlZmluZWR9IGNvbnRlbnRcbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtLnByb3RvdHlwZS5fY29udGVudFRvU3RyaW5nID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgcmV0dXJuIGNvbnRlbnQ7XG4gIGlmIChjb250ZW50ICYmICdvdXRlckhUTUwnIGluIGNvbnRlbnQpIHJldHVybiBjb250ZW50Lm91dGVySFRNTDtcbiAgcmV0dXJuIGNvbnRlbnQ7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGl0ZW0gbGVmdCBmcm9tIGl0cyBzdGFydCBkYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkl0ZW0ucHJvdG90eXBlLmdldFdpZHRoTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGl0ZW0gcmlnaHQgZnJvbSB0aGUgbWF4IG9mIGl0cyBzdGFydCBhbmQgZW5kIGRhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuSXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEl0ZW07XG4iLCJ2YXIgSXRlbSA9IHJlcXVpcmUoJy4vSXRlbScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBQb2ludEl0ZW1cbiAqIEBleHRlbmRzIEl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgc3RhcnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsIGNsYXNzTmFtZS5cbiAqIEBwYXJhbSB7e3RvU2NyZWVuOiBmdW5jdGlvbiwgdG9UaW1lOiBmdW5jdGlvbn19IGNvbnZlcnNpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnZlcnNpb24gZnVuY3Rpb25zIGZyb20gdGltZSB0byBzY3JlZW4gYW5kIHZpY2UgdmVyc2FcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVzY3JpYmUgYXZhaWxhYmxlIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUG9pbnRJdGVtIChkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHRoaXMucHJvcHMgPSB7XG4gICAgZG90OiB7XG4gICAgICB0b3A6IDAsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH0sXG4gICAgY29udGVudDoge1xuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgbWFyZ2luTGVmdDogMFxuICAgIH1cbiAgfTtcblxuICAvLyB2YWxpZGF0ZSBkYXRhXG4gIGlmIChkYXRhKSB7XG4gICAgaWYgKGRhdGEuc3RhcnQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwic3RhcnRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIEl0ZW0uY2FsbCh0aGlzLCBkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKTtcbn1cblxuUG9pbnRJdGVtLnByb3RvdHlwZSA9IG5ldyBJdGVtIChudWxsLCBudWxsLCBudWxsKTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoaXMgaXRlbSBpcyB2aXNpYmxlIGluc2lkZSBnaXZlbiByYW5nZVxuICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZpc2libGVcbiAqL1xuUG9pbnRJdGVtLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbihyYW5nZSkge1xuICAvLyBkZXRlcm1pbmUgdmlzaWJpbGl0eVxuICAvLyBUT0RPOiBhY2NvdW50IGZvciB0aGUgcmVhbCB3aWR0aCBvZiB0aGUgaXRlbS4gUmlnaHQgbm93IHdlIGp1c3QgYWRkIDEvNCB0byB0aGUgd2luZG93XG4gIHZhciBpbnRlcnZhbCA9IChyYW5nZS5lbmQgLSByYW5nZS5zdGFydCkgLyA0O1xuICByZXR1cm4gKHRoaXMuZGF0YS5zdGFydCA+IHJhbmdlLnN0YXJ0IC0gaW50ZXJ2YWwpICYmICh0aGlzLmRhdGEuc3RhcnQgPCByYW5nZS5lbmQgKyBpbnRlcnZhbCk7XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGl0ZW1cbiAqL1xuUG9pbnRJdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICBpZiAoIWRvbSkge1xuICAgIC8vIGNyZWF0ZSBET01cbiAgICB0aGlzLmRvbSA9IHt9O1xuICAgIGRvbSA9IHRoaXMuZG9tO1xuXG4gICAgLy8gYmFja2dyb3VuZCBib3hcbiAgICBkb20ucG9pbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAvLyBjbGFzc05hbWUgaXMgdXBkYXRlZCBpbiByZWRyYXcoKVxuXG4gICAgLy8gY29udGVudHMgYm94LCByaWdodCBmcm9tIHRoZSBkb3RcbiAgICBkb20uY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbS5jb250ZW50LmNsYXNzTmFtZSA9ICd2aXMtaXRlbS1jb250ZW50JztcbiAgICBkb20ucG9pbnQuYXBwZW5kQ2hpbGQoZG9tLmNvbnRlbnQpO1xuXG4gICAgLy8gZG90IGF0IHN0YXJ0XG4gICAgZG9tLmRvdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbS5wb2ludC5hcHBlbmRDaGlsZChkb20uZG90KTtcblxuICAgIC8vIGF0dGFjaCB0aGlzIGl0ZW0gYXMgYXR0cmlidXRlXG4gICAgZG9tLnBvaW50Wyd0aW1lbGluZS1pdGVtJ10gPSB0aGlzO1xuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cblxuICAvLyBhcHBlbmQgRE9NIHRvIHBhcmVudCBET01cbiAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBubyBwYXJlbnQgYXR0YWNoZWQnKTtcbiAgfVxuICBpZiAoIWRvbS5wb2ludC5wYXJlbnROb2RlKSB7XG4gICAgdmFyIGZvcmVncm91bmQgPSB0aGlzLnBhcmVudC5kb20uZm9yZWdyb3VuZDtcbiAgICBpZiAoIWZvcmVncm91bmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBwYXJlbnQgaGFzIG5vIGZvcmVncm91bmQgY29udGFpbmVyIGVsZW1lbnQnKTtcbiAgICB9XG4gICAgZm9yZWdyb3VuZC5hcHBlbmRDaGlsZChkb20ucG9pbnQpO1xuICB9XG4gIHRoaXMuZGlzcGxheWVkID0gdHJ1ZTtcblxuICAvLyBVcGRhdGUgRE9NIHdoZW4gaXRlbSBpcyBtYXJrZWQgZGlydHkuIEFuIGl0ZW0gaXMgbWFya2VkIGRpcnR5IHdoZW46XG4gIC8vIC0gdGhlIGl0ZW0gaXMgbm90IHlldCByZW5kZXJlZFxuICAvLyAtIHRoZSBpdGVtJ3MgZGF0YSBpcyBjaGFuZ2VkXG4gIC8vIC0gdGhlIGl0ZW0gaXMgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICBpZiAodGhpcy5kaXJ0eSkge1xuICAgIHRoaXMuX3VwZGF0ZUNvbnRlbnRzKHRoaXMuZG9tLmNvbnRlbnQpO1xuICAgIHRoaXMuX3VwZGF0ZVRpdGxlKHRoaXMuZG9tLnBvaW50KTtcbiAgICB0aGlzLl91cGRhdGVEYXRhQXR0cmlidXRlcyh0aGlzLmRvbS5wb2ludCk7XG4gICAgdGhpcy5fdXBkYXRlU3R5bGUodGhpcy5kb20ucG9pbnQpO1xuXG4gICAgdmFyIGVkaXRhYmxlID0gKHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lIHx8IFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0YWJsZSA9PT0gdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRhYmxlICE9PSBmYWxzZTtcblxuICAgIC8vIHVwZGF0ZSBjbGFzc1xuICAgIHZhciBjbGFzc05hbWUgPSAodGhpcy5kYXRhLmNsYXNzTmFtZSA/ICcgJyArIHRoaXMuZGF0YS5jbGFzc05hbWUgOiAnJykgK1xuICAgICAgICAodGhpcy5zZWxlY3RlZCA/ICcgdmlzLXNlbGVjdGVkJyA6ICcnKSArXG4gICAgICAgIChlZGl0YWJsZSA/ICcgdmlzLWVkaXRhYmxlJyA6ICcgdmlzLXJlYWRvbmx5Jyk7XG4gICAgZG9tLnBvaW50LmNsYXNzTmFtZSAgPSAndmlzLWl0ZW0gdmlzLXBvaW50JyArIGNsYXNzTmFtZTtcbiAgICBkb20uZG90LmNsYXNzTmFtZSAgPSAndmlzLWl0ZW0gdmlzLWRvdCcgKyBjbGFzc05hbWU7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBzaXplIG9mIGRvdCBhbmQgY29udGVudHNcbiAgICB0aGlzLnByb3BzLmRvdC53aWR0aCA9IGRvbS5kb3Qub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5wcm9wcy5kb3QuaGVpZ2h0ID0gZG9tLmRvdC5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5wcm9wcy5jb250ZW50LmhlaWdodCA9IGRvbS5jb250ZW50Lm9mZnNldEhlaWdodDtcblxuICAgIC8vIHJlc2l6ZSBjb250ZW50c1xuICAgIGRvbS5jb250ZW50LnN0eWxlLm1hcmdpbkxlZnQgPSAyICogdGhpcy5wcm9wcy5kb3Qud2lkdGggKyAncHgnO1xuICAgIC8vZG9tLmNvbnRlbnQuc3R5bGUubWFyZ2luUmlnaHQgPSAuLi4gKyAncHgnOyAvLyBUT0RPOiBtYXJnaW4gcmlnaHRcblxuICAgIC8vIHJlY2FsY3VsYXRlIHNpemVcbiAgICB0aGlzLndpZHRoID0gZG9tLnBvaW50Lm9mZnNldFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gZG9tLnBvaW50Lm9mZnNldEhlaWdodDtcblxuICAgIC8vIHJlcG9zaXRpb24gdGhlIGRvdFxuICAgIGRvbS5kb3Quc3R5bGUudG9wID0gKCh0aGlzLmhlaWdodCAtIHRoaXMucHJvcHMuZG90LmhlaWdodCkgLyAyKSArICdweCc7XG4gICAgZG9tLmRvdC5zdHlsZS5sZWZ0ID0gKHRoaXMucHJvcHMuZG90LndpZHRoIC8gMikgKyAncHgnO1xuXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9XG5cbiAgdGhpcy5fcmVwYWludERlbGV0ZUJ1dHRvbihkb20ucG9pbnQpO1xufTtcblxuLyoqXG4gKiBTaG93IHRoZSBpdGVtIGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSkuIFRoZSBpdGVtcyBET00gd2lsbFxuICogYmUgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAqL1xuUG9pbnRJdGVtLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5kaXNwbGF5ZWQpIHtcbiAgICB0aGlzLnJlZHJhdygpO1xuICB9XG59O1xuXG4vKipcbiAqIEhpZGUgdGhlIGl0ZW0gZnJvbSB0aGUgRE9NICh3aGVuIHZpc2libGUpXG4gKi9cblBvaW50SXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICBpZiAodGhpcy5kb20ucG9pbnQucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20ucG9pbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5wb2ludCk7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwbGF5ZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIGhvcml6b250YWxseVxuICogQE92ZXJyaWRlXG4gKi9cblBvaW50SXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5jb252ZXJzaW9uLnRvU2NyZWVuKHRoaXMuZGF0YS5zdGFydCk7XG5cbiAgdGhpcy5sZWZ0ID0gc3RhcnQgLSB0aGlzLnByb3BzLmRvdC53aWR0aDtcblxuICAvLyByZXBvc2l0aW9uIHBvaW50XG4gIHRoaXMuZG9tLnBvaW50LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyAncHgnO1xufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIHZlcnRpY2FsbHlcbiAqIEBPdmVycmlkZVxuICovXG5Qb2ludEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25ZID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtO1xuICB2YXIgcG9pbnQgPSB0aGlzLmRvbS5wb2ludDtcblxuICBpZiAob3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICBwb2ludC5zdHlsZS50b3AgPSB0aGlzLnRvcCArICdweCc7XG4gIH1cbiAgZWxzZSB7XG4gICAgcG9pbnQuc3R5bGUudG9wID0gKHRoaXMucGFyZW50LmhlaWdodCAtIHRoaXMudG9wIC0gdGhpcy5oZWlnaHQpICsgJ3B4JztcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBpdGVtIGxlZnQgZnJvbSBpdHMgc3RhcnQgZGF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5Qb2ludEl0ZW0ucHJvdG90eXBlLmdldFdpZHRoTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucHJvcHMuZG90LndpZHRoO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBpdGVtIHJpZ2h0IGZyb20gIGl0cyBzdGFydCBkYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblBvaW50SXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGggLSB0aGlzLnByb3BzLmRvdC53aWR0aDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnRJdGVtO1xuIiwidmFyIEhhbW1lciA9IHJlcXVpcmUoJy4uLy4uLy4uL21vZHVsZS9oYW1tZXInKTtcbnZhciBJdGVtID0gcmVxdWlyZSgnLi9JdGVtJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIFJhbmdlSXRlbVxuICogQGV4dGVuZHMgSXRlbVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBzdGFydCwgZW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LCBjbGFzc05hbWUuXG4gKiBAcGFyYW0ge3t0b1NjcmVlbjogZnVuY3Rpb24sIHRvVGltZTogZnVuY3Rpb259fSBjb252ZXJzaW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb252ZXJzaW9uIGZ1bmN0aW9ucyBmcm9tIHRpbWUgdG8gc2NyZWVuIGFuZCB2aWNlIHZlcnNhXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRlc2NyaWJlIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUmFuZ2VJdGVtIChkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHRoaXMucHJvcHMgPSB7XG4gICAgY29udGVudDoge1xuICAgICAgd2lkdGg6IDBcbiAgICB9XG4gIH07XG4gIHRoaXMub3ZlcmZsb3cgPSBmYWxzZTsgLy8gaWYgY29udGVudHMgY2FuIG92ZXJmbG93IChjc3Mgc3R5bGluZyksIHRoaXMgZmxhZyBpcyBzZXQgdG8gdHJ1ZVxuXG4gIC8vIHZhbGlkYXRlIGRhdGFcbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5zdGFydCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJzdGFydFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YS5pZCk7XG4gICAgfVxuICAgIGlmIChkYXRhLmVuZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJlbmRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEuaWQpO1xuICAgIH1cbiAgfVxuXG4gIEl0ZW0uY2FsbCh0aGlzLCBkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKTtcbn1cblxuUmFuZ2VJdGVtLnByb3RvdHlwZSA9IG5ldyBJdGVtIChudWxsLCBudWxsLCBudWxsKTtcblxuUmFuZ2VJdGVtLnByb3RvdHlwZS5iYXNlQ2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1yYW5nZSc7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGlzIGl0ZW0gaXMgdmlzaWJsZSBpbnNpZGUgZ2l2ZW4gcmFuZ2VcbiAqIEByZXR1cm5zIHt7c3RhcnQ6IE51bWJlciwgZW5kOiBOdW1iZXJ9fSByYW5nZSB3aXRoIGEgdGltZXN0YW1wIGZvciBzdGFydCBhbmQgZW5kXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2aXNpYmxlXG4gKi9cblJhbmdlSXRlbS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgLy8gZGV0ZXJtaW5lIHZpc2liaWxpdHlcbiAgcmV0dXJuICh0aGlzLmRhdGEuc3RhcnQgPCByYW5nZS5lbmQpICYmICh0aGlzLmRhdGEuZW5kID4gcmFuZ2Uuc3RhcnQpO1xufTtcblxuLyoqXG4gKiBSZXBhaW50IHRoZSBpdGVtXG4gKi9cblJhbmdlSXRlbS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgaWYgKCFkb20pIHtcbiAgICAvLyBjcmVhdGUgRE9NXG4gICAgdGhpcy5kb20gPSB7fTtcbiAgICBkb20gPSB0aGlzLmRvbTtcblxuICAgICAgLy8gYmFja2dyb3VuZCBib3hcbiAgICBkb20uYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLy8gY2xhc3NOYW1lIGlzIHVwZGF0ZWQgaW4gcmVkcmF3KClcblxuICAgIC8vIGZyYW1lIGJveCAodG8gcHJldmVudCB0aGUgaXRlbSBjb250ZW50cyBmcm9tIG92ZXJmbG93aW5nXG4gICAgZG9tLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9tLmZyYW1lLmNsYXNzTmFtZSA9ICd2aXMtaXRlbS1vdmVyZmxvdyc7XG4gICAgZG9tLmJveC5hcHBlbmRDaGlsZChkb20uZnJhbWUpO1xuXG4gICAgLy8gY29udGVudHMgYm94XG4gICAgZG9tLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20uY29udGVudC5jbGFzc05hbWUgPSAndmlzLWl0ZW0tY29udGVudCc7XG4gICAgZG9tLmZyYW1lLmFwcGVuZENoaWxkKGRvbS5jb250ZW50KTtcblxuICAgIC8vIGF0dGFjaCB0aGlzIGl0ZW0gYXMgYXR0cmlidXRlXG4gICAgZG9tLmJveFsndGltZWxpbmUtaXRlbSddID0gdGhpcztcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG5cbiAgLy8gYXBwZW5kIERPTSB0byBwYXJlbnQgRE9NXG4gIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogbm8gcGFyZW50IGF0dGFjaGVkJyk7XG4gIH1cbiAgaWYgKCFkb20uYm94LnBhcmVudE5vZGUpIHtcbiAgICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMucGFyZW50LmRvbS5mb3JlZ3JvdW5kO1xuICAgIGlmICghZm9yZWdyb3VuZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IHBhcmVudCBoYXMgbm8gZm9yZWdyb3VuZCBjb250YWluZXIgZWxlbWVudCcpO1xuICAgIH1cbiAgICBmb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGRvbS5ib3gpO1xuICB9XG4gIHRoaXMuZGlzcGxheWVkID0gdHJ1ZTtcblxuICAvLyBVcGRhdGUgRE9NIHdoZW4gaXRlbSBpcyBtYXJrZWQgZGlydHkuIEFuIGl0ZW0gaXMgbWFya2VkIGRpcnR5IHdoZW46XG4gIC8vIC0gdGhlIGl0ZW0gaXMgbm90IHlldCByZW5kZXJlZFxuICAvLyAtIHRoZSBpdGVtJ3MgZGF0YSBpcyBjaGFuZ2VkXG4gIC8vIC0gdGhlIGl0ZW0gaXMgc2VsZWN0ZWQvZGVzZWxlY3RlZFxuICBpZiAodGhpcy5kaXJ0eSkge1xuICAgIHRoaXMuX3VwZGF0ZUNvbnRlbnRzKHRoaXMuZG9tLmNvbnRlbnQpO1xuICAgIHRoaXMuX3VwZGF0ZVRpdGxlKHRoaXMuZG9tLmJveCk7XG4gICAgdGhpcy5fdXBkYXRlRGF0YUF0dHJpYnV0ZXModGhpcy5kb20uYm94KTtcbiAgICB0aGlzLl91cGRhdGVTdHlsZSh0aGlzLmRvbS5ib3gpO1xuXG4gICAgdmFyIGVkaXRhYmxlID0gKHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lIHx8IFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0YWJsZSA9PT0gdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRhYmxlICE9PSBmYWxzZTtcblxuICAgIC8vIHVwZGF0ZSBjbGFzc1xuICAgIHZhciBjbGFzc05hbWUgPSAodGhpcy5kYXRhLmNsYXNzTmFtZSA/ICgnICcgKyB0aGlzLmRhdGEuY2xhc3NOYW1lKSA6ICcnKSArXG4gICAgICAgICh0aGlzLnNlbGVjdGVkID8gJyB2aXMtc2VsZWN0ZWQnIDogJycpICsgXG4gICAgICAgIChlZGl0YWJsZSA/ICcgdmlzLWVkaXRhYmxlJyA6ICcgdmlzLXJlYWRvbmx5Jyk7XG4gICAgZG9tLmJveC5jbGFzc05hbWUgPSB0aGlzLmJhc2VDbGFzc05hbWUgKyBjbGFzc05hbWU7XG5cbiAgICAvLyBkZXRlcm1pbmUgZnJvbSBjc3Mgd2hldGhlciB0aGlzIGJveCBoYXMgb3ZlcmZsb3dcbiAgICB0aGlzLm92ZXJmbG93ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tLmZyYW1lKS5vdmVyZmxvdyAhPT0gJ2hpZGRlbic7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBzaXplXG4gICAgLy8gdHVybiBvZmYgbWF4LXdpZHRoIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHRoZSByZWFsIHdpZHRoXG4gICAgLy8gdGhpcyBjYXVzZXMgYW4gZXh0cmEgYnJvd3NlciByZXBhaW50L3JlZmxvdywgYnV0IHNvIGJlIGl0XG4gICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5tYXhXaWR0aCA9ICdub25lJztcbiAgICB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGggPSB0aGlzLmRvbS5jb250ZW50Lm9mZnNldFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5kb20uYm94Lm9mZnNldEhlaWdodDtcbiAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLm1heFdpZHRoID0gJyc7XG5cbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH1cblxuICB0aGlzLl9yZXBhaW50RGVsZXRlQnV0dG9uKGRvbS5ib3gpO1xuICB0aGlzLl9yZXBhaW50RHJhZ0xlZnQoKTtcbiAgdGhpcy5fcmVwYWludERyYWdSaWdodCgpO1xufTtcblxuLyoqXG4gKiBTaG93IHRoZSBpdGVtIGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSkuIFRoZSBpdGVtcyBET00gd2lsbFxuICogYmUgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAqL1xuUmFuZ2VJdGVtLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5kaXNwbGF5ZWQpIHtcbiAgICB0aGlzLnJlZHJhdygpO1xuICB9XG59O1xuXG4vKipcbiAqIEhpZGUgdGhlIGl0ZW0gZnJvbSB0aGUgRE9NICh3aGVuIHZpc2libGUpXG4gKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gKi9cblJhbmdlSXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICB2YXIgYm94ID0gdGhpcy5kb20uYm94O1xuXG4gICAgaWYgKGJveC5wYXJlbnROb2RlKSB7XG4gICAgICBib3gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChib3gpO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGxheWVkID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwb3NpdGlvbiB0aGUgaXRlbSBob3Jpem9udGFsbHlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xpbWl0U2l6ZT10cnVlXSBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHdpZHRoIG9mIHRoZSByYW5nZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gd2lsbCBiZSBsaW1pdGVkLCBhcyB0aGUgYnJvd3NlciBjYW5ub3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5IHZlcnkgd2lkZSBkaXZzLiBUaGlzIG1lYW5zIHRob3VnaFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgdGhlIGFwcGxpZWQgbGVmdCBhbmQgd2lkdGggbWF5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IGNvcnJlc3BvbmQgdG8gdGhlIHJhbmdlcyBzdGFydCBhbmQgZW5kXG4gKiBAT3ZlcnJpZGVcbiAqL1xuUmFuZ2VJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWCA9IGZ1bmN0aW9uKGxpbWl0U2l6ZSkge1xuICB2YXIgcGFyZW50V2lkdGggPSB0aGlzLnBhcmVudC53aWR0aDtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5jb252ZXJzaW9uLnRvU2NyZWVuKHRoaXMuZGF0YS5zdGFydCk7XG4gIHZhciBlbmQgPSB0aGlzLmNvbnZlcnNpb24udG9TY3JlZW4odGhpcy5kYXRhLmVuZCk7XG4gIHZhciBjb250ZW50TGVmdDtcbiAgdmFyIGNvbnRlbnRXaWR0aDtcblxuICAvLyBsaW1pdCB0aGUgd2lkdGggb2YgdGhlIHJhbmdlLCBhcyBicm93c2VycyBjYW5ub3QgZHJhdyB2ZXJ5IHdpZGUgZGl2c1xuICBpZiAobGltaXRTaXplID09PSB1bmRlZmluZWQgfHwgbGltaXRTaXplID09PSB0cnVlKSB7XG4gICAgaWYgKHN0YXJ0IDwgLXBhcmVudFdpZHRoKSB7XG4gICAgICBzdGFydCA9IC1wYXJlbnRXaWR0aDtcbiAgICB9XG4gICAgaWYgKGVuZCA+IDIgKiBwYXJlbnRXaWR0aCkge1xuICAgICAgZW5kID0gMiAqIHBhcmVudFdpZHRoO1xuICAgIH1cbiAgfVxuICB2YXIgYm94V2lkdGggPSBNYXRoLm1heChlbmQgLSBzdGFydCwgMSk7XG5cbiAgaWYgKHRoaXMub3ZlcmZsb3cpIHtcbiAgICB0aGlzLmxlZnQgPSBzdGFydDtcbiAgICB0aGlzLndpZHRoID0gYm94V2lkdGggKyB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGg7XG4gICAgY29udGVudFdpZHRoID0gdGhpcy5wcm9wcy5jb250ZW50LndpZHRoO1xuXG4gICAgLy8gTm90ZTogVGhlIGNhbGN1bGF0aW9uIG9mIHdpZHRoIGlzIGFuIG9wdGltaXN0aWMgY2FsY3VsYXRpb24sIGdpdmluZ1xuICAgIC8vICAgICAgIGEgd2lkdGggd2hpY2ggd2lsbCBub3QgY2hhbmdlIHdoZW4gbW92aW5nIHRoZSBUaW1lbGluZVxuICAgIC8vICAgICAgIFNvIG5vIHJlLXN0YWNraW5nIG5lZWRlZCwgd2hpY2ggaXMgbmljZXIgZm9yIHRoZSBleWU7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5sZWZ0ID0gc3RhcnQ7XG4gICAgdGhpcy53aWR0aCA9IGJveFdpZHRoO1xuICAgIGNvbnRlbnRXaWR0aCA9IE1hdGgubWluKGVuZCAtIHN0YXJ0LCB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGgpO1xuICB9XG5cbiAgdGhpcy5kb20uYm94LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyAncHgnO1xuICB0aGlzLmRvbS5ib3guc3R5bGUud2lkdGggPSBib3hXaWR0aCArICdweCc7XG5cbiAgc3dpdGNoICh0aGlzLm9wdGlvbnMuYWxpZ24pIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5sZWZ0ID0gTWF0aC5tYXgoKGJveFdpZHRoIC0gY29udGVudFdpZHRoKSwgMCkgKyAncHgnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5sZWZ0ID0gTWF0aC5tYXgoKGJveFdpZHRoIC0gY29udGVudFdpZHRoKSAvIDIsIDApICsgJ3B4JztcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDogLy8gJ2F1dG8nXG4gICAgICAvLyB3aGVuIHJhbmdlIGV4Y2VlZHMgbGVmdCBvZiB0aGUgd2luZG93LCBwb3NpdGlvbiB0aGUgY29udGVudHMgYXQgdGhlIGxlZnQgb2YgdGhlIHZpc2libGUgYXJlYVxuICAgICAgaWYgKHRoaXMub3ZlcmZsb3cpIHtcbiAgICAgICAgaWYgKGVuZCA+IDApIHtcbiAgICAgICAgICBjb250ZW50TGVmdCA9IE1hdGgubWF4KC1zdGFydCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGVudExlZnQgPSAtY29udGVudFdpZHRoOyAvLyBlbnN1cmUgaXQncyBub3QgdmlzaWJsZSBhbnltb3JlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgY29udGVudExlZnQgPSAtc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGVudExlZnQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLmxlZnQgPSBjb250ZW50TGVmdCArICdweCc7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwb3NpdGlvbiB0aGUgaXRlbSB2ZXJ0aWNhbGx5XG4gKiBAT3ZlcnJpZGVcbiAqL1xuUmFuZ2VJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbTtcbiAgdmFyIGJveCA9IHRoaXMuZG9tLmJveDtcblxuICBpZiAob3JpZW50YXRpb24gPT0gJ3RvcCcpIHtcbiAgICBib3guc3R5bGUudG9wID0gdGhpcy50b3AgKyAncHgnO1xuICB9XG4gIGVsc2Uge1xuICAgIGJveC5zdHlsZS50b3AgPSAodGhpcy5wYXJlbnQuaGVpZ2h0IC0gdGhpcy50b3AgLSB0aGlzLmhlaWdodCkgKyAncHgnO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgYSBkcmFnIGFyZWEgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgcmFuZ2Ugd2hlbiB0aGUgcmFuZ2UgaXMgc2VsZWN0ZWRcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmFuZ2VJdGVtLnByb3RvdHlwZS5fcmVwYWludERyYWdMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zZWxlY3RlZCAmJiB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSAmJiAhdGhpcy5kb20uZHJhZ0xlZnQpIHtcbiAgICAvLyBjcmVhdGUgYW5kIHNob3cgZHJhZyBhcmVhXG4gICAgdmFyIGRyYWdMZWZ0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZHJhZ0xlZnQuY2xhc3NOYW1lID0gJ3Zpcy1kcmFnLWxlZnQnO1xuICAgIGRyYWdMZWZ0LmRyYWdMZWZ0SXRlbSA9IHRoaXM7XG5cbiAgICB0aGlzLmRvbS5ib3guYXBwZW5kQ2hpbGQoZHJhZ0xlZnQpO1xuICAgIHRoaXMuZG9tLmRyYWdMZWZ0ID0gZHJhZ0xlZnQ7XG4gIH1cbiAgZWxzZSBpZiAoIXRoaXMuc2VsZWN0ZWQgJiYgdGhpcy5kb20uZHJhZ0xlZnQpIHtcbiAgICAvLyBkZWxldGUgZHJhZyBhcmVhXG4gICAgaWYgKHRoaXMuZG9tLmRyYWdMZWZ0LnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLmRyYWdMZWZ0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZHJhZ0xlZnQpO1xuICAgIH1cbiAgICB0aGlzLmRvbS5kcmFnTGVmdCA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwYWludCBhIGRyYWcgYXJlYSBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgcmFuZ2Ugd2hlbiB0aGUgcmFuZ2UgaXMgc2VsZWN0ZWRcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmFuZ2VJdGVtLnByb3RvdHlwZS5fcmVwYWludERyYWdSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2VsZWN0ZWQgJiYgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgJiYgIXRoaXMuZG9tLmRyYWdSaWdodCkge1xuICAgIC8vIGNyZWF0ZSBhbmQgc2hvdyBkcmFnIGFyZWFcbiAgICB2YXIgZHJhZ1JpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZHJhZ1JpZ2h0LmNsYXNzTmFtZSA9ICd2aXMtZHJhZy1yaWdodCc7XG4gICAgZHJhZ1JpZ2h0LmRyYWdSaWdodEl0ZW0gPSB0aGlzO1xuXG4gICAgdGhpcy5kb20uYm94LmFwcGVuZENoaWxkKGRyYWdSaWdodCk7XG4gICAgdGhpcy5kb20uZHJhZ1JpZ2h0ID0gZHJhZ1JpZ2h0O1xuICB9XG4gIGVsc2UgaWYgKCF0aGlzLnNlbGVjdGVkICYmIHRoaXMuZG9tLmRyYWdSaWdodCkge1xuICAgIC8vIGRlbGV0ZSBkcmFnIGFyZWFcbiAgICBpZiAodGhpcy5kb20uZHJhZ1JpZ2h0LnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLmRyYWdSaWdodC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmRyYWdSaWdodCk7XG4gICAgfVxuICAgIHRoaXMuZG9tLmRyYWdSaWdodCA9IG51bGw7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VJdGVtO1xuIiwiLy8gRW5nbGlzaFxuZXhwb3J0c1snZW4nXSA9IHtcbiAgY3VycmVudDogJ2N1cnJlbnQnLFxuICB0aW1lOiAndGltZSdcbn07XG5leHBvcnRzWydlbl9FTiddID0gZXhwb3J0c1snZW4nXTtcbmV4cG9ydHNbJ2VuX1VTJ10gPSBleHBvcnRzWydlbiddO1xuXG4vLyBEdXRjaFxuZXhwb3J0c1snbmwnXSA9IHtcbiAgY3VycmVudDogJ2h1aWRpZ2UnLFxuICB0aW1lOiAndGlqZCdcbn07XG5leHBvcnRzWydubF9OTCddID0gZXhwb3J0c1snbmwnXTtcbmV4cG9ydHNbJ25sX0JFJ10gPSBleHBvcnRzWydubCddO1xuIiwiLyoqXG4gKiBUaGlzIG9iamVjdCBjb250YWlucyBhbGwgcG9zc2libGUgb3B0aW9ucy4gSXQgd2lsbCBjaGVjayBpZiB0aGUgdHlwZXMgYXJlIGNvcnJlY3QsIGlmIHJlcXVpcmVkIGlmIHRoZSBvcHRpb24gaXMgb25lXG4gKiBvZiB0aGUgYWxsb3dlZCB2YWx1ZXMuXG4gKlxuICogX19hbnlfXyBtZWFucyB0aGF0IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBkb2VzIG5vdCBtYXR0ZXIuXG4gKiBfX3R5cGVfXyBpcyBhIHJlcXVpcmVkIGZpZWxkIGZvciBhbGwgb2JqZWN0cyBhbmQgY29udGFpbnMgdGhlIGFsbG93ZWQgdHlwZXMgb2YgYWxsIG9iamVjdHNcbiAqL1xubGV0IHN0cmluZyA9ICdzdHJpbmcnO1xubGV0IGJvb2xlYW4gPSAnYm9vbGVhbic7XG5sZXQgbnVtYmVyID0gJ251bWJlcic7XG5sZXQgYXJyYXkgPSAnYXJyYXknO1xubGV0IGRhdGUgPSAnZGF0ZSc7XG5sZXQgb2JqZWN0ID0gJ29iamVjdCc7IC8vIHNob3VsZCBvbmx5IGJlIGluIGEgX190eXBlX18gcHJvcGVydHlcbmxldCBkb20gPSAnZG9tJztcbmxldCBtb21lbnQgPSAnbW9tZW50JztcbmxldCBhbnkgPSAnYW55JztcblxuXG5sZXQgYWxsT3B0aW9ucyA9IHtcbiAgY29uZmlndXJlOiB7XG4gICAgZW5hYmxlZDoge2Jvb2xlYW59LFxuICAgIGZpbHRlcjoge2Jvb2xlYW4sJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgY29udGFpbmVyOiB7ZG9tfSxcbiAgICBfX3R5cGVfXzoge29iamVjdCxib29sZWFuLCdmdW5jdGlvbic6ICdmdW5jdGlvbid9XG4gIH0sXG5cbiAgLy9nbG9iYWxzIDpcbiAgYWxpZ246IHtzdHJpbmd9LFxuICBhdXRvUmVzaXplOiB7Ym9vbGVhbn0sXG4gIHRocm90dGxlUmVkcmF3OiB7bnVtYmVyfSxcbiAgY2xpY2tUb1VzZToge2Jvb2xlYW59LFxuICBkYXRhQXR0cmlidXRlczoge3N0cmluZywgYXJyYXl9LFxuICBlZGl0YWJsZToge1xuICAgIGFkZDoge2Jvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgcmVtb3ZlOiB7Ym9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICB1cGRhdGVHcm91cDoge2Jvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgdXBkYXRlVGltZToge2Jvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgX190eXBlX186IHtib29sZWFuLCBvYmplY3R9XG4gIH0sXG4gIGVuZDoge251bWJlciwgZGF0ZSwgc3RyaW5nLCBtb21lbnR9LFxuICBmb3JtYXQ6IHtcbiAgICBtaW5vckxhYmVsczoge1xuICAgICAgbWlsbGlzZWNvbmQ6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIHNlY29uZDoge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgbWludXRlOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBob3VyOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICB3ZWVrZGF5OiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBkYXk6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIG1vbnRoOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICB5ZWFyOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBfX3R5cGVfXzoge29iamVjdH1cbiAgICB9LFxuICAgIG1ham9yTGFiZWxzOiB7XG4gICAgICBtaWxsaXNlY29uZDoge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgc2Vjb25kOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBtaW51dGU6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIGhvdXI6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIHdlZWtkYXk6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIGRheToge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgbW9udGg6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIHllYXI6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIF9fdHlwZV9fOiB7b2JqZWN0fVxuICAgIH0sXG4gICAgX190eXBlX186IHtvYmplY3R9XG4gIH0sXG4gIG1vbWVudDogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBncm91cE9yZGVyOiB7c3RyaW5nLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgZ3JvdXBFZGl0YWJsZToge1xuXHQgYWRkOiB7Ym9vbGVhbiwgJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcblx0IHJlbW92ZToge2Jvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG5cdCBvcmRlcjoge2Jvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG5cdCBfX3R5cGVfXzoge2Jvb2xlYW4sIG9iamVjdH1cbiAgfSxcbiAgZ3JvdXBPcmRlclN3YXA6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgaGVpZ2h0OiB7c3RyaW5nLCBudW1iZXJ9LFxuICBoaWRkZW5EYXRlczoge1xuICAgIHN0YXJ0OiB7ZGF0ZSwgbnVtYmVyLCBzdHJpbmcsIG1vbWVudH0sXG4gICAgZW5kOiB7ZGF0ZSwgbnVtYmVyLCBzdHJpbmcsIG1vbWVudH0sXG4gICAgcmVwZWF0OiB7c3RyaW5nfSxcbiAgICBfX3R5cGVfXzoge29iamVjdCwgYXJyYXl9XG4gIH0sXG4gIGxvY2FsZTp7c3RyaW5nfSxcbiAgbG9jYWxlczp7XG4gICAgX190eXBlX186IHtvYmplY3R9XG4gIH0sXG4gIG1hcmdpbjoge1xuICAgIGF4aXM6IHtudW1iZXJ9LFxuICAgIGl0ZW06IHtcbiAgICAgIGhvcml6b250YWw6IHtudW1iZXIsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIHZlcnRpY2FsOiB7bnVtYmVyLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBfX3R5cGVfXzoge29iamVjdCxudW1iZXJ9XG4gICAgfSxcbiAgICBfX3R5cGVfXzoge29iamVjdCxudW1iZXJ9XG4gIH0sXG4gIG1heDoge2RhdGUsIG51bWJlciwgc3RyaW5nLCBtb21lbnR9LFxuICBtYXhIZWlnaHQ6IHtudW1iZXIsIHN0cmluZ30sXG4gIG1pbjoge2RhdGUsIG51bWJlciwgc3RyaW5nLCBtb21lbnR9LFxuICBtaW5IZWlnaHQ6IHtudW1iZXIsIHN0cmluZ30sXG4gIG1vdmVhYmxlOiB7Ym9vbGVhbn0sXG4gIG11bHRpc2VsZWN0OiB7Ym9vbGVhbn0sXG4gIG9uQWRkOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIG9uVXBkYXRlOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIG9uTW92ZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBvbk1vdmluZzogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBvblJlbW92ZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBvbkFkZEdyb3VwOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIG9uTW92ZUdyb3VwOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIG9uUmVtb3ZlR3JvdXA6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgb3JkZXI6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgb3JpZW50YXRpb246IHtcbiAgICBheGlzOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgaXRlbToge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgIF9fdHlwZV9fOiB7c3RyaW5nLCBvYmplY3R9XG4gIH0sXG4gIHNlbGVjdGFibGU6IHtib29sZWFufSxcbiAgc2hvd0N1cnJlbnRUaW1lOiB7Ym9vbGVhbn0sXG4gIHNob3dNYWpvckxhYmVsczoge2Jvb2xlYW59LFxuICBzaG93TWlub3JMYWJlbHM6IHtib29sZWFufSxcbiAgc3RhY2s6IHtib29sZWFufSxcbiAgc25hcDogeydmdW5jdGlvbic6ICdmdW5jdGlvbicsICdudWxsJzogJ251bGwnfSxcbiAgc3RhcnQ6IHtkYXRlLCBudW1iZXIsIHN0cmluZywgbW9tZW50fSxcbiAgdGVtcGxhdGU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgZ3JvdXBUZW1wbGF0ZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICB0aW1lQXhpczoge1xuICAgIHNjYWxlOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgc3RlcDoge251bWJlciwndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgIF9fdHlwZV9fOiB7b2JqZWN0fVxuICB9LFxuICB0eXBlOiB7c3RyaW5nfSxcbiAgd2lkdGg6IHtzdHJpbmcsIG51bWJlcn0sXG4gIHpvb21hYmxlOiB7Ym9vbGVhbn0sXG4gIHpvb21LZXk6IHtzdHJpbmc6IFsnY3RybEtleScsICdhbHRLZXknLCAnbWV0YUtleScsICcnXX0sXG4gIHpvb21NYXg6IHtudW1iZXJ9LFxuICB6b29tTWluOiB7bnVtYmVyfSxcblxuICBfX3R5cGVfXzoge29iamVjdH1cbn07XG5cbmxldCBjb25maWd1cmVPcHRpb25zID0ge1xuICBnbG9iYWw6IHtcbiAgICBhbGlnbjogIFsnY2VudGVyJywgJ2xlZnQnLCAncmlnaHQnXSxcbiAgICBhdXRvUmVzaXplOiB0cnVlLFxuICAgIHRocm90dGxlUmVkcmF3OiBbMTAsIDAsIDEwMDAsIDEwXSxcbiAgICBjbGlja1RvVXNlOiBmYWxzZSxcbiAgICAvLyBkYXRhQXR0cmlidXRlczogWydhbGwnXSwgLy8gRklYTUU6IGNhbiBiZSAnYWxsJyBvciBzdHJpbmdbXVxuICAgIGVkaXRhYmxlOiB7XG4gICAgICBhZGQ6IGZhbHNlLFxuICAgICAgcmVtb3ZlOiBmYWxzZSxcbiAgICAgIHVwZGF0ZUdyb3VwOiBmYWxzZSxcbiAgICAgIHVwZGF0ZVRpbWU6IGZhbHNlXG4gICAgfSxcbiAgICBlbmQ6ICcnLFxuICAgIGZvcm1hdDoge1xuICAgICAgbWlub3JMYWJlbHM6IHtcbiAgICAgICAgbWlsbGlzZWNvbmQ6J1NTUycsXG4gICAgICAgIHNlY29uZDogICAgICdzJyxcbiAgICAgICAgbWludXRlOiAgICAgJ0hIOm1tJyxcbiAgICAgICAgaG91cjogICAgICAgJ0hIOm1tJyxcbiAgICAgICAgd2Vla2RheTogICAgJ2RkZCBEJyxcbiAgICAgICAgZGF5OiAgICAgICAgJ0QnLFxuICAgICAgICBtb250aDogICAgICAnTU1NJyxcbiAgICAgICAgeWVhcjogICAgICAgJ1lZWVknXG4gICAgICB9LFxuICAgICAgbWFqb3JMYWJlbHM6IHtcbiAgICAgICAgbWlsbGlzZWNvbmQ6J0hIOm1tOnNzJyxcbiAgICAgICAgc2Vjb25kOiAgICAgJ0QgTU1NTSBISDptbScsXG4gICAgICAgIG1pbnV0ZTogICAgICdkZGQgRCBNTU1NJyxcbiAgICAgICAgaG91cjogICAgICAgJ2RkZCBEIE1NTU0nLFxuICAgICAgICB3ZWVrZGF5OiAgICAnTU1NTSBZWVlZJyxcbiAgICAgICAgZGF5OiAgICAgICAgJ01NTU0gWVlZWScsXG4gICAgICAgIG1vbnRoOiAgICAgICdZWVlZJyxcbiAgICAgICAgeWVhcjogICAgICAgJydcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy9ncm91cE9yZGVyOiB7c3RyaW5nLCAnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICBncm91cHNEcmFnZ2FibGU6IGZhbHNlLFxuICAgIGhlaWdodDogJycsXG4gICAgLy9oaWRkZW5EYXRlczoge29iamVjdCwgYXJyYXl9LFxuICAgIGxvY2FsZTogJycsXG4gICAgbWFyZ2luOiB7XG4gICAgICBheGlzOiBbMjAsIDAsIDEwMCwgMV0sXG4gICAgICBpdGVtOiB7XG4gICAgICAgIGhvcml6b250YWw6IFsxMCwgMCwgMTAwLCAxXSxcbiAgICAgICAgdmVydGljYWw6IFsxMCwgMCwgMTAwLCAxXVxuICAgICAgfVxuICAgIH0sXG4gICAgbWF4OiAnJyxcbiAgICBtYXhIZWlnaHQ6ICcnLFxuICAgIG1pbjogJycsXG4gICAgbWluSGVpZ2h0OiAnJyxcbiAgICBtb3ZlYWJsZTogZmFsc2UsXG4gICAgbXVsdGlzZWxlY3Q6IGZhbHNlLFxuICAgIC8vb25BZGQ6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAvL29uVXBkYXRlOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgLy9vbk1vdmU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAvL29uTW92aW5nOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgLy9vblJlbmFtZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICAgIC8vb3JkZXI6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICBvcmllbnRhdGlvbjoge1xuICAgICAgYXhpczogWydib3RoJywgJ2JvdHRvbScsICd0b3AnXSxcbiAgICAgIGl0ZW06IFsnYm90dG9tJywgJ3RvcCddXG4gICAgfSxcbiAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgIHNob3dDdXJyZW50VGltZTogZmFsc2UsXG4gICAgc2hvd01ham9yTGFiZWxzOiB0cnVlLFxuICAgIHNob3dNaW5vckxhYmVsczogdHJ1ZSxcbiAgICBzdGFjazogdHJ1ZSxcbiAgICAvL3NuYXA6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nLCBuYWRhfSxcbiAgICBzdGFydDogJycsXG4gICAgLy90ZW1wbGF0ZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICAgIC8vdGltZUF4aXM6IHtcbiAgICAvLyAgc2NhbGU6IFsnbWlsbGlzZWNvbmQnLCAnc2Vjb25kJywgJ21pbnV0ZScsICdob3VyJywgJ3dlZWtkYXknLCAnZGF5JywgJ21vbnRoJywgJ3llYXInXSxcbiAgICAvLyAgc3RlcDogWzEsIDEsIDEwLCAxXVxuICAgIC8vfSxcbiAgICB0eXBlOiBbJ2JveCcsICdwb2ludCcsICdyYW5nZScsICdiYWNrZ3JvdW5kJ10sXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICB6b29tYWJsZTogdHJ1ZSxcbiAgICB6b29tS2V5OiBbJ2N0cmxLZXknLCAnYWx0S2V5JywgJ21ldGFLZXknLCAnJ10sXG4gICAgem9vbU1heDogWzMxNTM2MDAwMDAwMDAwMCwgMTAsIDMxNTM2MDAwMDAwMDAwMCwgMV0sXG4gICAgem9vbU1pbjogWzEwLCAxMCwgMzE1MzYwMDAwMDAwMDAwLCAxXVxuICB9XG59O1xuXG5leHBvcnQge2FsbE9wdGlvbnMsIGNvbmZpZ3VyZU9wdGlvbnN9OyIsIi8vIHV0aWxpdHkgZnVuY3Rpb25zXG5cbi8vIGZpcnN0IGNoZWNrIGlmIG1vbWVudC5qcyBpcyBhbHJlYWR5IGxvYWRlZCBpbiB0aGUgYnJvd3NlciB3aW5kb3csIGlmIHNvLFxuLy8gdXNlIHRoaXMgaW5zdGFuY2UuIEVsc2UsIGxvYWQgdmlhIGNvbW1vbmpzLlxuXG5cbnZhciBtb21lbnQgPSByZXF1aXJlKCcuL21vZHVsZS9tb21lbnQnKTtcbnZhciB1dWlkID0gcmVxdWlyZSgnLi9tb2R1bGUvdXVpZCcpO1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBudW1iZXJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBpc051bWJlclxuICovXG5leHBvcnRzLmlzTnVtYmVyID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gKG9iamVjdCBpbnN0YW5jZW9mIE51bWJlciB8fCB0eXBlb2Ygb2JqZWN0ID09ICdudW1iZXInKTtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmUgZXZlcnl0aGluZyBpbiB0aGUgRE9NIG9iamVjdFxuICogQHBhcmFtIERPTW9iamVjdFxuICovXG5leHBvcnRzLnJlY3Vyc2l2ZURPTURlbGV0ZSA9IGZ1bmN0aW9uIChET01vYmplY3QpIHtcbiAgaWYgKERPTW9iamVjdCkge1xuICAgIHdoaWxlIChET01vYmplY3QuaGFzQ2hpbGROb2RlcygpID09PSB0cnVlKSB7XG4gICAgICBleHBvcnRzLnJlY3Vyc2l2ZURPTURlbGV0ZShET01vYmplY3QuZmlyc3RDaGlsZCk7XG4gICAgICBET01vYmplY3QucmVtb3ZlQ2hpbGQoRE9Nb2JqZWN0LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiB0aGlzIGZ1bmN0aW9uIGdpdmVzIHlvdSBhIHJhbmdlIGJldHdlZW4gMCBhbmQgMSBiYXNlZCBvbiB0aGUgbWluIGFuZCBtYXggdmFsdWVzIGluIHRoZSBzZXQsIHRoZSB0b3RhbCBzdW0gb2YgYWxsIHZhbHVlcyBhbmQgdGhlIGN1cnJlbnQgdmFsdWUuXG4gKlxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICogQHBhcmFtIHRvdGFsXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMuZ2l2ZVJhbmdlID0gZnVuY3Rpb24gKG1pbiwgbWF4LCB0b3RhbCwgdmFsdWUpIHtcbiAgaWYgKG1heCA9PSBtaW4pIHtcbiAgICByZXR1cm4gMC41O1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBzY2FsZSA9IDEgLyAobWF4IC0gbWluKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgKHZhbHVlIC0gbWluKSAqIHNjYWxlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBzdHJpbmdcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBpc1N0cmluZ1xuICovXG5leHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2Ygb2JqZWN0ID09ICdzdHJpbmcnKTtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIERhdGUsIG9yIGEgU3RyaW5nIGNvbnRhaW5pbmcgYSBEYXRlXG4gKiBAcGFyYW0ge0RhdGUgfCBTdHJpbmd9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn0gaXNEYXRlXG4gKi9cbmV4cG9ydHMuaXNEYXRlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVsc2UgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgIC8vIHRlc3Qgd2hldGhlciB0aGlzIHN0cmluZyBjb250YWlucyBhIGRhdGVcbiAgICB2YXIgbWF0Y2ggPSBBU1BEYXRlUmVnZXguZXhlYyhvYmplY3QpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc05hTihEYXRlLnBhcnNlKG9iamVjdCkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHNlbWkgVVVJRFxuICogc291cmNlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMDUwNzQvMTI2Mjc1M1xuICogQHJldHVybiB7U3RyaW5nfSB1dWlkXG4gKi9cbmV4cG9ydHMucmFuZG9tVVVJRCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHV1aWQudjQoKTtcbn07XG5cbi8qKlxuICogYXNzaWduIGFsbCBrZXlzIG9mIGFuIG9iamVjdCB0aGF0IGFyZSBub3QgbmVzdGVkIG9iamVjdHMgdG8gYSBjZXJ0YWluIHZhbHVlICh1c2VkIGZvciBjb2xvciBvYmplY3RzKS5cbiAqIEBwYXJhbSBvYmpcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnRzLmFzc2lnbkFsbEtleXMgPSBmdW5jdGlvbiAob2JqLCB2YWx1ZSkge1xuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqW3Byb3BdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvYmpbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIEZpbGwgYW4gb2JqZWN0IHdpdGggYSBwb3NzaWJseSBwYXJ0aWFsbHkgZGVmaW5lZCBvdGhlciBvYmplY3QuIE9ubHkgY29waWVzIHZhbHVlcyBpZiB0aGUgYSBvYmplY3QgaGFzIGFuIG9iamVjdCByZXF1aXJpbmcgdmFsdWVzLlxuICogVGhhdCBtZWFucyBhbiBvYmplY3QgaXMgbm90IGNyZWF0ZWQgb24gYSBwcm9wZXJ0eSBpZiBvbmx5IHRoZSBiIG9iamVjdCBoYXMgaXQuXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0cy5maWxsSWZEZWZpbmVkID0gZnVuY3Rpb24gKGEsIGIsIGFsbG93RGVsZXRpb24gPSBmYWxzZSkge1xuICBmb3IgKHZhciBwcm9wIGluIGEpIHtcbiAgICBpZiAoYltwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGJbcHJvcF0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICgoYltwcm9wXSA9PT0gdW5kZWZpbmVkIHx8IGJbcHJvcF0gPT09IG51bGwpICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGFbcHJvcF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZXhwb3J0cy5maWxsSWZEZWZpbmVkKGFbcHJvcF0sIGJbcHJvcF0sIGFsbG93RGVsZXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG4vKipcbiAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAqIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWQgdmFsdWVzIGFyZSBjb3BpZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0gey4uLiBPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICovXG5leHBvcnRzLnByb3RvRXh0ZW5kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvdGhlcikge1xuICAgICAgYVtwcm9wXSA9IG90aGVyW3Byb3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIG9iamVjdCBhIHdpdGggdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIgb3IgYSBzZXJpZXMgb2Ygb2JqZWN0c1xuICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7Li4uIE9iamVjdH0gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKi9cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvdGhlcikge1xuICAgICAgaWYgKG90aGVyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGFbcHJvcF0gPSBvdGhlcltwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHNlbGVjdGVkIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIgb3IgYSBzZXJpZXMgb2Ygb2JqZWN0c1xuICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZFxuICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gcHJvcHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKi9cbmV4cG9ydHMuc2VsZWN0aXZlRXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzLCBhLCBiKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IHdpdGggcHJvcGVydHkgbmFtZXMgZXhwZWN0ZWQgYXMgZmlyc3QgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG90aGVyID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1twXTtcbiAgICAgIGlmIChvdGhlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBhW3Byb3BdID0gb3RoZXJbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCBzZWxlY3RlZCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAqIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWQgdmFsdWVzIGFyZSBjb3BpZWRcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IHByb3BzXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICovXG5leHBvcnRzLnNlbGVjdGl2ZURlZXBFeHRlbmQgPSBmdW5jdGlvbiAocHJvcHMsIGEsIGIsIGFsbG93RGVsZXRpb24gPSBmYWxzZSkge1xuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgQXJyYXlzIHRvIGRlZXBFeHRlbmRcbiAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICB9XG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG90aGVyID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbcF07XG4gICAgICBpZiAob3RoZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgaWYgKGJbcHJvcF0gJiYgYltwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYVtwcm9wXSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYVtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICBleHBvcnRzLmRlZXBFeHRlbmQoYVtwcm9wXSwgYltwcm9wXSwgZmFsc2UsIGFsbG93RGVsZXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgoYltwcm9wXSA9PT0gbnVsbCkgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYltwcm9wXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgoYltwcm9wXSA9PT0gbnVsbCkgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCBzZWxlY3RlZCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAqIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWQgdmFsdWVzIGFyZSBjb3BpZWRcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IHByb3BzXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICovXG5leHBvcnRzLnNlbGVjdGl2ZU5vdERlZXBFeHRlbmQgPSBmdW5jdGlvbiAocHJvcHMsIGEsIGIsIGFsbG93RGVsZXRpb24gPSBmYWxzZSkge1xuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgQXJyYXlzIHRvIGRlZXBFeHRlbmRcbiAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICB9XG4gIGZvciAodmFyIHByb3AgaW4gYikge1xuICAgIGlmIChiLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBpZiAocHJvcHMuaW5kZXhPZihwcm9wKSA9PSAtMSkge1xuICAgICAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGJbcHJvcF0gPT09IG51bGwpICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJbcHJvcF0pKSB7XG4gICAgICAgICAgYVtwcm9wXSA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYltwcm9wXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYVtwcm9wXS5wdXNoKGJbcHJvcF1baV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoKGJbcHJvcF0gPT09IG51bGwpICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIERlZXAgZXh0ZW5kIGFuIG9iamVjdCBhIHdpdGggdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHBhcmFtIFtCb29sZWFuXSBwcm90b0V4dGVuZCAtLT4gb3B0aW9uYWwgcGFyYW1ldGVyLiBJZiB0cnVlLCB0aGUgcHJvdG90eXBlIHZhbHVlcyB3aWxsIGFsc28gYmUgZXh0ZW5kZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaWUuIHRoZSBvcHRpb25zIG9iamVjdHMgdGhhdCBpbmhlcml0IGZyb20gb3RoZXJzIHdpbGwgYWxzbyBnZXQgdGhlIGluaGVyaXRlZCBvcHRpb25zKVxuICogQHBhcmFtIFtCb29sZWFuXSBnbG9iYWwgICAgICAtLT4gb3B0aW9uYWwgcGFyYW1ldGVyLiBJZiB0cnVlLCB0aGUgdmFsdWVzIG9mIGZpZWxkcyB0aGF0IGFyZSBudWxsIHdpbGwgbm90IGRlbGV0ZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZGVlcEV4dGVuZCA9IGZ1bmN0aW9uIChhLCBiLCBwcm90b0V4dGVuZCwgYWxsb3dEZWxldGlvbikge1xuICBmb3IgKHZhciBwcm9wIGluIGIpIHtcbiAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCBwcm90b0V4dGVuZCA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKGJbcHJvcF0gJiYgYltwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgIGV4cG9ydHMuZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdLCBwcm90b0V4dGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKChiW3Byb3BdID09PSBudWxsKSAmJiBhW3Byb3BdICE9PSB1bmRlZmluZWQgJiYgYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYltwcm9wXSkpIHtcbiAgICAgICAgYVtwcm9wXSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJbcHJvcF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhW3Byb3BdLnB1c2goYltwcm9wXVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgoYltwcm9wXSA9PT0gbnVsbCkgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFsbCBlbGVtZW50cyBpbiB0d28gYXJyYXlzIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFcbiAqIEBwYXJhbSB7QXJyYXl9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBib3RoIGFycmF5cyBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhbmQgc2FtZVxuICogICAgICAgICAgICAgICAgICAgZWxlbWVudHMuXG4gKi9cbmV4cG9ydHMuZXF1YWxBcnJheSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYW4gb2JqZWN0IHRvIGFub3RoZXIgdHlwZVxuICogQHBhcmFtIHtCb29sZWFuIHwgTnVtYmVyIHwgU3RyaW5nIHwgRGF0ZSB8IE1vbWVudCB8IE51bGwgfCB1bmRlZmluZWR9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmcgfCB1bmRlZmluZWR9IHR5cGUgICBOYW1lIG9mIHRoZSB0eXBlLiBBdmFpbGFibGUgdHlwZXM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdCb29sZWFuJywgJ051bWJlcicsICdTdHJpbmcnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRGF0ZScsICdNb21lbnQnLCBJU09EYXRlJywgJ0FTUERhdGUnLlxuICogQHJldHVybiB7Kn0gb2JqZWN0XG4gKiBAdGhyb3dzIEVycm9yXG4gKi9cbmV4cG9ydHMuY29udmVydCA9IGZ1bmN0aW9uIChvYmplY3QsIHR5cGUpIHtcbiAgdmFyIG1hdGNoO1xuXG4gIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBpZiAoISh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpICYmICEodHlwZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIEJvb2xlYW4ob2JqZWN0KTtcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIHJldHVybiBOdW1iZXIob2JqZWN0LnZhbHVlT2YoKSk7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICByZXR1cm4gU3RyaW5nKG9iamVjdCk7XG5cbiAgICBjYXNlICdEYXRlJzpcbiAgICAgIGlmIChleHBvcnRzLmlzTnVtYmVyKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdCk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0LnZhbHVlT2YoKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChtb21lbnQuaXNNb21lbnQob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0LnZhbHVlT2YoKSk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAgIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIEFTUCBkYXRlXG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcihtYXRjaFsxXSkpOyAvLyBwYXJzZSBudW1iZXJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbW9tZW50KG9iamVjdCkudG9EYXRlKCk7IC8vIHBhcnNlIHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgK1xuICAgICAgICAgICcgdG8gdHlwZSBEYXRlJyk7XG4gICAgICB9XG5cbiAgICBjYXNlICdNb21lbnQnOlxuICAgICAgaWYgKGV4cG9ydHMuaXNOdW1iZXIob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbW9tZW50KG9iamVjdCk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gbW9tZW50KG9iamVjdC52YWx1ZU9mKCkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobW9tZW50LmlzTW9tZW50KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIC8vIG9iamVjdCBpcyBhbiBBU1AgZGF0ZVxuICAgICAgICAgIHJldHVybiBtb21lbnQoTnVtYmVyKG1hdGNoWzFdKSk7IC8vIHBhcnNlIG51bWJlclxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtb21lbnQob2JqZWN0KTsgLy8gcGFyc2Ugc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBjb252ZXJ0IG9iamVjdCBvZiB0eXBlICcgKyBleHBvcnRzLmdldFR5cGUob2JqZWN0KSArXG4gICAgICAgICAgJyB0byB0eXBlIERhdGUnKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ0lTT0RhdGUnOlxuICAgICAgaWYgKGV4cG9ydHMuaXNOdW1iZXIob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdC50b0lTT1N0cmluZygpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobW9tZW50LmlzTW9tZW50KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdC50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAgIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgLy8gb2JqZWN0IGlzIGFuIEFTUCBkYXRlXG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcihtYXRjaFsxXSkpLnRvSVNPU3RyaW5nKCk7IC8vIHBhcnNlIG51bWJlclxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmplY3QpLnRvSVNPU3RyaW5nKCk7IC8vIHBhcnNlIHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgK1xuICAgICAgICAgICcgdG8gdHlwZSBJU09EYXRlJyk7XG4gICAgICB9XG5cbiAgICBjYXNlICdBU1BEYXRlJzpcbiAgICAgIGlmIChleHBvcnRzLmlzTnVtYmVyKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuICcvRGF0ZSgnICsgb2JqZWN0ICsgJykvJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICcvRGF0ZSgnICsgb2JqZWN0LnZhbHVlT2YoKSArICcpLyc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAgICAgbWF0Y2ggPSBBU1BEYXRlUmVnZXguZXhlYyhvYmplY3QpO1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIC8vIG9iamVjdCBpcyBhbiBBU1AgZGF0ZVxuICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUoTnVtYmVyKG1hdGNoWzFdKSkudmFsdWVPZigpOyAvLyBwYXJzZSBudW1iZXJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKG9iamVjdCkudmFsdWVPZigpOyAvLyBwYXJzZSBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJy9EYXRlKCcgKyB2YWx1ZSArICcpLyc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgK1xuICAgICAgICAgICcgdG8gdHlwZSBBU1BEYXRlJyk7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUgXCInICsgdHlwZSArICdcIicpO1xuICB9XG59O1xuXG4vLyBwYXJzZSBBU1AuTmV0IERhdGUgcGF0dGVybixcbi8vIGZvciBleGFtcGxlICcvRGF0ZSgxMTk4OTA4NzE3MDU2KS8nIG9yICcvRGF0ZSgxMTk4OTA4NzE3MDU2LTA3MDApLydcbi8vIGNvZGUgZnJvbSBodHRwOi8vbW9tZW50anMuY29tL1xudmFyIEFTUERhdGVSZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbi8qKlxuICogR2V0IHRoZSB0eXBlIG9mIGFuIG9iamVjdCwgZm9yIGV4YW1wbGUgZXhwb3J0cy5nZXRUeXBlKFtdKSByZXR1cm5zICdBcnJheSdcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAqL1xuZXhwb3J0cy5nZXRUeXBlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBvYmplY3Q7XG5cbiAgaWYgKHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgcmV0dXJuICdCb29sZWFuJztcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICByZXR1cm4gJ1N0cmluZyc7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgIHJldHVybiAnQXJyYXknO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuICdEYXRlJztcbiAgICB9XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG4gIGVsc2UgaWYgKHR5cGUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gJ051bWJlcic7XG4gIH1cbiAgZWxzZSBpZiAodHlwZSA9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gJ0Jvb2xlYW4nO1xuICB9XG4gIGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gJ1N0cmluZyc7XG4gIH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9XG5cblxuICByZXR1cm4gdHlwZTtcbn07XG5cblxuLyoqXG4gKiBVc2VkIHRvIGV4dGVuZCBhbiBhcnJheSBhbmQgY29weSBpdC4gVGhpcyBpcyB1c2VkIHRvIHByb3BhZ2F0ZSBwYXRocyByZWN1cnNpdmVseS5cbiAqXG4gKiBAcGFyYW0gYXJyXG4gKiBAcGFyYW0gbmV3VmFsdWVcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZXhwb3J0cy5jb3B5QW5kRXh0ZW5kQXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBuZXdWYWx1ZSkge1xuICBsZXQgbmV3QXJyID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgfVxuICBuZXdBcnIucHVzaChuZXdWYWx1ZSk7XG4gIHJldHVybiBuZXdBcnI7XG59XG5cbi8qKlxuICogVXNlZCB0byBleHRlbmQgYW4gYXJyYXkgYW5kIGNvcHkgaXQuIFRoaXMgaXMgdXNlZCB0byBwcm9wYWdhdGUgcGF0aHMgcmVjdXJzaXZlbHkuXG4gKlxuICogQHBhcmFtIGFyclxuICogQHBhcmFtIG5ld1ZhbHVlXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmV4cG9ydHMuY29weUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICBsZXQgbmV3QXJyID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgfVxuICByZXR1cm4gbmV3QXJyO1xufVxuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhYnNvbHV0ZSBsZWZ0IHZhbHVlIG9mIGEgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAgICAgICAgQSBkb20gZWxlbWVudCwgZm9yIGV4YW1wbGUgYSBkaXZcbiAqIEByZXR1cm4ge251bWJlcn0gbGVmdCAgICAgICAgVGhlIGFic29sdXRlIGxlZnQgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBicm93c2VyIHBhZ2UuXG4gKi9cbmV4cG9ydHMuZ2V0QWJzb2x1dGVMZWZ0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGFic29sdXRlIHRvcCB2YWx1ZSBvZiBhIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gICAgICAgIEEgZG9tIGVsZW1lbnQsIGZvciBleGFtcGxlIGEgZGl2XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRvcCAgICAgICAgVGhlIGFic29sdXRlIHRvcCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGJyb3dzZXIgcGFnZS5cbiAqL1xuZXhwb3J0cy5nZXRBYnNvbHV0ZVRvcCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbn07XG5cbi8qKlxuICogYWRkIGEgY2xhc3NOYW1lIHRvIHRoZSBnaXZlbiBlbGVtZW50cyBzdHlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKi9cbmV4cG9ydHMuYWRkQ2xhc3NOYW1lID0gZnVuY3Rpb24gKGVsZW0sIGNsYXNzTmFtZSkge1xuICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gIGlmIChjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA9PSAtMSkge1xuICAgIGNsYXNzZXMucHVzaChjbGFzc05hbWUpOyAvLyBhZGQgdGhlIGNsYXNzIHRvIHRoZSBhcnJheVxuICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG4gIH1cbn07XG5cbi8qKlxuICogYWRkIGEgY2xhc3NOYW1lIHRvIHRoZSBnaXZlbiBlbGVtZW50cyBzdHlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKi9cbmV4cG9ydHMucmVtb3ZlQ2xhc3NOYW1lID0gZnVuY3Rpb24gKGVsZW0sIGNsYXNzTmFtZSkge1xuICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gIHZhciBpbmRleCA9IGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpO1xuICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICBjbGFzc2VzLnNwbGljZShpbmRleCwgMSk7IC8vIHJlbW92ZSB0aGUgY2xhc3MgZnJvbSB0aGUgYXJyYXlcbiAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xuICB9XG59O1xuXG4vKipcbiAqIEZvciBlYWNoIG1ldGhvZCBmb3IgYm90aCBhcnJheXMgYW5kIG9iamVjdHMuXG4gKiBJbiBjYXNlIG9mIGFuIGFycmF5LCB0aGUgYnVpbHQtaW4gQXJyYXkuZm9yRWFjaCgpIGlzIGFwcGxpZWQuXG4gKiBJbiBjYXNlIG9mIGFuIE9iamVjdCwgdGhlIG1ldGhvZCBsb29wcyBvdmVyIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdCB8IEFycmF5fSBvYmplY3QgICBBbiBPYmplY3Qgb3IgQXJyYXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgICAgIENhbGxiYWNrIG1ldGhvZCwgY2FsbGVkIGZvciBlYWNoIGl0ZW0gaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBvYmplY3Qgb3IgYXJyYXkgd2l0aCB0aHJlZSBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUsIGluZGV4LCBvYmplY3QpXG4gKi9cbmV4cG9ydHMuZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gIHZhciBpLFxuICAgIGxlbjtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIC8vIGFycmF5XG4gICAgZm9yIChpID0gMCwgbGVuID0gb2JqZWN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYWxsYmFjayhvYmplY3RbaV0sIGksIG9iamVjdCk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIG9iamVjdFxuICAgIGZvciAoaSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgY2FsbGJhY2sob2JqZWN0W2ldLCBpLCBvYmplY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGFuIGFycmF5OiBhbGwgb2JqZWN0cyBwcm9wZXJ0aWVzIGFyZSBwdXQgaW50byB0aGVcbiAqIGFycmF5LiBUaGUgcmVzdWx0aW5nIGFycmF5IGlzIHVub3JkZXJlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKi9cbmV4cG9ydHMudG9BcnJheSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgdmFyIGFycmF5ID0gW107XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KHByb3ApKSBhcnJheS5wdXNoKG9iamVjdFtwcm9wXSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBhIHByb3BlcnR5IGluIGFuIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICovXG5leHBvcnRzLnVwZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAob2JqZWN0W2tleV0gIT09IHZhbHVlKSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogVGhyb3R0bGUgdGhlIGdpdmVuIGZ1bmN0aW9uIHRvIGJlIG9ubHkgZXhlY3V0ZWQgb25jZSBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgICAgVGltZSBpbiBtaWxsaXNlY29uZHNcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gUmV0dXJucyB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydHMudGhyb3R0bGUgPSBmdW5jdGlvbiAoZm4sIHdhaXQpIHtcbiAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICB2YXIgbmVlZEV4ZWN1dGlvbiA9IGZhbHNlO1xuXG4gIHJldHVybiBmdW5jdGlvbiB0aHJvdHRsZWQgKCkge1xuICAgIGlmICghdGltZW91dCkge1xuICAgICAgbmVlZEV4ZWN1dGlvbiA9IGZhbHNlO1xuICAgICAgZm4oKTtcblxuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAobmVlZEV4ZWN1dGlvbikge1xuICAgICAgICAgIHRocm90dGxlZCgpO1xuICAgICAgICB9XG4gICAgICB9LCB3YWl0KVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG5lZWRFeGVjdXRpb24gPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBZGQgYW5kIGV2ZW50IGxpc3RlbmVyLiBXb3JrcyBmb3IgYWxsIGJyb3dzZXJzXG4gKiBAcGFyYW0ge0VsZW1lbnR9ICAgICBlbGVtZW50ICAgIEFuIGh0bWwgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgYWN0aW9uICAgICBUaGUgYWN0aW9uLCBmb3IgZXhhbXBsZSBcImNsaWNrXCIsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhvdXQgdGhlIHByZWZpeCBcIm9uXCJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259ICAgIGxpc3RlbmVyICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbdXNlQ2FwdHVyZV1cbiAqL1xuZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgaWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGlmICh1c2VDYXB0dXJlID09PSB1bmRlZmluZWQpXG4gICAgICB1c2VDYXB0dXJlID0gZmFsc2U7XG5cbiAgICBpZiAoYWN0aW9uID09PSBcIm1vdXNld2hlZWxcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID49IDApIHtcbiAgICAgIGFjdGlvbiA9IFwiRE9NTW91c2VTY3JvbGxcIjsgIC8vIEZvciBGaXJlZm94XG4gICAgfVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoXCJvblwiICsgYWN0aW9uLCBsaXN0ZW5lcik7ICAvLyBJRSBicm93c2Vyc1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gICAgIGVsZW1lbnQgICAgICAgICBBbiBodG1sIGRvbSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICBhY3Rpb24gICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LCBmb3IgZXhhbXBsZSBcIm1vdXNlZG93blwiXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSAgICBsaXN0ZW5lciAgICAgICAgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbdXNlQ2FwdHVyZV1cbiAqL1xuZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIC8vIG5vbi1JRSBicm93c2Vyc1xuICAgIGlmICh1c2VDYXB0dXJlID09PSB1bmRlZmluZWQpXG4gICAgICB1c2VDYXB0dXJlID0gZmFsc2U7XG5cbiAgICBpZiAoYWN0aW9uID09PSBcIm1vdXNld2hlZWxcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID49IDApIHtcbiAgICAgIGFjdGlvbiA9IFwiRE9NTW91c2VTY3JvbGxcIjsgIC8vIEZvciBGaXJlZm94XG4gICAgfVxuXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIC8vIElFIGJyb3dzZXJzXG4gICAgZWxlbWVudC5kZXRhY2hFdmVudChcIm9uXCIgKyBhY3Rpb24sIGxpc3RlbmVyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYW5jZWxzIHRoZSBldmVudCBpZiBpdCBpcyBjYW5jZWxhYmxlLCB3aXRob3V0IHN0b3BwaW5nIGZ1cnRoZXIgcHJvcGFnYXRpb24gb2YgdGhlIGV2ZW50LlxuICovXG5leHBvcnRzLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghZXZlbnQpXG4gICAgZXZlbnQgPSB3aW5kb3cuZXZlbnQ7XG5cbiAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgIC8vIG5vbi1JRSBicm93c2Vyc1xuICB9XG4gIGVsc2Uge1xuICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7ICAvLyBJRSBicm93c2Vyc1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBIVE1MIGVsZW1lbnQgd2hpY2ggaXMgdGhlIHRhcmdldCBvZiB0aGUgZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtFbGVtZW50fSB0YXJnZXQgZWxlbWVudFxuICovXG5leHBvcnRzLmdldFRhcmdldCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBjb2RlIGZyb20gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIGlmICghZXZlbnQpIHtcbiAgICBldmVudCA9IHdpbmRvdy5ldmVudDtcbiAgfVxuXG4gIHZhciB0YXJnZXQ7XG5cbiAgaWYgKGV2ZW50LnRhcmdldCkge1xuICAgIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgfVxuICBlbHNlIGlmIChldmVudC5zcmNFbGVtZW50KSB7XG4gICAgdGFyZ2V0ID0gZXZlbnQuc3JjRWxlbWVudDtcbiAgfVxuXG4gIGlmICh0YXJnZXQubm9kZVR5cGUgIT0gdW5kZWZpbmVkICYmIHRhcmdldC5ub2RlVHlwZSA9PSAzKSB7XG4gICAgLy8gZGVmZWF0IFNhZmFyaSBidWdcbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGdpdmVuIGVsZW1lbnQgY29udGFpbnMgZ2l2ZW4gcGFyZW50IHNvbWV3aGVyZSBpbiB0aGUgRE9NIHRyZWVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZXhwb3J0cy5oYXNQYXJlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgcGFyZW50KSB7XG4gIHZhciBlID0gZWxlbWVudDtcblxuICB3aGlsZSAoZSkge1xuICAgIGlmIChlID09PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlID0gZS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0cy5vcHRpb24gPSB7fTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIGJvb2xlYW5cbiAqIEBwYXJhbSB7Qm9vbGVhbiB8IGZ1bmN0aW9uIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICogQHBhcmFtIHtCb29sZWFufSBbZGVmYXVsdFZhbHVlXVxuICogQHJldHVybnMge0Jvb2xlYW59IGJvb2xcbiAqL1xuZXhwb3J0cy5vcHRpb24uYXNCb29sZWFuID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSgpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gKHZhbHVlICE9IGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gYSBudW1iZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbiB8IGZ1bmN0aW9uIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtkZWZhdWx0VmFsdWVdXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBudW1iZXJcbiAqL1xuZXhwb3J0cy5vcHRpb24uYXNOdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gIH1cblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpIHx8IGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmcgfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZGVmYXVsdFZhbHVlXVxuICogQHJldHVybnMge1N0cmluZ30gc3RyXG4gKi9cbmV4cG9ydHMub3B0aW9uLmFzU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSgpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHNpemUgb3IgbG9jYXRpb24gaW50byBhIHN0cmluZyB3aXRoIHBpeGVscyBvciBhIHBlcmNlbnRhZ2VcbiAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyIHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IHNpemVcbiAqL1xuZXhwb3J0cy5vcHRpb24uYXNTaXplID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSgpO1xuICB9XG5cbiAgaWYgKGV4cG9ydHMuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGVsc2UgaWYgKGV4cG9ydHMuaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JztcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IGZ1bmN0aW9uIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9IGRvbVxuICovXG5leHBvcnRzLm9wdGlvbi5hc0VsZW1lbnQgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gIH1cblxuICByZXR1cm4gdmFsdWUgfHwgZGVmYXVsdFZhbHVlIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTYyMzgzOC9yZ2ItdG8taGV4LWFuZC1oZXgtdG8tcmdiXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhleFxuICogQHJldHVybnMge3tyOiAqLCBnOiAqLCBiOiAqfX0gfCAyNTUgcmFuZ2VcbiAqL1xuZXhwb3J0cy5oZXhUb1JHQiA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgLy8gRXhwYW5kIHNob3J0aGFuZCBmb3JtIChlLmcuIFwiMDNGXCIpIHRvIGZ1bGwgZm9ybSAoZS5nLiBcIjAwMzNGRlwiKVxuICB2YXIgc2hvcnRoYW5kUmVnZXggPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pO1xuICBoZXggPSBoZXgucmVwbGFjZShzaG9ydGhhbmRSZWdleCwgZnVuY3Rpb24gKG0sIHIsIGcsIGIpIHtcbiAgICByZXR1cm4gciArIHIgKyBnICsgZyArIGIgKyBiO1xuICB9KTtcbiAgdmFyIHJlc3VsdCA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kuZXhlYyhoZXgpO1xuICByZXR1cm4gcmVzdWx0ID8ge1xuICAgIHI6IHBhcnNlSW50KHJlc3VsdFsxXSwgMTYpLFxuICAgIGc6IHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpLFxuICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpXG4gIH0gOiBudWxsO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGNvbG9yIGluIGhleCBmb3JtYXQgb3IgcmdiKCkgb3IgcmdiYSgpIGZvcm1hdCBhbmQgb3ZlcnJpZGVzIHRoZSBvcGFjaXR5LiBSZXR1cm5zIHJnYmEoKSBzdHJpbmcuXG4gKiBAcGFyYW0gY29sb3JcbiAqIEBwYXJhbSBvcGFjaXR5XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5vdmVycmlkZU9wYWNpdHkgPSBmdW5jdGlvbiAoY29sb3IsIG9wYWNpdHkpIHtcbiAgaWYgKGNvbG9yLmluZGV4T2YoXCJyZ2JhXCIpICE9IC0xKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIGVsc2UgaWYgKGNvbG9yLmluZGV4T2YoXCJyZ2JcIikgIT0gLTEpIHtcbiAgICB2YXIgcmdiID0gY29sb3Iuc3Vic3RyKGNvbG9yLmluZGV4T2YoXCIoXCIpICsgMSkucmVwbGFjZShcIilcIiwgXCJcIikuc3BsaXQoXCIsXCIpO1xuICAgIHJldHVybiBcInJnYmEoXCIgKyByZ2JbMF0gKyBcIixcIiArIHJnYlsxXSArIFwiLFwiICsgcmdiWzJdICsgXCIsXCIgKyBvcGFjaXR5ICsgXCIpXCJcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgcmdiID0gZXhwb3J0cy5oZXhUb1JHQihjb2xvcik7XG4gICAgaWYgKHJnYiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFwicmdiYShcIiArIHJnYi5yICsgXCIsXCIgKyByZ2IuZyArIFwiLFwiICsgcmdiLmIgKyBcIixcIiArIG9wYWNpdHkgKyBcIilcIlxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gcmVkICAgICAwIC0tIDI1NVxuICogQHBhcmFtIGdyZWVuICAgMCAtLSAyNTVcbiAqIEBwYXJhbSBibHVlICAgIDAgLS0gMjU1XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydHMuUkdCVG9IZXggPSBmdW5jdGlvbiAocmVkLCBncmVlbiwgYmx1ZSkge1xuICByZXR1cm4gXCIjXCIgKyAoKDEgPDwgMjQpICsgKHJlZCA8PCAxNikgKyAoZ3JlZW4gPDwgOCkgKyBibHVlKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgY29sb3IgcHJvcGVydHkgaW50byBhbiBvYmplY3Qgd2l0aCBib3JkZXIsIGJhY2tncm91bmQsIGFuZFxuICogaGlnaGxpZ2h0IGNvbG9yc1xuICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmd9IGNvbG9yXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvbG9yT2JqZWN0XG4gKi9cbmV4cG9ydHMucGFyc2VDb2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xuICB2YXIgYztcbiAgaWYgKGV4cG9ydHMuaXNTdHJpbmcoY29sb3IpID09PSB0cnVlKSB7XG4gICAgaWYgKGV4cG9ydHMuaXNWYWxpZFJHQihjb2xvcikgPT09IHRydWUpIHtcbiAgICAgIHZhciByZ2IgPSBjb2xvci5zdWJzdHIoNCkuc3Vic3RyKDAsIGNvbG9yLmxlbmd0aCAtIDUpLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gcGFyc2VJbnQodmFsdWUpIH0pO1xuICAgICAgY29sb3IgPSBleHBvcnRzLlJHQlRvSGV4KHJnYlswXSwgcmdiWzFdLCByZ2JbMl0pO1xuICAgIH1cbiAgICBpZiAoZXhwb3J0cy5pc1ZhbGlkSGV4KGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIGhzdiA9IGV4cG9ydHMuaGV4VG9IU1YoY29sb3IpO1xuICAgICAgdmFyIGxpZ2h0ZXJDb2xvckhTViA9IHsgaDogaHN2LmgsIHM6IGhzdi5zICogMC44LCB2OiBNYXRoLm1pbigxLCBoc3YudiAqIDEuMDIpIH07XG4gICAgICB2YXIgZGFya2VyQ29sb3JIU1YgPSB7IGg6IGhzdi5oLCBzOiBNYXRoLm1pbigxLCBoc3YucyAqIDEuMjUpLCB2OiBoc3YudiAqIDAuOCB9O1xuICAgICAgdmFyIGRhcmtlckNvbG9ySGV4ID0gZXhwb3J0cy5IU1ZUb0hleChkYXJrZXJDb2xvckhTVi5oLCBkYXJrZXJDb2xvckhTVi5zLCBkYXJrZXJDb2xvckhTVi52KTtcbiAgICAgIHZhciBsaWdodGVyQ29sb3JIZXggPSBleHBvcnRzLkhTVlRvSGV4KGxpZ2h0ZXJDb2xvckhTVi5oLCBsaWdodGVyQ29sb3JIU1YucywgbGlnaHRlckNvbG9ySFNWLnYpO1xuICAgICAgYyA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXgsXG4gICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGxpZ2h0ZXJDb2xvckhleCxcbiAgICAgICAgICBib3JkZXI6IGRhcmtlckNvbG9ySGV4XG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogbGlnaHRlckNvbG9ySGV4LFxuICAgICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXhcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjID0ge1xuICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvcixcbiAgICAgICAgYm9yZGVyOiBjb2xvcixcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgICAgYm9yZGVyOiBjb2xvclxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLFxuICAgICAgICAgIGJvcmRlcjogY29sb3JcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgYyA9IHt9O1xuICAgIGMuYmFja2dyb3VuZCA9IGNvbG9yLmJhY2tncm91bmQgfHwgdW5kZWZpbmVkO1xuICAgIGMuYm9yZGVyID0gY29sb3IuYm9yZGVyIHx8IHVuZGVmaW5lZDtcblxuICAgIGlmIChleHBvcnRzLmlzU3RyaW5nKGNvbG9yLmhpZ2hsaWdodCkpIHtcbiAgICAgIGMuaGlnaGxpZ2h0ID0ge1xuICAgICAgICBib3JkZXI6IGNvbG9yLmhpZ2hsaWdodCxcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3IuaGlnaGxpZ2h0XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYy5oaWdobGlnaHQgPSB7fTtcbiAgICAgIGMuaGlnaGxpZ2h0LmJhY2tncm91bmQgPSBjb2xvci5oaWdobGlnaHQgJiYgY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgfHwgdW5kZWZpbmVkO1xuICAgICAgYy5oaWdobGlnaHQuYm9yZGVyID0gY29sb3IuaGlnaGxpZ2h0ICYmIGNvbG9yLmhpZ2hsaWdodC5ib3JkZXIgfHwgdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChleHBvcnRzLmlzU3RyaW5nKGNvbG9yLmhvdmVyKSkge1xuICAgICAgYy5ob3ZlciA9IHtcbiAgICAgICAgYm9yZGVyOiBjb2xvci5ob3ZlcixcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3IuaG92ZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjLmhvdmVyID0ge307XG4gICAgICBjLmhvdmVyLmJhY2tncm91bmQgPSBjb2xvci5ob3ZlciAmJiBjb2xvci5ob3Zlci5iYWNrZ3JvdW5kIHx8IHVuZGVmaW5lZDtcbiAgICAgIGMuaG92ZXIuYm9yZGVyID0gY29sb3IuaG92ZXIgJiYgY29sb3IuaG92ZXIuYm9yZGVyIHx8IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYztcbn07XG5cblxuXG4vKipcbiAqIGh0dHA6Ly93d3cuamF2YXNjcmlwdGVyLm5ldC9mYXEvcmdiMmhzdi5odG1cbiAqXG4gKiBAcGFyYW0gcmVkXG4gKiBAcGFyYW0gZ3JlZW5cbiAqIEBwYXJhbSBibHVlXG4gKiBAcmV0dXJucyB7Kn1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnRzLlJHQlRvSFNWID0gZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgcmVkID0gcmVkIC8gMjU1OyBncmVlbiA9IGdyZWVuIC8gMjU1OyBibHVlID0gYmx1ZSAvIDI1NTtcbiAgdmFyIG1pblJHQiA9IE1hdGgubWluKHJlZCwgTWF0aC5taW4oZ3JlZW4sIGJsdWUpKTtcbiAgdmFyIG1heFJHQiA9IE1hdGgubWF4KHJlZCwgTWF0aC5tYXgoZ3JlZW4sIGJsdWUpKTtcblxuICAvLyBCbGFjay1ncmF5LXdoaXRlXG4gIGlmIChtaW5SR0IgPT0gbWF4UkdCKSB7XG4gICAgcmV0dXJuIHsgaDogMCwgczogMCwgdjogbWluUkdCIH07XG4gIH1cblxuICAvLyBDb2xvcnMgb3RoZXIgdGhhbiBibGFjay1ncmF5LXdoaXRlOlxuICB2YXIgZCA9IChyZWQgPT0gbWluUkdCKSA/IGdyZWVuIC0gYmx1ZSA6ICgoYmx1ZSA9PSBtaW5SR0IpID8gcmVkIC0gZ3JlZW4gOiBibHVlIC0gcmVkKTtcbiAgdmFyIGggPSAocmVkID09IG1pblJHQikgPyAzIDogKChibHVlID09IG1pblJHQikgPyAxIDogNSk7XG4gIHZhciBodWUgPSA2MCAqIChoIC0gZCAvIChtYXhSR0IgLSBtaW5SR0IpKSAvIDM2MDtcbiAgdmFyIHNhdHVyYXRpb24gPSAobWF4UkdCIC0gbWluUkdCKSAvIG1heFJHQjtcbiAgdmFyIHZhbHVlID0gbWF4UkdCO1xuICByZXR1cm4geyBoOiBodWUsIHM6IHNhdHVyYXRpb24sIHY6IHZhbHVlIH07XG59O1xuXG52YXIgY3NzVXRpbCA9IHtcbiAgLy8gc3BsaXQgYSBzdHJpbmcgd2l0aCBjc3Mgc3R5bGVzIGludG8gYW4gb2JqZWN0IHdpdGgga2V5L3ZhbHVlc1xuICBzcGxpdDogZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICB2YXIgc3R5bGVzID0ge307XG5cbiAgICBjc3NUZXh0LnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIGlmIChzdHlsZS50cmltKCkgIT0gJycpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gc3R5bGUuc3BsaXQoJzonKTtcbiAgICAgICAgdmFyIGtleSA9IHBhcnRzWzBdLnRyaW0oKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHNbMV0udHJpbSgpO1xuICAgICAgICBzdHlsZXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfSxcblxuICAvLyBidWlsZCBhIGNzcyB0ZXh0IHN0cmluZyBmcm9tIGFuIG9iamVjdCB3aXRoIGtleS92YWx1ZXNcbiAgam9pbjogZnVuY3Rpb24gKHN0eWxlcykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdHlsZXMpXG4gICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSArICc6ICcgKyBzdHlsZXNba2V5XTtcbiAgICAgIH0pXG4gICAgICAuam9pbignOyAnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBcHBlbmQgYSBzdHJpbmcgd2l0aCBjc3Mgc3R5bGVzIHRvIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGNzc1RleHRcbiAqL1xuZXhwb3J0cy5hZGRDc3NUZXh0ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNzc1RleHQpIHtcbiAgdmFyIGN1cnJlbnRTdHlsZXMgPSBjc3NVdGlsLnNwbGl0KGVsZW1lbnQuc3R5bGUuY3NzVGV4dCk7XG4gIHZhciBuZXdTdHlsZXMgPSBjc3NVdGlsLnNwbGl0KGNzc1RleHQpO1xuICB2YXIgc3R5bGVzID0gZXhwb3J0cy5leHRlbmQoY3VycmVudFN0eWxlcywgbmV3U3R5bGVzKTtcblxuICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBjc3NVdGlsLmpvaW4oc3R5bGVzKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgc3RyaW5nIHdpdGggY3NzIHN0eWxlcyBmcm9tIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGNzc1RleHRcbiAqL1xuZXhwb3J0cy5yZW1vdmVDc3NUZXh0ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNzc1RleHQpIHtcbiAgdmFyIHN0eWxlcyA9IGNzc1V0aWwuc3BsaXQoZWxlbWVudC5zdHlsZS5jc3NUZXh0KTtcbiAgdmFyIHJlbW92ZVN0eWxlcyA9IGNzc1V0aWwuc3BsaXQoY3NzVGV4dCk7XG5cbiAgZm9yICh2YXIga2V5IGluIHJlbW92ZVN0eWxlcykge1xuICAgIGlmIChyZW1vdmVTdHlsZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgZGVsZXRlIHN0eWxlc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGNzc1V0aWwuam9pbihzdHlsZXMpO1xufTtcblxuLyoqXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tamlqYWNrc29uLzUzMTEyNTZcbiAqIEBwYXJhbSBoXG4gKiBAcGFyYW0gc1xuICogQHBhcmFtIHZcbiAqIEByZXR1cm5zIHt7cjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcn19XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0cy5IU1ZUb1JHQiA9IGZ1bmN0aW9uIChoLCBzLCB2KSB7XG4gIHZhciByLCBnLCBiO1xuXG4gIHZhciBpID0gTWF0aC5mbG9vcihoICogNik7XG4gIHZhciBmID0gaCAqIDYgLSBpO1xuICB2YXIgcCA9IHYgKiAoMSAtIHMpO1xuICB2YXIgcSA9IHYgKiAoMSAtIGYgKiBzKTtcbiAgdmFyIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG5cbiAgc3dpdGNoIChpICUgNikge1xuICAgIGNhc2UgMDogciA9IHYsIGcgPSB0LCBiID0gcDsgYnJlYWs7XG4gICAgY2FzZSAxOiByID0gcSwgZyA9IHYsIGIgPSBwOyBicmVhaztcbiAgICBjYXNlIDI6IHIgPSBwLCBnID0gdiwgYiA9IHQ7IGJyZWFrO1xuICAgIGNhc2UgMzogciA9IHAsIGcgPSBxLCBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA0OiByID0gdCwgZyA9IHAsIGIgPSB2OyBicmVhaztcbiAgICBjYXNlIDU6IHIgPSB2LCBnID0gcCwgYiA9IHE7IGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHsgcjogTWF0aC5mbG9vcihyICogMjU1KSwgZzogTWF0aC5mbG9vcihnICogMjU1KSwgYjogTWF0aC5mbG9vcihiICogMjU1KSB9O1xufTtcblxuZXhwb3J0cy5IU1ZUb0hleCA9IGZ1bmN0aW9uIChoLCBzLCB2KSB7XG4gIHZhciByZ2IgPSBleHBvcnRzLkhTVlRvUkdCKGgsIHMsIHYpO1xuICByZXR1cm4gZXhwb3J0cy5SR0JUb0hleChyZ2IuciwgcmdiLmcsIHJnYi5iKTtcbn07XG5cbmV4cG9ydHMuaGV4VG9IU1YgPSBmdW5jdGlvbiAoaGV4KSB7XG4gIHZhciByZ2IgPSBleHBvcnRzLmhleFRvUkdCKGhleCk7XG4gIHJldHVybiBleHBvcnRzLlJHQlRvSFNWKHJnYi5yLCByZ2IuZywgcmdiLmIpO1xufTtcblxuZXhwb3J0cy5pc1ZhbGlkSGV4ID0gZnVuY3Rpb24gKGhleCkge1xuICB2YXIgaXNPayA9IC8oXiNbMC05QS1GXXs2fSQpfCheI1swLTlBLUZdezN9JCkvaS50ZXN0KGhleCk7XG4gIHJldHVybiBpc09rO1xufTtcblxuZXhwb3J0cy5pc1ZhbGlkUkdCID0gZnVuY3Rpb24gKHJnYikge1xuICByZ2IgPSByZ2IucmVwbGFjZShcIiBcIiwgXCJcIik7XG4gIHZhciBpc09rID0gL3JnYlxcKChcXGR7MSwzfSksKFxcZHsxLDN9KSwoXFxkezEsM30pXFwpL2kudGVzdChyZ2IpO1xuICByZXR1cm4gaXNPaztcbn1cbmV4cG9ydHMuaXNWYWxpZFJHQkEgPSBmdW5jdGlvbiAocmdiYSkge1xuICByZ2JhID0gcmdiYS5yZXBsYWNlKFwiIFwiLCBcIlwiKTtcbiAgdmFyIGlzT2sgPSAvcmdiYVxcKChcXGR7MSwzfSksKFxcZHsxLDN9KSwoXFxkezEsM30pLCguezEsM30pXFwpL2kudGVzdChyZ2JhKTtcbiAgcmV0dXJuIGlzT2s7XG59XG5cbi8qKlxuICogVGhpcyByZWN1cnNpdmVseSByZWRpcmVjdHMgdGhlIHByb3RvdHlwZSBvZiBKU09OIG9iamVjdHMgdG8gdGhlIHJlZmVyZW5jZU9iamVjdFxuICogVGhpcyBpcyB1c2VkIGZvciBkZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHJlZmVyZW5jZU9iamVjdFxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMuc2VsZWN0aXZlQnJpZGdlT2JqZWN0ID0gZnVuY3Rpb24gKGZpZWxkcywgcmVmZXJlbmNlT2JqZWN0KSB7XG4gIGlmICh0eXBlb2YgcmVmZXJlbmNlT2JqZWN0ID09IFwib2JqZWN0XCIpIHtcbiAgICB2YXIgb2JqZWN0VG8gPSBPYmplY3QuY3JlYXRlKHJlZmVyZW5jZU9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWZlcmVuY2VPYmplY3QuaGFzT3duUHJvcGVydHkoZmllbGRzW2ldKSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlZmVyZW5jZU9iamVjdFtmaWVsZHNbaV1dID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBvYmplY3RUb1tmaWVsZHNbaV1dID0gZXhwb3J0cy5icmlkZ2VPYmplY3QocmVmZXJlbmNlT2JqZWN0W2ZpZWxkc1tpXV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RUbztcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIHJlY3Vyc2l2ZWx5IHJlZGlyZWN0cyB0aGUgcHJvdG90eXBlIG9mIEpTT04gb2JqZWN0cyB0byB0aGUgcmVmZXJlbmNlT2JqZWN0XG4gKiBUaGlzIGlzIHVzZWQgZm9yIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gcmVmZXJlbmNlT2JqZWN0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5icmlkZ2VPYmplY3QgPSBmdW5jdGlvbiAocmVmZXJlbmNlT2JqZWN0KSB7XG4gIGlmICh0eXBlb2YgcmVmZXJlbmNlT2JqZWN0ID09IFwib2JqZWN0XCIpIHtcbiAgICB2YXIgb2JqZWN0VG8gPSBPYmplY3QuY3JlYXRlKHJlZmVyZW5jZU9iamVjdCk7XG4gICAgZm9yICh2YXIgaSBpbiByZWZlcmVuY2VPYmplY3QpIHtcbiAgICAgIGlmIChyZWZlcmVuY2VPYmplY3QuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWZlcmVuY2VPYmplY3RbaV0gPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIG9iamVjdFRvW2ldID0gZXhwb3J0cy5icmlkZ2VPYmplY3QocmVmZXJlbmNlT2JqZWN0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0VG87XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cblxuLyoqXG4gKiB0aGlzIGlzIHVzZWQgdG8gc2V0IHRoZSBvcHRpb25zIG9mIHN1Ym9iamVjdHMgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LiBBIHJlcXVpcmVtZW50IG9mIHRoZXNlIHN1Ym9iamVjdHNcbiAqIGlzIHRoYXQgdGhleSBoYXZlIGFuICdlbmFibGVkJyBlbGVtZW50IHdoaWNoIGlzIG9wdGlvbmFsIGZvciB0aGUgdXNlciBidXQgbWFuZGF0b3J5IGZvciB0aGUgcHJvZ3JhbS5cbiAqXG4gKiBAcGFyYW0gW29iamVjdF0gbWVyZ2VUYXJnZXQgfCB0aGlzIGlzIGVpdGhlciB0aGlzLm9wdGlvbnMgb3IgdGhlIG9wdGlvbnMgdXNlZCBmb3IgdGhlIGdyb3Vwcy5cbiAqIEBwYXJhbSBbb2JqZWN0XSBvcHRpb25zICAgICB8IG9wdGlvbnNcbiAqIEBwYXJhbSBbU3RyaW5nXSBvcHRpb24gICAgICB8IHRoaXMgaXMgdGhlIG9wdGlvbiBrZXkgaW4gdGhlIG9wdGlvbnMgYXJndW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG1lcmdlVGFyZ2V0LCBvcHRpb25zLCBvcHRpb24sIGFsbG93RGVsZXRpb24gPSBmYWxzZSwgZ2xvYmFsT3B0aW9ucyA9IHt9KSB7XG4gIGlmIChvcHRpb25zW29wdGlvbl0gPT09IG51bGwpIHtcbiAgICBtZXJnZVRhcmdldFtvcHRpb25dID0gT2JqZWN0LmNyZWF0ZShnbG9iYWxPcHRpb25zW29wdGlvbl0pO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmIChvcHRpb25zW29wdGlvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW29wdGlvbl0gPT09ICdib29sZWFuJykge1xuICAgICAgICBtZXJnZVRhcmdldFtvcHRpb25dLmVuYWJsZWQgPSBvcHRpb25zW29wdGlvbl07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnNbb3B0aW9uXS5lbmFibGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBtZXJnZVRhcmdldFtvcHRpb25dLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9uc1tvcHRpb25dKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnNbb3B0aW9uXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgbWVyZ2VUYXJnZXRbb3B0aW9uXVtwcm9wXSA9IG9wdGlvbnNbb3B0aW9uXVtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBhIGJpbmFyeSBzZWFyY2ggZm9yIGEgdmlzaWJsZSBpdGVtIGluIGEgc29ydGVkIGxpc3QuIElmIHdlIGZpbmQgYSB2aXNpYmxlIGl0ZW0sIHRoZSBjb2RlIHRoYXQgdXNlc1xuICogdGhpcyBmdW5jdGlvbiB3aWxsIHRoZW4gaXRlcmF0ZSBpbiBib3RoIGRpcmVjdGlvbnMgb3ZlciB0aGlzIHNvcnRlZCBsaXN0IHRvIGZpbmQgYWxsIHZpc2libGUgaXRlbXMuXG4gKlxuICogQHBhcmFtIHtJdGVtW119IG9yZGVyZWRJdGVtcyAgICAgICB8IEl0ZW1zIG9yZGVyZWQgYnkgc3RhcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHNlYXJjaEZ1bmN0aW9uICAgfCAtMSBpcyBsb3dlciwgMCBpcyBmb3VuZCwgMSBpcyBoaWdoZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkMlxuICogQHJldHVybnMge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYmluYXJ5U2VhcmNoQ3VzdG9tID0gZnVuY3Rpb24gKG9yZGVyZWRJdGVtcywgc2VhcmNoRnVuY3Rpb24sIGZpZWxkLCBmaWVsZDIpIHtcbiAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDAwMDtcbiAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gIHZhciBsb3cgPSAwO1xuICB2YXIgaGlnaCA9IG9yZGVyZWRJdGVtcy5sZW5ndGggLSAxO1xuXG4gIHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG5cbiAgICB2YXIgaXRlbSA9IG9yZGVyZWRJdGVtc1ttaWRkbGVdO1xuICAgIHZhciB2YWx1ZSA9IChmaWVsZDIgPT09IHVuZGVmaW5lZCkgPyBpdGVtW2ZpZWxkXSA6IGl0ZW1bZmllbGRdW2ZpZWxkMl07XG5cbiAgICB2YXIgc2VhcmNoUmVzdWx0ID0gc2VhcmNoRnVuY3Rpb24odmFsdWUpO1xuICAgIGlmIChzZWFyY2hSZXN1bHQgPT0gMCkgeyAvLyBqaWhhYSwgZm91bmQgYSB2aXNpYmxlIGl0ZW0hXG4gICAgICByZXR1cm4gbWlkZGxlO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWFyY2hSZXN1bHQgPT0gLTEpIHsgIC8vIGl0IGlzIHRvbyBzbWFsbCAtLT4gaW5jcmVhc2UgbG93XG4gICAgICBsb3cgPSBtaWRkbGUgKyAxO1xuICAgIH1cbiAgICBlbHNlIHsgIC8vIGl0IGlzIHRvbyBiaWcgLS0+IGRlY3JlYXNlIGhpZ2hcbiAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xuICAgIH1cblxuICAgIGl0ZXJhdGlvbisrO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgYSBiaW5hcnkgc2VhcmNoIGZvciBhIHNwZWNpZmljIHZhbHVlIGluIGEgc29ydGVkIGFycmF5LiBJZiBpdCBkb2VzIG5vdCBleGlzdCBidXQgaXMgaW4gYmV0d2VlbiBvZlxuICogdHdvIHZhbHVlcywgd2UgcmV0dXJuIGVpdGhlciB0aGUgb25lIGJlZm9yZSBvciB0aGUgb25lIGFmdGVyLCBkZXBlbmRpbmcgb24gdXNlciBpbnB1dFxuICogSWYgaXQgaXMgZm91bmQsIHdlIHJldHVybiB0aGUgaW5kZXgsIGVsc2UgLTEuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gb3JkZXJlZEl0ZW1zXG4gKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lkZVByZWZlcmVuY2UgICAnYmVmb3JlJyBvciAnYWZ0ZXInXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5iaW5hcnlTZWFyY2hWYWx1ZSA9IGZ1bmN0aW9uIChvcmRlcmVkSXRlbXMsIHRhcmdldCwgZmllbGQsIHNpZGVQcmVmZXJlbmNlKSB7XG4gIHZhciBtYXhJdGVyYXRpb25zID0gMTAwMDA7XG4gIHZhciBpdGVyYXRpb24gPSAwO1xuICB2YXIgbG93ID0gMDtcbiAgdmFyIGhpZ2ggPSBvcmRlcmVkSXRlbXMubGVuZ3RoIC0gMTtcbiAgdmFyIHByZXZWYWx1ZSwgdmFsdWUsIG5leHRWYWx1ZSwgbWlkZGxlO1xuXG4gIHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgLy8gZ2V0IGEgbmV3IGd1ZXNzXG4gICAgbWlkZGxlID0gTWF0aC5mbG9vcigwLjUgKiAoaGlnaCArIGxvdykpO1xuICAgIHByZXZWYWx1ZSA9IG9yZGVyZWRJdGVtc1tNYXRoLm1heCgwLCBtaWRkbGUgLSAxKV1bZmllbGRdO1xuICAgIHZhbHVlID0gb3JkZXJlZEl0ZW1zW21pZGRsZV1bZmllbGRdO1xuICAgIG5leHRWYWx1ZSA9IG9yZGVyZWRJdGVtc1tNYXRoLm1pbihvcmRlcmVkSXRlbXMubGVuZ3RoIC0gMSwgbWlkZGxlICsgMSldW2ZpZWxkXTtcblxuICAgIGlmICh2YWx1ZSA9PSB0YXJnZXQpIHsgLy8gd2UgZm91bmQgdGhlIHRhcmdldFxuICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJldlZhbHVlIDwgdGFyZ2V0ICYmIHZhbHVlID4gdGFyZ2V0KSB7ICAvLyB0YXJnZXQgaXMgaW4gYmV0d2VlbiBvZiB0aGUgcHJldmlvdXMgYW5kIHRoZSBjdXJyZW50XG4gICAgICByZXR1cm4gc2lkZVByZWZlcmVuY2UgPT0gJ2JlZm9yZScgPyBNYXRoLm1heCgwLCBtaWRkbGUgLSAxKSA6IG1pZGRsZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgPCB0YXJnZXQgJiYgbmV4dFZhbHVlID4gdGFyZ2V0KSB7IC8vIHRhcmdldCBpcyBpbiBiZXR3ZWVuIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgbmV4dFxuICAgICAgcmV0dXJuIHNpZGVQcmVmZXJlbmNlID09ICdiZWZvcmUnID8gbWlkZGxlIDogTWF0aC5taW4ob3JkZXJlZEl0ZW1zLmxlbmd0aCAtIDEsIG1pZGRsZSArIDEpO1xuICAgIH1cbiAgICBlbHNlIHsgIC8vIGRpZG50IGZpbmQgdGhlIHRhcmdldCwgd2UgbmVlZCB0byBjaGFuZ2Ugb3VyIGJvdW5kYXJpZXMuXG4gICAgICBpZiAodmFsdWUgPCB0YXJnZXQpIHsgLy8gaXQgaXMgdG9vIHNtYWxsIC0tPiBpbmNyZWFzZSBsb3dcbiAgICAgICAgbG93ID0gbWlkZGxlICsgMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgeyAgLy8gaXQgaXMgdG9vIGJpZyAtLT4gZGVjcmVhc2UgaGlnaFxuICAgICAgICBoaWdoID0gbWlkZGxlIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaXRlcmF0aW9uKys7XG4gIH1cblxuICAvLyBkaWRudCBmaW5kIGFueXRoaW5nLiBSZXR1cm4gLTEuXG4gIHJldHVybiAtMTtcbn07XG5cbi8qXG4gKiBFYXNpbmcgRnVuY3Rpb25zIC0gaW5zcGlyZWQgZnJvbSBodHRwOi8vZ2l6bWEuY29tL2Vhc2luZy9cbiAqIG9ubHkgY29uc2lkZXJpbmcgdGhlIHQgdmFsdWUgZm9yIHRoZSByYW5nZSBbMCwgMV0gPT4gWzAsIDFdXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ncmUvMTY1MDI5NFxuICovXG5leHBvcnRzLmVhc2luZ0Z1bmN0aW9ucyA9IHtcbiAgLy8gbm8gZWFzaW5nLCBubyBhY2NlbGVyYXRpb25cbiAgbGluZWFyOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0XG4gIH0sXG4gIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgZWFzZUluUXVhZDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCAqIHRcbiAgfSxcbiAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgZWFzZU91dFF1YWQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgKiAoMiAtIHQpXG4gIH0sXG4gIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0IDwgLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdFxuICB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJbkN1YmljOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0ICogdCAqIHRcbiAgfSxcbiAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgZWFzZU91dEN1YmljOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiAoLS10KSAqIHQgKiB0ICsgMVxuICB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgPCAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDFcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5RdWFydDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdFxuICB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIDEgLSAoLS10KSAqIHQgKiB0ICogdFxuICB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgPCAuNSA/IDggKiB0ICogdCAqIHQgKiB0IDogMSAtIDggKiAoLS10KSAqIHQgKiB0ICogdFxuICB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJblF1aW50OiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0ICogdFxuICB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIDEgKyAoLS10KSAqIHQgKiB0ICogdCAqIHRcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gIGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0IDwgLjUgPyAxNiAqIHQgKiB0ICogdCAqIHQgKiB0IDogMSArIDE2ICogKC0tdCkgKiB0ICogdCAqIHQgKiB0XG4gIH1cbn07XG4iLCJcbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICBmdW5jdGlvbiBvbigpIHtcbiAgICBzZWxmLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG4iLCIvKiEgSGFtbWVyLkpTIC0gdjIuMC43IC0gMjAxNi0wNC0yMlxuICogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgSm9yaWsgVGFuZ2VsZGVyO1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlICovXG4oZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCwgZXhwb3J0TmFtZSwgdW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxudmFyIFZFTkRPUl9QUkVGSVhFUyA9IFsnJywgJ3dlYmtpdCcsICdNb3onLCAnTVMnLCAnbXMnLCAnbyddO1xudmFyIFRFU1RfRUxFTUVOVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG52YXIgVFlQRV9GVU5DVElPTiA9ICdmdW5jdGlvbic7XG5cbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgbm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogc2V0IGEgdGltZW91dCB3aXRoIGEgZ2l2ZW4gc2NvcGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHNldFRpbWVvdXRDb250ZXh0KGZuLCB0aW1lb3V0LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoYmluZEZuKGZuLCBjb250ZXh0KSwgdGltZW91dCk7XG59XG5cbi8qKlxuICogaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCB3ZSB3YW50IHRvIGV4ZWN1dGUgdGhlIGZuIG9uIGVhY2ggZW50cnlcbiAqIGlmIGl0IGFpbnQgYW4gYXJyYXkgd2UgZG9uJ3Qgd2FudCB0byBkbyBhIHRoaW5nLlxuICogdGhpcyBpcyB1c2VkIGJ5IGFsbCB0aGUgbWV0aG9kcyB0aGF0IGFjY2VwdCBhIHNpbmdsZSBhbmQgYXJyYXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp8QXJyYXl9IGFyZ1xuICogQHBhcmFtIHtTdHJpbmd9IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaW52b2tlQXJyYXlBcmcoYXJnLCBmbiwgY29udGV4dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgZWFjaChhcmcsIGNvbnRleHRbZm5dLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiB3YWxrIG9iamVjdHMgYW5kIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBpO1xuXG4gICAgaWYgKCFvYmopIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvYmouZm9yRWFjaCkge1xuICAgICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgb2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoaSkgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogd3JhcCBhIG1ldGhvZCB3aXRoIGEgZGVwcmVjYXRpb24gd2FybmluZyBhbmQgc3RhY2sgdHJhY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHdyYXBwaW5nIHRoZSBzdXBwbGllZCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZShtZXRob2QsIG5hbWUsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZGVwcmVjYXRpb25NZXNzYWdlID0gJ0RFUFJFQ0FURUQgTUVUSE9EOiAnICsgbmFtZSArICdcXG4nICsgbWVzc2FnZSArICcgQVQgXFxuJztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlID0gbmV3IEVycm9yKCdnZXQtc3RhY2stdHJhY2UnKTtcbiAgICAgICAgdmFyIHN0YWNrID0gZSAmJiBlLnN0YWNrID8gZS5zdGFjay5yZXBsYWNlKC9eW15cXChdKz9bXFxuJF0vZ20sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXHMrYXRcXHMrL2dtLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKC9nbSwgJ3thbm9ueW1vdXN9KClAJykgOiAnVW5rbm93biBTdGFjayBUcmFjZSc7XG5cbiAgICAgICAgdmFyIGxvZyA9IHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS53YXJuIHx8IHdpbmRvdy5jb25zb2xlLmxvZyk7XG4gICAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgICAgIGxvZy5jYWxsKHdpbmRvdy5jb25zb2xlLCBkZXByZWNhdGlvbk1lc3NhZ2UsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gey4uLk9iamVjdH0gb2JqZWN0c190b19hc3NpZ25cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICovXG52YXIgYXNzaWduO1xuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59IGVsc2Uge1xuICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG59XG5cbi8qKlxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlPWZhbHNlXVxuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG52YXIgZXh0ZW5kID0gZGVwcmVjYXRlKGZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMsIG1lcmdlKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICghbWVyZ2UgfHwgKG1lcmdlICYmIGRlc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGRlc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn0sICdleHRlbmQnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4vKipcbiAqIG1lcmdlIHRoZSB2YWx1ZXMgZnJvbSBzcmMgaW4gdGhlIGRlc3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBkZXN0IHdpbGwgbm90IGJlIG92ZXJ3cml0dGVuIGJ5IHNyY1xuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xudmFyIG1lcmdlID0gZGVwcmVjYXRlKGZ1bmN0aW9uIG1lcmdlKGRlc3QsIHNyYykge1xuICAgIHJldHVybiBleHRlbmQoZGVzdCwgc3JjLCB0cnVlKTtcbn0sICdtZXJnZScsICdVc2UgYGFzc2lnbmAuJyk7XG5cbi8qKlxuICogc2ltcGxlIGNsYXNzIGluaGVyaXRhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGlsZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZVxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxuICovXG5mdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGJhc2VQID0gYmFzZS5wcm90b3R5cGUsXG4gICAgICAgIGNoaWxkUDtcblxuICAgIGNoaWxkUCA9IGNoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZVApO1xuICAgIGNoaWxkUC5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICAgIGNoaWxkUC5fc3VwZXIgPSBiYXNlUDtcblxuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGFzc2lnbihjaGlsZFAsIHByb3BlcnRpZXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBzaW1wbGUgZnVuY3Rpb24gYmluZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGJpbmRGbihmbiwgY29udGV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBib3VuZEZuKCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIGxldCBhIGJvb2xlYW4gdmFsdWUgYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgbXVzdCByZXR1cm4gYSBib29sZWFuXG4gKiB0aGlzIGZpcnN0IGl0ZW0gaW4gYXJncyB3aWxsIGJlIHVzZWQgYXMgdGhlIGNvbnRleHRcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gdmFsXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJnc11cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBib29sT3JGbih2YWwsIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PSBUWVBFX0ZVTkNUSU9OKSB7XG4gICAgICAgIHJldHVybiB2YWwuYXBwbHkoYXJncyA/IGFyZ3NbMF0gfHwgdW5kZWZpbmVkIDogdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiB1c2UgdGhlIHZhbDIgd2hlbiB2YWwxIGlzIHVuZGVmaW5lZFxuICogQHBhcmFtIHsqfSB2YWwxXG4gKiBAcGFyYW0geyp9IHZhbDJcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBpZlVuZGVmaW5lZCh2YWwxLCB2YWwyKSB7XG4gICAgcmV0dXJuICh2YWwxID09PSB1bmRlZmluZWQpID8gdmFsMiA6IHZhbDE7XG59XG5cbi8qKlxuICogYWRkRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIHJlbW92ZUV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gKiBAbWV0aG9kIGhhc1BhcmVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBoYXNQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogc21hbGwgaW5kZXhPZiB3cmFwcGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHJldHVybnMge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGluU3RyKHN0ciwgZmluZCkge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihmaW5kKSA+IC0xO1xufVxuXG4vKipcbiAqIHNwbGl0IHN0cmluZyBvbiB3aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7QXJyYXl9IHdvcmRzXG4gKi9cbmZ1bmN0aW9uIHNwbGl0U3RyKHN0cikge1xuICAgIHJldHVybiBzdHIudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xufVxuXG4vKipcbiAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seUZpbGxcbiAqIEBwYXJhbSB7QXJyYXl9IHNyY1xuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmluZEJ5S2V5XVxuICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcbiAqL1xuZnVuY3Rpb24gaW5BcnJheShzcmMsIGZpbmQsIGZpbmRCeUtleSkge1xuICAgIGlmIChzcmMuaW5kZXhPZiAmJiAhZmluZEJ5S2V5KSB7XG4gICAgICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKChmaW5kQnlLZXkgJiYgc3JjW2ldW2ZpbmRCeUtleV0gPT0gZmluZCkgfHwgKCFmaW5kQnlLZXkgJiYgc3JjW2ldID09PSBmaW5kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59XG5cbi8qKlxuICogY29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gcmVhbCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqLCAwKTtcbn1cblxuLyoqXG4gKiB1bmlxdWUgYXJyYXkgd2l0aCBvYmplY3RzIGJhc2VkIG9uIGEga2V5IChsaWtlICdpZCcpIG9yIGp1c3QgYnkgdGhlIGFycmF5J3MgdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IHNyYyBbe2lkOjF9LHtpZDoyfSx7aWQ6MX1dXG4gKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvcnQ9RmFsc2VdXG4gKiBAcmV0dXJucyB7QXJyYXl9IFt7aWQ6MX0se2lkOjJ9XVxuICovXG5mdW5jdGlvbiB1bmlxdWVBcnJheShzcmMsIGtleSwgc29ydCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsID0ga2V5ID8gc3JjW2ldW2tleV0gOiBzcmNbaV07XG4gICAgICAgIGlmIChpbkFycmF5KHZhbHVlcywgdmFsKSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChzcmNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1tpXSA9IHZhbDtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIGlmIChzb3J0KSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KGZ1bmN0aW9uIHNvcnRVbmlxdWVBcnJheShhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFba2V5XSA+IGJba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbi8qKlxuICogZ2V0IHRoZSBwcmVmaXhlZCBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7U3RyaW5nfFVuZGVmaW5lZH0gcHJlZml4ZWRcbiAqL1xuZnVuY3Rpb24gcHJlZml4ZWQob2JqLCBwcm9wZXJ0eSkge1xuICAgIHZhciBwcmVmaXgsIHByb3A7XG4gICAgdmFyIGNhbWVsUHJvcCA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IFZFTkRPUl9QUkVGSVhFUy5sZW5ndGgpIHtcbiAgICAgICAgcHJlZml4ID0gVkVORE9SX1BSRUZJWEVTW2ldO1xuICAgICAgICBwcm9wID0gKHByZWZpeCkgPyBwcmVmaXggKyBjYW1lbFByb3AgOiBwcm9wZXJ0eTtcblxuICAgICAgICBpZiAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBnZXQgYSB1bmlxdWUgaWRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZUlkXG4gKi9cbnZhciBfdW5pcXVlSWQgPSAxO1xuZnVuY3Rpb24gdW5pcXVlSWQoKSB7XG4gICAgcmV0dXJuIF91bmlxdWVJZCsrO1xufVxuXG4vKipcbiAqIGdldCB0aGUgd2luZG93IG9iamVjdCBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RG9jdW1lbnRWaWV3fFdpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93Rm9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBlbGVtZW50O1xuICAgIHJldHVybiAoZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cgfHwgd2luZG93KTtcbn1cblxudmFyIE1PQklMRV9SRUdFWCA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWQvaTtcblxudmFyIFNVUFBPUlRfVE9VQ0ggPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KTtcbnZhciBTVVBQT1JUX1BPSU5URVJfRVZFTlRTID0gcHJlZml4ZWQod2luZG93LCAnUG9pbnRlckV2ZW50JykgIT09IHVuZGVmaW5lZDtcbnZhciBTVVBQT1JUX09OTFlfVE9VQ0ggPSBTVVBQT1JUX1RPVUNIICYmIE1PQklMRV9SRUdFWC50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG52YXIgSU5QVVRfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XG52YXIgSU5QVVRfVFlQRV9QRU4gPSAncGVuJztcbnZhciBJTlBVVF9UWVBFX01PVVNFID0gJ21vdXNlJztcbnZhciBJTlBVVF9UWVBFX0tJTkVDVCA9ICdraW5lY3QnO1xuXG52YXIgQ09NUFVURV9JTlRFUlZBTCA9IDI1O1xuXG52YXIgSU5QVVRfU1RBUlQgPSAxO1xudmFyIElOUFVUX01PVkUgPSAyO1xudmFyIElOUFVUX0VORCA9IDQ7XG52YXIgSU5QVVRfQ0FOQ0VMID0gODtcblxudmFyIERJUkVDVElPTl9OT05FID0gMTtcbnZhciBESVJFQ1RJT05fTEVGVCA9IDI7XG52YXIgRElSRUNUSU9OX1JJR0hUID0gNDtcbnZhciBESVJFQ1RJT05fVVAgPSA4O1xudmFyIERJUkVDVElPTl9ET1dOID0gMTY7XG5cbnZhciBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9MRUZUIHwgRElSRUNUSU9OX1JJR0hUO1xudmFyIERJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9VUCB8IERJUkVDVElPTl9ET1dOO1xudmFyIERJUkVDVElPTl9BTEwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTDtcblxudmFyIFBST1BTX1hZID0gWyd4JywgJ3knXTtcbnZhciBQUk9QU19DTElFTlRfWFkgPSBbJ2NsaWVudFgnLCAnY2xpZW50WSddO1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSW5wdXQobWFuYWdlciwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5lbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIHRoaXMudGFyZ2V0ID0gbWFuYWdlci5vcHRpb25zLmlucHV0VGFyZ2V0O1xuXG4gICAgLy8gc21hbGxlciB3cmFwcGVyIGFyb3VuZCB0aGUgaGFuZGxlciwgZm9yIHRoZSBzY29wZSBhbmQgdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIG1hbmFnZXIsXG4gICAgLy8gc28gd2hlbiBkaXNhYmxlZCB0aGUgaW5wdXQgZXZlbnRzIGFyZSBjb21wbGV0ZWx5IGJ5cGFzc2VkLlxuICAgIHRoaXMuZG9tSGFuZGxlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmIChib29sT3JGbihtYW5hZ2VyLm9wdGlvbnMuZW5hYmxlLCBbbWFuYWdlcl0pKSB7XG4gICAgICAgICAgICBzZWxmLmhhbmRsZXIoZXYpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdCgpO1xuXG59XG5cbklucHV0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzaG91bGQgaGFuZGxlIHRoZSBpbnB1dEV2ZW50IGRhdGEgYW5kIHRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHsgfSxcblxuICAgIC8qKlxuICAgICAqIGJpbmQgdGhlIGV2ZW50c1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmV2RWwgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZUYXJnZXQgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZXaW4gJiYgYWRkRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgdGhlIGV2ZW50c1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmV2RWwgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZUYXJnZXQgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIGNhbGxlZCBieSB0aGUgTWFuYWdlciBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRJbnN0YW5jZShtYW5hZ2VyKSB7XG4gICAgdmFyIFR5cGU7XG4gICAgdmFyIGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcblxuICAgIGlmIChpbnB1dENsYXNzKSB7XG4gICAgICAgIFR5cGUgPSBpbnB1dENsYXNzO1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9QT0lOVEVSX0VWRU5UUykge1xuICAgICAgICBUeXBlID0gUG9pbnRlckV2ZW50SW5wdXQ7XG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX09OTFlfVE9VQ0gpIHtcbiAgICAgICAgVHlwZSA9IFRvdWNoSW5wdXQ7XG4gICAgfSBlbHNlIGlmICghU1VQUE9SVF9UT1VDSCkge1xuICAgICAgICBUeXBlID0gTW91c2VJbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBUeXBlID0gVG91Y2hNb3VzZUlucHV0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IChUeXBlKShtYW5hZ2VyLCBpbnB1dEhhbmRsZXIpO1xufVxuXG4vKipcbiAqIGhhbmRsZSBpbnB1dCBldmVudHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGlucHV0SGFuZGxlcihtYW5hZ2VyLCBldmVudFR5cGUsIGlucHV0KSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoO1xuICAgIHZhciBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xuICAgIHZhciBpc0ZpcnN0ID0gKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMCkpO1xuICAgIHZhciBpc0ZpbmFsID0gKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIChwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMCkpO1xuXG4gICAgaW5wdXQuaXNGaXJzdCA9ICEhaXNGaXJzdDtcbiAgICBpbnB1dC5pc0ZpbmFsID0gISFpc0ZpbmFsO1xuXG4gICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgbWFuYWdlci5zZXNzaW9uID0ge307XG4gICAgfVxuXG4gICAgLy8gc291cmNlIGV2ZW50IGlzIHRoZSBub3JtYWxpemVkIHZhbHVlIG9mIHRoZSBkb21FdmVudHNcbiAgICAvLyBsaWtlICd0b3VjaHN0YXJ0LCBtb3VzZXVwLCBwb2ludGVyZG93bidcbiAgICBpbnB1dC5ldmVudFR5cGUgPSBldmVudFR5cGU7XG5cbiAgICAvLyBjb21wdXRlIHNjYWxlLCByb3RhdGlvbiBldGNcbiAgICBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KTtcblxuICAgIC8vIGVtaXQgc2VjcmV0IGV2ZW50XG4gICAgbWFuYWdlci5lbWl0KCdoYW1tZXIuaW5wdXQnLCBpbnB1dCk7XG5cbiAgICBtYW5hZ2VyLnJlY29nbml6ZShpbnB1dCk7XG4gICAgbWFuYWdlci5zZXNzaW9uLnByZXZJbnB1dCA9IGlucHV0O1xufVxuXG4vKipcbiAqIGV4dGVuZCB0aGUgZGF0YSB3aXRoIHNvbWUgdXNhYmxlIHByb3BlcnRpZXMgbGlrZSBzY2FsZSwgcm90YXRlLCB2ZWxvY2l0eSBldGNcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYW5hZ2VyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCkge1xuICAgIHZhciBzZXNzaW9uID0gbWFuYWdlci5zZXNzaW9uO1xuICAgIHZhciBwb2ludGVycyA9IGlucHV0LnBvaW50ZXJzO1xuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcblxuICAgIC8vIHN0b3JlIHRoZSBmaXJzdCBpbnB1dCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGFuZCBkaXJlY3Rpb25cbiAgICBpZiAoIXNlc3Npb24uZmlyc3RJbnB1dCkge1xuICAgICAgICBzZXNzaW9uLmZpcnN0SW5wdXQgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gICAgfVxuXG4gICAgLy8gdG8gY29tcHV0ZSBzY2FsZSBhbmQgcm90YXRpb24gd2UgbmVlZCB0byBzdG9yZSB0aGUgbXVsdGlwbGUgdG91Y2hlc1xuICAgIGlmIChwb2ludGVyc0xlbmd0aCA+IDEgJiYgIXNlc3Npb24uZmlyc3RNdWx0aXBsZSkge1xuICAgICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gICAgfSBlbHNlIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RJbnB1dCA9IHNlc3Npb24uZmlyc3RJbnB1dDtcbiAgICB2YXIgZmlyc3RNdWx0aXBsZSA9IHNlc3Npb24uZmlyc3RNdWx0aXBsZTtcbiAgICB2YXIgb2Zmc2V0Q2VudGVyID0gZmlyc3RNdWx0aXBsZSA/IGZpcnN0TXVsdGlwbGUuY2VudGVyIDogZmlyc3RJbnB1dC5jZW50ZXI7XG5cbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50ZXJzKTtcbiAgICBpbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICBpbnB1dC5kZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBmaXJzdElucHV0LnRpbWVTdGFtcDtcblxuICAgIGlucHV0LmFuZ2xlID0gZ2V0QW5nbGUob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICAgIGlucHV0LmRpc3RhbmNlID0gZ2V0RGlzdGFuY2Uob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuXG4gICAgY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpO1xuICAgIGlucHV0Lm9mZnNldERpcmVjdGlvbiA9IGdldERpcmVjdGlvbihpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG5cbiAgICB2YXIgb3ZlcmFsbFZlbG9jaXR5ID0gZ2V0VmVsb2NpdHkoaW5wdXQuZGVsdGFUaW1lLCBpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WCA9IG92ZXJhbGxWZWxvY2l0eS54O1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVkgPSBvdmVyYWxsVmVsb2NpdHkueTtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHkgPSAoYWJzKG92ZXJhbGxWZWxvY2l0eS54KSA+IGFicyhvdmVyYWxsVmVsb2NpdHkueSkpID8gb3ZlcmFsbFZlbG9jaXR5LnggOiBvdmVyYWxsVmVsb2NpdHkueTtcblxuICAgIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XG4gICAgaW5wdXQucm90YXRpb24gPSBmaXJzdE11bHRpcGxlID8gZ2V0Um90YXRpb24oZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMDtcblxuICAgIGlucHV0Lm1heFBvaW50ZXJzID0gIXNlc3Npb24ucHJldklucHV0ID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogKChpbnB1dC5wb2ludGVycy5sZW5ndGggPlxuICAgICAgICBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycykgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycyk7XG5cbiAgICBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpO1xuXG4gICAgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcbiAgICB2YXIgdGFyZ2V0ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIGlmIChoYXNQYXJlbnQoaW5wdXQuc3JjRXZlbnQudGFyZ2V0LCB0YXJnZXQpKSB7XG4gICAgICAgIHRhcmdldCA9IGlucHV0LnNyY0V2ZW50LnRhcmdldDtcbiAgICB9XG4gICAgaW5wdXQudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG4gICAgdmFyIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcblxuICAgIGlmIChpbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX1NUQVJUIHx8IHByZXZJbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX0VORCkge1xuICAgICAgICBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSA9IHtcbiAgICAgICAgICAgIHg6IHByZXZJbnB1dC5kZWx0YVggfHwgMCxcbiAgICAgICAgICAgIHk6IHByZXZJbnB1dC5kZWx0YVkgfHwgMFxuICAgICAgICB9O1xuXG4gICAgICAgIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBjZW50ZXIueCxcbiAgICAgICAgICAgIHk6IGNlbnRlci55XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaW5wdXQuZGVsdGFYID0gcHJldkRlbHRhLnggKyAoY2VudGVyLnggLSBvZmZzZXQueCk7XG4gICAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XG59XG5cbi8qKlxuICogdmVsb2NpdHkgaXMgY2FsY3VsYXRlZCBldmVyeSB4IG1zXG4gKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvblxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCkge1xuICAgIHZhciBsYXN0ID0gc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgfHwgaW5wdXQsXG4gICAgICAgIGRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGxhc3QudGltZVN0YW1wLFxuICAgICAgICB2ZWxvY2l0eSwgdmVsb2NpdHlYLCB2ZWxvY2l0eVksIGRpcmVjdGlvbjtcblxuICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfQ0FOQ0VMICYmIChkZWx0YVRpbWUgPiBDT01QVVRFX0lOVEVSVkFMIHx8IGxhc3QudmVsb2NpdHkgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdmFyIGRlbHRhWCA9IGlucHV0LmRlbHRhWCAtIGxhc3QuZGVsdGFYO1xuICAgICAgICB2YXIgZGVsdGFZID0gaW5wdXQuZGVsdGFZIC0gbGFzdC5kZWx0YVk7XG5cbiAgICAgICAgdmFyIHYgPSBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgdmVsb2NpdHlYID0gdi54O1xuICAgICAgICB2ZWxvY2l0eVkgPSB2Lnk7XG4gICAgICAgIHZlbG9jaXR5ID0gKGFicyh2LngpID4gYWJzKHYueSkpID8gdi54IDogdi55O1xuICAgICAgICBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oZGVsdGFYLCBkZWx0YVkpO1xuXG4gICAgICAgIHNlc3Npb24ubGFzdEludGVydmFsID0gaW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlIGxhdGVzdCB2ZWxvY2l0eSBpbmZvIGlmIGl0IGRvZXNuJ3Qgb3ZlcnRha2UgYSBtaW5pbXVtIHBlcmlvZFxuICAgICAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XG4gICAgICAgIHZlbG9jaXR5WCA9IGxhc3QudmVsb2NpdHlYO1xuICAgICAgICB2ZWxvY2l0eVkgPSBsYXN0LnZlbG9jaXR5WTtcbiAgICAgICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XG4gICAgfVxuXG4gICAgaW5wdXQudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICBpbnB1dC52ZWxvY2l0eVggPSB2ZWxvY2l0eVg7XG4gICAgaW5wdXQudmVsb2NpdHlZID0gdmVsb2NpdHlZO1xuICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbn1cblxuLyoqXG4gKiBjcmVhdGUgYSBzaW1wbGUgY2xvbmUgZnJvbSB0aGUgaW5wdXQgdXNlZCBmb3Igc3RvcmFnZSBvZiBmaXJzdElucHV0IGFuZCBmaXJzdE11bHRpcGxlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqIEByZXR1cm5zIHtPYmplY3R9IGNsb25lZElucHV0RGF0YVxuICovXG5mdW5jdGlvbiBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCkge1xuICAgIC8vIG1ha2UgYSBzaW1wbGUgY29weSBvZiB0aGUgcG9pbnRlcnMgYmVjYXVzZSB3ZSB3aWxsIGdldCBhIHJlZmVyZW5jZSBpZiB3ZSBkb24ndFxuICAgIC8vIHdlIG9ubHkgbmVlZCBjbGllbnRYWSBmb3IgdGhlIGNhbGN1bGF0aW9uc1xuICAgIHZhciBwb2ludGVycyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgICBwb2ludGVyc1tpXSA9IHtcbiAgICAgICAgICAgIGNsaWVudFg6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFgpLFxuICAgICAgICAgICAgY2xpZW50WTogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WSlcbiAgICAgICAgfTtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHRpbWVTdGFtcDogbm93KCksXG4gICAgICAgIHBvaW50ZXJzOiBwb2ludGVycyxcbiAgICAgICAgY2VudGVyOiBnZXRDZW50ZXIocG9pbnRlcnMpLFxuICAgICAgICBkZWx0YVg6IGlucHV0LmRlbHRhWCxcbiAgICAgICAgZGVsdGFZOiBpbnB1dC5kZWx0YVlcbiAgICB9O1xufVxuXG4vKipcbiAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldENlbnRlcihwb2ludGVycykge1xuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcblxuICAgIC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRYKSxcbiAgICAgICAgICAgIHk6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFkpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHggPSAwLCB5ID0gMCwgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBwb2ludGVyc0xlbmd0aCkge1xuICAgICAgICB4ICs9IHBvaW50ZXJzW2ldLmNsaWVudFg7XG4gICAgICAgIHkgKz0gcG9pbnRlcnNbaV0uY2xpZW50WTtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJvdW5kKHggLyBwb2ludGVyc0xlbmd0aCksXG4gICAgICAgIHk6IHJvdW5kKHkgLyBwb2ludGVyc0xlbmd0aClcbiAgICB9O1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICovXG5mdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4IC8gZGVsdGFUaW1lIHx8IDAsXG4gICAgICAgIHk6IHkgLyBkZWx0YVRpbWUgfHwgMFxuICAgIH07XG59XG5cbi8qKlxuICogZ2V0IHRoZSBkaXJlY3Rpb24gYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge051bWJlcn0gZGlyZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldERpcmVjdGlvbih4LCB5KSB7XG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIERJUkVDVElPTl9OT05FO1xuICAgIH1cblxuICAgIGlmIChhYnMoeCkgPj0gYWJzKHkpKSB7XG4gICAgICAgIHJldHVybiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgIH1cbiAgICByZXR1cm4geSA8IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtPYmplY3R9IHAxIHt4LCB5fVxuICogQHBhcmFtIHtPYmplY3R9IHAyIHt4LCB5fVxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICovXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cbiAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXSxcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoKHggKiB4KSArICh5ICogeSkpO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMVxuICogQHBhcmFtIHtPYmplY3R9IHAyXG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbmZ1bmN0aW9uIGdldEFuZ2xlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSArIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHNjYWxlIGZhY3RvciBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogbm8gc2NhbGUgaXMgMSwgYW5kIGdvZXMgZG93biB0byAwIHdoZW4gcGluY2hlZCB0b2dldGhlciwgYW5kIGJpZ2dlciB3aGVuIHBpbmNoZWQgb3V0XG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gKi9cbmZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0sIFBST1BTX0NMSUVOVF9YWSkgLyBnZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG5cbnZhciBNT1VTRV9JTlBVVF9NQVAgPSB7XG4gICAgbW91c2Vkb3duOiBJTlBVVF9TVEFSVCxcbiAgICBtb3VzZW1vdmU6IElOUFVUX01PVkUsXG4gICAgbW91c2V1cDogSU5QVVRfRU5EXG59O1xuXG52YXIgTU9VU0VfRUxFTUVOVF9FVkVOVFMgPSAnbW91c2Vkb3duJztcbnZhciBNT1VTRV9XSU5ET1dfRVZFTlRTID0gJ21vdXNlbW92ZSBtb3VzZXVwJztcblxuLyoqXG4gKiBNb3VzZSBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gTW91c2VJbnB1dCgpIHtcbiAgICB0aGlzLmV2RWwgPSBNT1VTRV9FTEVNRU5UX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gTU9VU0VfV0lORE9XX0VWRU5UUztcblxuICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTUVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBNT1VTRV9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xuICAgICAgICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW91c2UgbXVzdCBiZSBkb3duXG4gICAgICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbnZhciBQT0lOVEVSX0lOUFVUX01BUCA9IHtcbiAgICBwb2ludGVyZG93bjogSU5QVVRfU1RBUlQsXG4gICAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXG4gICAgcG9pbnRlcnVwOiBJTlBVVF9FTkQsXG4gICAgcG9pbnRlcmNhbmNlbDogSU5QVVRfQ0FOQ0VMLFxuICAgIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxufTtcblxuLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cbnZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xuICAgIDI6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgMzogSU5QVVRfVFlQRV9QRU4sXG4gICAgNDogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICA1OiBJTlBVVF9UWVBFX0tJTkVDVCAvLyBzZWUgaHR0cHM6Ly90d2l0dGVyLmNvbS9qYWNvYnJvc3NpL3N0YXR1cy80ODA1OTY0Mzg0ODk4OTA4MTZcbn07XG5cbnZhciBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ3BvaW50ZXJkb3duJztcbnZhciBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAncG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnO1xuXG4vLyBJRTEwIGhhcyBwcmVmaXhlZCBzdXBwb3J0LCBhbmQgY2FzZS1zZW5zaXRpdmVcbmlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiYgIXdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xuICAgIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdNU1BvaW50ZXJNb3ZlIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG59XG5cbi8qKlxuICogUG9pbnRlciBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gUG9pbnRlckV2ZW50SW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gUE9JTlRFUl9XSU5ET1dfRVZFTlRTO1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuc3RvcmUgPSAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdKTtcbn1cblxuaW5oZXJpdChQb2ludGVyRXZlbnRJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gUEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIHZhciByZW1vdmVQb2ludGVyID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBQT0lOVEVSX0lOUFVUX01BUFtldmVudFR5cGVOb3JtYWxpemVkXTtcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XG5cbiAgICAgICAgdmFyIGlzVG91Y2ggPSAocG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCk7XG5cbiAgICAgICAgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgdmFyIHN0b3JlSW5kZXggPSBpbkFycmF5KHN0b3JlLCBldi5wb2ludGVySWQsICdwb2ludGVySWQnKTtcblxuICAgICAgICAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAoZXYuYnV0dG9uID09PSAwIHx8IGlzVG91Y2gpKSB7XG4gICAgICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgICBzdG9yZUluZGV4ID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgcmVtb3ZlUG9pbnRlciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpdCBub3QgZm91bmQsIHNvIHRoZSBwb2ludGVyIGhhc24ndCBiZWVuIGRvd24gKHNvIGl0J3MgcHJvYmFibHkgYSBob3ZlcilcbiAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgICBzdG9yZVtzdG9yZUluZGV4XSA9IGV2O1xuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiBzdG9yZSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmVtb3ZlUG9pbnRlcikge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlXG4gICAgICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxudmFyIFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQnO1xudmFyIFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBUb3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gU2luZ2xlVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTO1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChTaW5nbGVUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuICAgICAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuXG4gICAgICAgIC8vIHdoZW4gZG9uZSwgcmVzZXQgdGhlIHN0YXJ0ZWQgc3RhdGVcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiB0b3VjaGVzWzBdLmxlbmd0aCAtIHRvdWNoZXNbMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVTaW5nbGVUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbCA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2FsbCwgY2hhbmdlZF07XG59XG5cbnZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxudmFyIFRPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgdGhpcy50YXJnZXRJZHMgPSB7fTtcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNVEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciB0eXBlID0gVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG4gICAgICAgIGlmICghdG91Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHRoaXMge1RvdWNoSW5wdXR9XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gKi9cbmZ1bmN0aW9uIGdldFRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICB2YXIgYWxsVG91Y2hlcyA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzO1xuXG4gICAgLy8gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZSB0b3VjaCwgdGhlIHByb2Nlc3MgY2FuIGJlIHNpbXBsaWZpZWRcbiAgICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRhcmdldElkc1thbGxUb3VjaGVzWzBdLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFthbGxUb3VjaGVzLCBhbGxUb3VjaGVzXTtcbiAgICB9XG5cbiAgICB2YXIgaSxcbiAgICAgICAgdGFyZ2V0VG91Y2hlcyxcbiAgICAgICAgY2hhbmdlZFRvdWNoZXMgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKSxcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMgPSBbXSxcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG5cbiAgICAvLyBnZXQgdGFyZ2V0IHRvdWNoZXMgZnJvbSB0b3VjaGVzXG4gICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgIHJldHVybiBoYXNQYXJlbnQodG91Y2gudGFyZ2V0LCB0YXJnZXQpO1xuICAgIH0pO1xuXG4gICAgLy8gY29sbGVjdCB0b3VjaGVzXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgY2hhbmdlZCB0b3VjaGVzIHRvIG9ubHkgY29udGFpbiB0b3VjaGVzIHRoYXQgZXhpc3QgaW4gdGhlIGNvbGxlY3RlZCB0YXJnZXQgaWRzXG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhbnVwIHJlbW92ZWQgdG91Y2hlc1xuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gICAgICAgIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSxcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXNcbiAgICBdO1xufVxuXG4vKipcbiAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICpcbiAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG52YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG52YXIgREVEVVBfRElTVEFOQ0UgPSAyNTtcblxuZnVuY3Rpb24gVG91Y2hNb3VzZUlucHV0KCkge1xuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgaGFuZGxlciA9IGJpbmRGbih0aGlzLmhhbmRsZXIsIHRoaXMpO1xuICAgIHRoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2VJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuXG4gICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBudWxsO1xuICAgIHRoaXMubGFzdFRvdWNoZXMgPSBbXTtcbn1cblxuaW5oZXJpdChUb3VjaE1vdXNlSW5wdXQsIElucHV0LCB7XG4gICAgLyoqXG4gICAgICogaGFuZGxlIG1vdXNlIGFuZCB0b3VjaCBldmVudHNcbiAgICAgKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dEV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRNRWhhbmRsZXIobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKSB7XG4gICAgICAgIHZhciBpc1RvdWNoID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIKSxcbiAgICAgICAgICAgIGlzTW91c2UgPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfTU9VU0UpO1xuXG4gICAgICAgIGlmIChpc01vdXNlICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aGVuIHdlJ3JlIGluIGEgdG91Y2ggZXZlbnQsIHJlY29yZCB0b3VjaGVzIHRvICBkZS1kdXBlIHN5bnRoZXRpYyBtb3VzZSBldmVudFxuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgcmVjb3JkVG91Y2hlcy5jYWxsKHRoaXMsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiBpc1N5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgaW5wdXREYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayhtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudG91Y2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1vdXNlLmRlc3Ryb3koKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gcmVjb3JkVG91Y2hlcyhldmVudFR5cGUsIGV2ZW50RGF0YSkge1xuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgICB0aGlzLnByaW1hcnlUb3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF0uaWRlbnRpZmllcjtcbiAgICAgICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRMYXN0VG91Y2goZXZlbnREYXRhKSB7XG4gICAgdmFyIHRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXTtcblxuICAgIGlmICh0b3VjaC5pZGVudGlmaWVyID09PSB0aGlzLnByaW1hcnlUb3VjaCkge1xuICAgICAgICB2YXIgbGFzdFRvdWNoID0ge3g6IHRvdWNoLmNsaWVudFgsIHk6IHRvdWNoLmNsaWVudFl9O1xuICAgICAgICB0aGlzLmxhc3RUb3VjaGVzLnB1c2gobGFzdFRvdWNoKTtcbiAgICAgICAgdmFyIGx0cyA9IHRoaXMubGFzdFRvdWNoZXM7XG4gICAgICAgIHZhciByZW1vdmVMYXN0VG91Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpID0gbHRzLmluZGV4T2YobGFzdFRvdWNoKTtcbiAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZXRUaW1lb3V0KHJlbW92ZUxhc3RUb3VjaCwgREVEVVBfVElNRU9VVCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1N5bnRoZXRpY0V2ZW50KGV2ZW50RGF0YSkge1xuICAgIHZhciB4ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFgsIHkgPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFzdFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmxhc3RUb3VjaGVzW2ldO1xuICAgICAgICB2YXIgZHggPSBNYXRoLmFicyh4IC0gdC54KSwgZHkgPSBNYXRoLmFicyh5IC0gdC55KTtcbiAgICAgICAgaWYgKGR4IDw9IERFRFVQX0RJU1RBTkNFICYmIGR5IDw9IERFRFVQX0RJU1RBTkNFKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gPSBwcmVmaXhlZChURVNUX0VMRU1FTlQuc3R5bGUsICd0b3VjaEFjdGlvbicpO1xudmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcblxuLy8gbWFnaWNhbCB0b3VjaEFjdGlvbiB2YWx1ZVxudmFyIFRPVUNIX0FDVElPTl9DT01QVVRFID0gJ2NvbXB1dGUnO1xudmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xudmFyIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04gPSAnbWFuaXB1bGF0aW9uJzsgLy8gbm90IGltcGxlbWVudGVkXG52YXIgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xudmFyIFRPVUNIX0FDVElPTl9NQVAgPSBnZXRUb3VjaEFjdGlvblByb3BzKCk7XG5cbi8qKlxuICogVG91Y2ggQWN0aW9uXG4gKiBzZXRzIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBvciB1c2VzIHRoZSBqcyBhbHRlcm5hdGl2ZVxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBUb3VjaEFjdGlvbihtYW5hZ2VyLCB2YWx1ZSkge1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5zZXQodmFsdWUpO1xufVxuXG5Ub3VjaEFjdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZSBvbiB0aGUgZWxlbWVudCBvciBlbmFibGUgdGhlIHBvbHlmaWxsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBmaW5kIG91dCB0aGUgdG91Y2gtYWN0aW9uIGJ5IHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAgICBpZiAodmFsdWUgPT0gVE9VQ0hfQUNUSU9OX0NPTVBVVEUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jb21wdXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTiAmJiB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZSAmJiBUT1VDSF9BQ1RJT05fTUFQW3ZhbHVlXSkge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGVbUFJFRklYRURfVE9VQ0hfQUNUSU9OXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldCh0aGlzLm1hbmFnZXIub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvbXB1dGUgdGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlY29nbml6ZXIncyBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgY29tcHV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgIGVhY2godGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLCBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLmNvbmNhdChyZWNvZ25pemVyLmdldFRvdWNoQWN0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMuam9pbignICcpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIG9uIGVhY2ggaW5wdXQgY3ljbGUgYW5kIHByb3ZpZGVzIHRoZSBwcmV2ZW50aW5nIG9mIHRoZSBicm93c2VyIGJlaGF2aW9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHRzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0Lm9mZnNldERpcmVjdGlvbjtcblxuICAgICAgICAvLyBpZiB0aGUgdG91Y2ggYWN0aW9uIGRpZCBwcmV2ZW50ZWQgb25jZSB0aGlzIHNlc3Npb25cbiAgICAgICAgaWYgKHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCkge1xuICAgICAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICB2YXIgaGFzTm9uZSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1ldO1xuICAgICAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9YXTtcblxuICAgICAgICBpZiAoaGFzTm9uZSkge1xuICAgICAgICAgICAgLy9kbyBub3QgcHJldmVudCBkZWZhdWx0cyBpZiB0aGlzIGlzIGEgdGFwIGdlc3R1cmVcblxuICAgICAgICAgICAgdmFyIGlzVGFwUG9pbnRlciA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIHZhciBpc1RhcE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCAyO1xuICAgICAgICAgICAgdmFyIGlzVGFwVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgMjUwO1xuXG4gICAgICAgICAgICBpZiAoaXNUYXBQb2ludGVyICYmIGlzVGFwTW92ZW1lbnQgJiYgaXNUYXBUb3VjaFRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgICAgICAvLyBgcGFuLXggcGFuLXlgIG1lYW5zIGJyb3dzZXIgaGFuZGxlcyBhbGwgc2Nyb2xsaW5nL3Bhbm5pbmcsIGRvIG5vdCBwcmV2ZW50XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTm9uZSB8fFxuICAgICAgICAgICAgKGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHx8XG4gICAgICAgICAgICAoaGFzUGFuWCAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50U3JjKHNyY0V2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICAgKi9cbiAgICBwcmV2ZW50U3JjOiBmdW5jdGlvbihzcmNFdmVudCkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uc1xuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgICAvLyBub25lXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcblxuICAgIC8vIGlmIGJvdGggcGFuLXggYW5kIHBhbi15IGFyZSBzZXQgKGRpZmZlcmVudCByZWNvZ25pemVyc1xuICAgIC8vIGZvciBkaWZmZXJlbnQgZGlyZWN0aW9ucywgZS5nLiBob3Jpem9udGFsIHBhbiBidXQgdmVydGljYWwgc3dpcGU/KVxuICAgIC8vIHdlIG5lZWQgbm9uZSAoYXMgb3RoZXJ3aXNlIHdpdGggcGFuLXggcGFuLXkgY29tYmluZWQgbm9uZSBvZiB0aGVzZVxuICAgIC8vIHJlY29nbml6ZXJzIHdpbGwgd29yaywgc2luY2UgdGhlIGJyb3dzZXIgd291bGQgaGFuZGxlIGFsbCBwYW5uaW5nXG4gICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgLy8gcGFuLXggT1IgcGFuLXlcbiAgICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XG4gICAgICAgIHJldHVybiBoYXNQYW5YID8gVE9VQ0hfQUNUSU9OX1BBTl9YIDogVE9VQ0hfQUNUSU9OX1BBTl9ZO1xuICAgIH1cblxuICAgIC8vIG1hbmlwdWxhdGlvblxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OKSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTjtcbiAgICB9XG5cbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XG59XG5cbmZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uUHJvcHMoKSB7XG4gICAgaWYgKCFOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHRvdWNoTWFwID0ge307XG4gICAgdmFyIGNzc1N1cHBvcnRzID0gd2luZG93LkNTUyAmJiB3aW5kb3cuQ1NTLnN1cHBvcnRzO1xuICAgIFsnYXV0bycsICdtYW5pcHVsYXRpb24nLCAncGFuLXknLCAncGFuLXgnLCAncGFuLXggcGFuLXknLCAnbm9uZSddLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XG5cbiAgICAgICAgLy8gSWYgY3NzLnN1cHBvcnRzIGlzIG5vdCBzdXBwb3J0ZWQgYnV0IHRoZXJlIGlzIG5hdGl2ZSB0b3VjaC1hY3Rpb24gYXNzdW1lIGl0IHN1cHBvcnRzXG4gICAgICAgIC8vIGFsbCB2YWx1ZXMuIFRoaXMgaXMgdGhlIGNhc2UgZm9yIElFIDEwIGFuZCAxMS5cbiAgICAgICAgdG91Y2hNYXBbdmFsXSA9IGNzc1N1cHBvcnRzID8gd2luZG93LkNTUy5zdXBwb3J0cygndG91Y2gtYWN0aW9uJywgdmFsKSA6IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvdWNoTWFwO1xufVxuXG4vKipcbiAqIFJlY29nbml6ZXIgZmxvdyBleHBsYWluZWQ7ICpcbiAqIEFsbCByZWNvZ25pemVycyBoYXZlIHRoZSBpbml0aWFsIHN0YXRlIG9mIFBPU1NJQkxFIHdoZW4gYSBpbnB1dCBzZXNzaW9uIHN0YXJ0cy5cbiAqIFRoZSBkZWZpbml0aW9uIG9mIGEgaW5wdXQgc2Vzc2lvbiBpcyBmcm9tIHRoZSBmaXJzdCBpbnB1dCB1bnRpbCB0aGUgbGFzdCBpbnB1dCwgd2l0aCBhbGwgaXQncyBtb3ZlbWVudCBpbiBpdC4gKlxuICogRXhhbXBsZSBzZXNzaW9uIGZvciBtb3VzZS1pbnB1dDogbW91c2Vkb3duIC0+IG1vdXNlbW92ZSAtPiBtb3VzZXVwXG4gKlxuICogT24gZWFjaCByZWNvZ25pemluZyBjeWNsZSAoc2VlIE1hbmFnZXIucmVjb2duaXplKSB0aGUgLnJlY29nbml6ZSgpIG1ldGhvZCBpcyBleGVjdXRlZFxuICogd2hpY2ggZGV0ZXJtaW5lcyB3aXRoIHN0YXRlIGl0IHNob3VsZCBiZS5cbiAqXG4gKiBJZiB0aGUgcmVjb2duaXplciBoYXMgdGhlIHN0YXRlIEZBSUxFRCwgQ0FOQ0VMTEVEIG9yIFJFQ09HTklaRUQgKGVxdWFscyBFTkRFRCksIGl0IGlzIHJlc2V0IHRvXG4gKiBQT1NTSUJMRSB0byBnaXZlIGl0IGFub3RoZXIgY2hhbmdlIG9uIHRoZSBuZXh0IGN5Y2xlLlxuICpcbiAqICAgICAgICAgICAgICAgUG9zc2libGVcbiAqICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICArLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICArLS0tLS0rLS0tLS0rICAgICAgICAgICAgICAgfFxuICogICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgfFxuICogICBGYWlsZWQgICAgICBDYW5jZWxsZWQgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tKy0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICBSZWNvZ25pemVkICAgICAgIEJlZ2FuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoYW5nZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmRlZC9SZWNvZ25pemVkXG4gKi9cbnZhciBTVEFURV9QT1NTSUJMRSA9IDE7XG52YXIgU1RBVEVfQkVHQU4gPSAyO1xudmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xudmFyIFNUQVRFX0VOREVEID0gODtcbnZhciBTVEFURV9SRUNPR05JWkVEID0gU1RBVEVfRU5ERUQ7XG52YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XG52YXIgU1RBVEVfRkFJTEVEID0gMzI7XG5cbi8qKlxuICogUmVjb2duaXplclxuICogRXZlcnkgcmVjb2duaXplciBuZWVkcyB0byBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIHRoaXMuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgdGhpcy5pZCA9IHVuaXF1ZUlkKCk7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuXG4gICAgLy8gZGVmYXVsdCBpcyBlbmFibGUgdHJ1ZVxuICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSBpZlVuZGVmaW5lZCh0aGlzLm9wdGlvbnMuZW5hYmxlLCB0cnVlKTtcblxuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcblxuICAgIHRoaXMuc2ltdWx0YW5lb3VzID0ge307XG4gICAgdGhpcy5yZXF1aXJlRmFpbCA9IFtdO1xufVxuXG5SZWNvZ25pemVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgZGVmYXVsdHM6IHt9LFxuXG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1JlY29nbml6ZXJ9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGFsc28gdXBkYXRlIHRoZSB0b3VjaEFjdGlvbiwgaW4gY2FzZSBzb21ldGhpbmcgY2hhbmdlZCBhYm91dCB0aGUgZGlyZWN0aW9ucy9lbmFibGVkIHN0YXRlXG4gICAgICAgIHRoaXMubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgcmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpbXVsdGFuZW91cyA9IHRoaXMuc2ltdWx0YW5lb3VzO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGlmICghc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0pIHtcbiAgICAgICAgICAgIHNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdID0gb3RoZXJSZWNvZ25pemVyO1xuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlY29nbml6ZVdpdGgodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHNpbXVsdGFuZW91cyBsaW5rLiBpdCBkb2VzbnQgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZWNvZ25pemVyIGNhbiBvbmx5IHJ1biB3aGVuIGFuIG90aGVyIGlzIGZhaWxpbmdcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgcmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVxdWlyZUZhaWwgPSB0aGlzLnJlcXVpcmVGYWlsO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGlmIChpbkFycmF5KHJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpID09PSAtMSkge1xuICAgICAgICAgICAgcmVxdWlyZUZhaWwucHVzaChvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIGRyb3BSZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIHZhciBpbmRleCA9IGluQXJyYXkodGhpcy5yZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGFzIHJlcXVpcmUgZmFpbHVyZXMgYm9vbGVhblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1JlcXVpcmVGYWlsdXJlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGlmIHRoZSByZWNvZ25pemVyIGNhbiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFlvdSBzaG91bGQgdXNlIGB0cnlFbWl0YCBpbnN0ZWFkIG9mIGBlbWl0YCBkaXJlY3RseSB0byBjaGVja1xuICAgICAqIHRoYXQgYWxsIHRoZSBuZWVkZWQgcmVjb2duaXplcnMgaGFzIGZhaWxlZCBiZWZvcmUgZW1pdHRpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGYubWFuYWdlci5lbWl0KGV2ZW50LCBpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAncGFuc3RhcnQnIGFuZCAncGFubW92ZSdcbiAgICAgICAgaWYgKHN0YXRlIDwgU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50KTsgLy8gc2ltcGxlICdldmVudE5hbWUnIGV2ZW50c1xuXG4gICAgICAgIGlmIChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpIHsgLy8gYWRkaXRpb25hbCBldmVudChwYW5sZWZ0LCBwYW5yaWdodCwgcGluY2hpbiwgcGluY2hvdXQuLi4pXG4gICAgICAgICAgICBlbWl0KGlucHV0LmFkZGl0aW9uYWxFdmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYW5lbmQgYW5kIHBhbmNhbmNlbFxuICAgICAgICBpZiAoc3RhdGUgPj0gU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IGFsbCB0aGUgcmVxdWlyZSBmYWlsdXJlIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQsXG4gICAgICogaWYgdHJ1ZSwgaXQgZW1pdHMgYSBnZXN0dXJlIGV2ZW50LFxuICAgICAqIG90aGVyd2lzZSwgc2V0dXAgdGhlIHN0YXRlIHRvIEZBSUxFRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cbiAgICB0cnlFbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5jYW5FbWl0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGl0J3MgZmFpbGluZyBhbnl3YXlcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FuIHdlIGVtaXQ/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuRW1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5yZXF1aXJlRmFpbFtpXS5zdGF0ZSAmIChTVEFURV9GQUlMRUQgfCBTVEFURV9QT1NTSUJMRSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIHJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbihpbnB1dERhdGEpIHtcbiAgICAgICAgLy8gbWFrZSBhIG5ldyBjb3B5IG9mIHRoZSBpbnB1dERhdGFcbiAgICAgICAgLy8gc28gd2UgY2FuIGNoYW5nZSB0aGUgaW5wdXREYXRhIHdpdGhvdXQgbWVzc2luZyB1cCB0aGUgb3RoZXIgcmVjb2duaXplcnNcbiAgICAgICAgdmFyIGlucHV0RGF0YUNsb25lID0gYXNzaWduKHt9LCBpbnB1dERhdGEpO1xuXG4gICAgICAgIC8vIGlzIGlzIGVuYWJsZWQgYW5kIGFsbG93IHJlY29nbml6aW5nP1xuICAgICAgICBpZiAoIWJvb2xPckZuKHRoaXMub3B0aW9ucy5lbmFibGUsIFt0aGlzLCBpbnB1dERhdGFDbG9uZV0pKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgd2hlbiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnByb2Nlc3MoaW5wdXREYXRhQ2xvbmUpO1xuXG4gICAgICAgIC8vIHRoZSByZWNvZ25pemVyIGhhcyByZWNvZ25pemVkIGEgZ2VzdHVyZVxuICAgICAgICAvLyBzbyB0cmlnZ2VyIGFuIGV2ZW50XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEIHwgU1RBVEVfQ0FOQ0VMTEVEKSkge1xuICAgICAgICAgICAgdGhpcy50cnlFbWl0KGlucHV0RGF0YUNsb25lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHN0YXRlIG9mIHRoZSByZWNvZ25pemVyXG4gICAgICogdGhlIGFjdHVhbCByZWNvZ25pemluZyBoYXBwZW5zIGluIHRoaXMgbWV0aG9kXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICogQHJldHVybnMge0NvbnN0fSBTVEFURVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0RGF0YSkgeyB9LCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgcHJlZmVycmVkIHRvdWNoLWFjdGlvblxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHsgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGxlZCB3aGVuIHRoZSBnZXN0dXJlIGlzbid0IGFsbG93ZWQgdG8gcmVjb2duaXplXG4gICAgICogbGlrZSB3aGVuIGFub3RoZXIgaXMgYmVpbmcgcmVjb2duaXplZCBvciBpdCBpcyBkaXNhYmxlZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkgeyB9XG59O1xuXG4vKipcbiAqIGdldCBhIHVzYWJsZSBzdHJpbmcsIHVzZWQgYXMgZXZlbnQgcG9zdGZpeFxuICogQHBhcmFtIHtDb25zdH0gc3RhdGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0YXRlXG4gKi9cbmZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlICYgU1RBVEVfQ0FOQ0VMTEVEKSB7XG4gICAgICAgIHJldHVybiAnY2FuY2VsJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9DSEFOR0VEKSB7XG4gICAgICAgIHJldHVybiAnbW92ZSc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0JFR0FOKSB7XG4gICAgICAgIHJldHVybiAnc3RhcnQnO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogZGlyZWN0aW9uIGNvbnMgdG8gc3RyaW5nXG4gKiBAcGFyYW0ge0NvbnN0fSBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGRpcmVjdGlvblN0cihkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9ET1dOKSB7XG4gICAgICAgIHJldHVybiAnZG93bic7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQKSB7XG4gICAgICAgIHJldHVybiAndXAnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9MRUZUKSB7XG4gICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1JJR0hUKSB7XG4gICAgICAgIHJldHVybiAncmlnaHQnO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogZ2V0IGEgcmVjb2duaXplciBieSBuYW1lIGlmIGl0IGlzIGJvdW5kIHRvIGEgbWFuYWdlclxuICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gb3RoZXJSZWNvZ25pemVyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAqIEByZXR1cm5zIHtSZWNvZ25pemVyfVxuICovXG5mdW5jdGlvbiBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgcmVjb2duaXplcikge1xuICAgIHZhciBtYW5hZ2VyID0gcmVjb2duaXplci5tYW5hZ2VyO1xuICAgIGlmIChtYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiBtYW5hZ2VyLmdldChvdGhlclJlY29nbml6ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xufVxuXG4vKipcbiAqIFRoaXMgcmVjb2duaXplciBpcyBqdXN0IHVzZWQgYXMgYSBiYXNlIGZvciB0aGUgc2ltcGxlIGF0dHJpYnV0ZSByZWNvZ25pemVycy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBBdHRyUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoQXR0clJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gY2hlY2sgaWYgaXQgdGhlIHJlY29nbml6ZXIgcmVjZWl2ZXMgdmFsaWQgaW5wdXQsIGxpa2UgaW5wdXQuZGlzdGFuY2UgPiAxMC5cbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmVjb2duaXplZFxuICAgICAqL1xuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9uUG9pbnRlcnMgPSB0aGlzLm9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHJldHVybiBvcHRpb25Qb2ludGVycyA9PT0gMCB8fCBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvblBvaW50ZXJzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBpbnB1dCBhbmQgcmV0dXJuIHRoZSBzdGF0ZSBmb3IgdGhlIHJlY29nbml6ZXJcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Kn0gU3RhdGVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB2YXIgZXZlbnRUeXBlID0gaW5wdXQuZXZlbnRUeXBlO1xuXG4gICAgICAgIHZhciBpc1JlY29nbml6ZWQgPSBzdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQpO1xuICAgICAgICB2YXIgaXNWYWxpZCA9IHRoaXMuYXR0clRlc3QoaW5wdXQpO1xuXG4gICAgICAgIC8vIG9uIGNhbmNlbCBpbnB1dCBhbmQgd2UndmUgcmVjb2duaXplZCBiZWZvcmUsIHJldHVybiBTVEFURV9DQU5DRUxMRURcbiAgICAgICAgaWYgKGlzUmVjb2duaXplZCAmJiAoZXZlbnRUeXBlICYgSU5QVVRfQ0FOQ0VMIHx8ICFpc1ZhbGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0FOQ0VMTEVEO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmVjb2duaXplZCB8fCBpc1ZhbGlkKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfRU5ERUQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEoc3RhdGUgJiBTVEFURV9CRUdBTikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DSEFOR0VEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUGFuXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBhbmQgbW92ZWQgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBQYW5SZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLnBYID0gbnVsbDtcbiAgICB0aGlzLnBZID0gbnVsbDtcbn1cblxuaW5oZXJpdChQYW5SZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGFuUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncGFuJyxcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0FMTFxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1kpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3Rpb25zO1xuICAgIH0sXG5cbiAgICBkaXJlY3Rpb25UZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIGhhc01vdmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gaW5wdXQuZGlzdGFuY2U7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XG4gICAgICAgIHZhciB4ID0gaW5wdXQuZGVsdGFYO1xuICAgICAgICB2YXIgeSA9IGlucHV0LmRlbHRhWTtcblxuICAgICAgICAvLyBsb2NrIHRvIGF4aXM/XG4gICAgICAgIGlmICghKGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeCA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh4IDwgMCkgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHggIT0gdGhpcy5wWDtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh5ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHkgPCAwKSA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICAgICAgICAgICAgICAgIGhhc01vdmVkID0geSAhPSB0aGlzLnBZO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHJldHVybiBoYXNNb3ZlZCAmJiBkaXN0YW5jZSA+IG9wdGlvbnMudGhyZXNob2xkICYmIGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTiB8fCAoISh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pICYmIHRoaXMuZGlyZWN0aW9uVGVzdChpbnB1dCkpKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcblxuICAgICAgICB0aGlzLnBYID0gaW5wdXQuZGVsdGFYO1xuICAgICAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQuZGlyZWN0aW9uKTtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQaW5jaFxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXJzIGFyZSBtb3ZpbmcgdG93YXJkICh6b29tLWluKSBvciBhd2F5IGZyb20gZWFjaCBvdGhlciAoem9vbS1vdXQpLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChQaW5jaFJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3BpbmNoJyxcbiAgICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgICBwb2ludGVyczogMlxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoaW5wdXQuc2NhbGUgLSAxKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LnNjYWxlICE9PSAxKSB7XG4gICAgICAgICAgICB2YXIgaW5PdXQgPSBpbnB1dC5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCc7XG4gICAgICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBpbk91dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFByZXNzXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBmb3IgeCBtcyB3aXRob3V0IGFueSBtb3ZlbWVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBQcmVzc1JlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbn1cblxuaW5oZXJpdChQcmVzc1JlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFByZXNzUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncHJlc3MnLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgdGltZTogMjUxLCAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxuICAgICAgICB0aHJlc2hvbGQ6IDkgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9BVVRPXTtcbiAgICB9LFxuXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICAgIHZhciB2YWxpZFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPiBvcHRpb25zLnRpbWU7XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCAoaW5wdXQuZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgIXZhbGlkVGltZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgICAgIH0sIG9wdGlvbnMudGltZSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXQgJiYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArICd1cCcsIGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBSb3RhdGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVyIGFyZSBtb3ZpbmcgaW4gYSBjaXJjdWxhciBtb3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFJvdGF0ZVJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChSb3RhdGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUm90YXRlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncm90YXRlJyxcbiAgICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgICBwb2ludGVyczogMlxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoaW5wdXQucm90YXRpb24pID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFN3aXBlXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChTd2lwZVJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBTd2lwZVJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3N3aXBlJyxcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgICAgdmVsb2NpdHk6IDAuMyxcbiAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUGFuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0VG91Y2hBY3Rpb24uY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgdmVsb2NpdHk7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIChESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5O1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVg7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIGRpcmVjdGlvbiAmIGlucHV0Lm9mZnNldERpcmVjdGlvbiAmJlxuICAgICAgICAgICAgaW5wdXQuZGlzdGFuY2UgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkICYmXG4gICAgICAgICAgICBpbnB1dC5tYXhQb2ludGVycyA9PSB0aGlzLm9wdGlvbnMucG9pbnRlcnMgJiZcbiAgICAgICAgICAgIGFicyh2ZWxvY2l0eSkgPiB0aGlzLm9wdGlvbnMudmVsb2NpdHkgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0Lm9mZnNldERpcmVjdGlvbik7XG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbiwgaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQSB0YXAgaXMgZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG9pbmcgYSBzbWFsbCB0YXAvY2xpY2suIE11bHRpcGxlIHRhcHMgYXJlIHJlY29nbml6ZWQgaWYgdGhleSBvY2N1clxuICogYmV0d2VlbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgYW5kIHBvc2l0aW9uLiBUaGUgZGVsYXkgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHJlY29nbml6ZSBtdWx0aS10YXBzIHdpdGhvdXQgZmlyaW5nXG4gKiBhIHNpbmdsZSB0YXAuXG4gKlxuICogVGhlIGV2ZW50RGF0YSBmcm9tIHRoZSBlbWl0dGVkIGV2ZW50IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBgdGFwQ291bnRgLCB3aGljaCBjb250YWlucyB0aGUgYW1vdW50IG9mXG4gKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gVGFwUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBwcmV2aW91cyB0aW1lIGFuZCBjZW50ZXIsXG4gICAgLy8gdXNlZCBmb3IgdGFwIGNvdW50aW5nXG4gICAgdGhpcy5wVGltZSA9IGZhbHNlO1xuICAgIHRoaXMucENlbnRlciA9IGZhbHNlO1xuXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ID0gMDtcbn1cblxuaW5oZXJpdChUYXBSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3RhcCcsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICB0YXBzOiAxLFxuICAgICAgICBpbnRlcnZhbDogMzAwLCAvLyBtYXggdGltZSBiZXR3ZWVuIHRoZSBtdWx0aS10YXAgdGFwc1xuICAgICAgICB0aW1lOiAyNTAsIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXG4gICAgICAgIHRocmVzaG9sZDogOSwgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICAgICAgcG9zVGhyZXNob2xkOiAxMCAvLyBhIG11bHRpLXRhcCBjYW4gYmUgYSBiaXQgb2ZmIHRoZSBpbml0aWFsIHBvc2l0aW9uXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OXTtcbiAgICB9LFxuXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgdmFyIHZhbGlkVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgb3B0aW9ucy50aW1lO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICBpZiAoKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSAmJiAodGhpcy5jb3VudCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgICAgIGlmICh2YWxpZE1vdmVtZW50ICYmIHZhbGlkVG91Y2hUaW1lICYmIHZhbGlkUG9pbnRlcnMpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbGlkSW50ZXJ2YWwgPSB0aGlzLnBUaW1lID8gKGlucHV0LnRpbWVTdGFtcCAtIHRoaXMucFRpbWUgPCBvcHRpb25zLmludGVydmFsKSA6IHRydWU7XG4gICAgICAgICAgICB2YXIgdmFsaWRNdWx0aVRhcCA9ICF0aGlzLnBDZW50ZXIgfHwgZ2V0RGlzdGFuY2UodGhpcy5wQ2VudGVyLCBpbnB1dC5jZW50ZXIpIDwgb3B0aW9ucy5wb3NUaHJlc2hvbGQ7XG5cbiAgICAgICAgICAgIHRoaXMucFRpbWUgPSBpbnB1dC50aW1lU3RhbXA7XG4gICAgICAgICAgICB0aGlzLnBDZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG5cbiAgICAgICAgICAgIGlmICghdmFsaWRNdWx0aVRhcCB8fCAhdmFsaWRJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgICAgIC8vIGlmIHRhcCBjb3VudCBtYXRjaGVzIHdlIGhhdmUgcmVjb2duaXplZCBpdCxcbiAgICAgICAgICAgIC8vIGVsc2UgaXQgaGFzIGJlZ2FuIHJlY29nbml6aW5nLi4uXG4gICAgICAgICAgICB2YXIgdGFwQ291bnQgPSB0aGlzLmNvdW50ICUgb3B0aW9ucy50YXBzO1xuICAgICAgICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gZmFpbGluZyByZXF1aXJlbWVudHMsIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHRhcCBldmVudFxuICAgICAgICAgICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgZmFpbFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBTaW1wbGUgd2F5IHRvIGNyZWF0ZSBhIG1hbmFnZXIgd2l0aCBhIGRlZmF1bHQgc2V0IG9mIHJlY29nbml6ZXJzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEhhbW1lcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5yZWNvZ25pemVycyA9IGlmVW5kZWZpbmVkKG9wdGlvbnMucmVjb2duaXplcnMsIEhhbW1lci5kZWZhdWx0cy5wcmVzZXQpO1xuICAgIHJldHVybiBuZXcgTWFuYWdlcihlbGVtZW50LCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAY29uc3Qge3N0cmluZ31cbiAqL1xuSGFtbWVyLlZFUlNJT04gPSAnMi4wLjcnO1xuXG4vKipcbiAqIGRlZmF1bHQgc2V0dGluZ3NcbiAqIEBuYW1lc3BhY2VcbiAqL1xuSGFtbWVyLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIHNldCBpZiBET00gZXZlbnRzIGFyZSBiZWluZyB0cmlnZ2VyZWQuXG4gICAgICogQnV0IHRoaXMgaXMgc2xvd2VyIGFuZCB1bnVzZWQgYnkgc2ltcGxlIGltcGxlbWVudGF0aW9ucywgc28gZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGRvbUV2ZW50czogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eS9mYWxsYmFjay5cbiAgICAgKiBXaGVuIHNldCB0byBgY29tcHV0ZWAgaXQgd2lsbCBtYWdpY2FsbHkgc2V0IHRoZSBjb3JyZWN0IHZhbHVlIGJhc2VkIG9uIHRoZSBhZGRlZCByZWNvZ25pemVycy5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IGNvbXB1dGVcbiAgICAgKi9cbiAgICB0b3VjaEFjdGlvbjogVE9VQ0hfQUNUSU9OX0NPTVBVVEUsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgZW5hYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRVhQRVJJTUVOVEFMIEZFQVRVUkUgLS0gY2FuIGJlIHJlbW92ZWQvY2hhbmdlZFxuICAgICAqIENoYW5nZSB0aGUgcGFyZW50IGlucHV0IHRhcmdldCBlbGVtZW50LlxuICAgICAqIElmIE51bGwsIHRoZW4gaXQgaXMgYmVpbmcgc2V0IHRoZSB0byBtYWluIGVsZW1lbnQuXG4gICAgICogQHR5cGUge051bGx8RXZlbnRUYXJnZXR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0VGFyZ2V0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogZm9yY2UgYW4gaW5wdXQgY2xhc3NcbiAgICAgKiBAdHlwZSB7TnVsbHxGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRDbGFzczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgcmVjb2duaXplciBzZXR1cCB3aGVuIGNhbGxpbmcgYEhhbW1lcigpYFxuICAgICAqIFdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlciB0aGVzZSB3aWxsIGJlIHNraXBwZWQuXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHByZXNldDogW1xuICAgICAgICAvLyBSZWNvZ25pemVyQ2xhc3MsIG9wdGlvbnMsIFtyZWNvZ25pemVXaXRoLCAuLi5dLCBbcmVxdWlyZUZhaWx1cmUsIC4uLl1cbiAgICAgICAgW1JvdGF0ZVJlY29nbml6ZXIsIHtlbmFibGU6IGZhbHNlfV0sXG4gICAgICAgIFtQaW5jaFJlY29nbml6ZXIsIHtlbmFibGU6IGZhbHNlfSwgWydyb3RhdGUnXV0sXG4gICAgICAgIFtTd2lwZVJlY29nbml6ZXIsIHtkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMfV0sXG4gICAgICAgIFtQYW5SZWNvZ25pemVyLCB7ZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTH0sIFsnc3dpcGUnXV0sXG4gICAgICAgIFtUYXBSZWNvZ25pemVyXSxcbiAgICAgICAgW1RhcFJlY29nbml6ZXIsIHtldmVudDogJ2RvdWJsZXRhcCcsIHRhcHM6IDJ9LCBbJ3RhcCddXSxcbiAgICAgICAgW1ByZXNzUmVjb2duaXplcl1cbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogU29tZSBDU1MgcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHRoZSB3b3JraW5nIG9mIEhhbW1lci5cbiAgICAgKiBBZGQgdGhlbSB0byB0aGlzIG1ldGhvZCBhbmQgdGhleSB3aWxsIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIuXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqL1xuICAgIGNzc1Byb3BzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0ZXh0IHNlbGVjdGlvbiB0byBpbXByb3ZlIHRoZSBkcmFnZ2luZyBnZXN0dXJlLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlIHRoZSBXaW5kb3dzIFBob25lIGdyaXBwZXJzIHdoZW4gcHJlc3NpbmcgYW4gZWxlbWVudC5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaFNlbGVjdDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgZGVmYXVsdCBjYWxsb3V0IHNob3duIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0LlxuICAgICAgICAgKiBPbiBpT1MsIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0IHN1Y2ggYXMgYSBsaW5rLCBTYWZhcmkgZGlzcGxheXNcbiAgICAgICAgICogYSBjYWxsb3V0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmsuIFRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBkaXNhYmxlIHRoYXQgY2FsbG91dC5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaENhbGxvdXQ6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgem9vbWluZyBpcyBlbmFibGVkLiBVc2VkIGJ5IElFMTA+XG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgY29udGVudFpvb21pbmc6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJEcmFnOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlcyB0aGUgaGlnaGxpZ2h0IGNvbG9yIHNob3duIHdoZW4gdGhlIHVzZXIgdGFwcyBhIGxpbmsgb3IgYSBKYXZhU2NyaXB0XG4gICAgICAgICAqIGNsaWNrYWJsZSBlbGVtZW50IGluIGlPUy4gVGhpcyBwcm9wZXJ0eSBvYmV5cyB0aGUgYWxwaGEgdmFsdWUsIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ3JnYmEoMCwwLDAsMCknXG4gICAgICAgICAqL1xuICAgICAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG4gICAgfVxufTtcblxudmFyIFNUT1AgPSAxO1xudmFyIEZPUkNFRF9TVE9QID0gMjtcblxuLyoqXG4gKiBNYW5hZ2VyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTWFuYWdlcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCBIYW1tZXIuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG5cbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5yZWNvZ25pemVycyA9IFtdO1xuICAgIHRoaXMub2xkQ3NzUHJvcHMgPSB7fTtcblxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5pbnB1dCA9IGNyZWF0ZUlucHV0SW5zdGFuY2UodGhpcyk7XG4gICAgdGhpcy50b3VjaEFjdGlvbiA9IG5ldyBUb3VjaEFjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuXG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XG5cbiAgICBlYWNoKHRoaXMub3B0aW9ucy5yZWNvZ25pemVycywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMuYWRkKG5ldyAoaXRlbVswXSkoaXRlbVsxXSkpO1xuICAgICAgICBpdGVtWzJdICYmIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtWzJdKTtcbiAgICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgIH0sIHRoaXMpO1xufVxuXG5NYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIE9wdGlvbnMgdGhhdCBuZWVkIGEgbGl0dGxlIG1vcmUgc2V0dXBcbiAgICAgICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW5wdXRUYXJnZXQpIHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVpbml0aWFsaXplXG4gICAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQudGFyZ2V0ID0gb3B0aW9ucy5pbnB1dFRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzdG9wIHJlY29nbml6aW5nIGZvciB0aGlzIHNlc3Npb24uXG4gICAgICogVGhpcyBzZXNzaW9uIHdpbGwgYmUgZGlzY2FyZGVkLCB3aGVuIGEgbmV3IFtpbnB1dF1zdGFydCBldmVudCBpcyBmaXJlZC5cbiAgICAgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICB0aGlzLnNlc3Npb24uc3RvcHBlZCA9IGZvcmNlID8gRk9SQ0VEX1NUT1AgOiBTVE9QO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBydW4gdGhlIHJlY29nbml6ZXJzIVxuICAgICAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcbiAgICAgKiBpdCB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgcmVjb2duaXplcnMgYW5kIHRyaWVzIHRvIGRldGVjdCB0aGUgZ2VzdHVyZSB0aGF0IGlzIGJlaW5nIG1hZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbihpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJ1biB0aGUgdG91Y2gtYWN0aW9uIHBvbHlmaWxsXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24ucHJldmVudERlZmF1bHRzKGlucHV0RGF0YSk7XG5cbiAgICAgICAgdmFyIHJlY29nbml6ZXI7XG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG5cbiAgICAgICAgLy8gdGhpcyBob2xkcyB0aGUgcmVjb2duaXplciB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgIC8vIHNvIHRoZSByZWNvZ25pemVyJ3Mgc3RhdGUgbmVlZHMgdG8gYmUgQkVHQU4sIENIQU5HRUQsIEVOREVEIG9yIFJFQ09HTklaRURcbiAgICAgICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxuICAgICAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjtcblxuICAgICAgICAvLyByZXNldCB3aGVuIHRoZSBsYXN0IHJlY29nbml6ZXIgaXMgcmVjb2duaXplZFxuICAgICAgICAvLyBvciB3aGVuIHdlJ3JlIGluIGEgbmV3IHNlc3Npb25cbiAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyIHx8IChjdXJSZWNvZ25pemVyICYmIGN1clJlY29nbml6ZXIuc3RhdGUgJiBTVEFURV9SRUNPR05JWkVEKSkge1xuICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgcmVjb2duaXplcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07XG5cbiAgICAgICAgICAgIC8vIGZpbmQgb3V0IGlmIHdlIGFyZSBhbGxvd2VkIHRyeSB0byByZWNvZ25pemUgdGhlIGlucHV0IGZvciB0aGlzIG9uZS5cbiAgICAgICAgICAgIC8vIDEuICAgYWxsb3cgaWYgdGhlIHNlc3Npb24gaXMgTk9UIGZvcmNlZCBzdG9wcGVkIChzZWUgdGhlIC5zdG9wKCkgbWV0aG9kKVxuICAgICAgICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXG4gICAgICAgICAgICAvLyAgICAgIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgICAgIC8vIDMuICAgYWxsb3cgaWYgdGhlIHJlY29nbml6ZXIgaXMgYWxsb3dlZCB0byBydW4gc2ltdWx0YW5lb3VzIHdpdGggdGhlIGN1cnJlbnQgcmVjb2duaXplZCByZWNvZ25pemVyLlxuICAgICAgICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkICE9PSBGT1JDRURfU1RPUCAmJiAoIC8vIDFcbiAgICAgICAgICAgICAgICAgICAgIWN1clJlY29nbml6ZXIgfHwgcmVjb2duaXplciA9PSBjdXJSZWNvZ25pemVyIHx8IC8vIDJcbiAgICAgICAgICAgICAgICAgICAgcmVjb2duaXplci5jYW5SZWNvZ25pemVXaXRoKGN1clJlY29nbml6ZXIpKSkgeyAvLyAzXG4gICAgICAgICAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemUoaW5wdXREYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgcmVjb2duaXplci4gYnV0IG9ubHkgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSByZWNvZ25pemVyXG4gICAgICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgJiYgcmVjb2duaXplci5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCkpIHtcbiAgICAgICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgYSByZWNvZ25pemVyIGJ5IGl0cyBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxOdWxsfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlY29nbml6ZXJzW2ldLm9wdGlvbnMuZXZlbnQgPT0gcmVjb2duaXplcikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvZ25pemVyc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgcmVjb2duaXplciB0byB0aGUgbWFuYWdlclxuICAgICAqIGV4aXN0aW5nIHJlY29nbml6ZXJzIHdpdGggdGhlIHNhbWUgZXZlbnQgbmFtZSB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxNYW5hZ2VyfVxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ2FkZCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBleGlzdGluZ1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZ25pemVyKTtcbiAgICAgICAgcmVjb2duaXplci5tYW5hZ2VyID0gdGhpcztcblxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ3JlbW92ZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTtcblxuICAgICAgICAvLyBsZXQncyBtYWtlIHN1cmUgdGhpcyByZWNvZ25pemVyIGV4aXN0c1xuICAgICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGluQXJyYXkocmVjb2duaXplcnMsIHJlY29nbml6ZXIpO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGJpbmQgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuYmluZCBldmVudCwgbGVhdmUgZW1pdCBibGFuayB0byByZW1vdmUgYWxsIGhhbmRsZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXVxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBvZmY6IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSAmJiBoYW5kbGVyc1tldmVudF0uc3BsaWNlKGluQXJyYXkoaGFuZGxlcnNbZXZlbnRdLCBoYW5kbGVyKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZW1pdCBldmVudCB0byB0aGUgbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgICAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gdHJpZ2dlciBkb20gZXZlbnRzXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG9tRXZlbnRzKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gaGFuZGxlcnMsIHNvIHNraXAgaXQgYWxsXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuaGFuZGxlcnNbZXZlbnRdLnNsaWNlKCk7XG4gICAgICAgIGlmICghaGFuZGxlcnMgfHwgIWhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS50eXBlID0gZXZlbnQ7XG4gICAgICAgIGRhdGEucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRhdGEuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tpXShkYXRhKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcbiAgICAgKiBpdCBkb2Vzbid0IHVuYmluZCBkb20gZXZlbnRzLCB0aGF0IGlzIHRoZSB1c2VyIG93biByZXNwb25zaWJpbGl0eVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgJiYgdG9nZ2xlQ3NzUHJvcHModGhpcywgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogYWRkL3JlbW92ZSB0aGUgY3NzIHByb3BlcnRpZXMgYXMgZGVmaW5lZCBpbiBtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtCb29sZWFufSBhZGRcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQ3NzUHJvcHMobWFuYWdlciwgYWRkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHByb3A7XG4gICAgZWFjaChtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHByb3AgPSBwcmVmaXhlZChlbGVtZW50LnN0eWxlLCBuYW1lKTtcbiAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSA9IGVsZW1lbnQuc3R5bGVbcHJvcF07XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSB8fCAnJztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghYWRkKSB7XG4gICAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHMgPSB7fTtcbiAgICB9XG59XG5cbi8qKlxuICogdHJpZ2dlciBkb20gZXZlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqL1xuZnVuY3Rpb24gdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGdlc3R1cmVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xuICAgIGdlc3R1cmVFdmVudC5nZXN0dXJlID0gZGF0YTtcbiAgICBkYXRhLnRhcmdldC5kaXNwYXRjaEV2ZW50KGdlc3R1cmVFdmVudCk7XG59XG5cbmFzc2lnbihIYW1tZXIsIHtcbiAgICBJTlBVVF9TVEFSVDogSU5QVVRfU1RBUlQsXG4gICAgSU5QVVRfTU9WRTogSU5QVVRfTU9WRSxcbiAgICBJTlBVVF9FTkQ6IElOUFVUX0VORCxcbiAgICBJTlBVVF9DQU5DRUw6IElOUFVUX0NBTkNFTCxcblxuICAgIFNUQVRFX1BPU1NJQkxFOiBTVEFURV9QT1NTSUJMRSxcbiAgICBTVEFURV9CRUdBTjogU1RBVEVfQkVHQU4sXG4gICAgU1RBVEVfQ0hBTkdFRDogU1RBVEVfQ0hBTkdFRCxcbiAgICBTVEFURV9FTkRFRDogU1RBVEVfRU5ERUQsXG4gICAgU1RBVEVfUkVDT0dOSVpFRDogU1RBVEVfUkVDT0dOSVpFRCxcbiAgICBTVEFURV9DQU5DRUxMRUQ6IFNUQVRFX0NBTkNFTExFRCxcbiAgICBTVEFURV9GQUlMRUQ6IFNUQVRFX0ZBSUxFRCxcblxuICAgIERJUkVDVElPTl9OT05FOiBESVJFQ1RJT05fTk9ORSxcbiAgICBESVJFQ1RJT05fTEVGVDogRElSRUNUSU9OX0xFRlQsXG4gICAgRElSRUNUSU9OX1JJR0hUOiBESVJFQ1RJT05fUklHSFQsXG4gICAgRElSRUNUSU9OX1VQOiBESVJFQ1RJT05fVVAsXG4gICAgRElSRUNUSU9OX0RPV046IERJUkVDVElPTl9ET1dOLFxuICAgIERJUkVDVElPTl9IT1JJWk9OVEFMOiBESVJFQ1RJT05fSE9SSVpPTlRBTCxcbiAgICBESVJFQ1RJT05fVkVSVElDQUw6IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICBESVJFQ1RJT05fQUxMOiBESVJFQ1RJT05fQUxMLFxuXG4gICAgTWFuYWdlcjogTWFuYWdlcixcbiAgICBJbnB1dDogSW5wdXQsXG4gICAgVG91Y2hBY3Rpb246IFRvdWNoQWN0aW9uLFxuXG4gICAgVG91Y2hJbnB1dDogVG91Y2hJbnB1dCxcbiAgICBNb3VzZUlucHV0OiBNb3VzZUlucHV0LFxuICAgIFBvaW50ZXJFdmVudElucHV0OiBQb2ludGVyRXZlbnRJbnB1dCxcbiAgICBUb3VjaE1vdXNlSW5wdXQ6IFRvdWNoTW91c2VJbnB1dCxcbiAgICBTaW5nbGVUb3VjaElucHV0OiBTaW5nbGVUb3VjaElucHV0LFxuXG4gICAgUmVjb2duaXplcjogUmVjb2duaXplcixcbiAgICBBdHRyUmVjb2duaXplcjogQXR0clJlY29nbml6ZXIsXG4gICAgVGFwOiBUYXBSZWNvZ25pemVyLFxuICAgIFBhbjogUGFuUmVjb2duaXplcixcbiAgICBTd2lwZTogU3dpcGVSZWNvZ25pemVyLFxuICAgIFBpbmNoOiBQaW5jaFJlY29nbml6ZXIsXG4gICAgUm90YXRlOiBSb3RhdGVSZWNvZ25pemVyLFxuICAgIFByZXNzOiBQcmVzc1JlY29nbml6ZXIsXG5cbiAgICBvbjogYWRkRXZlbnRMaXN0ZW5lcnMsXG4gICAgb2ZmOiByZW1vdmVFdmVudExpc3RlbmVycyxcbiAgICBlYWNoOiBlYWNoLFxuICAgIG1lcmdlOiBtZXJnZSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBpbmhlcml0OiBpbmhlcml0LFxuICAgIGJpbmRGbjogYmluZEZuLFxuICAgIHByZWZpeGVkOiBwcmVmaXhlZFxufSk7XG5cbi8vIHRoaXMgcHJldmVudHMgZXJyb3JzIHdoZW4gSGFtbWVyIGlzIGxvYWRlZCBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EXG4vLyAgc3R5bGUgbG9hZGVyIGJ1dCBieSBzY3JpcHQgdGFnLCBub3QgYnkgdGhlIGxvYWRlci5cbnZhciBmcmVlR2xvYmFsID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fSkpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbmZyZWVHbG9iYWwuSGFtbWVyID0gSGFtbWVyO1xuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSGFtbWVyO1xuICAgIH0pO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW1tZXI7XG59IGVsc2Uge1xuICAgIHdpbmRvd1tleHBvcnROYW1lXSA9IEhhbW1lcjtcbn1cblxufSkod2luZG93LCBkb2N1bWVudCwgJ0hhbW1lcicpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IEFsZXggb24gMTEvNi8yMDE0LlxyXG4gKi9cclxuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvcmV0dXJuRXhwb3J0cy5qcyNMNDAtTDYwXHJcbi8vIGlmIHRoZSBtb2R1bGUgaGFzIG5vIGRlcGVuZGVuY2llcywgdGhlIGFib3ZlIHBhdHRlcm4gY2FuIGJlIHNpbXBsaWZpZWQgdG9cclxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XHJcbiAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcclxuICAgIC8vIGxpa2UgTm9kZS5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxyXG4gICAgcm9vdC5rZXljaGFybSA9IGZhY3RvcnkoKTtcclxuICB9XHJcbn0odGhpcywgZnVuY3Rpb24gKCkge1xyXG5cclxuICBmdW5jdGlvbiBrZXljaGFybShvcHRpb25zKSB7XHJcbiAgICB2YXIgcHJldmVudERlZmF1bHQgPSBvcHRpb25zICYmIG9wdGlvbnMucHJldmVudERlZmF1bHQgfHwgZmFsc2U7XHJcblxyXG4gICAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250YWluZXIgfHwgd2luZG93O1xyXG5cclxuICAgIHZhciBfZXhwb3J0RnVuY3Rpb25zID0ge307XHJcbiAgICB2YXIgX2JvdW5kID0ge2tleWRvd246e30sIGtleXVwOnt9fTtcclxuICAgIHZhciBfa2V5cyA9IHt9O1xyXG4gICAgdmFyIGk7XHJcblxyXG4gICAgLy8gYSAtIHpcclxuICAgIGZvciAoaSA9IDk3OyBpIDw9IDEyMjsgaSsrKSB7X2tleXNbU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSB7Y29kZTo2NSArIChpIC0gOTcpLCBzaGlmdDogZmFsc2V9O31cclxuICAgIC8vIEEgLSBaXHJcbiAgICBmb3IgKGkgPSA2NTsgaSA8PSA5MDsgaSsrKSB7X2tleXNbU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSB7Y29kZTppLCBzaGlmdDogdHJ1ZX07fVxyXG4gICAgLy8gMCAtIDlcclxuICAgIGZvciAoaSA9IDA7ICBpIDw9IDk7ICAgaSsrKSB7X2tleXNbJycgKyBpXSA9IHtjb2RlOjQ4ICsgaSwgc2hpZnQ6IGZhbHNlfTt9XHJcbiAgICAvLyBGMSAtIEYxMlxyXG4gICAgZm9yIChpID0gMTsgIGkgPD0gMTI7ICAgaSsrKSB7X2tleXNbJ0YnICsgaV0gPSB7Y29kZToxMTEgKyBpLCBzaGlmdDogZmFsc2V9O31cclxuICAgIC8vIG51bTAgLSBudW05XHJcbiAgICBmb3IgKGkgPSAwOyAgaSA8PSA5OyAgIGkrKykge19rZXlzWydudW0nICsgaV0gPSB7Y29kZTo5NiArIGksIHNoaWZ0OiBmYWxzZX07fVxyXG5cclxuICAgIC8vIG51bXBhZCBtaXNjXHJcbiAgICBfa2V5c1snbnVtKiddID0ge2NvZGU6MTA2LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ251bSsnXSA9IHtjb2RlOjEwNywgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWydudW0tJ10gPSB7Y29kZToxMDksIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snbnVtLyddID0ge2NvZGU6MTExLCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ251bS4nXSA9IHtjb2RlOjExMCwgc2hpZnQ6IGZhbHNlfTtcclxuICAgIC8vIGFycm93c1xyXG4gICAgX2tleXNbJ2xlZnQnXSAgPSB7Y29kZTozNywgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWyd1cCddICAgID0ge2NvZGU6MzgsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1sncmlnaHQnXSA9IHtjb2RlOjM5LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ2Rvd24nXSAgPSB7Y29kZTo0MCwgc2hpZnQ6IGZhbHNlfTtcclxuICAgIC8vIGV4dHJhIGtleXNcclxuICAgIF9rZXlzWydzcGFjZSddID0ge2NvZGU6MzIsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snZW50ZXInXSA9IHtjb2RlOjEzLCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ3NoaWZ0J10gPSB7Y29kZToxNiwgc2hpZnQ6IHVuZGVmaW5lZH07XHJcbiAgICBfa2V5c1snZXNjJ10gICA9IHtjb2RlOjI3LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ2JhY2tzcGFjZSddID0ge2NvZGU6OCwgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWyd0YWInXSAgICAgICA9IHtjb2RlOjksIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snY3RybCddICAgICAgPSB7Y29kZToxNywgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWydhbHQnXSAgICAgICA9IHtjb2RlOjE4LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ2RlbGV0ZSddICAgID0ge2NvZGU6NDYsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1sncGFnZXVwJ10gICAgPSB7Y29kZTozMywgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWydwYWdlZG93biddICA9IHtjb2RlOjM0LCBzaGlmdDogZmFsc2V9O1xyXG4gICAgLy8gc3ltYm9sc1xyXG4gICAgX2tleXNbJz0nXSAgICAgPSB7Y29kZToxODcsIHNoaWZ0OiBmYWxzZX07XHJcbiAgICBfa2V5c1snLSddICAgICA9IHtjb2RlOjE4OSwgc2hpZnQ6IGZhbHNlfTtcclxuICAgIF9rZXlzWyddJ10gICAgID0ge2NvZGU6MjIxLCBzaGlmdDogZmFsc2V9O1xyXG4gICAgX2tleXNbJ1snXSAgICAgPSB7Y29kZToyMTksIHNoaWZ0OiBmYWxzZX07XHJcblxyXG5cclxuXHJcbiAgICB2YXIgZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7aGFuZGxlRXZlbnQoZXZlbnQsJ2tleWRvd24nKTt9O1xyXG4gICAgdmFyIHVwID0gZnVuY3Rpb24oZXZlbnQpIHtoYW5kbGVFdmVudChldmVudCwna2V5dXAnKTt9O1xyXG5cclxuICAgIC8vIGhhbmRsZSB0aGUgYWN0dWFseSBib3VuZCBrZXkgd2l0aCB0aGUgZXZlbnRcclxuICAgIHZhciBoYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50LHR5cGUpIHtcclxuICAgICAgaWYgKF9ib3VuZFt0eXBlXVtldmVudC5rZXlDb2RlXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFyIGJvdW5kID0gX2JvdW5kW3R5cGVdW2V2ZW50LmtleUNvZGVdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmIChib3VuZFtpXS5zaGlmdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGJvdW5kW2ldLmZuKGV2ZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKGJvdW5kW2ldLnNoaWZ0ID09IHRydWUgJiYgZXZlbnQuc2hpZnRLZXkgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBib3VuZFtpXS5mbihldmVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIGlmIChib3VuZFtpXS5zaGlmdCA9PSBmYWxzZSAmJiBldmVudC5zaGlmdEtleSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBib3VuZFtpXS5mbihldmVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocHJldmVudERlZmF1bHQgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gYmluZCBhIGtleSB0byBhIGNhbGxiYWNrXHJcbiAgICBfZXhwb3J0RnVuY3Rpb25zLmJpbmQgPSBmdW5jdGlvbihrZXksIGNhbGxiYWNrLCB0eXBlKSB7XHJcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0eXBlID0gJ2tleWRvd24nO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfa2V5c1trZXldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXk6IFwiICsga2V5KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdID0gW107XHJcbiAgICAgIH1cclxuICAgICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0ucHVzaCh7Zm46Y2FsbGJhY2ssIHNoaWZ0Ol9rZXlzW2tleV0uc2hpZnR9KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8vIGJpbmQgYWxsIGtleXMgdG8gYSBjYWxsIGJhY2sgKGRlbW8gcHVycG9zZXMpXHJcbiAgICBfZXhwb3J0RnVuY3Rpb25zLmJpbmRBbGwgPSBmdW5jdGlvbihjYWxsYmFjaywgdHlwZSkge1xyXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdHlwZSA9ICdrZXlkb3duJztcclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gX2tleXMpIHtcclxuICAgICAgICBpZiAoX2tleXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgX2V4cG9ydEZ1bmN0aW9ucy5iaW5kKGtleSxjYWxsYmFjayx0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gZ2V0IHRoZSBrZXkgbGFiZWwgZnJvbSBhbiBldmVudFxyXG4gICAgX2V4cG9ydEZ1bmN0aW9ucy5nZXRLZXkgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gX2tleXMpIHtcclxuICAgICAgICBpZiAoX2tleXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5ID09IHRydWUgJiYgX2tleXNba2V5XS5zaGlmdCA9PSB0cnVlICYmIGV2ZW50LmtleUNvZGUgPT0gX2tleXNba2V5XS5jb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIGlmIChldmVudC5zaGlmdEtleSA9PSBmYWxzZSAmJiBfa2V5c1trZXldLnNoaWZ0ID09IGZhbHNlICYmIGV2ZW50LmtleUNvZGUgPT0gX2tleXNba2V5XS5jb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IF9rZXlzW2tleV0uY29kZSAmJiBrZXkgPT0gJ3NoaWZ0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gXCJ1bmtub3duIGtleSwgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIjtcclxuICAgIH07XHJcblxyXG4gICAgLy8gdW5iaW5kIGVpdGhlciBhIHNwZWNpZmljIGNhbGxiYWNrIGZyb20gYSBrZXkgb3IgYWxsIG9mIHRoZW0gKGJ5IGxlYXZpbmcgY2FsbGJhY2sgdW5kZWZpbmVkKVxyXG4gICAgX2V4cG9ydEZ1bmN0aW9ucy51bmJpbmQgPSBmdW5jdGlvbihrZXksIGNhbGxiYWNrLCB0eXBlKSB7XHJcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0eXBlID0gJ2tleWRvd24nO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfa2V5c1trZXldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXk6IFwiICsga2V5KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHZhciBuZXdCaW5kaW5ncyA9IFtdO1xyXG4gICAgICAgIHZhciBib3VuZCA9IF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdO1xyXG4gICAgICAgIGlmIChib3VuZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghKGJvdW5kW2ldLmZuID09IGNhbGxiYWNrICYmIGJvdW5kW2ldLnNoaWZ0ID09IF9rZXlzW2tleV0uc2hpZnQpKSB7XHJcbiAgICAgICAgICAgICAgbmV3QmluZGluZ3MucHVzaChfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPSBuZXdCaW5kaW5ncztcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9IFtdO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHJlc2V0IGFsbCBib3VuZCB2YXJpYWJsZXMuXHJcbiAgICBfZXhwb3J0RnVuY3Rpb25zLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIF9ib3VuZCA9IHtrZXlkb3duOnt9LCBrZXl1cDp7fX07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHVuYmluZCBhbGwgbGlzdGVuZXJzIGFuZCByZXNldCBhbGwgdmFyaWFibGVzLlxyXG4gICAgX2V4cG9ydEZ1bmN0aW9ucy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIF9ib3VuZCA9IHtrZXlkb3duOnt9LCBrZXl1cDp7fX07XHJcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93biwgdHJ1ZSk7XHJcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gY3JlYXRlIGxpc3RlbmVycy5cclxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJyxkb3duLHRydWUpO1xyXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJyx1cCx0cnVlKTtcclxuXHJcbiAgICAvLyByZXR1cm4gdGhlIHB1YmxpYyBmdW5jdGlvbnMuXHJcbiAgICByZXR1cm4gX2V4cG9ydEZ1bmN0aW9ucztcclxuICB9XHJcblxyXG4gIHJldHVybiBrZXljaGFybTtcclxufSkpO1xyXG5cclxuXHJcbiIsIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4xNC4xXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBob29rQ2FsbGJhY2s7XG5cbiAgICBmdW5jdGlvbiB1dGlsc19ob29rc19faG9va3MgKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgIC8vIGV2ZW4gaWYgaXRzIG5vdCBvd24gcHJvcGVydHkgSSdkIHN0aWxsIGNhbGwgaXQgbm9uLWVtcHR5XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVfdXRjX19jcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQgICAgIDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgICAgIG1lcmlkaWVtICAgICAgICA6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZF9faXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbS5faXNWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XG5cbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gbS5faXNWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkX19jcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4gICAgLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IHV0aWxzX2hvb2tzX19ob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSBpbiBtb21lbnRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHV0aWxzX2hvb2tzX19ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oJywgJykgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmICh1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICB1dGlsc19ob29rc19faG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVfc2V0X19zZXQgKGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX29yZGluYWxQYXJzZUxlbmllbnQuXG4gICAgICAgIHRoaXMuX29yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UgKyAnfCcgKyAoL1xcZHsxLDJ9Lykuc291cmNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLCBwcm9wO1xuICAgICAgICBmb3IgKHByb3AgaW4gY2hpbGRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pICYmIGlzT2JqZWN0KGNoaWxkQ29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgcGFyZW50Q29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgY2hpbGRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBjaGlsZENvbmZpZ1twcm9wXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3AgaW4gcGFyZW50Q29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChwYXJlbnRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGNoYW5nZXMgdG8gcHJvcGVydGllcyBkb24ndCBtb2RpZnkgcGFyZW50IGNvbmZpZ1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGV4dGVuZCh7fSwgcmVzW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvY2FsZShjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldChjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleXM7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgaSwgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgICAgIExUICAgOiAnaDptbSBBJyxcbiAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICB2YXIgZGVmYXVsdE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIG0gIDogJ2EgbWludXRlJyxcbiAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgICAgIGggIDogJ2FuIGhvdXInLFxuICAgICAgICBoaCA6ICclZCBob3VycycsXG4gICAgICAgIGQgIDogJ2EgZGF5JyxcbiAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgIE0gIDogJ2EgbW9udGgnLFxuICAgICAgICBNTSA6ICclZCBtb250aHMnLFxuICAgICAgICB5ICA6ICdhIHllYXInLFxuICAgICAgICB5eSA6ICclZCB5ZWFycydcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVfX3JlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgICAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgICAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnZXRfc2V0X19zZXQodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX2dldCAobW9tLCB1bml0KSB7XG4gICAgICAgIHJldHVybiBtb20uaXNWYWxpZCgpID9cbiAgICAgICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX3NldCAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpb3JpdGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgIHZhciBhYnNOdW1iZXIgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcbiAgICAgICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KFtIaF1tbShzcyk/fE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFFvP3xZWVlZWVl8WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xraz98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZztcblxuICAgIHZhciBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nO1xuXG4gICAgdmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgdmFyIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbiAgICAvLyB0b2tlbjogICAgJ00nXG4gICAgLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuICAgIC8vIG9yZGluYWw6ICAnTW8nXG4gICAgLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG4gICAgZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRlZCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRva2VuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gJycsIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYXJyYXlbaV0gaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxuICAgIHZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG4gICAgdmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxuICAgIHZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG4gICAgdmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxuICAgIHZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG4gICAgdmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxuICAgIHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxuICAgIHZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgdmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuICAgIHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgdmFyIG1hdGNoV29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pO1xuXG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBZRUFSID0gMDtcbiAgICB2YXIgTU9OVEggPSAxO1xuICAgIHZhciBEQVRFID0gMjtcbiAgICB2YXIgSE9VUiA9IDM7XG4gICAgdmFyIE1JTlVURSA9IDQ7XG4gICAgdmFyIFNFQ09ORCA9IDU7XG4gICAgdmFyIE1JTExJU0VDT05EID0gNjtcbiAgICB2YXIgV0VFSyA9IDc7XG4gICAgdmFyIFdFRUtEQVkgPSA4O1xuXG4gICAgdmFyIGluZGV4T2Y7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCArIDEsIDApKS5nZXRVVENEYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21vbnRoJywgOCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTScsICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICAgICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccyspK01NTU0/LztcbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNbKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0IChtLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXSA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFtNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXRzX21vbnRoX19oYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5pdHNfbW9udGhfX2hhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRfc2V0X19nZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XG4gICAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TW9udGhzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gbW9udGhzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IGRlZmF1bHRNb250aHNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLCBtb207XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgICAgIHJldHVybiB5IDw9IDk5OTkgPyAnJyArIHkgOiAnKycgKyB5O1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XG4gICAgICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODEzNDgvaW5zdGFudGlhdGluZy1hLWphdmFzY3JpcHQtb2JqZWN0LWJ5LWNhbGxpbmctcHJvdG90eXBlLWNvbnN0cnVjdG9yLWFwcGx5XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuXG4gICAgICAgIC8vdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQ0RhdGUgKHkpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcblxuICAgICAgICAvL3RoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwICYmIGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbiAgICB9XG5cbiAgICAvL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICAgICAgcmVzWWVhciwgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXG4gICAgICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV0gOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20uZGF5KCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlfb2Zfd2Vla19faGFuZGxlU3RyaWN0UGFyc2Uod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5X29mX3dlZWtfX2hhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkZCcgJiYgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbiAgICBhZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgbG93ZXJjYXNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWVyaWRpZW0oJ2EnLCB0cnVlKTtcbiAgICBtZXJpZGllbSgnQScsIGZhbHNlKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignSCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgLy8gdGhpcyBydWxlLlxuICAgIHZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuICAgIHZhciBiYXNlQ29uZmlnID0ge1xuICAgICAgICBjYWxlbmRhcjogZGVmYXVsdENhbGVuZGFyLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdDogZGVmYXVsdExvbmdEYXRlRm9ybWF0LFxuICAgICAgICBpbnZhbGlkRGF0ZTogZGVmYXVsdEludmFsaWREYXRlLFxuICAgICAgICBvcmRpbmFsOiBkZWZhdWx0T3JkaW5hbCxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiBkZWZhdWx0T3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlXG4gICAgfTtcblxuICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBkZWZpbmVMb2NhbGUgY3VycmVudGx5IGFsc28gc2V0cyB0aGUgZ2xvYmFsIGxvY2FsZSwgd2VcbiAgICAgICAgICAgICAgICAvLyB3YW50IHRvIHVuZG8gdGhhdCBmb3IgbGF6eSBsb2FkZWQgbG9jYWxlc1xuICAgICAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbG9jYWxlIGtleS5cbiAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlIChrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlIChuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cmVhdCBhcyBpZiB0aGVyZSBpcyBubyBiYXNlIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoJ3BhcmVudExvY2FsZVVuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NwZWNpZmllZCBwYXJlbnRMb2NhbGUgaXMgbm90IGRlZmluZWQgeWV0LiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9wYXJlbnQtbG9jYWxlLycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICAvLyBNRVJHRVxuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICBsb2NhbGUgPSBuZXcgTG9jYWxlKGNvbmZpZyk7XG4gICAgICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZV9sb2NhbGVzX19saXN0TG9jYWxlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyAobSkge1xuICAgICAgICB2YXIgb3ZlcmZsb3c7XG4gICAgICAgIHZhciBhID0gbS5fYTtcblxuICAgICAgICBpZiAoYSAmJiBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPT09IC0yKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICAgICAgYVtNT05USF0gICAgICAgPCAwIHx8IGFbTU9OVEhdICAgICAgID4gMTEgID8gTU9OVEggOlxuICAgICAgICAgICAgICAgIGFbREFURV0gICAgICAgIDwgMSB8fCBhW0RBVEVdICAgICAgICA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKSA/IERBVEUgOlxuICAgICAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICAgICAgYVtNSU5VVEVdICAgICAgPCAwIHx8IGFbTUlOVVRFXSAgICAgID4gNTkgID8gTUlOVVRFIDpcbiAgICAgICAgICAgICAgICBhW1NFQ09ORF0gICAgICA8IDAgfHwgYVtTRUNPTkRdICAgICAgPiA1OSAgPyBTRUNPTkQgOlxuICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgICAgICAtMTtcblxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dEYXlPZlllYXIgJiYgKG92ZXJmbG93IDwgWUVBUiB8fCBvdmVyZmxvdyA+IERBVEUpKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/LztcbiAgICB2YXIgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/LztcblxuICAgIHZhciB0elJlZ2V4ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vO1xuXG4gICAgdmFyIGlzb0RhdGVzID0gW1xuICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dLFxuICAgICAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgIFsnWVlZWU1NREQnLCAvXFxkezh9L10sXG4gICAgICAgIC8vIFlZWVlNTSBpcyBOT1QgYWxsb3dlZCBieSB0aGUgc3RhbmRhcmRcbiAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICAgICAgWydHR0dHW1ddV1cnLCAvXFxkezR9V1xcZHsyfS8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZREREJywgL1xcZHs3fS9dXG4gICAgXTtcblxuICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICB2YXIgaXNvVGltZXMgPSBbXG4gICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISDptbTpzcyxTU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkLFxcZCsvXSxcbiAgICAgICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISG1tc3MuU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcbiAgICAgICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEhtbScsIC9cXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgWydISCcsIC9cXGRcXGQvXVxuICAgIF07XG5cbiAgICB2YXIgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgYWxsb3dUaW1lLCBkYXRlRm9ybWF0LCB0aW1lRm9ybWF0LCB0ekZvcm1hdDtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlLiBUaGlzIGlzICcgK1xuICAgICAgICAnZGlzY291cmFnZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB1cGNvbWluZyBtYWpvciAnICtcbiAgICAgICAgJ3JlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgJ2h0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKHV0aWxzX2hvb2tzX19ob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhcikge1xuICAgICAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgMSk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkX19pc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkX19jcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF2YWxpZF9faXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHV0aWxzX2hvb2tzX19ob29rcy5ub3coKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZihsb2NhbGUpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgICAgIChpc0FycmF5KGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxfX2NyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZF9fY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIHZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZF9fY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gbW9tZW50c1swXTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IG1vbWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuICAgIGZ1bmN0aW9uIG1pbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF4ICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArKG5ldyBEYXRlKCkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgICAgIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlcikgfHwgW10pO1xuICAgICAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gaW5wdXQudmFsdWVPZigpIDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuICAgIC8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XG4gICAgLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuICAgIC8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbiAgICAvL1xuICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuICAgIC8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuICAgIC8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbiAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcbiAgICAvLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuICAgIGZ1bmN0aW9uIGdldFNldE9mZnNldCAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNikge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgICAgICBpZiAodGhpcy5fdHptKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQob2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhjLl9hKSA6IGxvY2FsX19jcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gIXRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGNPZmZzZXQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG4gICAgdmFyIGFzcE5ldFJlZ2V4ID0gL14oXFwtKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKylcXC4/KFxcZHszfSk/XFxkKik/JC87XG5cbiAgICAvLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICAvLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XG4gICAgdmFyIGlzb1JlZ2V4ID0gL14oLSk/UCg/OigtP1swLTksLl0qKVkpPyg/OigtP1swLTksLl0qKU0pPyg/OigtP1swLTksLl0qKVcpPyg/OigtP1swLTksLl0qKUQpPyg/OlQoPzooLT9bMC05LC5dKilIKT8oPzooLT9bMC05LC5dKilNKT8oPzooLT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlX19jcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5ICA6IDAsXG4gICAgICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBoICA6IHRvSW50KG1hdGNoW0hPVVJdKSAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtcyA6IHRvSW50KG1hdGNoW01JTExJU0VDT05EXSkgKiBzaWduXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGxvY2FsX19jcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlX19jcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgZHVyID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKG1vbS5fZC52YWx1ZU9mKCkgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIGdldF9zZXRfX3NldChtb20sICdEYXRlJywgZ2V0X3NldF9fZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vbnRocykge1xuICAgICAgICAgICAgc2V0TW9udGgobW9tLCBnZXRfc2V0X19nZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFkZF9zdWJ0cmFjdF9fYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG4gICAgdmFyIGFkZF9zdWJ0cmFjdF9fc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXIgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGxvY2FsX19jcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBmb3JtYXQgPSB1dGlsc19ob29rc19faG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnO1xuXG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRzICYmIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSkgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgbG9jYWxfX2NyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKGluY2x1c2l2aXR5WzBdID09PSAnKCcgPyB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpIDogIXRoaXMuaXNCZWZvcmUoZnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKHRvLCB1bml0cykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCx1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsXG4gICAgICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgICAgICBkZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkZWx0YSAvIDFlMyA6IC8vIDEwMDBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkZWx0YSAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnaG91cicgPyBkZWx0YSAvIDM2ZTUgOiAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA4NjRlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZyAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5jbG9uZSgpLnV0YygpO1xuICAgICAgICBpZiAoMCA8IG0ueWVhcigpICYmIG0ueWVhcigpIDw9IDk5OTkpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIGlucHV0U3RyaW5nID0gdGhpcy5pc1V0YygpID8gdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGxvY2FsX19jcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGxvY2FsX19jcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih7ZnJvbTogdGhpcywgdG86IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhsb2NhbF9fY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBzd2l0Y2ggaW50ZW50aW9uYWxseSBvbWl0cyBicmVhayBrZXl3b3Jkc1xuICAgICAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ2RhdGUnIGlzIGFuIGFsaWFzIGZvciAnZGF5Jywgc28gaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgc3VjaC5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgIHVuaXRzID0gJ2RheSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cykpLnN1YnRyYWN0KDEsICdtcycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvX3R5cGVfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4ICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICAgICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF92YWxpZF9faXNWYWxpZCAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZF9faXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XG5cblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICAgICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUFJJT1JPSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyBsb2NhbGUuX29yZGluYWxQYXJzZSA6IGxvY2FsZS5fb3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0sIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheU9mWWVhcicsIDQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG4gICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhciA9IE1hdGgucm91bmQoKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTUpICsgMTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSBkYXlPZlllYXIpLCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xuICAgIH0pO1xuXG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCAgICBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG4gICAgdmFyIHRva2VuO1xuICAgIGZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xuICAgIH1cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbiAgICB9XG5cbiAgICB2YXIgbW9tZW50UHJvdG90eXBlX19wcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkX3N1YnRyYWN0X19hZGQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jYWxlbmRhciAgICAgICAgICA9IG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGlmZiAgICAgICAgICAgICAgPSBkaWZmO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbSAgICAgICAgICAgICAgPSBmcm9tO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvTm93ICAgICAgICAgICAgID0gdG9Ob3c7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNBZnRlciAgICAgICAgICAgPSBpc0FmdGVyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lICAgICAgICAgICAgPSBpc1NhbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNWYWxpZCAgICAgICAgICAgPSBtb21lbnRfdmFsaWRfX2lzVmFsaWQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsZURhdGEgICAgICAgID0gbG9jYWxlRGF0YTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5wYXJzaW5nRmxhZ3MgICAgICA9IHBhcnNpbmdGbGFncztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc3VidHJhY3QgICAgICAgICAgPSBhZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9PYmplY3QgICAgICAgICAgPSB0b09iamVjdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgICAgICAgPSBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnVuaXggICAgICAgICAgICAgID0gdW5peDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICAgICAgID0gdG9fdHlwZV9fdmFsdWVPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuXG4gICAgLy8gWWVhclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ueWVhciAgICAgICA9IGdldFNldFllYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcblxuICAgIC8vIFdlZWsgWWVhclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla1llYXIgICAgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG5cbiAgICAvLyBRdWFydGVyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVyID0gbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG5cbiAgICAvLyBNb250aFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG5cbiAgICAvLyBXZWVrXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWsgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3NJblllYXIgICAgPSBnZXRXZWVrc0luWWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG5cbiAgICAvLyBEYXlcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5ICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtkYXkgICAgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcblxuICAgIC8vIEhvdXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXIgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcblxuICAgIC8vIE1pbnV0ZVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWludXRlID0gbW9tZW50UHJvdG90eXBlX19wcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuXG4gICAgLy8gU2Vjb25kXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG5cbiAgICAvLyBNaWxsaXNlY29uZFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuXG4gICAgLy8gT2Zmc2V0XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG5cbiAgICAvLyBUaW1lem9uZVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG5cbiAgICAvLyBEZXByZWNhdGlvbnNcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ueWVhcnMgID0gZGVwcmVjYXRlKCd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJywgZ2V0U2V0WWVhcik7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJywgZ2V0U2V0Wm9uZSk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xuXG4gICAgdmFyIG1vbWVudFByb3RvdHlwZSA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG87XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfX2NyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfX2NyZWF0ZUluWm9uZSAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQgKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVfX3Byb3RvID0gTG9jYWxlLnByb3RvdHlwZTtcblxuICAgIHByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgICAgID0gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhcjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG90eXBlX19wcm90by5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVfX3JlbGF0aXZlVGltZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnBhc3RGdXR1cmUgICAgICA9IHBhc3RGdXR1cmU7XG4gICAgcHJvdG90eXBlX19wcm90by5zZXQgICAgICAgICAgICAgPSBsb2NhbGVfc2V0X19zZXQ7XG5cbiAgICAvLyBNb250aFxuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG5cbiAgICAvLyBXZWVrXG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90b3R5cGVfX3Byb3RvLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgLy8gRGF5IG9mIFdlZWtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbiAgICAvLyBIb3Vyc1xuICAgIHByb3RvdHlwZV9fcHJvdG8uaXNQTSA9IGxvY2FsZUlzUE07XG4gICAgcHJvdG90eXBlX19wcm90by5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2dldCAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuICAgICAgICB2YXIgdXRjID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc0ltcGwgKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0c19fZ2V0KGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgLy8gKClcbiAgICAvLyAoNSlcbiAgICAvLyAoZm10LCA1KVxuICAgIC8vIChmbXQpXG4gICAgLy8gKHRydWUpXG4gICAgLy8gKHRydWUsIDUpXG4gICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAvLyAodHJ1ZSwgZm10KVxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdHNfX2dldChmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG4gICAgfVxuXG4gICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSk7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWJzX19hYnMgKCkge1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICAgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgICAgICAgID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZCAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0IChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICB2YXIgZGF5cztcbiAgICAgICAgdmFyIG1vbnRocztcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyAgID0gdGhpcy5fZGF5cyAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYXNfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fZ2V0X19nZXQgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpc1t1bml0cyArICdzJ10oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhW25hbWVdO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbiAgICB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgdmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG4gICAgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgdmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgIHM6IDQ1LCAgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICAgICAgbTogNDUsICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgaDogMjIsICAvLyBob3VycyB0byBkYXlcbiAgICAgICAgZDogMjYsICAvLyBkYXlzIHRvIG1vbnRoXG4gICAgICAgIE06IDExICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9odW1hbml6ZV9fcmVsYXRpdmVUaW1lIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgICAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSk7XG4gICAgICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgICAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICAgICAgdmFyIG1vbnRocyAgID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSk7XG4gICAgICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgICAgIHZhciBhID0gc2Vjb25kcyA8IHRocmVzaG9sZHMucyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPD0gMSAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10gICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcblxuICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IHRoZSByb3VuZGluZyBmdW5jdGlvbiBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIChyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKHJvdW5kaW5nRnVuY3Rpb24pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gZHVyYXRpb25faHVtYW5pemVfX3JlbGF0aXZlVGltZSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgaXNvX3N0cmluZ19fYWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBpc29fc3RyaW5nX190b0lTT1N0cmluZygpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIHZhciBzZWNvbmRzID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX21vbnRocyk7XG4gICAgICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICB2YXIgWSA9IHllYXJzO1xuICAgICAgICB2YXIgTSA9IG1vbnRocztcbiAgICAgICAgdmFyIEQgPSBkYXlzO1xuICAgICAgICB2YXIgaCA9IGhvdXJzO1xuICAgICAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgICAgIHZhciBzID0gc2Vjb25kcztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHRvdGFsIDwgMCA/ICctJyA6ICcnKSArXG4gICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgKFkgPyBZICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChNID8gTSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoRCA/IEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgKGggPyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtID8gbSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAocyA/IHMgKyAnUycgOiAnJyk7XG4gICAgfVxuXG4gICAgdmFyIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFicyAgICAgICAgICAgID0gZHVyYXRpb25fYWJzX19hYnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hZGQgICAgICAgICAgICA9IGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uc3VidHJhY3QgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXMgICAgICAgICAgICAgPSBhcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udmFsdWVPZiAgICAgICAgPSBkdXJhdGlvbl9hc19fdmFsdWVPZjtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLl9idWJibGUgICAgICAgID0gYnViYmxlO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uZ2V0ICAgICAgICAgICAgPSBkdXJhdGlvbl9nZXRfX2dldDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaG91cnMgICAgICAgICAgPSBob3VycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmRheXMgICAgICAgICAgID0gZGF5cztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5tb250aHMgICAgICAgICA9IG1vbnRocztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnllYXJzICAgICAgICAgID0geWVhcnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbiAgICAvLyBEZXByZWNhdGlvbnNcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nKTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQsIDEwKSAqIDEwMDApO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnZlcnNpb24gPSAnMi4xNC4xJztcblxuICAgIHNldEhvb2tDYWxsYmFjayhsb2NhbF9fY3JlYXRlTG9jYWwpO1xuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm5vdyAgICAgICAgICAgICAgICAgICA9IG5vdztcbiAgICB1dGlsc19ob29rc19faG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBtb21lbnRfX2NyZWF0ZVVuaXg7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RzX19saXN0TW9udGhzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IHZhbGlkX19jcmVhdGVJbnZhbGlkO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbiAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5cztcbiAgICB1dGlsc19ob29rc19faG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gbW9tZW50X19jcmVhdGVJblpvbmU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RzX19saXN0TW9udGhzU2hvcnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNNaW47XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlTG9jYWxlICAgICAgICAgID0gdXBkYXRlTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fbGlzdExvY2FsZXM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNTaG9ydDtcbiAgICB1dGlsc19ob29rc19faG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nID0gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBkdXJhdGlvbl9odW1hbml6ZV9fZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5jYWxlbmRhckZvcm1hdCAgICAgICAgPSBnZXRDYWxlbmRhckZvcm1hdDtcbiAgICB1dGlsc19ob29rc19faG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlO1xuXG4gICAgdmFyIF9tb21lbnQgPSB1dGlsc19ob29rc19faG9va3M7XG5cbiAgICByZXR1cm4gX21vbWVudDtcblxufSkpOyIsIid1c2Ugc3RyaWN0JztcblxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAvLyBsaWtlIE5vZGUuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICB3aW5kb3cucHJvcGFnYXRpbmcgPSBmYWN0b3J5KCk7XG4gIH1cbn0oZnVuY3Rpb24gKCkge1xuICB2YXIgX2ZpcnN0VGFyZ2V0ID0gbnVsbDsgLy8gc2luZ2xldG9uLCB3aWxsIGNvbnRhaW4gdGhlIHRhcmdldCBlbGVtZW50IHdoZXJlIHRoZSB0b3VjaCBldmVudCBzdGFydGVkXG5cbiAgLyoqXG4gICAqIEV4dGVuZCBhbiBIYW1tZXIuanMgaW5zdGFuY2Ugd2l0aCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICpcbiAgICogRmVhdHVyZXM6XG4gICAqIC0gRXZlbnRzIGVtaXR0ZWQgYnkgaGFtbWVyIHdpbGwgcHJvcGFnYXRlIGluIG9yZGVyIGZyb20gY2hpbGQgdG8gcGFyZW50XG4gICAqICAgZWxlbWVudHMuXG4gICAqIC0gRXZlbnRzIGFyZSBleHRlbmRlZCB3aXRoIGEgZnVuY3Rpb24gYGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpYCB0byBzdG9wXG4gICAqICAgcHJvcGFnYXRpb24gdG8gcGFyZW50IGVsZW1lbnRzLlxuICAgKiAtIEFuIG9wdGlvbiBgcHJldmVudERlZmF1bHRgIHRvIHN0b3AgYWxsIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvci5cbiAgICpcbiAgICogVXNhZ2U6XG4gICAqICAgdmFyIGhhbW1lciA9IHByb3BhZ2F0aW5nSGFtbWVyKG5ldyBIYW1tZXIoZWxlbWVudCkpO1xuICAgKiAgIHZhciBoYW1tZXIgPSBwcm9wYWdhdGluZ0hhbW1lcihuZXcgSGFtbWVyKGVsZW1lbnQpLCB7cHJldmVudERlZmF1bHQ6IHRydWV9KTtcbiAgICpcbiAgICogQHBhcmFtIHtIYW1tZXIuTWFuYWdlcn0gaGFtbWVyICAgQW4gaGFtbWVyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBgcHJldmVudERlZmF1bHQ6IHRydWUgfCBmYWxzZSB8ICdtb3VzZScgfCAndG91Y2gnIHwgJ3BlbidgLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZm9yY2UgcHJldmVudGluZyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbm5vdCBiZSBzZXQgdG8gYGZhbHNlYC5cbiAgICogQHJldHVybiB7SGFtbWVyLk1hbmFnZXJ9IFJldHVybnMgdGhlIHNhbWUgaGFtbWVyIGluc3RhbmNlIHdpdGggZXh0ZW5kZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uYWxpdHlcbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiBwcm9wYWdhdGluZyhoYW1tZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zIHx8IHtcbiAgICAgIHByZXZlbnREZWZhdWx0OiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAoaGFtbWVyLk1hbmFnZXIpIHtcbiAgICAgIC8vIFRoaXMgbG9va3MgbGlrZSB0aGUgSGFtbWVyIGNvbnN0cnVjdG9yLlxuICAgICAgLy8gT3ZlcmxvYWQgdGhlIGNvbnN0cnVjdG9ycyB3aXRoIG91ciBvd24uXG4gICAgICB2YXIgSGFtbWVyID0gaGFtbWVyO1xuXG4gICAgICB2YXIgUHJvcGFnYXRpbmdIYW1tZXIgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBvID0gT2JqZWN0LmNyZWF0ZShfb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zKSBIYW1tZXIuYXNzaWduKG8sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcHJvcGFnYXRpbmcobmV3IEhhbW1lcihlbGVtZW50LCBvKSwgbyk7XG4gICAgICB9O1xuICAgICAgSGFtbWVyLmFzc2lnbihQcm9wYWdhdGluZ0hhbW1lciwgSGFtbWVyKTtcblxuICAgICAgUHJvcGFnYXRpbmdIYW1tZXIuTWFuYWdlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBvID0gT2JqZWN0LmNyZWF0ZShfb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zKSBIYW1tZXIuYXNzaWduKG8sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcHJvcGFnYXRpbmcobmV3IEhhbW1lci5NYW5hZ2VyKGVsZW1lbnQsIG8pLCBvKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBQcm9wYWdhdGluZ0hhbW1lcjtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYSB3cmFwcGVyIG9iamVjdCB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBmdW5jdGlvbnNcbiAgICAvLyBgb25gLCBgb2ZmYCwgYGRlc3Ryb3lgLCBhbmQgYGVtaXRgIG9mIHRoZSBoYW1tZXIgaW5zdGFuY2VcbiAgICB2YXIgd3JhcHBlciA9IE9iamVjdC5jcmVhdGUoaGFtbWVyKTtcblxuICAgIC8vIGF0dGFjaCB0byBET00gZWxlbWVudFxuICAgIHZhciBlbGVtZW50ID0gaGFtbWVyLmVsZW1lbnQ7XG5cbiAgICBpZighZWxlbWVudC5oYW1tZXIpIGVsZW1lbnQuaGFtbWVyID0gW107XG4gICAgZWxlbWVudC5oYW1tZXIucHVzaCh3cmFwcGVyKTtcblxuICAgIC8vIHJlZ2lzdGVyIGFuIGV2ZW50IHRvIGNhdGNoIHRoZSBzdGFydCBvZiBhIGdlc3R1cmUgYW5kIHN0b3JlIHRoZVxuICAgIC8vIHRhcmdldCBpbiBhIHNpbmdsZXRvblxuICAgIGhhbW1lci5vbignaGFtbWVyLmlucHV0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoX29wdGlvbnMucHJldmVudERlZmF1bHQgPT09IHRydWUgfHwgKF9vcHRpb25zLnByZXZlbnREZWZhdWx0ID09PSBldmVudC5wb2ludGVyVHlwZSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5pc0ZpcnN0KSB7XG4gICAgICAgIF9maXJzdFRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIEFycmF5LjxmdW5jdGlvbj4+fSAqL1xuICAgIHdyYXBwZXIuX2hhbmRsZXJzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGhhbmRsZXIgZm9yIG9uZSBvciBtdWx0aXBsZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzICAgIEEgc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyB3aXRoIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgQSBjYWxsYmFjayBmdW5jdGlvbiwgY2FsbGVkIGFzIGhhbmRsZXIoZXZlbnQpXG4gICAgICogQHJldHVybnMge0hhbW1lci5NYW5hZ2VyfSBSZXR1cm5zIHRoZSBoYW1tZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICB3cmFwcGVyLm9uID0gZnVuY3Rpb24gKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgLy8gcmVnaXN0ZXIgdGhlIGhhbmRsZXJcbiAgICAgIHNwbGl0KGV2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9oYW5kbGVycyA9IHdyYXBwZXIuX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgaWYgKCFfaGFuZGxlcnMpIHtcbiAgICAgICAgICB3cmFwcGVyLl9oYW5kbGVyc1tldmVudF0gPSBfaGFuZGxlcnMgPSBbXTtcblxuICAgICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBzdGF0aWMsIHByb3BhZ2F0ZWQgaGFuZGxlclxuICAgICAgICAgIGhhbW1lci5vbihldmVudCwgcHJvcGFnYXRlZEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIF9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIGEgaGFuZGxlciBmb3Igb25lIG9yIG11bHRpcGxlIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHMgICAgICBBIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgd2l0aCBldmVudHNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gT3B0aW9uYWwuIFRoZSByZWdpc3RlcmVkIGhhbmRsZXIuIElmIG5vdFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCwgYWxsIGhhbmRsZXJzIGZvciBnaXZlbiBldmVudHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIHJlbW92ZWQuXG4gICAgICogQHJldHVybnMge0hhbW1lci5NYW5hZ2VyfSAgIFJldHVybnMgdGhlIGhhbW1lciBpbnN0YW5jZVxuICAgICAqL1xuICAgIHdyYXBwZXIub2ZmID0gZnVuY3Rpb24gKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgLy8gdW5yZWdpc3RlciB0aGUgaGFuZGxlclxuICAgICAgc3BsaXQoZXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX2hhbmRsZXJzID0gd3JhcHBlci5faGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICBpZiAoX2hhbmRsZXJzKSB7XG4gICAgICAgICAgX2hhbmRsZXJzID0gaGFuZGxlciA/IF9oYW5kbGVycy5maWx0ZXIoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoICE9PSBoYW5kbGVyO1xuICAgICAgICAgIH0pIDogW107XG5cbiAgICAgICAgICBpZiAoX2hhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHdyYXBwZXIuX2hhbmRsZXJzW2V2ZW50XSA9IF9oYW5kbGVycztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgc3RhdGljLCBwcm9wYWdhdGVkIGhhbmRsZXJcbiAgICAgICAgICAgIGhhbW1lci5vZmYoZXZlbnQsIHByb3BhZ2F0ZWRIYW5kbGVyKTtcbiAgICAgICAgICAgIGRlbGV0ZSB3cmFwcGVyLl9oYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVtaXQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqL1xuICAgIHdyYXBwZXIuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZXZlbnQpIHtcbiAgICAgIF9maXJzdFRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGhhbW1lci5lbWl0KGV2ZW50VHlwZSwgZXZlbnQpO1xuICAgIH07XG5cbiAgICB3cmFwcGVyLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBEZXRhY2ggZnJvbSBET00gZWxlbWVudFxuICAgICAgdmFyIGhhbW1lcnMgPSBoYW1tZXIuZWxlbWVudC5oYW1tZXI7XG4gICAgICB2YXIgaWR4ID0gaGFtbWVycy5pbmRleE9mKHdyYXBwZXIpO1xuICAgICAgaWYoaWR4ICE9PSAtMSkgaGFtbWVycy5zcGxpY2UoaWR4LDEpO1xuICAgICAgaWYoIWhhbW1lcnMubGVuZ3RoKSBkZWxldGUgaGFtbWVyLmVsZW1lbnQuaGFtbWVyO1xuXG4gICAgICAvLyBjbGVhciBhbGwgaGFuZGxlcnNcbiAgICAgIHdyYXBwZXIuX2hhbmRsZXJzID0ge307XG5cbiAgICAgIC8vIGNhbGwgb3JpZ2luYWwgaGFtbWVyIGRlc3Ryb3lcbiAgICAgIGhhbW1lci5kZXN0cm95KCk7XG4gICAgfTtcblxuICAgIC8vIHNwbGl0IGEgc3RyaW5nIHdpdGggc3BhY2Ugc2VwYXJhdGVkIHdvcmRzXG4gICAgZnVuY3Rpb24gc3BsaXQoZXZlbnRzKSB7XG4gICAgICByZXR1cm4gZXZlbnRzLm1hdGNoKC9bXiBdKy9nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHN0YXRpYyBldmVudCBoYW5kbGVyLCBhcHBseWluZyBldmVudCBwcm9wYWdhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVkSGFuZGxlcihldmVudCkge1xuICAgICAgLy8gbGV0IG9ubHkgYSBzaW5nbGUgaGFtbWVyIGluc3RhbmNlIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICBpZiAoZXZlbnQudHlwZSAhPT0gJ2hhbW1lci5pbnB1dCcpIHtcbiAgICAgICAgLy8gaXQgaXMgcG9zc2libGUgdGhhdCB0aGUgc2FtZSBzcmNFdmVudCBpcyB1c2VkIHdpdGggbXVsdGlwbGUgaGFtbWVyIGV2ZW50cyxcbiAgICAgICAgLy8gd2Uga2VlcCB0cmFjayBvbiB3aGljaCBldmVudHMgYXJlIGhhbmRsZWQgaW4gYW4gb2JqZWN0IF9oYW5kbGVkXG4gICAgICAgIGlmICghZXZlbnQuc3JjRXZlbnQuX2hhbmRsZWQpIHtcbiAgICAgICAgICBldmVudC5zcmNFdmVudC5faGFuZGxlZCA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LnNyY0V2ZW50Ll9oYW5kbGVkW2V2ZW50LnR5cGVdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGV2ZW50LnNyY0V2ZW50Ll9oYW5kbGVkW2V2ZW50LnR5cGVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhdHRhY2ggYSBzdG9wUHJvcGFnYXRpb24gZnVuY3Rpb24gdG8gdGhlIGV2ZW50XG4gICAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIC8vd3JhcCB0aGUgc3JjRXZlbnQncyBzdG9wUHJvcGFnYXRpb24gdG8gYWxzbyBzdG9wIGhhbW1lciBwcm9wYWdhdGlvbjpcbiAgICAgIHZhciBzcmNTdG9wID0gZXZlbnQuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uLmJpbmQoZXZlbnQuc3JjRXZlbnQpO1xuICAgICAgaWYodHlwZW9mIHNyY1N0b3AgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGV2ZW50LnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgc3JjU3RvcCgpO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGF0dGFjaCBmaXJzdFRhcmdldCBwcm9wZXJ0eSB0byB0aGUgZXZlbnRcbiAgICAgIGV2ZW50LmZpcnN0VGFyZ2V0ID0gX2ZpcnN0VGFyZ2V0O1xuXG4gICAgICAvLyBwcm9wYWdhdGUgb3ZlciBhbGwgZWxlbWVudHMgKHVudGlsIHN0b3BwZWQpXG4gICAgICB2YXIgZWxlbSA9IF9maXJzdFRhcmdldDtcbiAgICAgIHdoaWxlIChlbGVtICYmICFzdG9wcGVkKSB7XG4gICAgICAgIHZhciBlbGVtSGFtbWVyID0gZWxlbS5oYW1tZXI7XG4gICAgICAgIGlmKGVsZW1IYW1tZXIpe1xuICAgICAgICAgIHZhciBfaGFuZGxlcnM7XG4gICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGVsZW1IYW1tZXIubGVuZ3RoOyBrKyspe1xuICAgICAgICAgICAgX2hhbmRsZXJzID0gZWxlbUhhbW1lcltrXS5faGFuZGxlcnNbZXZlbnQudHlwZV07XG4gICAgICAgICAgICBpZihfaGFuZGxlcnMpIGZvciAodmFyIGkgPSAwOyBpIDwgX2hhbmRsZXJzLmxlbmd0aCAmJiAhc3RvcHBlZDsgaSsrKSB7XG4gICAgICAgICAgICAgIF9oYW5kbGVyc1tpXShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH07XG59KSk7XG4iLCIkID0gcmVxdWlyZSgnLi4vYm93ZXJfY29tcG9uZW50cy9qcXVlcnkvZGlzdC9qcXVlcnkuanMnKTtcblxuZnVuY3Rpb24gc2V0SW5wdXRWYWx1ZShlbCwgdmFsKSB7XG4gICAgZWwudmFsKHZhbCk7XG4gICAgLy8gdGlnZ2VySGFuZGxlciBvbmx5IHdvcmtzIHdpdGggYW5ndWxhciBlbGVtZW50IChub3QganF1ZXJ5KT9cbiAgICBhbmd1bGFyLmVsZW1lbnQoZWwpLnRyaWdnZXJIYW5kbGVyKHNuaWZmZXIuaGFzRXZlbnQoJ2lucHV0JykgPyAnaW5wdXQnIDogJ2NoYW5nZScpO1xuICAgIHJldHVybiBlbDtcbn1cblxuZnVuY3Rpb24gY2xpY2soZWwpIHtcbiAgICBhbmd1bGFyLmVsZW1lbnQoZWwpLnRyaWdnZXJIYW5kbGVyKCdjbGljaycpO1xufVxuXG5mdW5jdGlvbiBjb21waWxlKGh0bWwsIGNvbnRlbnRzKSB7XG4gICAgdmFyIHNjb3BlID0gJHJvb3RTY29wZS4kbmV3KCk7XG4gICAgdmFyIGVsID0gJGNvbXBpbGUoaHRtbCkoc2NvcGUpO1xuICAgIGFuZ3VsYXIuZXh0ZW5kKHNjb3BlLCBjb250ZW50cyk7XG4gICAgc2NvcGUuJGRpZ2VzdCgpO1xuICAgIHJldHVybiAkKGVsKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2NvcGUoZWwpIHtcbiAgICByZXR1cm4gYW5ndWxhci5lbGVtZW50KGVsKS5zY29wZSgpO1xufVxuXG5leHBvcnRzLmluamVjdCA9IGZ1bmN0aW9uKCkge1xuICAgIGluamVjdChmdW5jdGlvbihfJGNvbXBpbGVfLCBfJHJvb3RTY29wZV8sICRzbmlmZmVyKSB7XG4gICAgICAgICRjb21waWxlID0gXyRjb21waWxlXztcbiAgICAgICAgJHJvb3RTY29wZSA9IF8kcm9vdFNjb3BlXztcbiAgICAgICAgc25pZmZlciA9ICRzbmlmZmVyO1xuICAgIH0pO1xufTtcbmV4cG9ydHMuc2V0SW5wdXRWYWx1ZSA9IHNldElucHV0VmFsdWU7XG5leHBvcnRzLmNsaWNrID0gY2xpY2s7XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuZXhwb3J0cy5nZXRTY29wZSA9IGdldFNjb3BlOyIsInZhciBNYXBDb25maWdUcmFuc2Zvcm1lciA9IHJlcXVpcmUoJy4uL2xpYi9tYXBzdG9yeS9NYXBDb25maWdUcmFuc2Zvcm1lci5qcycpLk1hcENvbmZpZ1RyYW5zZm9ybWVyO1xuXG5kZXNjcmliZSgnTWFwQ29uZmlnVHJhbnNmb3JtZXInLCBmdW5jdGlvbigpIHtcbiAgICBpdCgnc2hvdWxkIHRyYW5zZm9ybSBtYXAgaWQgMTE5MycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoJ3tcInNvdXJjZXNcIjoge1wiMVwiOiB7XCJoaWRkZW5cIjogdHJ1ZSwgXCJwdHlwZVwiOiBcImd4cF9tYXBxdWVzdHNvdXJjZVwiLCBcImlkXCI6IFwiMVwifSwgXCIwXCI6IHtcInB0eXBlXCI6IFwiZ3hfb2xzb3VyY2VcIiwgXCJpZFwiOiBcIjBcIn0sIFwiMlwiOiB7XCJoaWRkZW5cIjogdHJ1ZSwgXCJwdHlwZVwiOiBcImd4cF9tYXBib3hzb3VyY2VcIiwgXCJpZFwiOiBcIjJcIn0sIFwibG9jYWxcIjoge1widGl0bGVcIjogXCJNeSBHZW9TZXJ2ZXIgV01TXCIsIFwidXJsXCI6IFwiL2dlb3NlcnZlci9nZW9ub2RlL0JyZXdlcmllczAvd21zXCIsIFwiYmFzZVBhcmFtc1wiOiB7XCJWRVJTSU9OXCI6IFwiMS4xLjFcIiwgXCJSRVFVRVNUXCI6IFwiR2V0Q2FwYWJpbGl0aWVzXCIsIFwiVElMRURcIjogdHJ1ZSwgXCJTRVJWSUNFXCI6IFwiV01TXCJ9LCBcInB0eXBlXCI6IFwiZ3hwX3dtc2Nzb3VyY2VcIiwgXCJyZXN0VXJsXCI6IFwiL2dzL3Jlc3RcIiwgXCJoaWRkZW5cIjogdHJ1ZSwgXCJpZFwiOiBcImxvY2FsXCJ9fSwgXCJhYm91dFwiOiB7XCJhYnN0cmFjdFwiOiBcIlRoaXMgbWFwIHNob3dzIHRoZSBldm9sdXRpb24gYW5kIGRldmVsb3BtZW50IG9mIHRoZSAgYnJld2luZyBpbmR1c3RyeSBpbiB0aGUgVW5pdGVkIFN0YXRlcy4gVGhlIGluZm9ybWF0aW9uIGlzIG9idGFpbmVkIGZyb20gdGhlIGJvb2sgQW1lcmljYW4gQnJld2VyaWVzIElJIGJ5IERhbGUgUC4gVmFuIFdpZXJlbi4gVGhlIHNhbWUgaW5mb3JtYXRpb24gY291bGQgYWxzbyBiZSBhY2Nlc3NlZCBhdCB3d3cuYmVlcmJvb2tzLmNvbVwiLCBcInRpdGxlXCI6IFwiQ2hyb25vbG9neSBvZiB0aGUgQW1lcmljYW4gQnJld2luZyBJbmR1c3RyeVwifSwgXCJsb2NhbEdlb1NlcnZlckJhc2VVcmxcIjogXCJodHRwOi8vbWFwc3Rvcnkub3JnL2dlb3NlcnZlci9cIiwgXCJtYXBcIjoge1wibGF5ZXJzXCI6IFt7XCJvcGFjaXR5XCI6IDEuMCwgXCJhcmdzXCI6IFtcIk5vIGJhY2tncm91bmRcIl0sIFwiZ3JvdXBcIjogXCJiYWNrZ3JvdW5kXCIsIFwibmFtZVwiOiBcIk5vIGJhY2tncm91bmRcIiwgXCJ0aXRsZVwiOiBcIk5vIGJhY2tncm91bmRcIiwgXCJzZWxlY3RlZFwiOiBmYWxzZSwgXCJ2aXNpYmlsaXR5XCI6IGZhbHNlLCBcInNvdXJjZVwiOiBcIjBcIiwgXCJmaXhlZFwiOiB0cnVlLCBcInR5cGVcIjogXCJPcGVuTGF5ZXJzLkxheWVyXCJ9LCB7XCJvcGFjaXR5XCI6IDEuMCwgXCJhcmdzXCI6IFtcIk9wZW5TdHJlZXRNYXBcIl0sIFwiZ3JvdXBcIjogXCJiYWNrZ3JvdW5kXCIsIFwibmFtZVwiOiBcIk9wZW5TdHJlZXRNYXBcIiwgXCJ0aXRsZVwiOiBcIk9wZW5TdHJlZXRNYXBcIiwgXCJzZWxlY3RlZFwiOiBmYWxzZSwgXCJ2aXNpYmlsaXR5XCI6IHRydWUsIFwic291cmNlXCI6IFwiMFwiLCBcImZpeGVkXCI6IHRydWUsIFwidHlwZVwiOiBcIk9wZW5MYXllcnMuTGF5ZXIuT1NNXCJ9LCB7XCJvcGFjaXR5XCI6IDEuMCwgXCJhcmdzXCI6IFtcIkh1bWFuaXRhcmlhbiBPcGVuU3RyZWV0TWFwXCIsIFtcImh0dHA6Ly9hLnRpbGUub3BlbnN0cmVldG1hcC5mci9ob3QvJHt6fS8ke3h9LyR7eX0ucG5nXCIsIFwiaHR0cDovL2IudGlsZS5vcGVuc3RyZWV0bWFwLmZyL2hvdC8ke3p9LyR7eH0vJHt5fS5wbmdcIiwgXCJodHRwOi8vYy50aWxlLm9wZW5zdHJlZXRtYXAuZnIvaG90LyR7en0vJHt4fS8ke3l9LnBuZ1wiXSwge1widGlsZU9wdGlvbnNcIjoge1wiY3Jvc3NPcmlnaW5LZXl3b3JkXCI6IG51bGx9fV0sIFwiZ3JvdXBcIjogXCJiYWNrZ3JvdW5kXCIsIFwibmFtZVwiOiBcIkh1bWFuaXRhcmlhbiBPcGVuU3RyZWV0TWFwXCIsIFwidGl0bGVcIjogXCJIdW1hbml0YXJpYW4gT3BlblN0cmVldE1hcFwiLCBcInNlbGVjdGVkXCI6IGZhbHNlLCBcInZpc2liaWxpdHlcIjogZmFsc2UsIFwic291cmNlXCI6IFwiMFwiLCBcImZpeGVkXCI6IHRydWUsIFwidHlwZVwiOiBcIk9wZW5MYXllcnMuTGF5ZXIuT1NNXCJ9LCB7XCJvcGFjaXR5XCI6IDEuMCwgXCJhcmdzXCI6IFtcIk5ha2VkIEVhcnRoXCIsIFwiaHR0cDovL21hcHMub3Blbmdlby5vcmcvZ2Vvd2ViY2FjaGUvc2VydmljZS93bXNcIiwge1wibGF5ZXJzXCI6IFtcIldheW5lXCJdLCBcInRpbGVkXCI6IHRydWUsIFwidGlsZXNPcmlnaW5cIjogWy0yMDAzNzUwOC4zNCwgLTIwMDM3NTA4LjM0XSwgXCJmb3JtYXRcIjogXCJpbWFnZS9wbmdcIn0sIHtcImJ1ZmZlclwiOiAwfV0sIFwiZ3JvdXBcIjogXCJiYWNrZ3JvdW5kXCIsIFwibmFtZVwiOiBcIk5ha2VkIEVhcnRoXCIsIFwidGl0bGVcIjogXCJOYWtlZCBFYXJ0aFwiLCBcInNlbGVjdGVkXCI6IGZhbHNlLCBcInZpc2liaWxpdHlcIjogZmFsc2UsIFwic291cmNlXCI6IFwiMFwiLCBcImZpeGVkXCI6IHRydWUsIFwidHlwZVwiOiBcIk9wZW5MYXllcnMuTGF5ZXIuV01TXCJ9LCB7XCJvcGFjaXR5XCI6IDEuMCwgXCJncm91cFwiOiBcImJhY2tncm91bmRcIiwgXCJuYW1lXCI6IFwibmFpcFwiLCBcInRpdGxlXCI6IFwiU2F0ZWxsaXRlIEltYWdlcnlcIiwgXCJzZWxlY3RlZFwiOiBmYWxzZSwgXCJ2aXNpYmlsaXR5XCI6IGZhbHNlLCBcInNvdXJjZVwiOiBcIjFcIiwgXCJmaXhlZFwiOiB0cnVlfSwge1wib3BhY2l0eVwiOiAxLjAsIFwiZ3JvdXBcIjogXCJiYWNrZ3JvdW5kXCIsIFwibmFtZVwiOiBcIm5hdHVyYWwtZWFydGgtMVwiLCBcInRpdGxlXCI6IFwiTmF0dXJhbCBFYXJ0aFwiLCBcInNlbGVjdGVkXCI6IGZhbHNlLCBcInZpc2liaWxpdHlcIjogZmFsc2UsIFwic291cmNlXCI6IFwiMlwiLCBcImZpeGVkXCI6IGZhbHNlfSwge1wib3BhY2l0eVwiOiAxLjAsIFwiZ3JvdXBcIjogXCJiYWNrZ3JvdW5kXCIsIFwibmFtZVwiOiBcIm5hdHVyYWwtZWFydGgtMlwiLCBcInRpdGxlXCI6IFwiTmF0dXJhbCBFYXJ0aCAyXCIsIFwic2VsZWN0ZWRcIjogZmFsc2UsIFwidmlzaWJpbGl0eVwiOiBmYWxzZSwgXCJzb3VyY2VcIjogXCIyXCIsIFwiZml4ZWRcIjogZmFsc2V9LCB7XCJvcGFjaXR5XCI6IDEuMCwgXCJncm91cFwiOiBcImJhY2tncm91bmRcIiwgXCJuYW1lXCI6IFwiZ2VvZ3JhcGh5LWNsYXNzXCIsIFwidGl0bGVcIjogXCJHZW9ncmFwaHkgQ2xhc3NcIiwgXCJzZWxlY3RlZFwiOiBmYWxzZSwgXCJ2aXNpYmlsaXR5XCI6IGZhbHNlLCBcInNvdXJjZVwiOiBcIjJcIiwgXCJmaXhlZFwiOiBmYWxzZX0sIHtcIm9wYWNpdHlcIjogMS4wLCBcImdyb3VwXCI6IFwiYmFja2dyb3VuZFwiLCBcIm5hbWVcIjogXCJ3b3JsZC1saWdodFwiLCBcInRpdGxlXCI6IFwiV29ybGQgTGlnaHRcIiwgXCJzZWxlY3RlZFwiOiBmYWxzZSwgXCJ2aXNpYmlsaXR5XCI6IGZhbHNlLCBcInNvdXJjZVwiOiBcIjJcIiwgXCJmaXhlZFwiOiBmYWxzZX0sIHtcIm9wYWNpdHlcIjogMS4wLCBcInN0eWxlc1wiOiBcImdlb25vZGVfQnJld2VyaWVzXCIsIFwibmFtZVwiOiBcIkJyZXdlcmllczBcIiwgXCJmb3JtYXRcIjogXCJpbWFnZS9wbmdcIiwgXCJjYWNoZWRcIjogdHJ1ZSwgXCJzZWxlY3RlZFwiOiB0cnVlLCBcInZpc2liaWxpdHlcIjogdHJ1ZSwgXCJjYXBhYmlsaXR5XCI6IHtcImFic3RyYWN0XCI6IFwiXCIsIFwibmVzdGVkTGF5ZXJzXCI6IFtdLCBcImNhc2NhZGVkXCI6IDAsIFwiZml4ZWRIZWlnaHRcIjogMCwgXCJwcmVmaXhcIjogXCJCcmV3ZXJpZXMwXCIsIFwia2V5d29yZHNcIjogW10sIFwibm9TdWJzZXRzXCI6IGZhbHNlLCBcImRpbWVuc2lvbnNcIjoge1widGltZVwiOiB7XCJuZWFyZXN0VmFsXCI6IGZhbHNlLCBcIm11bHRpcGxlVmFsXCI6IGZhbHNlLCBcIm5hbWVcIjogXCJ0aW1lXCIsIFwiZGVmYXVsdFwiOiBcImN1cnJlbnRcIiwgXCJjdXJyZW50XCI6IGZhbHNlLCBcInVuaXRzXCI6IFwiSVNPODYwMVwiLCBcInZhbHVlc1wiOiBbXCIxNTg3LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNjA3LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNjA5LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNjEyLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNjE0LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNjIwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNjMyLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNjMzLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNjM0LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNjM3LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNjM5LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNjcwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNjgzLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNzM0LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNzM4LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNzY1LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNzc0LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNzg5LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNzkyLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxNzkzLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODA4LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODEwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODE5LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODI2LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODI5LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODMwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODMzLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODM2LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODM3LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODQwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODQ0LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODQ2LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODQ3LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODQ4LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODQ5LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODUwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODUyLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODUzLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODU0LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODU1LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODU2LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODU3LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODU5LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODYyLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODY1LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODY2LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODY3LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODY4LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODY5LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODcxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODcyLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODczLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODc1LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODc3LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODg0LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODg1LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODg3LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODg4LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODg5LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODkwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODkyLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODk4LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxODk5LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTAwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTA1LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTE2LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTIyLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTI2LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTM1LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTUxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTUzLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTU5LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTYyLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTY5LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTcyLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTc3LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTgyLTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTg0LTAxLTAxVDAwOjAwOjAwLjAwMFpcIiwgXCIxOTkwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIl0sIFwidW5pdHN5bWJvbFwiOiBudWxsfX0sIFwib3BhcXVlXCI6IGZhbHNlLCBcInRpbGVTZXRzXCI6IFt7XCJsYXllcnNcIjogXCJCcmV3ZXJpZXMwXCIsIFwic3R5bGVzXCI6IFwiXCIsIFwiZm9ybWF0XCI6IFwiaW1hZ2UvcG5nXCIsIFwiaGVpZ2h0XCI6IDI1NiwgXCJzcnNcIjoge1wiRVBTRzo5MDA5MTNcIjogdHJ1ZX0sIFwiYmJveFwiOiB7XCJFUFNHOjkwMDkxM1wiOiB7XCJzcnNcIjogXCJFUFNHOjkwMDkxM1wiLCBcImJib3hcIjogWy0yMDAzNzUwOC4zNCwgMCwgMCwgMjAwMzc1MDguMzRdfX0sIFwicmVzb2x1dGlvbnNcIjogWzE1NjU0My4wMzM5MDYyNSwgNzgyNzEuNTE2OTUzMTI0OTk5LCAzOTEzNS43NTg0NzY1NjI1LCAxOTU2Ny44NzkyMzgyODEyNSwgOTc4My45Mzk2MTkxNDA2MjQ5LCA0ODkxLjk2OTgwOTU3MDMxMjUsIDI0NDUuOTg0OTA0Nzg1MTU2MiwgMTIyMi45OTI0NTIzOTI1NzgxLCA2MTEuNDk2MjI2MTk2Mjg5MDYsIDMwNS43NDgxMTMwOTgxNDQ1MywgMTUyLjg3NDA1NjU0OTA3MjI2LCA3Ni40MzcwMjgyNzQ1MzYxMzIsIDM4LjIxODUxNDEzNzI2ODA2NiwgMTkuMTA5MjU3MDY4NjM0MDMzLCA5LjU1NDYyODUzNDMxNzAxNjUsIDQuNzc3MzE0MjY3MTU4NTA4MywgMi4zODg2NTcxMzM1NzkyNTQxLCAxLjE5NDMyODU2Njc4OTYyNzEsIDAuNTk3MTY0MjgzMzk0ODEzNTMsIDAuMjk4NTgyMTQxNjk3NDA2NzcsIDAuMTQ5MjkxMDcwODQ4NzAzMzgsIDAuMDc0NjQ1NTM1NDI0MzUxNjkyLCAwLjAzNzMyMjc2NzcxMjE3NTg0NiwgMC4wMTg2NjEzODM4NTYwODc5MjMsIDAuMDA5MzMwNjkxOTI4MDQzOTYxNSwgMC4wMDQ2NjUzNDU5NjQwMjE5ODA3LCAwLjAwMjMzMjY3Mjk4MjAxMDk5MDQsIDAuMDAxMTY2MzM2NDkxMDA1NDk1MiwgMC4wMDA1ODMxNjgyNDU1MDI3NDc1OSwgMC4wMDAyOTE1ODQxMjI3NTEzNzM4LCAwLjAwMDE0NTc5MjA2MTM3NTY4NjldLCBcIndpZHRoXCI6IDI1Nn1dLCBcImluZm9Gb3JtYXRzXCI6IFtcInRleHQvcGxhaW5cIiwgXCJhcHBsaWNhdGlvbi92bmQub2djLmdtbFwiLCBcImFwcGxpY2F0aW9uL3ZuZC5vZ2MuZ21sLzMuMS4xXCIsIFwidGV4dC9odG1sXCIsIFwiYXBwbGljYXRpb24vanNvblwiXSwgXCJzdHlsZXNcIjogW3tcImFic3RyYWN0XCI6IFwiXCIsIFwidGl0bGVcIjogXCJhenVyZSBzcXVhcmUgcG9pbnQgc3R5bGVcIiwgXCJsZWdlbmRcIjoge1wiaGVpZ2h0XCI6IFwiMjBcIiwgXCJ3aWR0aFwiOiBcIjIwXCIsIFwiaHJlZlwiOiBcImh0dHA6Ly9tYXBzdG9yeS5vcmc6ODAvZ2Vvc2VydmVyL2dlb25vZGUvQnJld2VyaWVzMC93bXM/cmVxdWVzdD1HZXRMZWdlbmRHcmFwaGljJmZvcm1hdD1pbWFnZSUyRnBuZyZ3aWR0aD0yMCZoZWlnaHQ9MjAmbGF5ZXI9QnJld2VyaWVzMFwiLCBcImZvcm1hdFwiOiBcImltYWdlL3BuZ1wifSwgXCJuYW1lXCI6IFwiZ2Vvbm9kZV9CcmV3ZXJpZXNcIn1dLCBcImF0dHJpYnV0aW9uXCI6IHtcInRpdGxlXCI6IFwiYWRtaW5cIn0sIFwiYXV0aG9yaXR5VVJMc1wiOiB7fSwgXCJiYm94XCI6IHtcIkVQU0c6NDMyNlwiOiB7XCJzcnNcIjogXCJFUFNHOjQzMjZcIiwgXCJiYm94XCI6IFstMTU3LjgxNjY2NywgMjEuMzAwMDAwMDAwMDAwMDAxLCAtNjkuNzgwMDAwMDAwMDAwMDAxLCA0Ni42MDE5NDQwMDAwMDAwMDNdfX0sIFwiZml4ZWRXaWR0aFwiOiAwLCBcIm1ldGFkYXRhVVJMc1wiOiBbXSwgXCJuYW1lXCI6IFwiQnJld2VyaWVzMFwiLCBcImlkZW50aWZpZXJzXCI6IHt9LCBcInNyc1wiOiB7XCJFUFNHOjkwMDkxM1wiOiB0cnVlfSwgXCJmb3JtYXRzXCI6IFtcImltYWdlL3BuZ1wiLCBcImFwcGxpY2F0aW9uL2F0b20geG1sXCIsIFwiYXBwbGljYXRpb24vYXRvbSt4bWxcIiwgXCJhcHBsaWNhdGlvbi9vcGVubGF5ZXJzXCIsIFwiYXBwbGljYXRpb24vcGRmXCIsIFwiYXBwbGljYXRpb24vcnNzIHhtbFwiLCBcImFwcGxpY2F0aW9uL3Jzcyt4bWxcIiwgXCJhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmttbFwiLCBcImFwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua21sIHhtbFwiLCBcImFwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua21sK3htbFwiLCBcImFwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua21sK3htbDttb2RlPW5ldHdvcmtsaW5rXCIsIFwiYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbXpcIiwgXCJhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmtteiB4bWxcIiwgXCJhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmtteit4bWxcIiwgXCJhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmttejttb2RlPW5ldHdvcmtsaW5rXCIsIFwiYXRvbVwiLCBcImltYWdlL2dlb3RpZmZcIiwgXCJpbWFnZS9nZW90aWZmOFwiLCBcImltYWdlL2dpZlwiLCBcImltYWdlL2dpZjtzdWJ0eXBlPWFuaW1hdGVkXCIsIFwiaW1hZ2UvanBlZ1wiLCBcImltYWdlL3BuZzhcIiwgXCJpbWFnZS9wbmc7IG1vZGU9OGJpdFwiLCBcImltYWdlL3N2Z1wiLCBcImltYWdlL3N2ZyB4bWxcIiwgXCJpbWFnZS9zdmcreG1sXCIsIFwiaW1hZ2UvdGlmZlwiLCBcImltYWdlL3RpZmY4XCIsIFwia21sXCIsIFwia216XCIsIFwib3BlbmxheWVyc1wiLCBcInJzc1wiXSwgXCJ0aXRsZVwiOiBcIkJyZXdlcmllczBcIiwgXCJxdWVyeWFibGVcIjogdHJ1ZSwgXCJsbGJib3hcIjogWy0xNTcuODE2NjY3LCAyMS4zMDAwMDAwMDAwMDAwMDEsIC02OS43ODAwMDAwMDAwMDAwMDEsIDQ2LjYwMTk0NDAwMDAwMDAwM119LCBcInNvdXJjZVwiOiBcImxvY2FsXCIsIFwidGlsZWRcIjogZmFsc2UsIFwidGl0bGVcIjogXCJCcmV3ZXJpZXMwXCIsIFwiZml4ZWRcIjogZmFsc2UsIFwidHJhbnNwYXJlbnRcIjogdHJ1ZX1dLCBcIndyYXBEYXRlTGluZVwiOiBmYWxzZSwgXCJwcm9qZWN0aW9uXCI6IFwiRVBTRzo5MDA5MTNcIiwgXCJjZW50ZXJcIjogWy0xMjY2Nzk3Mi41MzY1OCwgNDE1MjUxNC4wMzAwODM3MDAxXSwgXCJ6b29tXCI6IDQsIFwidW5pdHNcIjogXCJtXCIsIFwibWF4UmVzb2x1dGlvblwiOiAxNTY1NDMuMDMzOTA2MjUsIFwibWF4RXh0ZW50XCI6IFstMjAwMzc1MDguMzQsIC0yMDAzNzUwOC4zNCwgMjAwMzc1MDguMzQsIDIwMDM3NTA4LjM0XSwgXCJudW1ab29tTGV2ZWxzXCI6IDIyfSwgXCJkZWZhdWx0U291cmNlVHlwZVwiOiBcImd4cF93bXNjc291cmNlXCIsIFwiYXBpS2V5c1wiOiB7XCJnb29nbGVcIjogXCJBQlFJQUFBQWtvZm9vWnhUZmNDdjlXaTN6ekdUVnhUbm1lNUV3bkxWdEVER25oLWxGVnpSSmhiZFFoUWdBaEIxZVRfMm11WnRjMGRsLVpTV3J0em1yd1wifSwgXCJ0b29sc1wiOiBbe1wib3V0cHV0Q29uZmlnXCI6IHtcImxvb3BlZFwiOiB0cnVlLCBcImxheW91dFwiOiBcInRvb2xiYXJcIiwgXCJ4dHlwZVwiOiBcImFwcF9wbGF5YmFja3Rvb2xiYXJcIiwgXCJoaWRlUGFyZW50XCI6IHRydWUsIFwiY29udHJvbENvbmZpZ1wiOiB7XCJ0aW1lU3RlcFwiOiBudWxsLCBcImFuaW1hdGlvblJhbmdlXCI6IFstMTIwODYzMjMyMDAwMDAsIDYzMTE1MjAwMDAwMF0sIFwic25hcFRvTGlzdFwiOiB0cnVlLCBcIm1vZGVsXCI6IHtcInJhbmdlXCI6IFstMTIwODYzMjMyMDAwMDAsIDYzMTE1MjAwMDAwMF0sIFwidmFsdWVzXCI6IFstMTIwODYzMjMyMDAwMDAsIC0xMTQ1NTE3MTIwMDAwMCwgLTExMzkyMDEyODAwMDAwLCAtMTEyOTc0MDQ4MDAwMDAsIC0xMTIzNDI0NjQwMDAwMCwgLTExMDQ0OTQ0MDAwMDAwLCAtMTA2NjYyNTI4MDAwMDAsIC0xMDYzNDYzMDQwMDAwMCwgLTEwNjAzMDk0NDAwMDAwLCAtMTA1MDg0MDAwMDAwMDAsIC0xMDQ0NTMyODAwMDAwMCwgLTk0NjcwMjA4MDAwMDAsIC05MDU2NzkzNjAwMDAwLCAtNzQ0NzQyMDgwMDAwMCwgLTczMjExOTA0MDAwMDAsIC02NDY5MTEzNjAwMDAwLCAtNjE4NTExNjgwMDAwMCwgLTU3MTE3MzEyMDAwMDAsIC01NjE3MTIzMjAwMDAwLCAtNTU4NTUwMDgwMDAwMCwgLTUxMTIyODgwMDAwMDAsIC01MDQ5MTI5NjAwMDAwLCAtNDc2NTEzMjgwMDAwMCwgLTQ1NDQyMDgwMDAwMDAsIC00NDQ5NTEzNjAwMDAwLCAtNDQxNzk3NzYwMDAwMCwgLTQzMjMyODMyMDAwMDAsIC00MjI4Njc1MjAwMDAwLCAtNDE5NzA1MjgwMDAwMCwgLTQxMDI0NDQ4MDAwMDAsIC0zOTc2MjE0NDAwMDAwLCAtMzkxMzA1NjAwMDAwMCwgLTM4ODE1MjAwMDAwMDAsIC0zODQ5OTg0MDAwMDAwLCAtMzgxODM2MTYwMDAwMCwgLTM3ODY4MjU2MDAwMDAsIC0zNzIzNzUzNjAwMDAwLCAtMzY5MjEzMTIwMDAwMCwgLTM2NjA1OTUyMDAwMDAsIC0zNjI5MDU5MjAwMDAwLCAtMzU5NzUyMzIwMDAwMCwgLTM1NjU5MDA4MDAwMDAsIC0zNTAyODI4ODAwMDAwLCAtMzQwODEzNDQwMDAwMCwgLTMzMTM0NDAwMDAwMDAsIC0zMjgxOTA0MDAwMDAwLCAtMzI1MDM2ODAwMDAwMCwgLTMyMTg4MzIwMDAwMDAsIC0zMTg3MjA5NjAwMDAwLCAtMzEyNDEzNzYwMDAwMCwgLTMwOTI2MDE2MDAwMDAsIC0zMDYwOTc5MjAwMDAwLCAtMjk5NzkwNzIwMDAwMCwgLTI5MzQ3NDg4MDAwMDAsIC0yNzEzOTEwNDAwMDAwLCAtMjY4MjI4ODAwMDAwMCwgLTI2MTkyMTYwMDAwMDAsIC0yNTg3NjgwMDAwMDAwLCAtMjU1NjA1NzYwMDAwMCwgLTI1MjQ1MjE2MDAwMDAsIC0yNDYxNDQ5NjAwMDAwLCAtMjI3MjA2MDgwMDAwMCwgLTIyNDA1MjQ4MDAwMDAsIC0yMjA4OTg4ODAwMDAwLCAtMjE3NzQ1MjgwMDAwMCwgLTIwNTEyMjI0MDAwMDAsIC0xNzA0MTUzNjAwMDAwLCAtMTUxNDc2NDgwMDAwMCwgLTEzODg1MzQ0MDAwMDAsIC0xMTA0NTM3NjAwMDAwLCAtNTk5NjE2MDAwMDAwLCAtNTM2NDU3NjAwMDAwLCAtMzQ3MTU1MjAwMDAwLCAtMjUyNDYwODAwMDAwLCAtMzE1MzYwMDAwMDAsIDYzMDcyMDAwMDAwLCAyMjA5MjQ4MDAwMDAsIDM3ODY5MTIwMDAwMCwgNDQxNzYzMjAwMDAwLCA2MzExNTIwMDAwMDBdLCBcImRpbWVuc2lvblwiOiBcInRpbWVcIn0sIFwiZGltZW5zaW9uXCI6IFwidGltZVwiLCBcImxvb3BcIjogdHJ1ZX0sIFwibGlzdGVuZXJzXCI6IHtcInNpbmdsZVwiOiB0cnVlfSwgXCJyZW1vdmVNb2RlXCI6IFwiY29udGFpbmVyXCIsIFwicGxheWJhY2tNb2RlXCI6IFwiY3VtdWxhdGl2ZVwiLCBcImRlZmF1bHRzXCI6IHtcInNjYWxlXCI6IFwibWVkaXVtXCJ9LCBcImF1dG9QbGF5XCI6IGZhbHNlfSwgXCJsb29wZWRcIjogdHJ1ZSwgXCJvdXRwdXRUYXJnZXRcIjogXCJtYXAtYmJhclwiLCBcInB0eXBlXCI6IFwiZ3hwX3BsYXliYWNrXCIsIFwiaWRcIjogXCJwbGF5YmFjay10b29sXCJ9LCB7XCJiZ0NvbG9yXCI6IFwiIzQ1NDIzOFwiLCBcIndyYXBEYXRlTGluZVwiOiBmYWxzZSwgXCJwdHlwZVwiOiBcIm1zLXRvb2wtYmFyXCIsIFwibnVtWm9vbUxldmVsc1wiOiAyMn0sIHtcInBsYXliYWNrVG9vbFwiOiBcInBsYXliYWNrLXRvb2xcIiwgXCJvdXRwdXRDb25maWdcIjoge1widGl0bGVcIjogbnVsbH0sIFwib3V0cHV0VGFyZ2V0XCI6IFwidGltZWxpbmUtY29udGFpbmVyXCIsIFwicHR5cGVcIjogXCJneHBfdGltZWxpbmVcIiwgXCJpZFwiOiBcInRpbWVsaW5lLXRvb2xcIn1dLCBcImF1dGhvcml6ZWRSb2xlc1wiOiBbXCJST0xFX0FOT05ZTU9VU1wiXSwgXCJpZFwiOiAxMTkzfScpO1xuICAgICAgICB2YXIgY29uZmlnID0gTWFwQ29uZmlnVHJhbnNmb3JtZXIoZGF0YSk7XG4gICAgICAgIGV4cGVjdChKU09OLnN0cmluZ2lmeShjb25maWcpKS50b0JlKCd7XCJpZFwiOjExOTMsXCJwbGF5YmFja01vZGVcIjpcImN1bXVsYXRpdmVcIixcIm1hcFwiOntcImNlbnRlclwiOlstMTI2Njc5NzIuNTM2NTgsNDE1MjUxNC4wMzAwODM3XSxcInByb2plY3Rpb25cIjpcIkVQU0c6OTAwOTEzXCIsXCJ6b29tXCI6NCxcImxheWVyc1wiOlt7XCJ2aXNpYmlsaXR5XCI6dHJ1ZSxcImdyb3VwXCI6XCJiYWNrZ3JvdW5kXCIsXCJ0eXBlXCI6XCJPU01cIixcInRpdGxlXCI6XCJPcGVuU3RyZWV0TWFwXCJ9LHtcInZpc2liaWxpdHlcIjp0cnVlLFwidHlwZVwiOlwiV01TXCIsXCJzaW5nbGVUaWxlXCI6dHJ1ZSxcImlkXCI6XCJCcmV3ZXJpZXMwXCIsXCJuYW1lXCI6XCJCcmV3ZXJpZXMwXCIsXCJ0aXRsZVwiOlwiQnJld2VyaWVzMFwiLFwidXJsXCI6XCIvZ2Vvc2VydmVyL2dlb25vZGUvQnJld2VyaWVzMC93bXNcIixcInBhcmFtc1wiOntcIkxBWUVSU1wiOlwiQnJld2VyaWVzMFwiLFwiU1RZTEVTXCI6XCJnZW9ub2RlX0JyZXdlcmllc1wiLFwiVElMRURcIjpcIlRSVUVcIixcIkZPUk1BVFwiOlwiaW1hZ2UvcG5nXCIsXCJUUkFOU1BBUkVOVFwiOnRydWUsXCJWRVJTSU9OXCI6XCIxLjEuMVwifSxcImxhdGxvbkJCT1hcIjpbLTE1Ny44MTY2NjcsMjEuMywtNjkuNzgsNDYuNjAxOTQ0XSxcInRpbWVzXCI6Wy0xMjA4NjMyMzIwMDAwMCwtMTE0NTUxNzEyMDAwMDAsLTExMzkyMDEyODAwMDAwLC0xMTI5NzQwNDgwMDAwMCwtMTEyMzQyNDY0MDAwMDAsLTExMDQ0OTQ0MDAwMDAwLC0xMDY2NjI1MjgwMDAwMCwtMTA2MzQ2MzA0MDAwMDAsLTEwNjAzMDk0NDAwMDAwLC0xMDUwODQ4NjQwMDAwMCwtMTA0NDU0MTQ0MDAwMDAsLTk0NjcxMDcyMDAwMDAsLTkwNTY4ODAwMDAwMDAsLTc0NDc0MjA4MDAwMDAsLTczMjExOTA0MDAwMDAsLTY0NjkxMTM2MDAwMDAsLTYxODUyMDMyMDAwMDAsLTU3MTE4MTc2MDAwMDAsLTU2MTcyMDk2MDAwMDAsLTU1ODU1ODcyMDAwMDAsLTUxMTIyODgwMDAwMDAsLTUwNDkxMjk2MDAwMDAsLTQ3NjUxMzI4MDAwMDAsLTQ1NDQyMDgwMDAwMDAsLTQ0NDk1MTM2MDAwMDAsLTQ0MTc5Nzc2MDAwMDAsLTQzMjMyODMyMDAwMDAsLTQyMjg2NzUyMDAwMDAsLTQxOTcwNTI4MDAwMDAsLTQxMDI0NDQ4MDAwMDAsLTM5NzYyMTQ0MDAwMDAsLTM5MTMwNTYwMDAwMDAsLTM4ODE1MjAwMDAwMDAsLTM4NDk5ODQwMDAwMDAsLTM4MTgzNjE2MDAwMDAsLTM3ODY4MjU2MDAwMDAsLTM3MjM3NTM2MDAwMDAsLTM2OTIxMzEyMDAwMDAsLTM2NjA1OTUyMDAwMDAsLTM2MjkwNTkyMDAwMDAsLTM1OTc1MjMyMDAwMDAsLTM1NjU5MDA4MDAwMDAsLTM1MDI4Mjg4MDAwMDAsLTM0MDgxMzQ0MDAwMDAsLTMzMTM0NDAwMDAwMDAsLTMyODE5MDQwMDAwMDAsLTMyNTAzNjgwMDAwMDAsLTMyMTg4MzIwMDAwMDAsLTMxODcyMDk2MDAwMDAsLTMxMjQxMzc2MDAwMDAsLTMwOTI2MDE2MDAwMDAsLTMwNjA5NzkyMDAwMDAsLTI5OTc5MDcyMDAwMDAsLTI5MzQ3NDg4MDAwMDAsLTI3MTM5MTA0MDAwMDAsLTI2ODIyODgwMDAwMDAsLTI2MTkyMTYwMDAwMDAsLTI1ODc2ODAwMDAwMDAsLTI1NTYwNTc2MDAwMDAsLTI1MjQ1MjE2MDAwMDAsLTI0NjE0NDk2MDAwMDAsLTIyNzIwNjA4MDAwMDAsLTIyNDA1MjQ4MDAwMDAsLTIyMDg5ODg4MDAwMDAsLTIxNzc0NTI4MDAwMDAsLTIwNTEyMjI0MDAwMDAsLTE3MDQxNTM2MDAwMDAsLTE1MTQ3NjQ4MDAwMDAsLTEzODg1MzQ0MDAwMDAsLTExMDQ1Mzc2MDAwMDAsLTU5OTYxNjAwMDAwMCwtNTM2NDU3NjAwMDAwLC0zNDcxNTUyMDAwMDAsLTI1MjQ2MDgwMDAwMCwtMzE1MzYwMDAwMDAsNjMwNzIwMDAwMDAsMjIwOTI0ODAwMDAwLDM3ODY5MTIwMDAwMCw0NDE3NjMyMDAwMDAsNjMxMTUyMDAwMDAwXSxcImJib3hcIjpbLTIwMDM3NTA4LjM0LDAsMCwyMDAzNzUwOC4zNF0sXCJyZXNvbHV0aW9uc1wiOlsxNTY1NDMuMDMzOTA2MjUsNzgyNzEuNTE2OTUzMTI1LDM5MTM1Ljc1ODQ3NjU2MjUsMTk1NjcuODc5MjM4MjgxMjUsOTc4My45Mzk2MTkxNDA2MjUsNDg5MS45Njk4MDk1NzAzMTI1LDI0NDUuOTg0OTA0Nzg1MTU2MiwxMjIyLjk5MjQ1MjM5MjU3ODEsNjExLjQ5NjIyNjE5NjI4OTEsMzA1Ljc0ODExMzA5ODE0NDUzLDE1Mi44NzQwNTY1NDkwNzIyNiw3Ni40MzcwMjgyNzQ1MzYxMywzOC4yMTg1MTQxMzcyNjgwNjYsMTkuMTA5MjU3MDY4NjM0MDMzLDkuNTU0NjI4NTM0MzE3MDE3LDQuNzc3MzE0MjY3MTU4NTA4LDIuMzg4NjU3MTMzNTc5MjU0LDEuMTk0MzI4NTY2Nzg5NjI3LDAuNTk3MTY0MjgzMzk0ODEzNSwwLjI5ODU4MjE0MTY5NzQwNjc3LDAuMTQ5MjkxMDcwODQ4NzAzMzgsMC4wNzQ2NDU1MzU0MjQzNTE2OSwwLjAzNzMyMjc2NzcxMjE3NTg0NiwwLjAxODY2MTM4Mzg1NjA4NzkyMywwLjAwOTMzMDY5MTkyODA0Mzk2MSwwLjAwNDY2NTM0NTk2NDAyMTk4MSwwLjAwMjMzMjY3Mjk4MjAxMDk5MDQsMC4wMDExNjYzMzY0OTEwMDU0OTUyLDAuMDAwNTgzMTY4MjQ1NTAyNzQ3NiwwLjAwMDI5MTU4NDEyMjc1MTM3MzgsMC4wMDAxNDU3OTIwNjEzNzU2ODY5XX1dfX0nKTtcbiAgICB9KTtcbn0pO1xuIiwidmFyIFNMRFN0eWxlQ29udmVydGVyID0gcmVxdWlyZSgnLi4vbGliL2VkaXQvc3R5bGUvU0xEU3R5bGVDb252ZXJ0ZXIuanMnKS5TTERTdHlsZUNvbnZlcnRlcjtcbnZhciBpbnN0YW5jZSA9IG5ldyBTTERTdHlsZUNvbnZlcnRlcigpO1xuXG5kZXNjcmliZSgnU0xEU3R5bGVDb252ZXJ0ZXInLCBmdW5jdGlvbigpIHtcblxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGphc21pbmUuYWRkTWF0Y2hlcnMoY3VzdG9tTWF0Y2hlcnMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjb252ZXJ0IHNpbXBsZSB0eXBlcyAocG9pbnQpJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdHlsZUNvbmZpZyA9IHtcbiAgICAgICAgICAgIFwidHlwZU5hbWVcIjogXCJzaW1wbGVcIixcbiAgICAgICAgICAgIFwic3ltYm9sXCI6IHtcbiAgICAgICAgICAgICAgICBcInNpemVcIjogMTAsXG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcImNpcmNsZVwiLFxuICAgICAgICAgICAgICAgIFwiZ3JhcGhpY1wiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwiZ3JhcGhpY1R5cGVcIjogbnVsbCxcbiAgICAgICAgICAgICAgICBcImZpbGxDb2xvclwiOiBcIiNmZjAwMDBcIixcbiAgICAgICAgICAgICAgICBcImZpbGxPcGFjaXR5XCI6IDgwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogXCIjZmZmZjAwXCIsXG4gICAgICAgICAgICAgICAgXCJzdHJva2VXaWR0aFwiOiAzLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlU3R5bGVcIjogXCJkb3R0ZWRcIixcbiAgICAgICAgICAgICAgICBcInN0cm9rZU9wYWNpdHlcIjogOTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdlb21UeXBlXCI6IFwicG9pbnRcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgc3R5bGUgPSBpbnN0YW5jZS5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnLCAnc2ltcGxlJyk7XG4gICAgICAgIGV4cGVjdChzdHlsZSkudG9CZVhNTCgnPHNsZDpTdHlsZWRMYXllckRlc2NyaXB0b3IgeG1sbnM6c2xkPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9zbGRcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4bWxuczpvZ2M9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiIHZlcnNpb249XCIxLjAuMFwiPjxzbGQ6TmFtZWRMYXllcj48c2xkOk5hbWU+c2ltcGxlPC9zbGQ6TmFtZT48c2xkOlVzZXJTdHlsZT48c2xkOkZlYXR1cmVUeXBlU3R5bGU+PHNsZDpSdWxlPjxzbGQ6UG9pbnRTeW1ib2xpemVyPjxzbGQ6R3JhcGhpYz48c2xkOk1hcms+PHNsZDpXZWxsS25vd25OYW1lPmNpcmNsZTwvc2xkOldlbGxLbm93bk5hbWU+PHNsZDpGaWxsPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsXCI+I2ZmMDAwMDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbC1vcGFjaXR5XCI+MC44PC9zbGQ6Q3NzUGFyYW1ldGVyPjwvc2xkOkZpbGw+PHNsZDpTdHJva2U+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZVwiPiNmZmZmMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS13aWR0aFwiPjM8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1vcGFjaXR5XCI+MC45PC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2UtZGFzaGFycmF5XCI+MSAyPC9zbGQ6Q3NzUGFyYW1ldGVyPjwvc2xkOlN0cm9rZT48L3NsZDpNYXJrPjxzbGQ6T3BhY2l0eT4wLjg8L3NsZDpPcGFjaXR5PjxzbGQ6U2l6ZT4xMDwvc2xkOlNpemU+PC9zbGQ6R3JhcGhpYz48L3NsZDpQb2ludFN5bWJvbGl6ZXI+PC9zbGQ6UnVsZT48L3NsZDpGZWF0dXJlVHlwZVN0eWxlPjwvc2xkOlVzZXJTdHlsZT48L3NsZDpOYW1lZExheWVyPjwvc2xkOlN0eWxlZExheWVyRGVzY3JpcHRvcj4nKTtcbiAgICAgICAgLy8gc3ZnIHN5bWJvbCAoZ3JhcGhpYylcbiAgICAgICAgc3R5bGVDb25maWcgPSB7XG4gICAgICAgICAgICBcInR5cGVOYW1lXCI6IFwic2ltcGxlXCIsXG4gICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaXplXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogbnVsbCxcbiAgICAgICAgICAgICAgICBcImdyYXBoaWNcIjogXCJpY29uLnN2Z1wiLFxuICAgICAgICAgICAgICAgIFwiZ3JhcGhpY1R5cGVcIjogbnVsbCxcbiAgICAgICAgICAgICAgICBcImZpbGxDb2xvclwiOiBcIiNmZjAwMDBcIixcbiAgICAgICAgICAgICAgICBcImZpbGxPcGFjaXR5XCI6IDgwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogXCIjZmZmZjAwXCIsXG4gICAgICAgICAgICAgICAgXCJzdHJva2VXaWR0aFwiOiAzLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlU3R5bGVcIjogXCJzb2xpZFwiLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlT3BhY2l0eVwiOiA5MFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2VvbVR5cGVcIjogXCJwb2ludFwiXG4gICAgICAgIH07XG4gICAgICAgIHN0eWxlID0gaW5zdGFuY2UuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZywgJ3NpbXBsZScpO1xuICAgICAgICBleHBlY3Qoc3R5bGUpLnRvQmVYTUwoJzxzbGQ6U3R5bGVkTGF5ZXJEZXNjcmlwdG9yIHhtbG5zOnNsZD1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvc2xkXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeG1sbnM6b2djPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIiB2ZXJzaW9uPVwiMS4wLjBcIj48c2xkOk5hbWVkTGF5ZXI+PHNsZDpOYW1lPnNpbXBsZTwvc2xkOk5hbWU+PHNsZDpVc2VyU3R5bGU+PHNsZDpGZWF0dXJlVHlwZVN0eWxlPjxzbGQ6UnVsZT48c2xkOlBvaW50U3ltYm9saXplcj48c2xkOkdyYXBoaWM+PHNsZDpFeHRlcm5hbEdyYXBoaWM+PHNsZDpPbmxpbmVSZXNvdXJjZSB4bGluazpocmVmPVwiaHR0cDovL2xvY2FsaG9zdDo5ODc2L2ljb24uc3ZnP2ZpbGw9JTIzZmYwMDAwJmFtcDtzdHJva2U9JTIzZmZmZjAwXCIvPjxzbGQ6Rm9ybWF0PmltYWdlL3N2Zyt4bWw8L3NsZDpGb3JtYXQ+PC9zbGQ6RXh0ZXJuYWxHcmFwaGljPjxzbGQ6T3BhY2l0eT4wLjg8L3NsZDpPcGFjaXR5PjxzbGQ6U2l6ZT4xMDwvc2xkOlNpemU+PC9zbGQ6R3JhcGhpYz48L3NsZDpQb2ludFN5bWJvbGl6ZXI+PC9zbGQ6UnVsZT48L3NsZDpGZWF0dXJlVHlwZVN0eWxlPjwvc2xkOlVzZXJTdHlsZT48L3NsZDpOYW1lZExheWVyPjwvc2xkOlN0eWxlZExheWVyRGVzY3JpcHRvcj4nKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY29udmVydCBzaW1wbGUgdHlwZXMgKGxpbmUpJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdHlsZUNvbmZpZyA9IHtcbiAgICAgICAgICAgIFwidHlwZU5hbWVcIjogXCJzaW1wbGUgbGluZVwiLFxuICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogXCIjZmZmZjAwXCIsXG4gICAgICAgICAgICAgICAgXCJzdHJva2VXaWR0aFwiOiAzLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlU3R5bGVcIjogXCJkYXNoZWRcIixcbiAgICAgICAgICAgICAgICBcInN0cm9rZU9wYWNpdHlcIjogOTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdlb21UeXBlXCI6IFwibGluZVwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHlsZSA9IGluc3RhbmNlLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsICdzaW1wbGUgbGluZScpO1xuICAgICAgICBleHBlY3Qoc3R5bGUpLnRvQmVYTUwoJzxzbGQ6U3R5bGVkTGF5ZXJEZXNjcmlwdG9yIHhtbG5zOnNsZD1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvc2xkXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeG1sbnM6b2djPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIiB2ZXJzaW9uPVwiMS4wLjBcIj48c2xkOk5hbWVkTGF5ZXI+PHNsZDpOYW1lPnNpbXBsZSBsaW5lPC9zbGQ6TmFtZT48c2xkOlVzZXJTdHlsZT48c2xkOkZlYXR1cmVUeXBlU3R5bGU+PHNsZDpSdWxlPjxzbGQ6TGluZVN5bWJvbGl6ZXI+PHNsZDpTdHJva2U+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZVwiPiNmZmZmMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS13aWR0aFwiPjM8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1vcGFjaXR5XCI+MC45PC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2UtZGFzaGFycmF5XCI+NTwvc2xkOkNzc1BhcmFtZXRlcj48L3NsZDpTdHJva2U+PC9zbGQ6TGluZVN5bWJvbGl6ZXI+PC9zbGQ6UnVsZT48L3NsZDpGZWF0dXJlVHlwZVN0eWxlPjwvc2xkOlVzZXJTdHlsZT48L3NsZDpOYW1lZExheWVyPjwvc2xkOlN0eWxlZExheWVyRGVzY3JpcHRvcj4nKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY29udmVydCBzaW1wbGUgdHlwZXMgKHBvbHlnb24pJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdHlsZUNvbmZpZyA9IHtcbiAgICAgICAgICAgIFwidHlwZU5hbWVcIjogXCJzaW1wbGUgcG9seWdvblwiLFxuICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiI2ZmMDAwMFwiLFxuICAgICAgICAgICAgICAgIFwiZmlsbE9wYWNpdHlcIjogODBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzdHJva2VDb2xvclwiOiBcIiNmZmZmMDBcIixcbiAgICAgICAgICAgICAgICBcInN0cm9rZVdpZHRoXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJzdHJva2VTdHlsZVwiOiBcImRhc2hlZFwiLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlT3BhY2l0eVwiOiA5MFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2VvbVR5cGVcIjogXCJwb2x5Z29uXCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0eWxlID0gaW5zdGFuY2UuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZywgJ3NpbXBsZSBwb2x5Z29uJyk7XG4gICAgICAgIGV4cGVjdChzdHlsZSkudG9CZVhNTCgnPHNsZDpTdHlsZWRMYXllckRlc2NyaXB0b3IgeG1sbnM6c2xkPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9zbGRcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4bWxuczpvZ2M9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiIHZlcnNpb249XCIxLjAuMFwiPjxzbGQ6TmFtZWRMYXllcj48c2xkOk5hbWU+c2ltcGxlIHBvbHlnb248L3NsZDpOYW1lPjxzbGQ6VXNlclN0eWxlPjxzbGQ6RmVhdHVyZVR5cGVTdHlsZT48c2xkOlJ1bGU+PHNsZDpQb2x5Z29uU3ltYm9saXplcj48c2xkOkZpbGw+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGxcIj4jZmYwMDAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsLW9wYWNpdHlcIj4wLjg8L3NsZDpDc3NQYXJhbWV0ZXI+PC9zbGQ6RmlsbD48c2xkOlN0cm9rZT48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlXCI+I2ZmZmYwMDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLXdpZHRoXCI+Mzwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLW9wYWNpdHlcIj4wLjk8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1kYXNoYXJyYXlcIj41PC9zbGQ6Q3NzUGFyYW1ldGVyPjwvc2xkOlN0cm9rZT48L3NsZDpQb2x5Z29uU3ltYm9saXplcj48L3NsZDpSdWxlPjwvc2xkOkZlYXR1cmVUeXBlU3R5bGU+PC9zbGQ6VXNlclN0eWxlPjwvc2xkOk5hbWVkTGF5ZXI+PC9zbGQ6U3R5bGVkTGF5ZXJEZXNjcmlwdG9yPicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjb252ZXJ0IGxhYmVscycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGVDb25maWcgPSB7XG4gICAgICAgICAgICBcInR5cGVOYW1lXCI6IFwic2ltcGxlXCIsXG4gICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaXplXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJjaXJjbGVcIixcbiAgICAgICAgICAgICAgICBcImdyYXBoaWNcIjogbnVsbCxcbiAgICAgICAgICAgICAgICBcImdyYXBoaWNUeXBlXCI6IG51bGwsXG4gICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjZmYwMDAwXCIsXG4gICAgICAgICAgICAgICAgXCJmaWxsT3BhY2l0eVwiOiA4MFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICBcInN0cm9rZUNvbG9yXCI6IFwiI2ZmZmYwMFwiLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlV2lkdGhcIjogMyxcbiAgICAgICAgICAgICAgICBcInN0cm9rZVN0eWxlXCI6IFwic29saWRcIixcbiAgICAgICAgICAgICAgICBcInN0cm9rZU9wYWNpdHlcIjogOTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImxhYmVsXCI6IHtcbiAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZVwiOiBcImZvb1wiLFxuICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgICAgIFwiZm9udEZhbWlseVwiOiBcInNlcmlmXCIsXG4gICAgICAgICAgICAgICAgXCJmb250U2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcImZvbnRTdHlsZVwiOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgICAgIFwiZm9udFdlaWdodFwiOiBcIm5vcm1hbFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZW9tVHlwZVwiOiBcInBvaW50XCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0eWxlID0gaW5zdGFuY2UuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZywgJ3NpbXBsZScpO1xuICAgICAgICBleHBlY3Qoc3R5bGUpLnRvQmVYTUwoJzxzbGQ6U3R5bGVkTGF5ZXJEZXNjcmlwdG9yIHhtbG5zOnNsZD1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvc2xkXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeG1sbnM6b2djPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIiB2ZXJzaW9uPVwiMS4wLjBcIj48c2xkOk5hbWVkTGF5ZXI+PHNsZDpOYW1lPnNpbXBsZTwvc2xkOk5hbWU+PHNsZDpVc2VyU3R5bGU+PHNsZDpGZWF0dXJlVHlwZVN0eWxlPjxzbGQ6UnVsZT48c2xkOlBvaW50U3ltYm9saXplcj48c2xkOkdyYXBoaWM+PHNsZDpNYXJrPjxzbGQ6V2VsbEtub3duTmFtZT5jaXJjbGU8L3NsZDpXZWxsS25vd25OYW1lPjxzbGQ6RmlsbD48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbFwiPiNmZjAwMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGwtb3BhY2l0eVwiPjAuODwvc2xkOkNzc1BhcmFtZXRlcj48L3NsZDpGaWxsPjxzbGQ6U3Ryb2tlPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2VcIj4jZmZmZjAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utd2lkdGhcIj4zPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utb3BhY2l0eVwiPjAuOTwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLWRhc2hhcnJheVwiLz48L3NsZDpTdHJva2U+PC9zbGQ6TWFyaz48c2xkOk9wYWNpdHk+MC44PC9zbGQ6T3BhY2l0eT48c2xkOlNpemU+MTA8L3NsZDpTaXplPjwvc2xkOkdyYXBoaWM+PC9zbGQ6UG9pbnRTeW1ib2xpemVyPjxzbGQ6VGV4dFN5bWJvbGl6ZXI+PHNsZDpMYWJlbD48b2djOlByb3BlcnR5TmFtZT5mb288L29nYzpQcm9wZXJ0eU5hbWU+PC9zbGQ6TGFiZWw+PHNsZDpGb250PjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmb250LWZhbWlseVwiPlNlcmlmPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmb250LXNpemVcIj4xMDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZm9udC1zdHlsZVwiPm5vcm1hbDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZm9udC13ZWlnaHRcIj5ub3JtYWw8L3NsZDpDc3NQYXJhbWV0ZXI+PC9zbGQ6Rm9udD48c2xkOkxhYmVsUGxhY2VtZW50PjxzbGQ6TGluZVBsYWNlbWVudC8+PC9zbGQ6TGFiZWxQbGFjZW1lbnQ+PHNsZDpIYWxvPjxzbGQ6UmFkaXVzPjE8L3NsZDpSYWRpdXM+PHNsZDpGaWxsPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsXCI+I0ZGRkZGRjwvc2xkOkNzc1BhcmFtZXRlcj48L3NsZDpGaWxsPjwvc2xkOkhhbG8+PHNsZDpGaWxsPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsXCI+IzAwMDAwMDwvc2xkOkNzc1BhcmFtZXRlcj48L3NsZDpGaWxsPjxzbGQ6VmVuZG9yT3B0aW9uIG5hbWU9XCJtYXhEaXNwbGFjZW1lbnRcIj40MDwvc2xkOlZlbmRvck9wdGlvbj48c2xkOlZlbmRvck9wdGlvbiBuYW1lPVwiYXV0b1dyYXBcIj40MDwvc2xkOlZlbmRvck9wdGlvbj48c2xkOlZlbmRvck9wdGlvbiBuYW1lPVwic3BhY2VBcm91bmRcIj4wPC9zbGQ6VmVuZG9yT3B0aW9uPjxzbGQ6VmVuZG9yT3B0aW9uIG5hbWU9XCJmb2xsb3dMaW5lXCI+ZmFsc2U8L3NsZDpWZW5kb3JPcHRpb24+PHNsZDpWZW5kb3JPcHRpb24gbmFtZT1cImdyb3VwXCI+eWVzPC9zbGQ6VmVuZG9yT3B0aW9uPjxzbGQ6VmVuZG9yT3B0aW9uIG5hbWU9XCJnb29kbmVzc09mRml0XCI+MC4yPC9zbGQ6VmVuZG9yT3B0aW9uPjxzbGQ6VmVuZG9yT3B0aW9uIG5hbWU9XCJjb25mbGljdFJlc29sdXRpb25cIj50cnVlPC9zbGQ6VmVuZG9yT3B0aW9uPjwvc2xkOlRleHRTeW1ib2xpemVyPjwvc2xkOlJ1bGU+PC9zbGQ6RmVhdHVyZVR5cGVTdHlsZT48L3NsZDpVc2VyU3R5bGU+PC9zbGQ6TmFtZWRMYXllcj48L3NsZDpTdHlsZWRMYXllckRlc2NyaXB0b3I+Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNvbnZlcnQgdW5pcXVlIGNsYXNzaWZpY2F0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdHlsZUNvbmZpZyA9IHtcbiAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICBcInN0cm9rZUNvbG9yXCI6IFwiI2ZmZmYwMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZW9tVHlwZVwiOiBcInBvaW50XCIsXG4gICAgICAgICAgICBcImNsYXNzaWZ5XCI6IHtcbiAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZVwiOiBcImZvb1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJydWxlc1wiOiBbe1xuICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJiYXJcIixcbiAgICAgICAgICAgICAgICBcInN0eWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjZmY5OTAwXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VDb2xvclwiOiBcIiNmZjk5MDBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJiYXpcIixcbiAgICAgICAgICAgICAgICBcInN0eWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjYjM2YjAwXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VDb2xvclwiOiBcIiNiMzZiMDBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0eWxlID0gaW5zdGFuY2UuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZyk7XG4gICAgICAgIGV4cGVjdChzdHlsZSkudG9CZVhNTCgnPHNsZDpTdHlsZWRMYXllckRlc2NyaXB0b3IgeG1sbnM6c2xkPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9zbGRcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4bWxuczpvZ2M9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiIHZlcnNpb249XCIxLjAuMFwiPjxzbGQ6TmFtZWRMYXllcj48c2xkOlVzZXJTdHlsZT48c2xkOkZlYXR1cmVUeXBlU3R5bGU+PHNsZDpSdWxlPjxvZ2M6RmlsdGVyPjxvZ2M6UHJvcGVydHlJc0VxdWFsVG8+PG9nYzpQcm9wZXJ0eU5hbWU+Zm9vPC9vZ2M6UHJvcGVydHlOYW1lPjxvZ2M6TGl0ZXJhbD5iYXI8L29nYzpMaXRlcmFsPjwvb2djOlByb3BlcnR5SXNFcXVhbFRvPjwvb2djOkZpbHRlcj48c2xkOlBvaW50U3ltYm9saXplcj48c2xkOkdyYXBoaWM+PHNsZDpNYXJrPjxzbGQ6V2VsbEtub3duTmFtZT5jaXJjbGU8L3NsZDpXZWxsS25vd25OYW1lPjxzbGQ6RmlsbD48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbFwiPiNmZjk5MDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGwtb3BhY2l0eVwiPjE8L3NsZDpDc3NQYXJhbWV0ZXI+PC9zbGQ6RmlsbD48c2xkOlN0cm9rZT48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlXCI+I2ZmZmYwMDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLXdpZHRoXCIvPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utb3BhY2l0eVwiLz48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLWRhc2hhcnJheVwiLz48L3NsZDpTdHJva2U+PC9zbGQ6TWFyaz48c2xkOk9wYWNpdHk+MTwvc2xkOk9wYWNpdHk+PHNsZDpTaXplPjEwPC9zbGQ6U2l6ZT48L3NsZDpHcmFwaGljPjwvc2xkOlBvaW50U3ltYm9saXplcj48L3NsZDpSdWxlPjxzbGQ6UnVsZT48b2djOkZpbHRlcj48b2djOlByb3BlcnR5SXNFcXVhbFRvPjxvZ2M6UHJvcGVydHlOYW1lPmZvbzwvb2djOlByb3BlcnR5TmFtZT48b2djOkxpdGVyYWw+YmF6PC9vZ2M6TGl0ZXJhbD48L29nYzpQcm9wZXJ0eUlzRXF1YWxUbz48L29nYzpGaWx0ZXI+PHNsZDpQb2ludFN5bWJvbGl6ZXI+PHNsZDpHcmFwaGljPjxzbGQ6TWFyaz48c2xkOldlbGxLbm93bk5hbWU+Y2lyY2xlPC9zbGQ6V2VsbEtub3duTmFtZT48c2xkOkZpbGw+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGxcIj4jYjM2YjAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsLW9wYWNpdHlcIj4xPC9zbGQ6Q3NzUGFyYW1ldGVyPjwvc2xkOkZpbGw+PHNsZDpTdHJva2U+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZVwiPiNmZmZmMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS13aWR0aFwiLz48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLW9wYWNpdHlcIi8+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1kYXNoYXJyYXlcIi8+PC9zbGQ6U3Ryb2tlPjwvc2xkOk1hcms+PHNsZDpPcGFjaXR5PjE8L3NsZDpPcGFjaXR5PjxzbGQ6U2l6ZT4xMDwvc2xkOlNpemU+PC9zbGQ6R3JhcGhpYz48L3NsZDpQb2ludFN5bWJvbGl6ZXI+PC9zbGQ6UnVsZT48L3NsZDpGZWF0dXJlVHlwZVN0eWxlPjwvc2xkOlVzZXJTdHlsZT48L3NsZDpOYW1lZExheWVyPjwvc2xkOlN0eWxlZExheWVyRGVzY3JpcHRvcj4nKTtcbiAgICAgICAgc3R5bGVDb25maWcuZ2VvbVR5cGUgPSBcImxpbmVcIjtcbiAgICAgICAgc3R5bGUgPSBpbnN0YW5jZS5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlKS50b0JlWE1MKCc8c2xkOlN0eWxlZExheWVyRGVzY3JpcHRvciB4bWxuczpzbGQ9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3NsZFwiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhtbG5zOm9nYz1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djXCIgdmVyc2lvbj1cIjEuMC4wXCI+PHNsZDpOYW1lZExheWVyPjxzbGQ6VXNlclN0eWxlPjxzbGQ6RmVhdHVyZVR5cGVTdHlsZT48c2xkOlJ1bGU+PG9nYzpGaWx0ZXI+PG9nYzpQcm9wZXJ0eUlzRXF1YWxUbz48b2djOlByb3BlcnR5TmFtZT5mb288L29nYzpQcm9wZXJ0eU5hbWU+PG9nYzpMaXRlcmFsPmJhcjwvb2djOkxpdGVyYWw+PC9vZ2M6UHJvcGVydHlJc0VxdWFsVG8+PC9vZ2M6RmlsdGVyPjxzbGQ6TGluZVN5bWJvbGl6ZXI+PHNsZDpTdHJva2U+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZVwiPiNmZjk5MDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS13aWR0aFwiLz48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLW9wYWNpdHlcIi8+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1kYXNoYXJyYXlcIi8+PC9zbGQ6U3Ryb2tlPjwvc2xkOkxpbmVTeW1ib2xpemVyPjwvc2xkOlJ1bGU+PHNsZDpSdWxlPjxvZ2M6RmlsdGVyPjxvZ2M6UHJvcGVydHlJc0VxdWFsVG8+PG9nYzpQcm9wZXJ0eU5hbWU+Zm9vPC9vZ2M6UHJvcGVydHlOYW1lPjxvZ2M6TGl0ZXJhbD5iYXo8L29nYzpMaXRlcmFsPjwvb2djOlByb3BlcnR5SXNFcXVhbFRvPjwvb2djOkZpbHRlcj48c2xkOkxpbmVTeW1ib2xpemVyPjxzbGQ6U3Ryb2tlPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2VcIj4jYjM2YjAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utd2lkdGhcIi8+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1vcGFjaXR5XCIvPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2UtZGFzaGFycmF5XCIvPjwvc2xkOlN0cm9rZT48L3NsZDpMaW5lU3ltYm9saXplcj48L3NsZDpSdWxlPjwvc2xkOkZlYXR1cmVUeXBlU3R5bGU+PC9zbGQ6VXNlclN0eWxlPjwvc2xkOk5hbWVkTGF5ZXI+PC9zbGQ6U3R5bGVkTGF5ZXJEZXNjcmlwdG9yPicpO1xuICAgICAgICBzdHlsZUNvbmZpZy5nZW9tVHlwZSA9IFwicG9seWdvblwiO1xuICAgICAgICBzdHlsZSA9IGluc3RhbmNlLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcpO1xuICAgICAgICBleHBlY3Qoc3R5bGUpLnRvQmVYTUwoJzxzbGQ6U3R5bGVkTGF5ZXJEZXNjcmlwdG9yIHhtbG5zOnNsZD1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvc2xkXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeG1sbnM6b2djPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIiB2ZXJzaW9uPVwiMS4wLjBcIj48c2xkOk5hbWVkTGF5ZXI+PHNsZDpVc2VyU3R5bGU+PHNsZDpGZWF0dXJlVHlwZVN0eWxlPjxzbGQ6UnVsZT48b2djOkZpbHRlcj48b2djOlByb3BlcnR5SXNFcXVhbFRvPjxvZ2M6UHJvcGVydHlOYW1lPmZvbzwvb2djOlByb3BlcnR5TmFtZT48b2djOkxpdGVyYWw+YmFyPC9vZ2M6TGl0ZXJhbD48L29nYzpQcm9wZXJ0eUlzRXF1YWxUbz48L29nYzpGaWx0ZXI+PHNsZDpQb2x5Z29uU3ltYm9saXplcj48c2xkOkZpbGw+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGxcIj4jZmY5OTAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsLW9wYWNpdHlcIj4xPC9zbGQ6Q3NzUGFyYW1ldGVyPjwvc2xkOkZpbGw+PHNsZDpTdHJva2U+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZVwiPiNmZmZmMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS13aWR0aFwiLz48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLW9wYWNpdHlcIi8+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1kYXNoYXJyYXlcIi8+PC9zbGQ6U3Ryb2tlPjwvc2xkOlBvbHlnb25TeW1ib2xpemVyPjwvc2xkOlJ1bGU+PHNsZDpSdWxlPjxvZ2M6RmlsdGVyPjxvZ2M6UHJvcGVydHlJc0VxdWFsVG8+PG9nYzpQcm9wZXJ0eU5hbWU+Zm9vPC9vZ2M6UHJvcGVydHlOYW1lPjxvZ2M6TGl0ZXJhbD5iYXo8L29nYzpMaXRlcmFsPjwvb2djOlByb3BlcnR5SXNFcXVhbFRvPjwvb2djOkZpbHRlcj48c2xkOlBvbHlnb25TeW1ib2xpemVyPjxzbGQ6RmlsbD48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbFwiPiNiMzZiMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGwtb3BhY2l0eVwiPjE8L3NsZDpDc3NQYXJhbWV0ZXI+PC9zbGQ6RmlsbD48c2xkOlN0cm9rZT48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlXCI+I2ZmZmYwMDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLXdpZHRoXCIvPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utb3BhY2l0eVwiLz48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLWRhc2hhcnJheVwiLz48L3NsZDpTdHJva2U+PC9zbGQ6UG9seWdvblN5bWJvbGl6ZXI+PC9zbGQ6UnVsZT48L3NsZDpGZWF0dXJlVHlwZVN0eWxlPjwvc2xkOlVzZXJTdHlsZT48L3NsZDpOYW1lZExheWVyPjwvc2xkOlN0eWxlZExheWVyRGVzY3JpcHRvcj4nKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY29udmVydCByYW5nZXMgb2YgYSBjbGFzc2lmaWNhdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGVDb25maWcgPSB7XG4gICAgICAgICAgICBcInN0cm9rZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzdHJva2VDb2xvclwiOiBcIiNmZmZmMDBcIlxuICAgICAgICAgICAgfSwgIFxuICAgICAgICAgICAgXCJnZW9tVHlwZVwiOiBcInBvaW50XCIsXG4gICAgICAgICAgICBcImNsYXNzaWZ5XCI6IHtcbiAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZVwiOiBcImZvb1wiXG4gICAgICAgICAgICB9LCAgICAgIFxuICAgICAgICAgICAgXCJydWxlc1wiOiBbe1xuICAgICAgICAgICAgICAgIFwicmFuZ2VcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIm1pblwiOiAwLFxuICAgICAgICAgICAgICAgICAgICBcIm1heFwiOiAxMFxuICAgICAgICAgICAgICAgIH0sICBcbiAgICAgICAgICAgICAgICBcInN0eWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjZmY5OTAwXCJcbiAgICAgICAgICAgICAgICAgICAgfSAgIFxuICAgICAgICAgICAgICAgIH0gICBcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInJhbmdlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJtaW5cIjogMTAsXG4gICAgICAgICAgICAgICAgICAgIFwibWF4XCI6IDIwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInN0eWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjYjM2YjAwXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH07ICBcbiAgICAgICAgdmFyIHN0eWxlID0gaW5zdGFuY2UuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZyk7XG4gICAgICAgIGV4cGVjdChzdHlsZSkudG9CZVhNTCgnPHNsZDpTdHlsZWRMYXllckRlc2NyaXB0b3IgeG1sbnM6c2xkPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9zbGRcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4bWxuczpvZ2M9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nY1wiIHZlcnNpb249XCIxLjAuMFwiPjxzbGQ6TmFtZWRMYXllcj48c2xkOlVzZXJTdHlsZT48c2xkOkZlYXR1cmVUeXBlU3R5bGU+PHNsZDpSdWxlPjxvZ2M6RmlsdGVyPjxvZ2M6UHJvcGVydHlJc0JldHdlZW4+PG9nYzpQcm9wZXJ0eU5hbWU+Zm9vPC9vZ2M6UHJvcGVydHlOYW1lPjxvZ2M6TG93ZXJCb3VuZGFyeT48b2djOkxpdGVyYWw+MDwvb2djOkxpdGVyYWw+PC9vZ2M6TG93ZXJCb3VuZGFyeT48b2djOlVwcGVyQm91bmRhcnk+PG9nYzpMaXRlcmFsPjEwPC9vZ2M6TGl0ZXJhbD48L29nYzpVcHBlckJvdW5kYXJ5Pjwvb2djOlByb3BlcnR5SXNCZXR3ZWVuPjwvb2djOkZpbHRlcj48c2xkOlBvaW50U3ltYm9saXplcj48c2xkOkdyYXBoaWM+PHNsZDpNYXJrPjxzbGQ6V2VsbEtub3duTmFtZT5jaXJjbGU8L3NsZDpXZWxsS25vd25OYW1lPjxzbGQ6RmlsbD48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbFwiPiNmZjk5MDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGwtb3BhY2l0eVwiPjE8L3NsZDpDc3NQYXJhbWV0ZXI+PC9zbGQ6RmlsbD48c2xkOlN0cm9rZT48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlXCI+I2ZmZmYwMDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLXdpZHRoXCIvPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utb3BhY2l0eVwiLz48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLWRhc2hhcnJheVwiLz48L3NsZDpTdHJva2U+PC9zbGQ6TWFyaz48c2xkOk9wYWNpdHk+MTwvc2xkOk9wYWNpdHk+PHNsZDpTaXplPjEwPC9zbGQ6U2l6ZT48L3NsZDpHcmFwaGljPjwvc2xkOlBvaW50U3ltYm9saXplcj48L3NsZDpSdWxlPjxzbGQ6UnVsZT48b2djOkZpbHRlcj48b2djOlByb3BlcnR5SXNCZXR3ZWVuPjxvZ2M6UHJvcGVydHlOYW1lPmZvbzwvb2djOlByb3BlcnR5TmFtZT48b2djOkxvd2VyQm91bmRhcnk+PG9nYzpMaXRlcmFsPjEwPC9vZ2M6TGl0ZXJhbD48L29nYzpMb3dlckJvdW5kYXJ5PjxvZ2M6VXBwZXJCb3VuZGFyeT48b2djOkxpdGVyYWw+MjA8L29nYzpMaXRlcmFsPjwvb2djOlVwcGVyQm91bmRhcnk+PC9vZ2M6UHJvcGVydHlJc0JldHdlZW4+PC9vZ2M6RmlsdGVyPjxzbGQ6UG9pbnRTeW1ib2xpemVyPjxzbGQ6R3JhcGhpYz48c2xkOk1hcms+PHNsZDpXZWxsS25vd25OYW1lPmNpcmNsZTwvc2xkOldlbGxLbm93bk5hbWU+PHNsZDpGaWxsPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsXCI+I2IzNmIwMDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbC1vcGFjaXR5XCI+MTwvc2xkOkNzc1BhcmFtZXRlcj48L3NsZDpGaWxsPjxzbGQ6U3Ryb2tlPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2VcIj4jZmZmZjAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utd2lkdGhcIi8+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1vcGFjaXR5XCIvPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2UtZGFzaGFycmF5XCIvPjwvc2xkOlN0cm9rZT48L3NsZDpNYXJrPjxzbGQ6T3BhY2l0eT4xPC9zbGQ6T3BhY2l0eT48c2xkOlNpemU+MTA8L3NsZDpTaXplPjwvc2xkOkdyYXBoaWM+PC9zbGQ6UG9pbnRTeW1ib2xpemVyPjwvc2xkOlJ1bGU+PC9zbGQ6RmVhdHVyZVR5cGVTdHlsZT48L3NsZDpVc2VyU3R5bGU+PC9zbGQ6TmFtZWRMYXllcj48L3NsZDpTdHlsZWRMYXllckRlc2NyaXB0b3I+Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNvbnZlcnQgcm90YXRpb24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0eWxlQ29uZmlnID0ge1xuICAgICAgICAgICAgXCJ0eXBlTmFtZVwiOiBcInNpbXBsZVwiLFxuICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwidHJpYW5nbGVcIixcbiAgICAgICAgICAgICAgICBcImdyYXBoaWNcIjogbnVsbCxcbiAgICAgICAgICAgICAgICBcImdyYXBoaWNUeXBlXCI6IG51bGwsXG4gICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjZmYwMDAwXCIsXG4gICAgICAgICAgICAgICAgXCJmaWxsT3BhY2l0eVwiOiA4MCxcbiAgICAgICAgICAgICAgICBcInJvdGF0aW9uQXR0cmlidXRlXCI6IFwicm90YXRpb25cIixcbiAgICAgICAgICAgICAgICBcInJvdGF0aW9uVW5pdHNcIjogXCJkZWdyZWVzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzdHJva2VDb2xvclwiOiBcIiNmZmZmMDBcIixcbiAgICAgICAgICAgICAgICBcInN0cm9rZVdpZHRoXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJzdHJva2VTdHlsZVwiOiBcImRvdHRlZFwiLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlT3BhY2l0eVwiOiA5MFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2VvbVR5cGVcIjogXCJwb2ludFwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHlsZSA9IGluc3RhbmNlLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcpO1xuICAgICAgICBleHBlY3Qoc3R5bGUpLnRvQmVYTUwoJzxzbGQ6U3R5bGVkTGF5ZXJEZXNjcmlwdG9yIHhtbG5zOnNsZD1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvc2xkXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeG1sbnM6b2djPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIiB2ZXJzaW9uPVwiMS4wLjBcIj48c2xkOk5hbWVkTGF5ZXI+PHNsZDpVc2VyU3R5bGU+PHNsZDpGZWF0dXJlVHlwZVN0eWxlPjxzbGQ6UnVsZT48c2xkOlBvaW50U3ltYm9saXplcj48c2xkOkdyYXBoaWM+PHNsZDpNYXJrPjxzbGQ6V2VsbEtub3duTmFtZT50cmlhbmdsZTwvc2xkOldlbGxLbm93bk5hbWU+PHNsZDpGaWxsPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJmaWxsXCI+I2ZmMDAwMDwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbC1vcGFjaXR5XCI+MC44PC9zbGQ6Q3NzUGFyYW1ldGVyPjwvc2xkOkZpbGw+PHNsZDpTdHJva2U+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZVwiPiNmZmZmMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS13aWR0aFwiPjM8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cInN0cm9rZS1vcGFjaXR5XCI+MC45PC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2UtZGFzaGFycmF5XCI+MSAyPC9zbGQ6Q3NzUGFyYW1ldGVyPjwvc2xkOlN0cm9rZT48L3NsZDpNYXJrPjxzbGQ6T3BhY2l0eT4wLjg8L3NsZDpPcGFjaXR5PjxzbGQ6U2l6ZT4xMDwvc2xkOlNpemU+PHNsZDpSb3RhdGlvbj48b2djOlByb3BlcnR5TmFtZT5yb3RhdGlvbjwvb2djOlByb3BlcnR5TmFtZT48L3NsZDpSb3RhdGlvbj48L3NsZDpHcmFwaGljPjwvc2xkOlBvaW50U3ltYm9saXplcj48L3NsZDpSdWxlPjwvc2xkOkZlYXR1cmVUeXBlU3R5bGU+PC9zbGQ6VXNlclN0eWxlPjwvc2xkOk5hbWVkTGF5ZXI+PC9zbGQ6U3R5bGVkTGF5ZXJEZXNjcmlwdG9yPicpO1xuXG4gICAgICAgICAvLyBub3cgdXNlIHJhZGlhbnNcbiAgICAgICAgIHN0eWxlQ29uZmlnLnN5bWJvbC5yb3RhdGlvblVuaXRzID0gXCJyYWRpYW5zXCI7XG4gICAgICAgICBzdHlsZSA9IGluc3RhbmNlLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcpO1xuICAgICAgICAgZXhwZWN0KHN0eWxlKS50b0JlWE1MKCc8c2xkOlN0eWxlZExheWVyRGVzY3JpcHRvciB4bWxuczpzbGQ9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3NsZFwiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhtbG5zOm9nYz1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djXCIgdmVyc2lvbj1cIjEuMC4wXCI+PHNsZDpOYW1lZExheWVyPjxzbGQ6VXNlclN0eWxlPjxzbGQ6RmVhdHVyZVR5cGVTdHlsZT48c2xkOlJ1bGU+PHNsZDpQb2ludFN5bWJvbGl6ZXI+PHNsZDpHcmFwaGljPjxzbGQ6TWFyaz48c2xkOldlbGxLbm93bk5hbWU+dHJpYW5nbGU8L3NsZDpXZWxsS25vd25OYW1lPjxzbGQ6RmlsbD48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwiZmlsbFwiPiNmZjAwMDA8L3NsZDpDc3NQYXJhbWV0ZXI+PHNsZDpDc3NQYXJhbWV0ZXIgbmFtZT1cImZpbGwtb3BhY2l0eVwiPjAuODwvc2xkOkNzc1BhcmFtZXRlcj48L3NsZDpGaWxsPjxzbGQ6U3Ryb2tlPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2VcIj4jZmZmZjAwPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utd2lkdGhcIj4zPC9zbGQ6Q3NzUGFyYW1ldGVyPjxzbGQ6Q3NzUGFyYW1ldGVyIG5hbWU9XCJzdHJva2Utb3BhY2l0eVwiPjAuOTwvc2xkOkNzc1BhcmFtZXRlcj48c2xkOkNzc1BhcmFtZXRlciBuYW1lPVwic3Ryb2tlLWRhc2hhcnJheVwiPjEgMjwvc2xkOkNzc1BhcmFtZXRlcj48L3NsZDpTdHJva2U+PC9zbGQ6TWFyaz48c2xkOk9wYWNpdHk+MC44PC9zbGQ6T3BhY2l0eT48c2xkOlNpemU+MTA8L3NsZDpTaXplPjxzbGQ6Um90YXRpb24+PG9nYzpEaXY+PG9nYzpQcm9wZXJ0eU5hbWU+cm90YXRpb248L29nYzpQcm9wZXJ0eU5hbWU+PG9nYzpEaXY+PG9nYzpGdW5jdGlvbiBuYW1lPVwicGlcIi8+PG9nYzpMaXRlcmFsPjM2MDwvb2djOkxpdGVyYWw+PC9vZ2M6RGl2Pjwvb2djOkRpdj48L3NsZDpSb3RhdGlvbj48L3NsZDpHcmFwaGljPjwvc2xkOlBvaW50U3ltYm9saXplcj48L3NsZDpSdWxlPjwvc2xkOkZlYXR1cmVUeXBlU3R5bGU+PC9zbGQ6VXNlclN0eWxlPjwvc2xkOk5hbWVkTGF5ZXI+PC9zbGQ6U3R5bGVkTGF5ZXJEZXNjcmlwdG9yPicpO1xuICAgIH0pO1xuXG59KTtcbiIsInZhciBTdHlsZUNvbXBsZXRlID0gcmVxdWlyZSgnLi4vbGliL2VkaXQvc3R5bGUvU3R5bGVDb21wbGV0ZS5qcycpLlN0eWxlQ29tcGxldGU7XG52YXIgaW5zdGFuY2UgPSBuZXcgU3R5bGVDb21wbGV0ZSgpO1xuXG5kZXNjcmliZSgnU3R5bGVDb21wbGV0ZScsIGZ1bmN0aW9uKCkge1xuXG4gICAgaXQoJ3VuaXF1ZSBjbGFzc2lmaWNhdGlvbiBuZWVkcyBhdHRyaWJ1dGUsIG1heENsYXNzZXMgYW5kIGNvbG9yUGFsZXR0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgICAgICBcImNsYXNzaWZ5XCI6IHtcbiAgICAgICAgICAgICAgICBcIm1ldGhvZFwiOiBcInVuaXF1ZVwiLFxuICAgICAgICAgICAgICAgIFwibWF4Q2xhc3Nlc1wiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwiYXR0cmlidXRlXCI6IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGluc3RhbmNlLmlzQ29tcGxldGUoc3R5bGUpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlRmFsc3koKTtcbiAgICAgICAgc3R5bGUuY2xhc3NpZnkuYXR0cmlidXRlID0gJ2Zvbyc7XG4gICAgICAgIHJlc3VsdCA9IGluc3RhbmNlLmlzQ29tcGxldGUoc3R5bGUpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlRmFsc3koKTtcbiAgICAgICAgc3R5bGUuY2xhc3NpZnkubWF4Q2xhc3NlcyA9IDEwO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlRmFsc3koKTtcbiAgICAgICAgc3R5bGUuY2xhc3NpZnkuY29sb3JQYWxldHRlID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0ID0gaW5zdGFuY2UuaXNDb21wbGV0ZShzdHlsZSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVUcnV0aHkoKTtcbiAgICB9KTtcblxuICAgIGl0KCdvdGhlciBjbGFzc2lmY2F0aW9uIHR5cGVzIG5lZWQgdG8gaGF2ZSBhbGwgaW5mbycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgICAgICBcImNsYXNzaWZ5XCI6IHtcbiAgICAgICAgICAgICAgICBcIm1ldGhvZFwiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwiYXR0cmlidXRlXCI6IG51bGwsXG4gICAgICAgICAgICAgICAgXCJjb2xvclJhbXBcIjogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bGVzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gaW5zdGFuY2UuaXNDb21wbGV0ZShzdHlsZSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVGYWxzeSgpO1xuICAgICAgICBzdHlsZS5jbGFzc2lmeS5tZXRob2QgPSAnZm9vJztcbiAgICAgICAgcmVzdWx0ID0gaW5zdGFuY2UuaXNDb21wbGV0ZShzdHlsZSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVGYWxzeSgpO1xuICAgICAgICBzdHlsZS5jbGFzc2lmeS5hdHRyaWJ1dGUgPSAnYmFyJztcbiAgICAgICAgcmVzdWx0ID0gaW5zdGFuY2UuaXNDb21wbGV0ZShzdHlsZSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVGYWxzeSgpO1xuICAgICAgICBzdHlsZS5jbGFzc2lmeS5jb2xvclJhbXAgPSB0cnVlO1xuICAgICAgICByZXN1bHQgPSBpbnN0YW5jZS5pc0NvbXBsZXRlKHN0eWxlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZUZhbHN5KCk7XG4gICAgICAgIHN0eWxlLnJ1bGVzLnB1c2goe30pO1xuICAgICAgICByZXN1bHQgPSBpbnN0YW5jZS5pc0NvbXBsZXRlKHN0eWxlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZVRydXRoeSgpO1xuICAgIH0pO1xuXG59KTtcblxuIiwidmFyIFdGU19ERlQgPSByZXF1aXJlKCcuLi9saWIvZWRpdC9zdHlsZS9XRlNEZXNjcmliZUZlYXR1cmVUeXBlLmpzJykuV0ZTRGVzY3JpYmVGZWF0dXJlVHlwZTtcbnZhciBpbnN0YW5jZSA9IG5ldyBXRlNfREZUKCk7XG5cbmRlc2NyaWJlKCdXRlNEZXNjcmliZUZlYXR1cmVUeXBlJywgZnVuY3Rpb24oKSB7XG4gICAgaXQoJ3Nob3VsZCBwYXJzZSBhIFdGUyBEZXNjcmliZUZlYXR1cmVUeXBlIHJlc3BvbnNlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB4bWwgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+PHhzZDpzY2hlbWEgeG1sbnM6eHNkPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWFcIiB4bWxuczpnZW9ub2RlPVwiaHR0cDovL2dlb25vZGUub3JnL1wiIHhtbG5zOmdtbD1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sXCIgZWxlbWVudEZvcm1EZWZhdWx0PVwicXVhbGlmaWVkXCIgdGFyZ2V0TmFtZXNwYWNlPVwiaHR0cDovL2dlb25vZGUub3JnL1wiPicgK1xuJyAgPHhzZDppbXBvcnQgbmFtZXNwYWNlPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWxcIiBzY2hlbWFMb2NhdGlvbj1cImh0dHA6Ly9tYXBzdG9yeS5vcmc6ODAvZ2Vvc2VydmVyL3NjaGVtYXMvZ21sLzIuMS4yL2ZlYXR1cmUueHNkXCIvPicgK1xuJyAgPHhzZDpjb21wbGV4VHlwZSBuYW1lPVwiYWZyaWNhbl9iZWVzXzIwMDlUeXBlXCI+JyArXG4nICAgIDx4c2Q6Y29tcGxleENvbnRlbnQ+JyArXG4nICAgICAgPHhzZDpleHRlbnNpb24gYmFzZT1cImdtbDpBYnN0cmFjdEZlYXR1cmVUeXBlXCI+JyArXG4nICAgICAgICA8eHNkOnNlcXVlbmNlPicgK1xuJyAgICAgICAgICA8eHNkOmVsZW1lbnQgbWF4T2NjdXJzPVwiMVwiIG1pbk9jY3Vycz1cIjBcIiBuYW1lPVwidGhlX2dlb21cIiBuaWxsYWJsZT1cInRydWVcIiB0eXBlPVwiZ21sOk11bHRpUG9seWdvblByb3BlcnR5VHlwZVwiLz4nICtcbicgICAgICAgICAgPHhzZDplbGVtZW50IG1heE9jY3Vycz1cIjFcIiBtaW5PY2N1cnM9XCIwXCIgbmFtZT1cIkFSRUFcIiBuaWxsYWJsZT1cInRydWVcIiB0eXBlPVwieHNkOmRvdWJsZVwiLz4nICtcbicgICAgICAgICAgPHhzZDplbGVtZW50IG1heE9jY3Vycz1cIjFcIiBtaW5PY2N1cnM9XCIwXCIgbmFtZT1cIlBFUklNRVRFUlwiIG5pbGxhYmxlPVwidHJ1ZVwiIHR5cGU9XCJ4c2Q6ZG91YmxlXCIvPicgK1xuJyAgICAgICAgICA8eHNkOmVsZW1lbnQgbWF4T2NjdXJzPVwiMVwiIG1pbk9jY3Vycz1cIjBcIiBuYW1lPVwiQUZSQkVFUDAyMFwiIG5pbGxhYmxlPVwidHJ1ZVwiIHR5cGU9XCJ4c2Q6bG9uZ1wiLz4nICtcbicgICAgICAgICAgPHhzZDplbGVtZW50IG1heE9jY3Vycz1cIjFcIiBtaW5PY2N1cnM9XCIwXCIgbmFtZT1cIlNUQVRFXCIgbmlsbGFibGU9XCJ0cnVlXCIgdHlwZT1cInhzZDpzdHJpbmdcIi8+JyArXG4nICAgICAgICAgIDx4c2Q6ZWxlbWVudCBtYXhPY2N1cnM9XCIxXCIgbWluT2NjdXJzPVwiMFwiIG5hbWU9XCJDT1VOVFlcIiBuaWxsYWJsZT1cInRydWVcIiB0eXBlPVwieHNkOnN0cmluZ1wiLz4nICtcbicgICAgICAgICAgPHhzZDplbGVtZW50IG1heE9jY3Vycz1cIjFcIiBtaW5PY2N1cnM9XCIwXCIgbmFtZT1cIkZJUFNcIiBuaWxsYWJsZT1cInRydWVcIiB0eXBlPVwieHNkOnN0cmluZ1wiLz4nICtcbicgICAgICAgICAgPHhzZDplbGVtZW50IG1heE9jY3Vycz1cIjFcIiBtaW5PY2N1cnM9XCIwXCIgbmFtZT1cIlNUQVRFX0ZJUFNcIiBuaWxsYWJsZT1cInRydWVcIiB0eXBlPVwieHNkOnN0cmluZ1wiLz4nICtcbicgICAgICAgICAgPHhzZDplbGVtZW50IG1heE9jY3Vycz1cIjFcIiBtaW5PY2N1cnM9XCIwXCIgbmFtZT1cIkZJUlNUX1lSXCIgbmlsbGFibGU9XCJ0cnVlXCIgdHlwZT1cInhzZDpkYXRlVGltZVwiLz4nICtcbicgICAgICAgIDwveHNkOnNlcXVlbmNlPicgK1xuJyAgICAgIDwveHNkOmV4dGVuc2lvbj4nICtcbicgICAgPC94c2Q6Y29tcGxleENvbnRlbnQ+JyArXG4nICA8L3hzZDpjb21wbGV4VHlwZT4nICtcbicgIDx4c2Q6ZWxlbWVudCBuYW1lPVwiYWZyaWNhbl9iZWVzXzIwMDlcIiBzdWJzdGl0dXRpb25Hcm91cD1cImdtbDpfRmVhdHVyZVwiIHR5cGU9XCJnZW9ub2RlOmFmcmljYW5fYmVlc18yMDA5VHlwZVwiLz4nICtcbic8L3hzZDpzY2hlbWE+JztcbiAgICAgICAgZXhwZWN0KEpTT04uc3RyaW5naWZ5KGluc3RhbmNlLnBhcnNlUmVzdWx0KHhtbCkpKS50b0JlKCd7XCJ0aW1lQXR0cmlidXRlXCI6XCJGSVJTVF9ZUlwiLFwiZmVhdHVyZU5TXCI6XCJodHRwOi8vZ2Vvbm9kZS5vcmcvXCIsXCJnZW9tVHlwZVwiOlwicG9seWdvblwiLFwiYXR0cmlidXRlc1wiOlt7XCJuYW1lXCI6XCJ0aGVfZ2VvbVwiLFwidHlwZVwiOlwiTXVsdGlQb2x5Z29uUHJvcGVydHlUeXBlXCIsXCJ0eXBlTlNcIjpcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sXCJ9LHtcIm5hbWVcIjpcIkFSRUFcIixcInR5cGVcIjpcImRvdWJsZVwiLFwidHlwZU5TXCI6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYVwifSx7XCJuYW1lXCI6XCJQRVJJTUVURVJcIixcInR5cGVcIjpcImRvdWJsZVwiLFwidHlwZU5TXCI6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYVwifSx7XCJuYW1lXCI6XCJBRlJCRUVQMDIwXCIsXCJ0eXBlXCI6XCJsb25nXCIsXCJ0eXBlTlNcIjpcImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hXCJ9LHtcIm5hbWVcIjpcIlNUQVRFXCIsXCJ0eXBlXCI6XCJzdHJpbmdcIixcInR5cGVOU1wiOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWFcIn0se1wibmFtZVwiOlwiQ09VTlRZXCIsXCJ0eXBlXCI6XCJzdHJpbmdcIixcInR5cGVOU1wiOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWFcIn0se1wibmFtZVwiOlwiRklQU1wiLFwidHlwZVwiOlwic3RyaW5nXCIsXCJ0eXBlTlNcIjpcImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hXCJ9LHtcIm5hbWVcIjpcIlNUQVRFX0ZJUFNcIixcInR5cGVcIjpcInN0cmluZ1wiLFwidHlwZU5TXCI6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYVwifSx7XCJuYW1lXCI6XCJGSVJTVF9ZUlwiLFwidHlwZVwiOlwiZGF0ZVRpbWVcIixcInR5cGVOU1wiOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWFcIn1dfScpO1xuICAgIH0pO1xufSk7XG4iLCJ2YXIgV1BTQ2xhc3NpZnkgPSByZXF1aXJlKCcuLi9saWIvZWRpdC9zdHlsZS9XUFNDbGFzc2lmeS5qcycpLldQU0NsYXNzaWZ5O1xudmFyIGluc3RhbmNlID0gbmV3IFdQU0NsYXNzaWZ5KCk7XG5cbmRlc2NyaWJlKCdXUFNDbGFzc2lmeScsIGZ1bmN0aW9uKCkge1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgamFzbWluZS5hZGRNYXRjaGVycyhjdXN0b21NYXRjaGVycyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSB0aGUgY29ycmVjdCBXUFMgcmVxdWVzdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiAnY2l0ZTpzdGF0ZXMnLFxuICAgICAgICAgICAgZmVhdHVyZU5TOiAnaHR0cDovL3d3dy5vcGVuZ2Vvc3BhdGlhbC5uZXQvY2l0ZScsXG4gICAgICAgICAgICBmZWF0dXJlUHJlZml4OiAnY2l0ZScsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdQT1BVTEFUSU9OJyxcbiAgICAgICAgICAgIG51bUNsYXNzZXM6IDEwLFxuICAgICAgICAgICAgbWV0aG9kOiAnRVFVQUxfSU5URVJWQUwnXG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXF1ZXN0ID0gaW5zdGFuY2UuY2xhc3NpZnlWZWN0b3IoZGF0YSk7XG4gICAgICAgIGV4cGVjdChyZXF1ZXN0KS50b0JlWE1MKCc8d3BzOkV4ZWN1dGUgeG1sbnM6d3BzPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC93cHMvMS4wLjBcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4bWxuczpvd3M9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L293cy8xLjFcIiB4bWxuczp3ZnM9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dmc1wiIHNlcnZpY2U9XCJXUFNcIiB2ZXJzaW9uPVwiMS4wLjBcIj48b3dzOklkZW50aWZpZXI+dmVjOkZlYXR1cmVDbGFzc1N0YXRzPC9vd3M6SWRlbnRpZmllcj48d3BzOkRhdGFJbnB1dHM+PHdwczpJbnB1dD48b3dzOklkZW50aWZpZXI+ZmVhdHVyZXM8L293czpJZGVudGlmaWVyPjx3cHM6UmVmZXJlbmNlIHhsaW5rOmhyZWY9XCJodHRwOi8vZ2Vvc2VydmVyL3dmc1wiIG1ldGhvZD1cIlBPU1RcIiBtaW1lVHlwZT1cInRleHQveG1sXCI+PHdwczpCb2R5Pjx3ZnM6R2V0RmVhdHVyZSBzZXJ2aWNlPVwiV0ZTXCIgdmVyc2lvbj1cIjEuMS4wXCIgb3V0cHV0Rm9ybWF0PVwiR01MMlwiPjx3ZnM6UXVlcnkgeG1sbnM6Y2l0ZT1cImh0dHA6Ly93d3cub3Blbmdlb3NwYXRpYWwubmV0L2NpdGVcIiB0eXBlTmFtZT1cImNpdGU6c3RhdGVzXCIvPjwvd2ZzOkdldEZlYXR1cmU+PC93cHM6Qm9keT48L3dwczpSZWZlcmVuY2U+PC93cHM6SW5wdXQ+PHdwczpJbnB1dD48b3dzOklkZW50aWZpZXI+YXR0cmlidXRlPC9vd3M6SWRlbnRpZmllcj48d3BzOkRhdGE+PHdwczpMaXRlcmFsRGF0YT5QT1BVTEFUSU9OPC93cHM6TGl0ZXJhbERhdGE+PC93cHM6RGF0YT48L3dwczpJbnB1dD48d3BzOklucHV0Pjxvd3M6SWRlbnRpZmllcj5jbGFzc2VzPC9vd3M6SWRlbnRpZmllcj48d3BzOkRhdGE+PHdwczpMaXRlcmFsRGF0YT4xMDwvd3BzOkxpdGVyYWxEYXRhPjwvd3BzOkRhdGE+PC93cHM6SW5wdXQ+PHdwczpJbnB1dD48b3dzOklkZW50aWZpZXI+bWV0aG9kPC9vd3M6SWRlbnRpZmllcj48d3BzOkRhdGE+PHdwczpMaXRlcmFsRGF0YT5FUVVBTF9JTlRFUlZBTDwvd3BzOkxpdGVyYWxEYXRhPjwvd3BzOkRhdGE+PC93cHM6SW5wdXQ+PHdwczpJbnB1dD48b3dzOklkZW50aWZpZXI+c3RhdHM8L293czpJZGVudGlmaWVyPjx3cHM6RGF0YT48d3BzOkxpdGVyYWxEYXRhPm1lYW48L3dwczpMaXRlcmFsRGF0YT48L3dwczpEYXRhPjwvd3BzOklucHV0Pjwvd3BzOkRhdGFJbnB1dHM+PHdwczpSZXNwb25zZUZvcm0+PHdwczpSYXdEYXRhT3V0cHV0Pjxvd3M6SWRlbnRpZmllcj5yZXN1bHRzPC9vd3M6SWRlbnRpZmllcj48L3dwczpSYXdEYXRhT3V0cHV0Pjwvd3BzOlJlc3BvbnNlRm9ybT48L3dwczpFeGVjdXRlPicpO1xuICAgIH0pO1xuXG59KTtcbiIsInZhciBib3hlcyA9IHJlcXVpcmUoJy4uL2xpYi9jb3JlL3RpbWUvYm94ZXMuanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL2xpYi9jb3JlL3RpbWUvdXRpbHMuanMnKTtcbnZhciBCb3ggPSBib3hlcy5Cb3g7XG52YXIgQm94TW9kZWwgPSBib3hlcy5Cb3hNb2RlbDtcblxuZGVzY3JpYmUoXCJ0ZXN0IGJveGVzXCIsIGZ1bmN0aW9uKCkge1xuICAgIGl0KFwiZmluZHMgdGhlIHJpZ2h0IGJveCBieSBpbmRleFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gZXhwZWN0Qm94T2Zmc2V0KGRhdGEsIGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdChib3hlcy5maW5kQm94KGRhdGEsIGlkeCkuX29mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICB2YXIgZGF0YSA9IFt7X29mZnNldDogMH1dO1xuICAgICAgICBleHBlY3RCb3hPZmZzZXQoZGF0YSwgMCkudG9CZSgwKTtcbiAgICAgICAgZXhwZWN0Qm94T2Zmc2V0KGRhdGEsIDEpLnRvQmUoMCk7XG5cbiAgICAgICAgZGF0YSA9IFt7X29mZnNldDogMH0sIHtfb2Zmc2V0OiAxMH1dO1xuICAgICAgICBleHBlY3RCb3hPZmZzZXQoZGF0YSwgMCkudG9CZSgwKTtcbiAgICAgICAgZXhwZWN0Qm94T2Zmc2V0KGRhdGEsIDUpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdEJveE9mZnNldChkYXRhLCAxMCkudG9CZSgxMCk7XG4gICAgICAgIGV4cGVjdEJveE9mZnNldChkYXRhLCAxMSkudG9CZSgxMCk7XG4gICAgfSk7XG4gICAgaXQoXCJib3ggc3RlcHMgd29ya3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vZXhwZWN0KG5ldyBCb3goe2RhdGE6IFsxLCAyLCAzXX0pLmdldFN0ZXBzKCkpLnRvQmUoMyk7XG4gICAgICAgIGV4cGVjdChuZXcgQm94KHtyYW5nZTogdXRpbHMuY3JlYXRlUmFuZ2UoMTAwMDAsIDIwMDAwKSwgc3BlZWQ6IHtpbnRlcnZhbDogMTAwMH19KS5nZXRTdGVwcygpKS50b0JlKDExKTtcbiAgICAgICAgZXhwZWN0KG5ldyBCb3goe3JhbmdlOiB1dGlscy5jcmVhdGVSYW5nZSgxMDAwMCwgMTEwMDApLCBzcGVlZDoge2ludGVydmFsOiAzMzN9fSkuZ2V0U3RlcHMoKSkudG9CZSg0KTtcbiAgICB9KTtcbiAgICBpdChcImJveCBnZXRJbmRleCB3b3Jrc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJveCA9IG5ldyBCb3goe2RhdGE6IFsxLCA1LCAxMF19KTtcbiAgICAgICAgZXhwZWN0KGJveC5nZXRJbmRleCgwKSkudG9CZSgwKTtcbiAgICAgICAgZXhwZWN0KGJveC5nZXRJbmRleCgxKSkudG9CZSgwKTtcbiAgICAgICAgZXhwZWN0KGJveC5nZXRJbmRleCgzKSkudG9CZSgwKTtcbiAgICAgICAgZXhwZWN0KGJveC5nZXRJbmRleCgxMCkpLnRvQmUoMik7XG5cbiAgICAgICAgYm94ID0gbmV3IEJveCh7cmFuZ2U6IHV0aWxzLmNyZWF0ZVJhbmdlKDEwLCAyMCksIHNwZWVkOiB7aW50ZXJ2YWw6IDV9fSk7XG4gICAgICAgIGV4cGVjdChib3guZ2V0SW5kZXgoNSkpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdChib3guZ2V0SW5kZXgoMTApKS50b0JlKDApO1xuICAgICAgICBleHBlY3QoYm94LmdldEluZGV4KDEyKSkudG9CZSgwKTtcbiAgICAgICAgZXhwZWN0KGJveC5nZXRJbmRleCgxNSkpLnRvQmUoMSk7XG4gICAgICAgIGV4cGVjdChib3guZ2V0SW5kZXgoMTgpKS50b0JlKDEpO1xuICAgICAgICBleHBlY3QoYm94LmdldEluZGV4KDIwKSkudG9CZSgyKTtcbiAgICAgICAgZXhwZWN0KGJveC5nZXRJbmRleCgyNSkpLnRvQmUoMik7XG4gICAgfSk7XG4gICAgaXQoXCJib3ggZ2V0RGF0ZSB3b3Jrc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJveCA9IG5ldyBCb3goe2RhdGE6IFsxLCA1LCAxMF19KTtcbiAgICAgICAgYm94Ll9vZmZzZXQgPSAwO1xuICAgICAgICBleHBlY3QoYm94LmdldERhdGUoMCkpLnRvQmUoMSk7XG4gICAgICAgIGJveC5fb2Zmc2V0ID0gMTA7XG4gICAgICAgIGV4cGVjdChib3guZ2V0RGF0ZSgxMSkpLnRvQmUoNSk7XG5cbiAgICAgICAgYm94ID0gbmV3IEJveCh7cmFuZ2U6IHV0aWxzLmNyZWF0ZVJhbmdlKDEwLCAyMCksIHNwZWVkOiB7aW50ZXJ2YWw6IDV9fSk7XG4gICAgICAgIGJveC5fb2Zmc2V0ID0gMDtcbiAgICAgICAgZXhwZWN0KGJveC5nZXREYXRlKDApKS50b0JlKDEwKTtcbiAgICAgICAgYm94Ll9vZmZzZXQgPSAxMDtcbiAgICAgICAgZXhwZWN0KGJveC5nZXREYXRlKDExKSkudG9CZSgxNSk7XG4gICAgfSk7XG59KTtcblxuZGVzY3JpYmUoXCJ0ZXN0IGJveCBtb2RlbFwiLCBmdW5jdGlvbigpIHtcbiAgICBpdChcInNob3VsZCB3b3JrIHdpdGggYSBzaW5nbGUgYm94IG9mIGxpc3QgZGF0YVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgQm94TW9kZWwoW3tkYXRhOiBbMSwgMiwgM119XSk7XG4gICAgICAgIHZhciByYW5nZSA9IGNvbnRyb2xsZXIuZ2V0UmFuZ2UoKTtcbiAgICAgICAgZXhwZWN0KHJhbmdlLnN0YXJ0KS50b0JlKDEpO1xuICAgICAgICBleHBlY3QocmFuZ2UuZW5kKS50b0JlKDMpO1xuICAgICAgICAvL2V4cGVjdChjb250cm9sbGVyLmdldFN0ZXBzKCkpLnRvQmUoMyk7XG4gICAgICAgIHJhbmdlID0gY29udHJvbGxlci5nZXRSYW5nZUF0KDAsIDEpO1xuICAgICAgICBleHBlY3QocmFuZ2Uuc3RhcnQpLnRvQmUoMSk7XG4gICAgICAgIGV4cGVjdChyYW5nZS5lbmQpLnRvQmUoMik7XG4gICAgICAgIGV4cGVjdChjb250cm9sbGVyLmdldEluZGV4KDEpKS50b0JlKDApO1xuICAgIH0pO1xuICAgIGl0KFwic2hvdWxkIHdvcmsgd2l0aCB0d28gbGlzdCBib3hlc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgQm94TW9kZWwoW3tkYXRhOiBbMSwgMiwgM119LCB7ZGF0YTogWzQsIDUsIDZdfV0pO1xuICAgICAgICB2YXIgcmFuZ2UgPSBjb250cm9sbGVyLmdldFJhbmdlKCk7XG4gICAgICAgIGV4cGVjdChyYW5nZS5zdGFydCkudG9CZSgxKTtcbiAgICAgICAgZXhwZWN0KHJhbmdlLmVuZCkudG9CZSg2KTtcbiAgICAgICAgLy9leHBlY3QoY29udHJvbGxlci5nZXRTdGVwcygpKS50b0JlKDYpO1xuICAgICAgICByYW5nZSA9IGNvbnRyb2xsZXIuZ2V0UmFuZ2VBdCgyLCAzKTtcbiAgICAgICAgLy9leHBlY3QocmFuZ2Uuc3RhcnQpLnRvQmUoMyk7XG4gICAgICAgIC8vZXhwZWN0KHJhbmdlLmVuZCkudG9CZSg0KTtcbiAgICAgICAgZXhwZWN0KGNvbnRyb2xsZXIuZ2V0SW5kZXgoMCkpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdChjb250cm9sbGVyLmdldEluZGV4KDMpKS50b0JlKDIpO1xuICAgICAgICAvL2V4cGVjdChjb250cm9sbGVyLmdldEluZGV4KDQpKS50b0JlKDMpO1xuICAgICAgICAvL2V4cGVjdChjb250cm9sbGVyLmdldEluZGV4KDcpKS50b0JlKDYpO1xuICAgIH0pO1xuICAgIGl0KFwic2hvdWxkIHdvcmsgd2l0aCBvbmUgcmFuZ2UgYm94XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29udHJvbGxlciA9IG5ldyBCb3hNb2RlbChbe3JhbmdlOiB1dGlscy5jcmVhdGVSYW5nZSgxMCwgMjApLCBzcGVlZDoge2ludGVydmFsOiA1fX1dKTtcbiAgICAgICAgdmFyIHJhbmdlID0gY29udHJvbGxlci5nZXRSYW5nZSgpO1xuICAgICAgICBleHBlY3QocmFuZ2Uuc3RhcnQpLnRvQmUoMTApO1xuICAgICAgICBleHBlY3QocmFuZ2UuZW5kKS50b0JlKDIwKTtcbiAgICAgICAgLy9leHBlY3QoY29udHJvbGxlci5nZXRTdGVwcygpKS50b0JlKDMpO1xuICAgICAgICByYW5nZSA9IGNvbnRyb2xsZXIuZ2V0UmFuZ2VBdCgwLCAxKTtcbiAgICAgICAgZXhwZWN0KHJhbmdlLnN0YXJ0KS50b0JlKDEwKTtcbiAgICAgICAgZXhwZWN0KHJhbmdlLmVuZCkudG9CZSgxNSk7XG4gICAgICAgIGV4cGVjdChjb250cm9sbGVyLmdldEluZGV4KDEpKS50b0JlKDApO1xuICAgICAgICBcbiAgICB9KTtcbiAgICBpdChcInNob3VsZCB3b3JrIHdpdGggdHdvIHJhbmdlIGJveGVzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29udHJvbGxlciA9IG5ldyBCb3hNb2RlbChbXG4gICAgICAgICAgICB7cmFuZ2U6IHV0aWxzLmNyZWF0ZVJhbmdlKDEwLCAyMCksIHNwZWVkOiB7aW50ZXJ2YWw6IDV9fSxcbiAgICAgICAgICAgIHtyYW5nZTogdXRpbHMuY3JlYXRlUmFuZ2UoMzAsIDUwKSwgc3BlZWQ6IHtpbnRlcnZhbDogMTB9fVxuICAgICAgICBdKTtcbiAgICAgICAgdmFyIHJhbmdlID0gY29udHJvbGxlci5nZXRSYW5nZSgpO1xuICAgICAgICBleHBlY3QocmFuZ2Uuc3RhcnQpLnRvQmUoMTApO1xuICAgICAgICBleHBlY3QocmFuZ2UuZW5kKS50b0JlKDUwKTtcbiAgICAgICAgZXhwZWN0KGNvbnRyb2xsZXIuZ2V0U3RlcHMoKSkudG9CZSg2KTtcbiAgICAgICAgcmFuZ2UgPSBjb250cm9sbGVyLmdldFJhbmdlQXQoMiwgMyk7XG4gICAgICAgIGV4cGVjdChyYW5nZS5zdGFydCkudG9CZSgyMCk7XG4gICAgICAgIGV4cGVjdChyYW5nZS5lbmQpLnRvQmUoMzApO1xuICAgICAgICBleHBlY3QoY29udHJvbGxlci5nZXRJbmRleCg0MCkpLnRvQmUoNCk7XG4gICAgfSk7XG59KTtcbiIsInZhciBtYXBzID0gcmVxdWlyZSgnLi4vbGliL2NvcmUvdGltZS9tYXBzLmpzJyk7XG5yZXF1aXJlKCcuLi9saWIvbmcvY29yZS9vZ2MvbW9kdWxlLmpzJyk7XG5cbmRlc2NyaWJlKFwidGVzdCBtYXBzXCIsIGZ1bmN0aW9uKCkge1xuICAgIGl0KFwicmVhZENhcGFiaWxpdGllc1RpbWVEaW1lbnNpb25zIHdvcmtzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBtYWtlQ2Fwcyhjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0eToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllcjogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY29uZmlnKS5tYXAoZnVuY3Rpb24obHlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7bmFtZTogbHlyLCBkaW1lbnNpb246IHt9LCBleHRlbnQ6IFt7dmFsdWU6IGNvbmZpZ1tseXJdfV19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGV4cGVjdERhdGEoYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdChtYXBzLnJlYWRDYXBhYmlsaXRpZXNUaW1lRGltZW5zaW9ucyhtYWtlQ2FwcyhhcmdzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlYWQodmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwcy5yZWFkQ2FwYWJpbGl0aWVzVGltZURpbWVuc2lvbnMobWFrZUNhcHMoe2RhdGE6dmFsdWVzfSkpLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGltZShzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShzdHIpLmdldFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IHJlYWQoJzE5OTAtMDEtMDFUMDA6MDA6MDAuMDAwWi8yMDA5LTAxLTAxVDAwOjAwOjAwLjAwMFovUDFZJyk7XG4gICAgICAgIGV4cGVjdChyLnN0YXJ0KS50b0JlKHRpbWUoJzE5OTAtMDEtMDFUMDA6MDA6MDAuMDAwWicpKTtcbiAgICAgICAgZXhwZWN0KHIuZW5kKS50b0JlKHRpbWUoJzIwMDktMDEtMDFUMDA6MDA6MDAuMDAwWicpKTtcbiAgICAgICAgZXhwZWN0KHIuaW50ZXJ2YWwpLnRvQmUoMzE1MzYwMDAwMDApO1xuXG4gICAgICAgIGV4cGVjdERhdGEoe2xpc3Q6ICcxOTkwJ30pLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAge2xpc3Q6IFt0aW1lKCcxOTkwJyldfVxuICAgICAgICApO1xuICAgICAgICBleHBlY3REYXRhKHtsaXN0OiAnMTk5MCwxOTkxLDE5OTInfSkudG9FcXVhbChcbiAgICAgICAgICAgICAgICB7bGlzdDogW3RpbWUoJzE5OTAnKSx0aW1lKCcxOTkxJyksdGltZSgnMTk5MicpXX1cbiAgICAgICAgKTtcblxuICAgICAgICByID0gcmVhZCgnMjAwMC8yMDAxJyk7XG4gICAgICAgIGV4cGVjdChyLnN0YXJ0KS50b0JlKHRpbWUoJzIwMDAnKSk7XG4gICAgICAgIGV4cGVjdChyLmVuZCkudG9CZSh0aW1lKCcyMDAxJykpO1xuICAgIH0pO1xuICAgIGl0KFwicmVhZENhcGFiaWxpdGllc1RpbWVEaW1lbnNpb25zIHdvcmtzIGZvciBPcGVuTGF5ZXJzIDIgY29uZmlnXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBtYWtlQ2FwcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAndGltZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogW1wiMTk4OS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk5MC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk5MS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk5Mi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk5My0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk5NC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk5NS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk5Ni0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk5Ny0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk5OC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMTk5OS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMjAwMC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMjAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMjAwMi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMjAwMy0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMjAwNC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMjAwNS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMjAwNi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMjAwNy0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMjAwOC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMjAwOS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMjAxMC0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMjAxMS0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMjAxMi0wMS0wMVQwMDowMDowMC4wMDBaXCIsIFwiMjAxMy0wMS0wMVQwMDowMDowMC4wMDBaXCJdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gbWFwcy5yZWFkQ2FwYWJpbGl0aWVzVGltZURpbWVuc2lvbnMobWFrZUNhcHMoKSwgdHJ1ZSk7XG4gICAgICAgIGV4cGVjdChkYXRhLmxlbmd0aCkudG9CZSgyNSk7XG4gICAgICAgIGV4cGVjdChkYXRhWzBdKS50b0JlKDU5OTYxNjAwMDAwMCk7XG4gICAgICAgIGV4cGVjdChkYXRhWzI0XSkudG9CZSgxMzU2OTk4NDAwMDAwKTtcbiAgICB9KTtcbiAgICBkZXNjcmliZSgnY29tcHV0ZVZlY3RvclJhbmdlIHdvcmtzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdG9yeUxheWVyLCBmZWF0dXJlcywgcmFuZ2UsIFN0b3J5TGF5ZXI7XG5cbiAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlIGlzIHdvcmsgYXJvdW5kIGJyb3dzZXJpZnkgY29uZmxpY3RcbiAgICAgICAgICAgIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlKCdzdG9yeXRvb2xzLmNvcmUub2djJyk7XG5cbiAgICAgICAgICAgIGluamVjdChmdW5jdGlvbigkaW5qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBTdG9yeUxheWVyID0gJGluamVjdG9yLmdldCgnU3RvcnlMYXllcicpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHN0b3J5TGF5ZXIgPSBuZXcgU3RvcnlMYXllcih7XG4gICAgICAgICAgICAgICAgdGltZUF0dHJpYnV0ZTogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJWRUNUT1JcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdG9yeUxheWVyLmdldExheWVyKCkuc2V0U291cmNlKG5ldyBvbC5zb3VyY2UuVmVjdG9yKCkpO1xuXG4gICAgICAgICAgICBmZWF0dXJlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgb2wuRmVhdHVyZSh7dGltZTogMTAwMH0pXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc3RvcnlMYXllci5zZXQoJ2ZlYXR1cmVzJywgZmVhdHVyZXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgndXNpbmcgZmVhdHVyZXMgYXMgcHJvcGVydHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJhbmdlID0gbWFwcy5jb21wdXRlVmVjdG9yUmFuZ2Uoc3RvcnlMYXllcik7XG4gICAgICAgICAgICBleHBlY3QocmFuZ2Uuc3RhcnQpLnRvQmUoMTAwMCk7XG4gICAgICAgICAgICBleHBlY3QocmFuZ2UuZW5kKS50b0JlKDEwMDApO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3VzaW5nIGZlYXR1cmVzIGZyb20gc291cmNlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzdG9yeUxheWVyLnNldCgnZmVhdHVyZXMnLCBudWxsKTtcbiAgICAgICAgICAgIHN0b3J5TGF5ZXIuZ2V0TGF5ZXIoKS5nZXRTb3VyY2UoKS5hZGRGZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgICAgICAgICByYW5nZSA9IG1hcHMuY29tcHV0ZVZlY3RvclJhbmdlKHN0b3J5TGF5ZXIpO1xuICAgICAgICAgICAgZXhwZWN0KHJhbmdlLnN0YXJ0KS50b0JlKDEwMDApO1xuICAgICAgICAgICAgZXhwZWN0KHJhbmdlLmVuZCkudG9CZSgxMDAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCd3aGVuIGVtcHR5IGVuZFRpbWVBdHRyaWJ1dGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdlbmRUaW1lQXR0cmlidXRlJywgJ2VuZFRpbWUnKTtcbiAgICAgICAgICAgIHJhbmdlID0gbWFwcy5jb21wdXRlVmVjdG9yUmFuZ2Uoc3RvcnlMYXllcik7XG4gICAgICAgICAgICBleHBlY3QocmFuZ2Uuc3RhcnQpLnRvQmUoMTAwMCk7XG4gICAgICAgICAgICBleHBlY3QocmFuZ2UuZW5kKS50b0JlKDEwMDApO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3doZW4gdW5zb3J0ZWQgbWl4ZWQgZGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3RvcnlMYXllci5zZXQoJ2VuZFRpbWVBdHRyaWJ1dGUnLCAnZW5kVGltZScpO1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChuZXcgb2wuRmVhdHVyZSh7dGltZTogNTAwfSkpO1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChuZXcgb2wuRmVhdHVyZSh7dGltZTogMTAwLCBlbmRUaW1lOiA5MDB9KSk7XG4gICAgICAgICAgICByYW5nZSA9IG1hcHMuY29tcHV0ZVZlY3RvclJhbmdlKHN0b3J5TGF5ZXIpO1xuICAgICAgICAgICAgZXhwZWN0KHJhbmdlLnN0YXJ0KS50b0JlKDEwMCk7XG4gICAgICAgICAgICBleHBlY3QocmFuZ2UuZW5kKS50b0JlKDEwMDApO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3dpdGggc2luZ2xlIGVuZEF0dHJpYnV0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3RvcnlMYXllci5zZXQoJ2VuZFRpbWVBdHRyaWJ1dGUnLCAnZW5kVGltZScpO1xuICAgICAgICAgICAgc3RvcnlMYXllci5zZXQoJ2ZlYXR1cmVzJywgW25ldyBvbC5GZWF0dXJlKHtlbmRUaW1lOiA2Nzh9KV0pO1xuICAgICAgICAgICAgcmFuZ2UgPSBtYXBzLmNvbXB1dGVWZWN0b3JSYW5nZShzdG9yeUxheWVyKTtcbiAgICAgICAgICAgIGV4cGVjdChyYW5nZS5zdGFydCkudG9CZSg2NzgpO1xuICAgICAgICAgICAgZXhwZWN0KHJhbmdlLmVuZCkudG9CZSg2NzgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3doZW4gdGV4dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gd29ya3Mgd2l0aCB0ZXh0XG4gICAgICAgICAgICBzdG9yeUxheWVyLnNldCgnZmVhdHVyZXMnLCBbbmV3IG9sLkZlYXR1cmUoe3RpbWU6ICcyMDAxJ30pXSk7XG4gICAgICAgICAgICByYW5nZSA9IG1hcHMuY29tcHV0ZVZlY3RvclJhbmdlKHN0b3J5TGF5ZXIpO1xuICAgICAgICAgICAgZXhwZWN0KHJhbmdlLnN0YXJ0KS50b0JlKERhdGUucGFyc2UoJzIwMDEnKSk7XG4gICAgICAgICAgICBleHBlY3QocmFuZ2UuZW5kKS50b0JlKERhdGUucGFyc2UoJzIwMDEnKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGRlc2NyaWJlKCdmaWx0ZXJWZWN0b3JMYXllciB3b3JrcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RvcnlMYXllciwgZmVhdHVyZXMsIFN0b3J5TGF5ZXI7XG5cbiAgICAgICAgZnVuY3Rpb24gaWRzKCkge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gc3RvcnlMYXllci5nZXRMYXllcigpO1xuICAgICAgICAgICAgdmFyIGlkcyA9IGxheWVyLmdldFNvdXJjZSgpLmdldEZlYXR1cmVzKCkubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZi5nZXQoJ2lkJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlkcy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlIGlzIHdvcmsgYXJvdW5kIGJyb3dzZXJpZnkgY29uZmxpY3RcbiAgICAgICAgICAgIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlKCdzdG9yeXRvb2xzLmNvcmUub2djJyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpbmplY3QoZnVuY3Rpb24oJGluamVjdG9yKSB7XG4gICAgICAgICAgICAgICAgU3RvcnlMYXllciA9ICRpbmplY3Rvci5nZXQoJ1N0b3J5TGF5ZXInKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzdG9yeUxheWVyID0gbmV3IFN0b3J5TGF5ZXIoe1xuICAgICAgICAgICAgICB0aW1lQXR0cmlidXRlOiBcInRpbWVcIixcbiAgICAgICAgICAgICAgZW5kVGltZUF0dHJpYnV0ZTogXCJlbmRUaW1lXCIsXG4gICAgICAgICAgICAgIHR5cGU6IFwiVkVDVE9SXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RvcnlMYXllci5nZXRMYXllcigpLnNldFNvdXJjZShuZXcgb2wuc291cmNlLlZlY3RvcigpKTtcbiAgICAgICAgICAgIHZhciBpZCA9IDE7XG4gICAgICAgICAgICBmZWF0dXJlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgb2wuRmVhdHVyZSh7aWQ6aWQrKywgdGltZTogMTAwMH0pLFxuICAgICAgICAgICAgICAgIG5ldyBvbC5GZWF0dXJlKHtpZDppZCsrLCB0aW1lOiAxMDAwLCBlbmRUaW1lOiAyMDAwfSksXG4gICAgICAgICAgICAgICAgbmV3IG9sLkZlYXR1cmUoe2lkOmlkKyssIHRpbWU6IDIwMDB9KSxcbiAgICAgICAgICAgICAgICBuZXcgb2wuRmVhdHVyZSh7aWQ6aWQrKywgdGltZTogMjAwMCwgZW5kVGltZTogMzAwMH0pXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc3RvcnlMYXllci5zZXQoJ2ZlYXR1cmVzJywgZmVhdHVyZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ2ZpbHRlcnMgaW5zdGFudHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN0b3J5TGF5ZXIuc2V0KCdlbmRUaW1lQXR0cmlidXRlJywgbnVsbCk7XG4gICAgICAgICAgICAvLyByYW5nZSBiZWZvcmUgZXZlcnl0aGluZ1xuICAgICAgICAgICAgbWFwcy5maWx0ZXJWZWN0b3JMYXllcihzdG9yeUxheWVyLCB7c3RhcnQ6NTAwLCBlbmQ6IDUwMX0pO1xuICAgICAgICAgICAgZXhwZWN0KGlkcygpKS50b0VxdWFsKFtdKTtcbiAgICAgICAgICAgIC8vIHJhbmdlIGFmdGVyIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgIG1hcHMuZmlsdGVyVmVjdG9yTGF5ZXIoc3RvcnlMYXllciwge3N0YXJ0OjI1MDAsIGVuZDogMjYwMH0pO1xuICAgICAgICAgICAgZXhwZWN0KGlkcygpKS50b0VxdWFsKFtdKTtcbiAgICAgICAgICAgIC8vIGRpcmVjdCBoaXQgKGlnbm9yZXMgZW5kIGV4Y2x1c2lvbilcbiAgICAgICAgICAgIG1hcHMuZmlsdGVyVmVjdG9yTGF5ZXIoc3RvcnlMYXllciwge3N0YXJ0OjIwMDAsIGVuZDogMjAwMH0pO1xuICAgICAgICAgICAgZXhwZWN0KGlkcygpKS50b0VxdWFsKFszLDRdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdmaWx0ZXJzIGV4dGVudHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHJhbmdlIGJlZm9yZSBldmVyeXRoaW5nXG4gICAgICAgICAgICBtYXBzLmZpbHRlclZlY3RvckxheWVyKHN0b3J5TGF5ZXIsIHtzdGFydDo1MDAsIGVuZDogNTAxfSk7XG4gICAgICAgICAgICBleHBlY3QoaWRzKCkpLnRvRXF1YWwoW10pO1xuICAgICAgICAgICAgLy8gcmFuZ2UgYmVmb3JlIGFuZCBhZnRlciBldmVyeXRoaW5nXG4gICAgICAgICAgICBtYXBzLmZpbHRlclZlY3RvckxheWVyKHN0b3J5TGF5ZXIsIHtzdGFydDo1MDAsIGVuZDogNDAwMH0pO1xuICAgICAgICAgICAgZXhwZWN0KGlkcygpKS50b0VxdWFsKFsxLDIsMyw0XSk7XG4gICAgICAgICAgICAvLyBleGNsdWRlcyAzIGR1ZSB0byBpbnRlcnNlY3Rpb24gcnVsZXMgd2l0aCBlbmRcbiAgICAgICAgICAgIG1hcHMuZmlsdGVyVmVjdG9yTGF5ZXIoc3RvcnlMYXllciwge3N0YXJ0OjEwMDAsIGVuZDoyMDAwfSk7XG4gICAgICAgICAgICBleHBlY3QoaWRzKCkpLnRvRXF1YWwoWzEsMl0pO1xuICAgICAgICAgICAgLy8gMSBhbmQgMyBpbmNsdWRlZCBhcyB0aGV5IGFyZSBvcGVuIGVuZGVkIGFuZCBiZWZvcmVcbiAgICAgICAgICAgIG1hcHMuZmlsdGVyVmVjdG9yTGF5ZXIoc3RvcnlMYXllciwge3N0YXJ0OjMwMDAsIGVuZDo0MDAwfSk7XG4gICAgICAgICAgICBleHBlY3QoaWRzKCkpLnRvRXF1YWwoWzEsMyw0XSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ01hcENvbmZpZycsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgLy8gd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUgaXMgd29yayBhcm91bmQgYnJvd3NlcmlmeSBjb25mbGljdFxuICAgICAgICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSgnc3Rvcnl0b29scy5jb3JlLm9nYycpO1xuICBcbiAgICAgICAgICAgICAgaW5qZWN0KGZ1bmN0aW9uKCRpbmplY3Rvcikge1xuICAgICAgICAgICAgICAgICAgU3RvcnlNYXAgPSAkaW5qZWN0b3IuZ2V0KCdTdG9yeU1hcCcpO1xuICAgICAgICAgICAgICAgICAgRWRpdGFibGVTdG9yeU1hcCA9ICRpbmplY3Rvci5nZXQoJ0VkaXRhYmxlU3RvcnlNYXAnKTtcbiAgICAgICAgICAgICAgICAgIHN0U3RvcnlNYXBCdWlsZGVyID0gJGluamVjdG9yLmdldCgnc3RTdG9yeU1hcEJ1aWxkZXInKTtcbiAgICAgICAgICAgICAgICAgIHN0U3RvcnlNYXBCYXNlQnVpbGRlciA9ICRpbmplY3Rvci5nZXQoJ3N0U3RvcnlNYXBCYXNlQnVpbGRlcicpO1xuICAgICAgICAgICAgICAgICAgc3RMYXllckJ1aWxkZXIgPSAkaW5qZWN0b3IuZ2V0KCdzdExheWVyQnVpbGRlcicpO1xuICAgICAgICAgICAgICAgICAgJHRpbWVvdXQgPSAkaW5qZWN0b3IuZ2V0KCckdGltZW91dCcpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyppdCgnc2hvdWxkIHRyYW5zZm9ybSB0byBJbnRlcnZhbCBvYmplY3QnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoJ3tcImlkXCI6MjE0LFwibWFwXCI6e1wiY2VudGVyXCI6WzAsMF0sXCJwcm9qZWN0aW9uXCI6XCJFUFNHOjM4NTdcIixcInpvb21cIjozLFwibGF5ZXJzXCI6W3tcImlkXCI6XCJmb29cIixcIm5hbWVcIjpcImZvb1wiLFwidGl0bGVcIjpcIk15IGxheWVyXCIsXCJnZW9tVHlwZVwiOlwicG9pbnRcIixcImF0dHJpYnV0ZXNcIjogW1wiYXR0cjFcIiwgXCJhdHRyMlwiXSxcInRpbWVBdHRyaWJ1dGVcIjpcImF0dHIxXCIsXCJyZXNvbHV0aW9uc1wiOlswLDEwLCAyMF0sXCJiYm94XCI6IFswLDEwMCwxMDAsMjAwXSxcImxhdGxvbkJCT1hcIjpbLTEwLC0xMCwxMCwxMF0sXCJ0aW1lc1wiOntcInN0YXJ0XCI6IDYzMTE1MjAwMDAwMCwgXCJlbmRcIjogMTIzMDc2ODAwMDAwMCwgXCJkdXJhdGlvblwiOiBcIlAxWVwifSxcInNpbmdsZVRpbGVcIjpmYWxzZSxcInR5cGVcIjpcIldNU1wiLFwidXJsXCI6XCJodHRwOi8vbXlzZXJ2ZXJcIixcInBhcmFtc1wiOntcIkxBWUVSU1wiOlwieFwifX1dfX0nKTtcbiAgICAgICAgICAgIHZhciBzdG9yeU1hcCA9IG5ldyBTdG9yeU1hcCh7dGFyZ2V0OiAnZm9vJ30pO1xuICAgICAgICAgICAgc3RvcnlNYXAuZ2V0U3RvcnlMYXllcnMoKS5vbignY2hhbmdlOmxlbmd0aCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBleHBlY3Qoc3RvcnlNYXAuZ2V0U3RvcnlMYXllcnMoKS5pdGVtKDApLmdldCgndGltZXMnKS5pbnRlcnZhbCkudG9CZSgzMTUzNjAwMDAwMCk7XG4gICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RTdG9yeU1hcEJ1aWxkZXIubW9kaWZ5U3RvcnlNYXAoc3RvcnlNYXAsIGRhdGEpO1xuICAgICAgICAgICAgJHRpbWVvdXQuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICAgICovXG5cbiAgICAgICAgaXQoJ3Nob3VsZCBjb252ZXJ0IGV4dGVudCwgem9vbSBhbmQgcHJvamVjdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHN0b3J5TWFwID0gbmV3IEVkaXRhYmxlU3RvcnlNYXAoe3RhcmdldDogJ2Zvbyd9KTtcbiAgICAgICAgICAgIHN0b3J5TWFwLnNldCgnaWQnLCAyMTUpO1xuICAgICAgICAgICAgc3RvcnlNYXAuZ2V0TWFwKCkuc2V0VmlldyhuZXcgb2wuVmlldyh7Y2VudGVyOiBbMCwwXSwgem9vbTogM30pKTtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBzdG9yeU1hcC5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gJ3tcIm1hcFwiOntcImNlbnRlclwiOlswLDBdLFwicHJvamVjdGlvblwiOlwiRVBTRzozODU3XCIsXCJ6b29tXCI6MyxcImxheWVyc1wiOltdfSxcImlkXCI6MjE1fSc7XG4gICAgICAgICAgICBleHBlY3QoSlNPTi5zdHJpbmdpZnkoY29uZmlnKSkudG9CZShleHBlY3RlZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgY29udmVydCBhIHRpbGVkIFdNUyBsYXllcicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIHZhciBzdG9yeU1hcCA9IG5ldyBFZGl0YWJsZVN0b3J5TWFwKHt0YXJnZXQ6ICdmb28nfSk7XG4gICAgICAgICAgICBzdG9yeU1hcC5zZXQoJ2lkJywgMjE2KTsgXG4gICAgICAgICAgICBzdG9yeU1hcC5nZXRNYXAoKS5zZXRWaWV3KG5ldyBvbC5WaWV3KHtjZW50ZXI6IFswLDBdLCB6b29tOiAzfSkpO1xuICAgICAgICAgICAgc3RMYXllckJ1aWxkZXIuYnVpbGRMYXllcih7XG4gICAgICAgICAgICAgIHR5cGU6ICdXTVMnLFxuICAgICAgICAgICAgICBpZDogJ2ZvbycsXG4gICAgICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICAgICAgdGl0bGU6ICdNeSBsYXllcicsXG4gICAgICAgICAgICAgIGdlb21UeXBlOiAncG9pbnQnLFxuICAgICAgICAgICAgICB0aW1lQXR0cmlidXRlOiAnYXR0cjEnLFxuICAgICAgICAgICAgICB0aW1lczogWycyMDAxJywgJzIwMDInLCAnMjAwMyddLFxuICAgICAgICAgICAgICB1cmw6ICdodHRwOi8vbXlzZXJ2ZXInLFxuICAgICAgICAgICAgICBsYXRsb25CQk9YOiBbLTkwLC0xODAsOTAsMTgwXSxcbiAgICAgICAgICAgICAgYmJveDogWzAsMCwxLDFdLFxuICAgICAgICAgICAgICByZXNvbHV0aW9uczogWzEwMCw1MCwxMF0sXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnZm9vJywnYmFyJ11cbiAgICAgICAgICAgIH0sIHN0b3J5TWFwLmdldE1hcCgpKS50aGVuKGZ1bmN0aW9uKHNsKSB7XG4gICAgICAgICAgICAgIHN0b3J5TWFwLmFkZFN0b3J5TGF5ZXIoc2wpO1xuICAgICAgICAgICAgICBleHBlY3Qoc2wuZ2V0TGF5ZXIoKSBpbnN0YW5jZW9mIG9sLmxheWVyLlRpbGUpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICAgIGV4cGVjdChzbC5nZXRMYXllcigpLmdldFNvdXJjZSgpIGluc3RhbmNlb2Ygb2wuc291cmNlLlRpbGVXTVMpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICAgIHZhciBjb25maWcgPSBzdG9yeU1hcC5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICB2YXIgZXhwZWN0ZWQgPSAne1wibWFwXCI6e1wiY2VudGVyXCI6WzAsMF0sXCJwcm9qZWN0aW9uXCI6XCJFUFNHOjM4NTdcIixcInpvb21cIjozLFwibGF5ZXJzXCI6W3tcInR5cGVcIjpcIldNU1wiLFwiaWRcIjpcImZvb1wiLFwibmFtZVwiOlwieFwiLFwidGl0bGVcIjpcIk15IGxheWVyXCIsXCJnZW9tVHlwZVwiOlwicG9pbnRcIixcInRpbWVBdHRyaWJ1dGVcIjpcImF0dHIxXCIsXCJ0aW1lc1wiOltcIjIwMDFcIixcIjIwMDJcIixcIjIwMDNcIl0sXCJ1cmxcIjpcImh0dHA6Ly9teXNlcnZlclwiLFwibGF0bG9uQkJPWFwiOlstOTAsLTE4MCw5MCwxODBdLFwiYmJveFwiOlswLDAsMSwxXSxcInJlc29sdXRpb25zXCI6WzEwMCw1MCwxMF0sXCJhdHRyaWJ1dGVzXCI6W1wiZm9vXCIsXCJiYXJcIl19XX0sXCJpZFwiOjIxNn0nO1xuICAgICAgICAgICAgICBleHBlY3QoSlNPTi5zdHJpbmdpZnkoY29uZmlnKSkudG9CZShleHBlY3RlZCk7XG4gICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJHRpbWVvdXQuZmx1c2goKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBjb252ZXJ0IGFuIHVudGlsZWQgV01TIGxheWVyJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgdmFyIHN0b3J5TWFwID0gbmV3IEVkaXRhYmxlU3RvcnlNYXAoe3RhcmdldDogJ2Zvbyd9KTtcbiAgICAgICAgICAgIHN0b3J5TWFwLnNldCgnaWQnLCAyMTcpO1xuICAgICAgICAgICAgc3RvcnlNYXAuZ2V0TWFwKCkuc2V0VmlldyhuZXcgb2wuVmlldyh7Y2VudGVyOiBbMCwwXSwgem9vbTogM30pKTtcbiAgICAgICAgICAgIHN0TGF5ZXJCdWlsZGVyLmJ1aWxkTGF5ZXIoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdXTVMnLFxuICAgICAgICAgICAgICAgIHNpbmdsZVRpbGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdNeSBsYXllcicsXG4gICAgICAgICAgICAgICAgaWQ6ICdmb28nLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICAgICAgICBnZW9tVHlwZTogJ3BvaW50JyxcbiAgICAgICAgICAgICAgICB0aW1lQXR0cjogJ2F0dHIxJyxcbiAgICAgICAgICAgICAgICB0aW1lczogWycyMDAxJywgJzIwMDInLCAnMjAwMyddLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHA6Ly9teXNlcnZlcicsXG4gICAgICAgICAgICAgICAgbGF0bG9uQkJPWDogWy05MCwtMTgwLDkwLDE4MF0sXG4gICAgICAgICAgICAgICAgYmJveDogWzAsMCwxLDFdLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb25zOiBbMTAwLDUwLDEwXSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2ZvbycsJ2JhciddXG4gICAgICAgICAgICB9LCBzdG9yeU1hcC5nZXRNYXAoKSkudGhlbihmdW5jdGlvbihzbCkge1xuICAgICAgICAgICAgICAgIHN0b3J5TWFwLmFkZFN0b3J5TGF5ZXIoc2wpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChzbC5nZXRMYXllcigpIGluc3RhbmNlb2Ygb2wubGF5ZXIuSW1hZ2UpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHNsLmdldExheWVyKCkuZ2V0U291cmNlKCkgaW5zdGFuY2VvZiBvbC5zb3VyY2UuSW1hZ2VXTVMpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHN0b3J5TWFwLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gJ3tcIm1hcFwiOntcImNlbnRlclwiOlswLDBdLFwicHJvamVjdGlvblwiOlwiRVBTRzozODU3XCIsXCJ6b29tXCI6MyxcImxheWVyc1wiOlt7XCJ0eXBlXCI6XCJXTVNcIixcInNpbmdsZVRpbGVcIjp0cnVlLFwidGl0bGVcIjpcIk15IGxheWVyXCIsXCJpZFwiOlwiZm9vXCIsXCJuYW1lXCI6XCJ4XCIsXCJnZW9tVHlwZVwiOlwicG9pbnRcIixcInRpbWVBdHRyXCI6XCJhdHRyMVwiLFwidGltZXNcIjpbXCIyMDAxXCIsXCIyMDAyXCIsXCIyMDAzXCJdLFwidXJsXCI6XCJodHRwOi8vbXlzZXJ2ZXJcIixcImxhdGxvbkJCT1hcIjpbLTkwLC0xODAsOTAsMTgwXSxcImJib3hcIjpbMCwwLDEsMV0sXCJyZXNvbHV0aW9uc1wiOlsxMDAsNTAsMTBdLFwiYXR0cmlidXRlc1wiOltcImZvb1wiLFwiYmFyXCJdfV19LFwiaWRcIjoyMTd9JztcbiAgICAgICAgICAgICAgICBleHBlY3QoSlNPTi5zdHJpbmdpZnkoY29uZmlnKSkudG9CZShleHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkdGltZW91dC5mbHVzaCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGNvbnZlcnQgYSB2ZWN0b3IgbGF5ZXInLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICB2YXIgc3RvcnlNYXAgPSBuZXcgRWRpdGFibGVTdG9yeU1hcCh7dGFyZ2V0OiAnZm9vJ30pO1xuICAgICAgICAgICAgc3RvcnlNYXAuc2V0KCdpZCcsIDIyNyk7XG4gICAgICAgICAgICBzdG9yeU1hcC5nZXRNYXAoKS5zZXRWaWV3KG5ldyBvbC5WaWV3KHtjZW50ZXI6IFswLDBdLCB6b29tOiAzfSkpO1xuICAgICAgICAgICAgc3RMYXllckJ1aWxkZXIuYnVpbGRMYXllcih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1ZFQ1RPUicsXG4gICAgICAgICAgICAgICAgaWQ6ICdmb28nLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAnTXkgbGF5ZXInLFxuICAgICAgICAgICAgICAgIHVybDogJy9nZW9zZXJ2ZXIvd2ZzJyxcbiAgICAgICAgICAgICAgICBnZW9tVHlwZTogJ3BvaW50JyxcbiAgICAgICAgICAgICAgICB0aW1lQXR0cjogJ2F0dHIxJyxcbiAgICAgICAgICAgICAgICB0eXBlTmFtZTogJ2ZvbycsXG4gICAgICAgICAgICAgICAgdGltZXM6IFsnMjAwMScsICcyMDAyJywgJzIwMDMnXSxcbiAgICAgICAgICAgICAgICBsYXRsb25CQk9YOiBbLTkwLC0xODAsOTAsMTgwXSxcbiAgICAgICAgICAgICAgICBiYm94OiBbMCwwLDEsMV0sXG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbnM6IFsxMDAsNTAsMTBdLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnZm9vJywnYmFyJ11cbiAgICAgICAgICAgIH0sIHN0b3J5TWFwLmdldE1hcCgpKS50aGVuKGZ1bmN0aW9uKHNsKSB7XG4gICAgICAgICAgICAgICAgc3RvcnlNYXAuYWRkU3RvcnlMYXllcihzbCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHNsLmdldExheWVyKCkgaW5zdGFuY2VvZiBvbC5sYXllci5WZWN0b3IpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHN0b3J5TWFwLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gJ3tcIm1hcFwiOntcImNlbnRlclwiOlswLDBdLFwicHJvamVjdGlvblwiOlwiRVBTRzozODU3XCIsXCJ6b29tXCI6MyxcImxheWVyc1wiOlt7XCJ0eXBlXCI6XCJWRUNUT1JcIixcImlkXCI6XCJmb29cIixcInRpdGxlXCI6XCJNeSBsYXllclwiLFwidXJsXCI6XCIvZ2Vvc2VydmVyL3dmc1wiLFwiZ2VvbVR5cGVcIjpcInBvaW50XCIsXCJ0aW1lQXR0clwiOlwiYXR0cjFcIixcInR5cGVOYW1lXCI6XCJmb29cIixcInRpbWVzXCI6W1wiMjAwMVwiLFwiMjAwMlwiLFwiMjAwM1wiXSxcImxhdGxvbkJCT1hcIjpbLTkwLC0xODAsOTAsMTgwXSxcImJib3hcIjpbMCwwLDEsMV0sXCJyZXNvbHV0aW9uc1wiOlsxMDAsNTAsMTBdLFwiYXR0cmlidXRlc1wiOltcImZvb1wiLFwiYmFyXCJdfV19LFwiaWRcIjoyMjd9JztcbiAgICAgICAgICAgICAgICBleHBlY3QoSlNPTi5zdHJpbmdpZnkoY29uZmlnKSkudG9CZShleHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkdGltZW91dC5mbHVzaCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGNvbnZlcnQgYW4gT1NNIGxheWVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc3RvcnlNYXAgPSBuZXcgRWRpdGFibGVTdG9yeU1hcCh7dGFyZ2V0OiAnZm9vJ30pO1xuICAgICAgICAgICAgc3RvcnlNYXAuc2V0KCdpZCcsIDIxOCk7XG4gICAgICAgICAgICBzdG9yeU1hcC5nZXRNYXAoKS5zZXRWaWV3KG5ldyBvbC5WaWV3KHtjZW50ZXI6IFswLDBdLCB6b29tOiAzfSkpO1xuICAgICAgICAgICAgc3RTdG9yeU1hcEJhc2VCdWlsZGVyLnNldEJhc2VMYXllcihzdG9yeU1hcCwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdPU00nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBleHBlY3RlZCA9ICd7XCJtYXBcIjp7XCJjZW50ZXJcIjpbMCwwXSxcInByb2plY3Rpb25cIjpcIkVQU0c6Mzg1N1wiLFwiem9vbVwiOjMsXCJsYXllcnNcIjpbe1widHlwZVwiOlwiT1NNXCIsXCJncm91cFwiOlwiYmFja2dyb3VuZFwiLFwidmlzaWJpbGl0eVwiOnRydWV9XX0sXCJpZFwiOjIxOH0nO1xuICAgICAgICAgICAgZXhwZWN0KEpTT04uc3RyaW5naWZ5KHN0b3J5TWFwLmdldFN0YXRlKCkpKS50b0JlKGV4cGVjdGVkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBjb252ZXJ0IGFuIE1hcFF1ZXN0IGxheWVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc3RvcnlNYXAgPSBuZXcgRWRpdGFibGVTdG9yeU1hcCh7dGFyZ2V0OiAnZm9vJ30pO1xuICAgICAgICAgICAgc3RvcnlNYXAuc2V0KCdpZCcsIDIxOSk7XG4gICAgICAgICAgICBzdG9yeU1hcC5nZXRNYXAoKS5zZXRWaWV3KG5ldyBvbC5WaWV3KHtjZW50ZXI6IFswLDBdLCB6b29tOiAzfSkpO1xuICAgICAgICAgICAgc3RTdG9yeU1hcEJhc2VCdWlsZGVyLnNldEJhc2VMYXllcihzdG9yeU1hcCwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNYXBRdWVzdCcsXG4gICAgICAgICAgICAgICAgbGF5ZXI6ICdzYXQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBleHBlY3RlZCA9ICd7XCJtYXBcIjp7XCJjZW50ZXJcIjpbMCwwXSxcInByb2plY3Rpb25cIjpcIkVQU0c6Mzg1N1wiLFwiem9vbVwiOjMsXCJsYXllcnNcIjpbe1widHlwZVwiOlwiTWFwUXVlc3RcIixcImxheWVyXCI6XCJzYXRcIixcImdyb3VwXCI6XCJiYWNrZ3JvdW5kXCIsXCJ2aXNpYmlsaXR5XCI6dHJ1ZX1dfSxcImlkXCI6MjE5fSc7XG4gICAgICAgICAgICBleHBlY3QoSlNPTi5zdHJpbmdpZnkoc3RvcnlNYXAuZ2V0U3RhdGUoKSkpLnRvQmUoZXhwZWN0ZWQpO1xuICAgICAgICB9KTtcblxuICAgIH0pO1xuXG59KTtcbiIsInJlcXVpcmUoJy4uL2xpYi9uZy9jb3JlL3N0eWxlL29sM1N0eWxlQ29udmVydGVyLmpzJyk7XG5yZXF1aXJlKCcuLi9saWIvbmcvY29yZS9zdHlsZS9zdmdJY29uLmpzJyk7XG5cbmRlc2NyaWJlKCdvbDNTdHlsZUNvbnZlcnRlcicsIGZ1bmN0aW9uKCkge1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUgaXMgd29yayBhcm91bmQgYnJvd3NlcmlmeSBjb25mbGljdFxuICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSgnc3Rvcnl0b29scy5jb3JlLnN0eWxlLm9sM1N0eWxlQ29udmVydGVyJyk7XG4gICAgICAgIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlKCdzdG9yeXRvb2xzLmNvcmUuc3R5bGUuc3ZnSWNvbicpO1xuXG4gICAgICAgIGluamVjdChmdW5jdGlvbihvbDNTdHlsZUNvbnZlcnRlcikge1xuICAgICAgICAgICAgdGhpcy5vbDNTdHlsZUNvbnZlcnRlciA9IG9sM1N0eWxlQ29udmVydGVyO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY29udmVydCBzaW1wbGUgc3R5cGVzJywgaW5qZWN0KGZ1bmN0aW9uKG9sM1N0eWxlQ29udmVydGVyKSB7XG4gICAgICAgIHZhciBzdHlsZUNvbmZpZyA9IHtcbiAgICAgICAgICAgIFwic3ltYm9sXCI6IHtcbiAgICAgICAgICAgICAgICBcInNpemVcIjogMTAsXG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcImNpcmNsZVwiLFxuICAgICAgICAgICAgICAgIFwiZ3JhcGhpY1wiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwiZ3JhcGhpY1R5cGVcIjogbnVsbCxcbiAgICAgICAgICAgICAgICBcImZpbGxDb2xvclwiOiBcIiNmZjAwMDBcIixcbiAgICAgICAgICAgICAgICBcImZpbGxPcGFjaXR5XCI6IDgwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogXCIjZmZmZjAwXCIsXG4gICAgICAgICAgICAgICAgXCJzdHJva2VXaWR0aFwiOiAzLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlU3R5bGVcIjogXCJzb2xpZFwiLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlT3BhY2l0eVwiOiA5MFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc3R5bGUgPSBvbDNTdHlsZUNvbnZlcnRlci5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlWzBdIGluc3RhbmNlb2Ygb2wuc3R5bGUuU3R5bGUpLnRvQmVUcnV0aHkoKTtcbiAgICAgICAgdmFyIGltYWdlID0gc3R5bGVbMF0uZ2V0SW1hZ2UoKTtcbiAgICAgICAgZXhwZWN0KGltYWdlIGluc3RhbmNlb2Ygb2wuc3R5bGUuQ2lyY2xlKS50b0JlVHJ1dGh5KCk7XG4gICAgICAgIGV4cGVjdChpbWFnZS5nZXRSYWRpdXMoKSkudG9CZSgxMC8yKTtcbiAgICAgICAgZXhwZWN0KGltYWdlLmdldEZpbGwoKS5nZXRDb2xvcigpKS50b0JlKCdyZ2JhKDI1NSwwLDAsMC44KScpO1xuICAgICAgICBleHBlY3QoaW1hZ2UuZ2V0U3Ryb2tlKCkuZ2V0Q29sb3IoKSkudG9CZSgncmdiYSgyNTUsMjU1LDAsMC45KScpO1xuICAgICAgICBleHBlY3QoaW1hZ2UuZ2V0U3Ryb2tlKCkuZ2V0V2lkdGgoKSkudG9CZSgzKTtcbiAgICAgICAgdmFyIG5ld1N0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZyk7XG4gICAgICAgIGV4cGVjdChzdHlsZSA9PT0gbmV3U3R5bGUpLnRvQmVUcnV0aHkoKTtcbiAgICB9KSk7XG5cbiAgICBpdCgnc2hvdWxkIGNvbnZlcnQgdG8gc3F1YXJlJywgaW5qZWN0KGZ1bmN0aW9uKG9sM1N0eWxlQ29udmVydGVyKSB7XG4gICAgICAgIHZhciBzaGFwZUNvbmZpZyA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU2hhcGVDb25maWcoe1xuICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwic3F1YXJlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5wb2ludHMpLnRvQmUoNCk7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5yYWRpdXMpLnRvQmUoMTAvMik7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5hbmdsZSkudG9CZShNYXRoLlBJIC8gNCk7XG4gICAgfSkpO1xuXG4gICAgaXQoJ3Nob3VsZCBjb252ZXJ0IHRvIHRyaWFuZ2xlJywgaW5qZWN0KGZ1bmN0aW9uKG9sM1N0eWxlQ29udmVydGVyKSB7XG4gICAgICAgIHZhciBzaGFwZUNvbmZpZyA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU2hhcGVDb25maWcoe1xuICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwidHJpYW5nbGVcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KHNoYXBlQ29uZmlnLnBvaW50cykudG9CZSgzKTtcbiAgICAgICAgZXhwZWN0KHNoYXBlQ29uZmlnLnJhZGl1cykudG9CZSgxMC8yKTtcbiAgICAgICAgZXhwZWN0KHNoYXBlQ29uZmlnLmFuZ2xlKS50b0JlKDApO1xuICAgIH0pKTtcblxuICAgIGl0KCdzaG91bGQgY29udmVydCB0byBzdGFyJywgaW5qZWN0KGZ1bmN0aW9uKG9sM1N0eWxlQ29udmVydGVyKSB7XG4gICAgICAgIHZhciBzaGFwZUNvbmZpZyA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU2hhcGVDb25maWcoe1xuICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwic3RhclwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBleHBlY3Qoc2hhcGVDb25maWcucG9pbnRzKS50b0JlKDUpO1xuICAgICAgICBleHBlY3Qoc2hhcGVDb25maWcucmFkaXVzKS50b0JlKDEwLzIpO1xuICAgICAgICBleHBlY3Qoc2hhcGVDb25maWcucmFkaXVzMikudG9CZSgxMC80KTtcbiAgICAgICAgZXhwZWN0KHNoYXBlQ29uZmlnLmFuZ2xlKS50b0JlKDApO1xuICAgIH0pKTtcblxuICAgIGl0KCdzaG91bGQgY29udmVydCB0byBjcm9zcycsIGluamVjdChmdW5jdGlvbihvbDNTdHlsZUNvbnZlcnRlcikge1xuICAgICAgICB2YXIgc2hhcGVDb25maWcgPSBvbDNTdHlsZUNvbnZlcnRlci5nZW5lcmF0ZVNoYXBlQ29uZmlnKHtcbiAgICAgICAgICAgIFwic3ltYm9sXCI6IHtcbiAgICAgICAgICAgICAgICBcInNpemVcIjogMTAsXG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcImNyb3NzXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5wb2ludHMpLnRvQmUoNCk7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5yYWRpdXMpLnRvQmUoMTAvMik7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5yYWRpdXMyKS50b0JlKDApO1xuICAgICAgICBleHBlY3Qoc2hhcGVDb25maWcuYW5nbGUpLnRvQmUoMCk7XG4gICAgfSkpO1xuXG4gICAgaXQoJ3Nob3VsZCBjb252ZXJ0IHRvIHgnLCBpbmplY3QoZnVuY3Rpb24ob2wzU3R5bGVDb252ZXJ0ZXIpIHtcbiAgICAgICAgdmFyIHNoYXBlQ29uZmlnID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTaGFwZUNvbmZpZyh7XG4gICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaXplXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJ4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5wb2ludHMpLnRvQmUoNCk7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5yYWRpdXMpLnRvQmUoMTAvMik7XG4gICAgICAgIGV4cGVjdChzaGFwZUNvbmZpZy5yYWRpdXMyKS50b0JlKDApO1xuICAgICAgICBleHBlY3Qoc2hhcGVDb25maWcuYW5nbGUpLnRvQmUoTWF0aC5QSSAvIDQpO1xuICAgIH0pKTtcblxuICAgIGl0KCdzaG91bGQgY29udmVydCBsYWJlbHMnLCBpbmplY3QoZnVuY3Rpb24ob2wzU3R5bGVDb252ZXJ0ZXIpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZSh7XG4gICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaXplXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJjaXJjbGVcIixcbiAgICAgICAgICAgICAgICBcImdyYXBoaWNcIjogbnVsbCxcbiAgICAgICAgICAgICAgICBcImdyYXBoaWNUeXBlXCI6IG51bGwsXG4gICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjZmYwMDAwXCIsXG4gICAgICAgICAgICAgICAgXCJmaWxsT3BhY2l0eVwiOiA4MFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICBcInN0cm9rZUNvbG9yXCI6IFwiI2ZmZmYwMFwiLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlV2lkdGhcIjogMyxcbiAgICAgICAgICAgICAgICBcInN0cm9rZVN0eWxlXCI6IFwic29saWRcIixcbiAgICAgICAgICAgICAgICBcInN0cm9rZU9wYWNpdHlcIjogOTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImxhYmVsXCI6IHtcbiAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZVwiOiBcImZvb1wiLFxuICAgICAgICAgICAgICAgIFwiZm9udFN0eWxlXCI6IFwiaXRhbGljXCIsXG4gICAgICAgICAgICAgICAgXCJmb250V2VpZ2h0XCI6IFwiYm9sZFwiLFxuICAgICAgICAgICAgICAgIFwiZm9udFNpemVcIjogMTIsXG4gICAgICAgICAgICAgICAgXCJmb250RmFtaWx5XCI6IFwiU2VyaWZcIixcbiAgICAgICAgICAgICAgICBcImZpbGxDb2xvclwiOiBcIiMwMDAwZmZcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBuZXcgb2wuRmVhdHVyZSh7J2Zvbyc6ICdiYXInfSkpO1xuICAgICAgICBleHBlY3Qoc3R5bGUubGVuZ3RoKS50b0JlKDEpO1xuICAgICAgICB2YXIgdGV4dCA9IHN0eWxlWzBdLmdldFRleHQoKTtcbiAgICAgICAgZXhwZWN0KHRleHQgaW5zdGFuY2VvZiBvbC5zdHlsZS5UZXh0KS50b0JlVHJ1dGh5KCk7XG4gICAgICAgIGV4cGVjdCh0ZXh0LmdldFRleHQoKSkudG9CZSgnYmFyJyk7XG4gICAgICAgIGV4cGVjdCh0ZXh0LmdldEZvbnQoKSkudG9CZSgnaXRhbGljIGJvbGQgMTJweCBTZXJpZicpO1xuICAgICAgICBleHBlY3QodGV4dC5nZXRGaWxsKCkuZ2V0Q29sb3IoKSkudG9CZSgnIzAwMDBmZicpO1xuICAgIH0pKTtcblxuICAgIGl0KCdzaG91bGQgdGFrZSByb3RhdGlvbiBpbnRvIGFjY291bnQnLCBpbmplY3QoZnVuY3Rpb24ob2wzU3R5bGVDb252ZXJ0ZXIpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZSh7XG4gICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaXplXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJ0cmlhbmdsZVwiLFxuICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiI2ZmMDAwMFwiLFxuICAgICAgICAgICAgICAgIFwicm90YXRpb25BdHRyaWJ1dGVcIjogJ3JvdGF0aW9uJyxcbiAgICAgICAgICAgICAgICBcInJvdGF0aW9uVW5pdHNcIjogJ3JhZGlhbnMnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG5ldyBvbC5GZWF0dXJlKHsncm90YXRpb24nOiBNYXRoLlBJLzR9KSk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRJbWFnZSgpLmdldFJvdGF0aW9uKCkpLnRvQmUoTWF0aC5QSS80KTtcbiAgICAgICAgdmFyIG5ld1N0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZSh7XG4gICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaXplXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJ0cmlhbmdsZVwiLFxuICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiI2ZmMDAwMFwiLFxuICAgICAgICAgICAgICAgIFwicm90YXRpb25BdHRyaWJ1dGVcIjogJ3JvdGF0aW9uJyxcbiAgICAgICAgICAgICAgICBcInJvdGF0aW9uVW5pdHNcIjogJ3JhZGlhbnMnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG5ldyBvbC5GZWF0dXJlKHsncm90YXRpb24nOiBNYXRoLlBJLzR9KSk7XG4gICAgICAgIC8vIHRha2VuIGZyb20gc3R5bGUgY2FjaGVcbiAgICAgICAgZXhwZWN0KG5ld1N0eWxlID09PSBzdHlsZSkudG9CZVRydXRoeSgpO1xuICAgICAgICBzdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoe1xuICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwidHJpYW5nbGVcIixcbiAgICAgICAgICAgICAgICBcImZpbGxDb2xvclwiOiBcIiNmZjAwMDBcIixcbiAgICAgICAgICAgICAgICBcInJvdGF0aW9uQXR0cmlidXRlXCI6ICdyb3RhdGlvbicsXG4gICAgICAgICAgICAgICAgXCJyb3RhdGlvblVuaXRzXCI6ICdkZWdyZWVzJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBuZXcgb2wuRmVhdHVyZSh7J3JvdGF0aW9uJzogMTgwfSkpO1xuICAgICAgICBleHBlY3Qoc3R5bGVbMF0uZ2V0SW1hZ2UoKS5nZXRSb3RhdGlvbigpKS50b0JlKE1hdGguUEkvMik7XG4gICAgfSkpO1xuXG4gICAgaXQoJ3Nob3VsZCBjb252ZXJ0IHVuaXF1ZSBjbGFzc2lmaWNhdGlvbicsIGluamVjdChmdW5jdGlvbihvbDNTdHlsZUNvbnZlcnRlcikge1xuICAgICAgICB2YXIgc3R5bGVDb25maWcgPSB7XG4gICAgICAgICAgICBcInN0cm9rZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzdHJva2VDb2xvclwiOiBcIiNmZmZmMDBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3ltYm9sXCI6IHtcbiAgICAgICAgICAgICAgICBcInNpemVcIjogMTAsXG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcImNpcmNsZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZW9tVHlwZVwiOiBcInBvaW50XCIsXG4gICAgICAgICAgICBcImNsYXNzaWZ5XCI6IHtcbiAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZVwiOiBcImZvb1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJydWxlc1wiOiBbe1xuICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJiYXJcIixcbiAgICAgICAgICAgICAgICBcInN0eWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjZmY5OTAwXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VDb2xvclwiOiBcIiNmZjk5MDBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJiYXpcIixcbiAgICAgICAgICAgICAgICBcInN0eWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjYjM2YjAwXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VDb2xvclwiOiBcIiNiMzZiMDBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0gICAgXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsIG5ldyBvbC5GZWF0dXJlKHsnZm9vJzogJ2Jhcid9KSk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRJbWFnZSgpLmdldEZpbGwoKS5nZXRDb2xvcigpKS50b0JlKCcjZmY5OTAwJyk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRJbWFnZSgpLmdldFN0cm9rZSgpLmdldENvbG9yKCkpLnRvQmUoJ3JnYmEoMjU1LDI1NSwwLDEpJyk7XG4gICAgICAgIHN0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZywgbmV3IG9sLkZlYXR1cmUoeydmb28nOiAnYmF6J30pKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlWzBdLmdldEltYWdlKCkuZ2V0RmlsbCgpLmdldENvbG9yKCkpLnRvQmUoJyNiMzZiMDAnKTsgXG5cbiAgICAgICAgc3R5bGVDb25maWcuZ2VvbVR5cGUgPSBcImxpbmVcIjtcbiAgICAgICAgc3R5bGUgPSBvbDNTdHlsZUNvbnZlcnRlci5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnLCBuZXcgb2wuRmVhdHVyZSh7J2Zvbyc6ICdiYXInfSkpO1xuICAgICAgICBleHBlY3Qoc3R5bGVbMF0uZ2V0U3Ryb2tlKCkuZ2V0Q29sb3IoKSkudG9CZSgnI2ZmOTkwMCcpO1xuICAgICAgICBzdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsIG5ldyBvbC5GZWF0dXJlKHsnZm9vJzogJ2Jheid9KSk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRTdHJva2UoKS5nZXRDb2xvcigpKS50b0JlKCcjYjM2YjAwJyk7XG5cbiAgICAgICAgc3R5bGVDb25maWcuZ2VvbVR5cGUgPSBcInBvbHlnb25cIjtcbiAgICAgICAgc3R5bGUgPSBvbDNTdHlsZUNvbnZlcnRlci5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnLCBuZXcgb2wuRmVhdHVyZSh7J2Zvbyc6ICdiYXInfSkpO1xuICAgICAgICBleHBlY3Qoc3R5bGVbMF0uZ2V0RmlsbCgpLmdldENvbG9yKCkpLnRvQmUoJyNmZjk5MDAnKTtcbiAgICAgICAgc3R5bGUgPSBvbDNTdHlsZUNvbnZlcnRlci5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnLCBuZXcgb2wuRmVhdHVyZSh7J2Zvbyc6ICdiYXonfSkpO1xuICAgICAgICBleHBlY3Qoc3R5bGVbMF0uZ2V0RmlsbCgpLmdldENvbG9yKCkpLnRvQmUoJyNiMzZiMDAnKTtcbiAgICB9KSk7XG5cbiAgICBpdCgnc2hvdWxkIGNvbnZlcnQgcmFuZ2VzIG9mIGEgY2xhc3NpZmljYXRpb24nLCBpbmplY3QoZnVuY3Rpb24ob2wzU3R5bGVDb252ZXJ0ZXIpIHtcbiAgICAgICAgdmFyIHN0eWxlQ29uZmlnID0ge1xuICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogXCIjZmZmZjAwXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaXplXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJjaXJjbGVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2VvbVR5cGVcIjogXCJwb2ludFwiLFxuICAgICAgICAgICAgXCJjbGFzc2lmeVwiOiB7XG4gICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGVcIjogXCJmb29cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicnVsZXNcIjogW3tcbiAgICAgICAgICAgICAgICBcInJhbmdlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJtaW5cIjogMCxcbiAgICAgICAgICAgICAgICAgICAgXCJtYXhcIjogMTBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic3R5bGVcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImZpbGxDb2xvclwiOiBcIiNmZjk5MDBcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcInN0cm9rZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cm9rZUNvbG9yXCI6IFwiI2ZmOTkwMFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJyYW5nZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwibWluXCI6IDEwLFxuICAgICAgICAgICAgICAgICAgICBcIm1heFwiOiAyMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzdHlsZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwic3ltYm9sXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiI2IzNmIwMFwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogXCIjYjM2YjAwXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgICAgIC8vIHRoaXMgdGVzdHMgZm9yIGJlaW5nIGluY2x1c2l2ZSBvbiB0aGUgbG93ZXIgYm91bmRhcnlcbiAgICAgICAgdmFyIHN0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZywgbmV3IG9sLkZlYXR1cmUoeydmb28nOiAwfSkpO1xuICAgICAgICBleHBlY3Qoc3R5bGVbMF0uZ2V0SW1hZ2UoKS5nZXRGaWxsKCkuZ2V0Q29sb3IoKSkudG9CZSgnI2ZmOTkwMCcpO1xuICAgICAgICBzdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsIG5ldyBvbC5GZWF0dXJlKHsnZm9vJzogMTV9KSk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRJbWFnZSgpLmdldEZpbGwoKS5nZXRDb2xvcigpKS50b0JlKCcjYjM2YjAwJyk7XG5cbiAgICAgICAgc3R5bGVDb25maWcuZ2VvbVR5cGUgPSBcImxpbmVcIjtcbiAgICAgICAgc3R5bGUgPSBvbDNTdHlsZUNvbnZlcnRlci5nZW5lcmF0ZVN0eWxlKHN0eWxlQ29uZmlnLCBuZXcgb2wuRmVhdHVyZSh7J2Zvbyc6IDV9KSk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRTdHJva2UoKS5nZXRDb2xvcigpKS50b0JlKCcjZmY5OTAwJyk7XG4gICAgICAgIHN0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZywgbmV3IG9sLkZlYXR1cmUoeydmb28nOiAxNX0pKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlWzBdLmdldFN0cm9rZSgpLmdldENvbG9yKCkpLnRvQmUoJyNiMzZiMDAnKTtcblxuICAgICAgICBzdHlsZUNvbmZpZy5nZW9tVHlwZSA9IFwicG9seWdvblwiO1xuICAgICAgICBzdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsIG5ldyBvbC5GZWF0dXJlKHsnZm9vJzogNX0pKTtcbiAgICAgICAgZXhwZWN0KHN0eWxlWzBdLmdldEZpbGwoKS5nZXRDb2xvcigpKS50b0JlKCcjZmY5OTAwJyk7XG4gICAgICAgIC8vIHRoaXMgdGVzdHMgZm9yIGJlaW5nIGluY2x1c2l2ZSBvbiB0aGUgdXBwZXIgYm9uZGFyeVxuICAgICAgICBzdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsIG5ldyBvbC5GZWF0dXJlKHsnZm9vJzogMjB9KSk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRGaWxsKCkuZ2V0Q29sb3IoKSkudG9CZSgnI2IzNmIwMCcpO1xuXG4gICAgfSkpO1xuXG4gICAgaXQoJ3Nob3VsZCBjb252ZXJ0IHVuaXF1ZSBjbGFzc2lmaWNhdGlvbiB3aXRoIGxhYmVsJywgaW5qZWN0KGZ1bmN0aW9uKG9sM1N0eWxlQ29udmVydGVyKSB7XG4gICAgICAgIHZhciBzdHlsZUNvbmZpZyA9IHtcbiAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICBcInN0cm9rZUNvbG9yXCI6IFwiI2ZmZmYwMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiY2lyY2xlXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdlb21UeXBlXCI6IFwicG9pbnRcIixcbiAgICAgICAgICAgIFwiY2xhc3NpZnlcIjoge1xuICAgICAgICAgICAgICAgIFwiYXR0cmlidXRlXCI6IFwiZm9vXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImxhYmVsXCI6IHtcbiAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZVwiOiBcImZvb1wiLFxuICAgICAgICAgICAgICAgIFwiZm9udFdlaWdodFwiOiBcImJvbGRcIixcbiAgICAgICAgICAgICAgICBcImZvbnRTaXplXCI6IDEyLFxuICAgICAgICAgICAgICAgIFwiZm9udEZhbWlseVwiOiBcIlNlcmlmXCIsXG4gICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjMDAwMGZmXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInJ1bGVzXCI6IFt7XG4gICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcImJhclwiLFxuICAgICAgICAgICAgICAgIFwic3R5bGVcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInN5bWJvbFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImZpbGxDb2xvclwiOiBcIiNmZjk5MDBcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJiYXpcIixcbiAgICAgICAgICAgICAgICBcInN0eWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzeW1ib2xcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxsQ29sb3JcIjogXCIjYjM2YjAwXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsIG5ldyBvbC5GZWF0dXJlKHsnZm9vJzogJ2Jheid9KSk7XG4gICAgICAgIGV4cGVjdChzdHlsZVswXS5nZXRUZXh0KCkuZ2V0VGV4dCgpKS50b0JlKCdiYXonKTtcbiAgICAgICAgdmFyIG5ld1N0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZywgbmV3IG9sLkZlYXR1cmUoeydmb28nOiAnYmF6J30pKTtcbiAgICAgICAgLy8gdGFrZW4gZnJvbSBzdHlsZSBjYWNoZVxuICAgICAgICBleHBlY3QobmV3U3R5bGUgPT09IHN0eWxlKS50b0JlVHJ1dGh5KCk7XG4gICAgICAgIG5ld1N0eWxlID0gb2wzU3R5bGVDb252ZXJ0ZXIuZ2VuZXJhdGVTdHlsZShzdHlsZUNvbmZpZywgbmV3IG9sLkZlYXR1cmUoeydmb28nOiAnYmFyJ30pKTtcbiAgICAgICAgLy8gbm90IHRha2VuIGZyb20gc3R5bGUgY2FjaGVcbiAgICAgICAgZXhwZWN0KG5ld1N0eWxlID09PSBzdHlsZSkudG9CZUZhbHN5KCk7XG4gICAgICAgIHN0eWxlQ29uZmlnLnN0cm9rZS5zdHJva2VDb2xvciA9IFwiI2ZmMDAwMFwiO1xuICAgICAgICBuZXdTdHlsZSA9IG9sM1N0eWxlQ29udmVydGVyLmdlbmVyYXRlU3R5bGUoc3R5bGVDb25maWcsIG5ldyBvbC5GZWF0dXJlKHsnZm9vJzogJ2Jheid9KSk7XG4gICAgICAgIC8vIG5vdCB0YWtlbiBmcm9tIHN0eWxlIGNhY2hlIHNpbmNlIHN0cm9rZUNvbG9yIGNoYW5nZWRcbiAgICAgICAgZXhwZWN0KG5ld1N0eWxlID09PSBzdHlsZSkudG9CZUZhbHN5KCk7XG4gICAgfSkpO1xuXG59KTtcbiIsInBpbnMgPSByZXF1aXJlKCcuLi9saWIvY29yZS90aW1lL3BpbnMuanMnKTtcblxuZGVzY3JpYmUoJ3Rlc3Qgc3RvcnlQaW5zJywgZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgZGVzY3JpYmUoJ1N0b3J5UGluIGNsYXNzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdjb25zdHJ1Y3RvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNwID0gbmV3IHBpbnMuU3RvcnlQaW4oe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAndGVzdCcsXG4gICAgICAgICAgICAgICAgdGhlX2dlb206ICd7XCJ0eXBlXCI6XCJQb2ludFwiLFwiY29vcmRpbmF0ZXNcIjpbMTIzLDMyMV19JyxcbiAgICAgICAgICAgICAgICBpZDogMjJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KHNwLmdldCgndGl0bGUnKSkudG9CZSgndGVzdCcpO1xuICAgICAgICAgICAgZXhwZWN0KHNwLnRpdGxlKS50b0JlKCd0ZXN0Jyk7XG4gICAgICAgICAgICBleHBlY3Qoc3AuZ2V0SWQoKSkudG9CZSgyMik7XG4gICAgICAgICAgICBleHBlY3Qoc3AuaWQpLnRvQmUoMjIpO1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IHNwLmdldEdlb21ldHJ5KCkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICAgIGV4cGVjdChjb29yZHNbMF0pLnRvQmUoMTIzKTtcbiAgICAgICAgICAgIGV4cGVjdChjb29yZHNbMV0pLnRvQmUoMzIxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCd1cGRhdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzcCA9IG5ldyBwaW5zLlN0b3J5UGluKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ3Rlc3QnLFxuICAgICAgICAgICAgICAgIHRoZV9nZW9tOiAne1widHlwZVwiOlwiUG9pbnRcIixcImNvb3JkaW5hdGVzXCI6WzEyMywzMjFdfSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KHNwLmNvbnRlbnQpLnRvQmUobnVsbCk7XG4gICAgICAgICAgICBleHBlY3Qoc3AudGl0bGUpLnRvQmUoJ3Rlc3QnKTtcbiAgICAgICAgICAgIHNwLnNldFByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdjb250ZW50J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3Qoc3AuY29udGVudCkudG9CZSgnY29udGVudCcpO1xuICAgICAgICAgICAgZXhwZWN0KHNwLnRpdGxlKS50b0JlKG51bGwpO1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IHNwLmdldEdlb21ldHJ5KCkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICAgIGV4cGVjdChjb29yZHNbMF0pLnRvQmUoMTIzKTtcbiAgICAgICAgICAgIGV4cGVjdChjb29yZHNbMV0pLnRvQmUoMzIxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdlbXB0eScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNwID0gbmV3IHBpbnMuU3RvcnlQaW4oKTtcbiAgICAgICAgICAgIGV4cGVjdChzcC5jb250ZW50KS50b0JlKG51bGwpO1xuICAgICAgICAgICAgZXhwZWN0KHNwLnRpdGxlKS50b0JlKG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGdlb2pzb24gPSB7XG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IDI0LFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7IHR5cGU6J1BvaW50JywgY29vcmRpbmF0ZXM6Wy05MCw0NV0gfSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAndGVzdCcsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X3RpbWU6IDEwMDAwMDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9O1xuICAgIGRlc2NyaWJlKCdsb2FkRnJvbUdlb0pTT04nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ3dvcmtzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbG9hZGVkID0gcGlucy5sb2FkRnJvbUdlb0pTT04oZ2VvanNvbik7XG4gICAgICAgICAgICBleHBlY3QobG9hZGVkLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgICAgIHZhciBzcCA9IGxvYWRlZFswXTtcbiAgICAgICAgICAgIGV4cGVjdChzcC5pZCkudG9CZSgyNCk7XG4gICAgICAgICAgICBleHBlY3Qoc3AuZ2V0R2VvbWV0cnkoKS5nZXRDb29yZGluYXRlcygpWzBdKS50b0JlKC05MCk7XG4gICAgICAgICAgICBleHBlY3Qoc3AuZ2V0R2VvbWV0cnkoKS5nZXRDb29yZGluYXRlcygpWzFdKS50b0JlKDQ1KTtcbiAgICAgICAgICAgIGV4cGVjdChzcC5zdGFydF90aW1lKS50b0JlKDEwMDAwMDAwMDApO1xuICAgICAgICAgICAgZXhwZWN0KHNwLmVuZF90aW1lKS50b0JlKG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3dvcmtzIHdpdGggcHJvamVjdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxvYWRlZCA9IHBpbnMubG9hZEZyb21HZW9KU09OKGdlb2pzb24sIG9sLnByb2ouZ2V0KCdFUFNHOjM4NTcnKSk7XG4gICAgICAgICAgICB2YXIgc3AgPSBsb2FkZWRbMF07XG4gICAgICAgICAgICBleHBlY3Qoc3AuZ2V0R2VvbWV0cnkoKS5nZXRDb29yZGluYXRlcygpWzBdKS50b0JlKC0xMDAxODc1NC4xNzEzOTQ2MjIpO1xuICAgICAgICAgICAgZXhwZWN0KHNwLmdldEdlb21ldHJ5KCkuZ2V0Q29vcmRpbmF0ZXMoKVsxXSkudG9CZSg1NjIxNTIxLjQ4NjE5MjA2Nik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGRlc2NyaWJlKCd0b0dlb0pTT04nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ3dvcmtzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyB0byBkbyB0aGlzIGNvcnJlY3RseSwgd2UgbmVlZCB0byB1bmRlcnN0YW5kIHRoZSBjdXJyZW50IHByb2plY3Rpb25cbiAgICAgICAgICAgIC8vIHRoaXMgdGVzdCBqdXN0IHZlcmlmaWVzIHRoZSBvbDMgZm9ybWF0IHdvcmtzIHByb3Blcmx5XG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gbmV3IG9sLmZvcm1hdC5HZW9KU09OKHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0RGF0YVByb2plY3Rpb246ICdFUFNHOjQzMjYnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzcCA9IG5ldyBwaW5zLlN0b3J5UGluKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ3Rlc3QnLFxuICAgICAgICAgICAgICAgIHRoZV9nZW9tOiAne1widHlwZVwiOlwiUG9pbnRcIixcImNvb3JkaW5hdGVzXCI6WzEyMywzMjFdfScsXG4gICAgICAgICAgICAgICAgaWQ6IDIyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzcCA9IGZvcm1hdC5yZWFkRmVhdHVyZShmb3JtYXQud3JpdGVGZWF0dXJlKHNwKSk7XG4gICAgICAgICAgICBleHBlY3Qoc3AuZ2V0KCd0aXRsZScpKS50b0JlKCd0ZXN0Jyk7XG4gICAgICAgICAgICBleHBlY3Qoc3AuZ2V0SWQoKSkudG9CZSgyMik7XG4gICAgICAgICAgICB2YXIgY29vcmRzID0gc3AuZ2V0R2VvbWV0cnkoKS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICAgICAgZXhwZWN0KGNvb3Jkc1swXSkudG9CZSgxMjMpO1xuICAgICAgICAgICAgZXhwZWN0KGNvb3Jkc1sxXSkudG9CZSgzMjEpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIiwic3Rvcnl0b29scyA9IHtcbiAgICBjb3JlOiByZXF1aXJlKCcuLi9saWIvY29yZS9pbmRleC5qcycpXG59O1xucmVxdWlyZSgnLi4vbGliL25nL2NvcmUvcGlucy9tb2R1bGUuanMnKTtcblxuZGVzY3JpYmUoJ3Rlc3Qgc3RvcnlQaW5zJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIFN0b3J5UGluO1xuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlIGlzIHdvcmsgYXJvdW5kIGJyb3dzZXJpZnkgY29uZmxpY3RcbiAgICAgICAgd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUoJ3N0b3J5dG9vbHMuY29yZS5waW5zJyk7XG5cbiAgICAgICAgaW5qZWN0KGZ1bmN0aW9uKCRpbmplY3Rvcikge1xuICAgICAgICAgICAgU3RvcnlQaW4gPSAkaW5qZWN0b3IuZ2V0KCdTdG9yeVBpbicpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdTdG9yeVBpbkxheWVyTWFuYWdlcicsIGZ1bmN0aW9uKCkge1xuXG4gICAgfSk7XG5cbn0pOyIsInJlcXVpcmUoJy4uL2xpYi9uZy9lZGl0L3N0eWxlL3NlcnZpY2VzL3N0eWxlQ2hvaWNlcy5qcycpO1xuXG5kZXNjcmliZSgndGVzdCBzdHlsZUNob2ljZXMnLCBmdW5jdGlvbigpIHtcblxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlKCdzdG9yeXRvb2xzLmVkaXQuc3R5bGUuc3R5bGVDaG9pY2VzJyk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnc3RSZWNlbnRDaG9pY2VzIHdvcmtzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGluamVjdChmdW5jdGlvbigkaW5qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBzdFJlY2VudENob2ljZXMgPSAkaW5qZWN0b3IuZ2V0KCdzdFJlY2VudENob2ljZXMnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3Nob3VsZCBzdG9yZSByZWNlbnQgaWNvbnMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpY29ucyA9IHN0UmVjZW50Q2hvaWNlcy5pY29ucztcbiAgICAgICAgICAgIGljb25zLmNsZWFyKCk7XG4gICAgICAgICAgICBpY29ucy5hZGQoJ2EnKTtcbiAgICAgICAgICAgIGV4cGVjdChpY29ucy5yZWNlbnQpLnRvRXF1YWwoWydhJ10pO1xuICAgICAgICAgICAgaWNvbnMuYWRkKCdiJyk7XG4gICAgICAgICAgICBleHBlY3QoaWNvbnMucmVjZW50KS50b0VxdWFsKFsnYScsICdiJ10pO1xuICAgICAgICAgICAgaWNvbnMuYWRkKCdiJyk7XG4gICAgICAgICAgICBleHBlY3QoaWNvbnMucmVjZW50KS50b0VxdWFsKFsnYScsICdiJ10pO1xuICAgICAgICAgICAgdmFyIG90aGVycyA9ICdjZGVmZ2hpamtsbW9ucHFyc3R1dnh5eic7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8b3RoZXJzLmxlbmd0aDtpKyspIHtcbiAgICAgICAgICAgICAgICBpY29ucy5hZGQob3RoZXJzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGVjdChpY29ucy5yZWNlbnQubGVuZ3RoKS50b0JlKGljb25zLl9tYXgpO1xuICAgICAgICAgICAgLy8gdGhpcyBhc3NlcnRpb24gaXMgYmFzZWQgb24gdGhlIGFzc3VtcHRpb24gb2YgX21heD0yNC4uLlxuICAgICAgICAgICAgZXhwZWN0KGljb25zLnJlY2VudFswXSkudG9CZSgnYicpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pOyIsInJlcXVpcmUoJy4uL2xpYi9uZy9lZGl0L3N0eWxlL2RpcmVjdGl2ZXMvZGlyZWN0aXZlcy5qcycpO1xucmVxdWlyZSgnLi4vbGliL25nL2VkaXQvc3R5bGUvc2VydmljZXMvaWNvbkNvbW1vbnMuanMnKTtcbnJlcXVpcmUoJy4uL2xpYi9uZy9lZGl0L3N0eWxlL3NlcnZpY2VzL3N0eWxlQ2hvaWNlcy5qcycpO1xucmVxdWlyZSgnLi4vbGliL25nL2NvcmUvc3R5bGUvb2wzU3R5bGVDb252ZXJ0ZXIuanMnKTtcbnJlcXVpcmUoJy4uL2xpYi9uZy9jb3JlL3N0eWxlL3N2Z0ljb24uanMnKTtcbmhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMuanMnKTtcbiQgPSByZXF1aXJlKCcuLi9ib3dlcl9jb21wb25lbnRzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcycpO1xuXG5kZXNjcmliZSgndGVzdCBzdHlsZSBkaXJlY3RpdmVzJywgZnVuY3Rpb24oKSB7XG5cbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBAdG9kbyBtb2NrIGRlcGVuZGVuY3kgZm9yIG5vdyAtIHVzZWQgYnkgZ3JhcGhpY0VkaXRvclxuICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZShmdW5jdGlvbigkcHJvdmlkZSkge1xuICAgICAgICAgICAgJHByb3ZpZGUudmFsdWUoJyRtb2RhbCcsIHtvcGVuOiBuZXcgRnVuY3Rpb24oKX0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSBpcyB3b3JrIGFyb3VuZCBicm93c2VyaWZ5IGNvbmZsaWN0XG4gICAgICAgIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlKCdzdG9yeXRvb2xzLmVkaXQuc3R5bGUuZGlyZWN0aXZlcycpO1xuICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSgnc3Rvcnl0b29scy5hbGxUZW1wbGF0ZXMnKTtcbiAgICAgICAgd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUoJ3N0b3J5dG9vbHMuZWRpdC5zdHlsZS5zdHlsZUNob2ljZXMnKTtcbiAgICAgICAgd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUoJ3N0b3J5dG9vbHMuZWRpdC5zdHlsZS5pY29uQ29tbW9ucycpO1xuICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSgnc3Rvcnl0b29scy5jb3JlLnN0eWxlLm9sM1N0eWxlQ29udmVydGVyJyk7XG4gICAgICAgIHdpbmRvdy5hbmd1bGFyLm1vY2subW9kdWxlKCdzdG9yeXRvb2xzLmNvcmUuc3R5bGUuc3ZnSWNvbicpO1xuXG4gICAgICAgIGluamVjdChoZWxwZXJzLmluamVjdCk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnYXR0cmlidXRlLWNvbWJvJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdzaG91bGQgZmlsdGVyIGF0dHJpYnV0ZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gW1xuICAgICAgICAgICAgICAgIHtuYW1lOiAncycsIHR5cGU6ICdzdHJpbmcnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2knLCB0eXBlOiAnaW50ZWdlcid9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnZCcsIHR5cGU6ICdkb3VibGUnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ3QnLCB0eXBlOiAnZGF0ZVRpbWUnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2cnLCB0eXBlOiAnZ2VvbScsIHR5cGVOUzonaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciBzY29wZSA9IHtcbiAgICAgICAgICAgICAgICBsYXllcjoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuY3Rpb24gYXR0cmlidXRlVGV4dChlbCkge1xuICAgICAgICAgICAgICAgIC8vIGV4dHJhY3QgYXR0cmlidXRlIHRleHQgZnJvbSBlbGVtZW50cyBkaXNyZWdhcmRpbmcgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuZ3VsYXIuZWxlbWVudChlbC5maW5kKCdsaScpLnNwbGljZSgxKSkudGV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXhwZWN0aW5nIGFsbCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICB2YXIgZWwgPSBoZWxwZXJzLmNvbXBpbGUoXCI8YXR0cmlidXRlLWNvbWJvIGxheWVyPWxheWVyPjwvYXR0cmlidXRlLWNvbWJvPlwiLCBzY29wZSk7XG4gICAgICAgICAgICBleHBlY3QoYXR0cmlidXRlVGV4dChlbCkpLnRvQmUoJ2RnaXN0Jyk7XG4gICAgICAgICAgICAvLyBleGNsdWRlIGdlb21cbiAgICAgICAgICAgIGVsID0gaGVscGVycy5jb21waWxlKFwiPGF0dHJpYnV0ZS1jb21ibyBmaWx0ZXI9bm9nZW9tIGxheWVyPWxheWVyPjwvYXR0cmlidXRlLWNvbWJvPlwiLCBzY29wZSk7XG4gICAgICAgICAgICBleHBlY3QoYXR0cmlidXRlVGV4dChlbCkpLnRvQmUoJ2Rpc3QnKTtcbiAgICAgICAgICAgIC8vIGluY2x1ZGUgc3RyaW5nIGFuZCBpbnRlZ2VyXG4gICAgICAgICAgICBlbCA9IGhlbHBlcnMuY29tcGlsZShcIjxhdHRyaWJ1dGUtY29tYm8gaW5jbHVkZT0nc3RyaW5nLGludGVnZXInIGxheWVyPWxheWVyPjwvYXR0cmlidXRlLWNvbWJvPlwiLCBzY29wZSk7XG4gICAgICAgICAgICBleHBlY3QoYXR0cmlidXRlVGV4dChlbCkpLnRvQmUoJ2lzJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ251bWJlciBlZGl0b3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ3Nob3VsZCBiaW5kIGFuZCBlZGl0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBoZWxwZXJzLmNvbXBpbGUoXCI8bnVtYmVyLWVkaXRvciBzdC1tb2RlbD0ndGhpbmcnIHByb3BlcnR5PSd2YWx1ZSc+PC9udW1iZXItZWRpdG9yPlwiLCB7dGhpbmc6IHt2YWx1ZTogNDJ9fSk7XG4gICAgICAgICAgICBleHBlY3QoZWwuZmluZCgnYnV0dG9uJykudGV4dCgpLnRyaW0oKSkudG9CZSgnNDInKTtcbiAgICAgICAgICAgIGhlbHBlcnMuc2V0SW5wdXRWYWx1ZShlbC5maW5kKCdpbnB1dCcpLCAnMTMnKTtcbiAgICAgICAgICAgIGV4cGVjdChoZWxwZXJzLmdldFNjb3BlKGVsKS50aGluZy52YWx1ZSkudG9CZSgxMyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2NvbG9yIGVkaXRvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnc2hvdWxkIGJpbmQgYW5kIGVkaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGhlbHBlcnMuY29tcGlsZShcIjxjb2xvci1lZGl0b3Igc3QtbW9kZWw9J3RoaW5nJyBwcm9wZXJ0eT0ndmFsdWUnPjwvY29sb3ItZWRpdG9yPlwiLCB7dGhpbmc6IHt2YWx1ZTogJyNmYWEnfX0pO1xuICAgICAgICAgICAgZXhwZWN0KGVsLmZpbmQoJ2knKS5jc3MoJ2JhY2tncm91bmRDb2xvcicpKS50b0JlKCdyZ2IoMjU1LCAxNzAsIDE3MCknKTtcbiAgICAgICAgICAgIGhlbHBlcnMuc2V0SW5wdXRWYWx1ZShlbC5maW5kKCdpbnB1dCcpLCAnI2FhYScpO1xuICAgICAgICAgICAgZXhwZWN0KGhlbHBlcnMuZ2V0U2NvcGUoZWwpLnRoaW5nLnZhbHVlKS50b0JlKCcjYWFhJyk7XG4gICAgICAgICAgICBleHBlY3QoZWwuZmluZCgnaScpLmNzcygnYmFja2dyb3VuZENvbG9yJykpLnRvQmUoJ3JnYigxNzAsIDE3MCwgMTcwKScpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdncmFwaGljLWVkaXRvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBiZWZvcmVFYWNoKGluamVjdChmdW5jdGlvbigkaW5qZWN0b3IpIHtcbiAgICAgICAgICAgIHN0UmVjZW50Q2hvaWNlcyA9ICRpbmplY3Rvci5nZXQoJ3N0UmVjZW50Q2hvaWNlcycpO1xuICAgICAgICAgICAgLy8gY2xlYXIgdGhlc2UgYXMgdGhleSBtYXkgdHJpZ2dlciBodHRwIHJlcXVlc3RzXG4gICAgICAgICAgICBzdFJlY2VudENob2ljZXMuaWNvbnMuY2xlYXIoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBpdCgnc2hvdWxkIGJpbmQgYW5kIGVkaXQgbWFya3MnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGhlbHBlcnMuY29tcGlsZShcIjxncmFwaGljLWVkaXRvciBzeW1ib2w9J3RoaW5nJz48L2dyYXBoaWMtZWRpdG9yPlwiLCB7dGhpbmc6IHtzaGFwZTogJ2NpcmNsZSd9fSk7XG4gICAgICAgICAgICAvLyBAdG9kbyBub3QgYSBncmVhdCB0ZXN0IC0gaW5zdGVhZCBvZiB1c2luZyBhIGNhbnZhcywgdGhpcyBjb3VsZCBiZSBhbiBpbWFnZSB3LyBkYXRhIFVSSVxuICAgICAgICAgICAgZXhwZWN0KGVsLmZpbmQoJ3NwYW4gY2FudmFzJykuYXR0cignbWFyaycpKS50b0JlKCdjaXJjbGUnKTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChlbC5maW5kKCdjYW52YXMnKSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGUgPSBhbmd1bGFyLmVsZW1lbnQoZSk7XG4gICAgICAgICAgICAgICAgaWYgKGUuYXR0cignbWFyaycpID09ICdzcXVhcmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGUudHJpZ2dlckhhbmRsZXIoJ2NsaWNrJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZWwuZmluZCgnc3BhbiBjYW52YXMnKS5hdHRyKCdtYXJrJykpLnRvQmUoJ3NxdWFyZScpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVzY3JpYmUoJ3dvcmtzIHdpdGggaWNvbiBjb21tb25zJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBleHRyYSBnbmFybCAtIHJlbmRlcmluZyBvZiB0aGUgcmVjZW50LWljb25zIHJlcXVpcmVzIHNvbWVcbiAgICAgICAgICAgIC8vIG1vY2sgaHR0cCB0byB0YWxrIHRvIHRoZSBpY29uQ29tbW9ucyBhbmQgd2FpdCB1bnRpbCB0aGVcbiAgICAgICAgICAgIC8vIGRpcmVjdGl2ZSB1cGRhdGVzIGl0c2VsZiAtIHNlZSB3aGVuUmVhZHlcbiAgICAgICAgICAgIGJlZm9yZUVhY2goaW5qZWN0KGZ1bmN0aW9uKCRpbmplY3Rvcikge1xuICAgICAgICAgICAgICAgICRodHRwQmFja2VuZCA9ICRpbmplY3Rvci5nZXQoJyRodHRwQmFja2VuZCcpO1xuICAgICAgICAgICAgICAgIHN0UmVjZW50Q2hvaWNlcyA9ICRpbmplY3Rvci5nZXQoJ3N0UmVjZW50Q2hvaWNlcycpO1xuICAgICAgICAgICAgICAgICRxID0gJGluamVjdG9yLmdldCgnJHEnKTtcbiAgICAgICAgICAgICAgICAkdGltZW91dCA9ICRpbmplY3Rvci5nZXQoJyR0aW1lb3V0Jyk7XG5cbiAgICAgICAgICAgICAgICBzdFJlY2VudENob2ljZXMuaWNvbnMuYWRkKCcvaXRlbTEuc3ZnJyk7XG4gICAgICAgICAgICAgICAgc3RSZWNlbnRDaG9pY2VzLmljb25zLmFkZCgnL2l0ZW0yLnN2ZycpO1xuICAgICAgICAgICAgICAgIC8vIG1vY2sgcmVxdWVzdHMgZm9yIHRoZSBpY29uc1xuICAgICAgICAgICAgICAgICRodHRwQmFja2VuZC53aGVuKCdHRVQnLCAnL2l0ZW0xLnN2ZycpLnJlc3BvbmQoJzxzdmc+PC9zdmc+JywgeydDb250ZW50LVR5cGUnOiAndGV4dC94bWwnfSk7XG4gICAgICAgICAgICAgICAgJGh0dHBCYWNrZW5kLndoZW4oJ0dFVCcsICcvaXRlbTIuc3ZnJykucmVzcG9uZCgnPHN2Zz48L3N2Zz4nLCB7J0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3htbCd9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgb25jZSB0aGUgaHR0cCByZXF1ZXN0cyBoYXZlXG4gICAgICAgICAgICAvLyBjb21wbGV0ZWQgYW5kIHRoZSByZWNlbnQgaWNvbnMgaGF2ZSBiZWVuIHNldCBpbiB0aGUgc2NvcGVcbiAgICAgICAgICAgIGZ1bmN0aW9uIHdoZW5SZWFkeShlbCwgJGh0dHBCYWNrZW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gZ3JhYiB0aGUgZGlyZWN0aXZlIHNjb3BlIGFuZCB3YXRjaCBmb3Igc3ZnIGljb25zIHRvIHJlc29sdmUgYmVmb3JlIHJ1bm5pbmcgdGVzdHNcbiAgICAgICAgICAgICAgICB2YXIgc2NvcGUgPSBoZWxwZXJzLmdldFNjb3BlKGVsLmNoaWxkcmVuKCkpO1xuICAgICAgICAgICAgICAgIHZhciBsb2FkZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaCgncmVjZW50JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZC5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGZsdXNoIHBlbmRpbmcgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICAkaHR0cEJhY2tlbmQuZmx1c2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVkLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJTVBPUlRBTlQgOiBmb3IgYWxsIHRlc3RzIGhlcmUsIGlmIGBkb25lYCBpcyBub3QgY2FsbGVkLCBqYXNtaW5lIHdpbGwgdGltZW91dCAtXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgY292ZXIgdGhlIGZhaWx1cmUgY2FzZS4gc2VlOiBodHRwOi8vamFzbWluZS5naXRodWIuaW8vMi4wL2ludHJvZHVjdGlvbi5odG1sI3NlY3Rpb24tQXN5bmNocm9ub3VzX1N1cHBvcnRcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogJHRpbWVvdXQuZmx1c2goKSBpcyByZXF1aXJlZCB0byB0cmlnZ2VyIHByb21pc2UgcmVzb2x1dGlvblxuICAgICAgICAgICAgaXQoJ3Nob3VsZCBiaW5kIHRvIHJlY2VudCBjaG9pY2VzJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGhlbHBlcnMuY29tcGlsZShcIjxncmFwaGljLWVkaXRvciBzeW1ib2w9J3RoaW5nJz48L2dyYXBoaWMtZWRpdG9yPlwiLCB7dGhpbmc6IHt9fSk7XG4gICAgICAgICAgICAgICAgd2hlblJlYWR5KGVsLCAkaHR0cEJhY2tlbmQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWcgPSBlbC5maW5kKCcucmVjZW50LWljb25zIGltZycpO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoaW1nLmxlbmd0aCkudG9CZSgyKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICR0aW1lb3V0LmZsdXNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0KCdzaG91bGQgdXBkYXRlIHdpdGggY2hhbmdlIGluIHJlY2VudCBjaG9pY2VzJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGhlbHBlcnMuY29tcGlsZShcIjxncmFwaGljLWVkaXRvciBzeW1ib2w9J3RoaW5nJz48L2dyYXBoaWMtZWRpdG9yPlwiLCB7dGhpbmc6IHt9fSk7XG5cbiAgICAgICAgICAgICAgICB3aGVuUmVhZHkoZWwsICRodHRwQmFja2VuZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltZyA9IGVsLmZpbmQoJy5yZWNlbnQtaWNvbnMgaW1nJyk7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChpbWcubGVuZ3RoKS50b0JlKDIpO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoaW1nLmF0dHIoJ3NyYycpLmluZGV4T2YoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJykpLnRvQmUoMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSdyZSBhbHJlYWR5IGluIHRoZSBkaWdlc3QsIGNhbGwgdGhpcyB3aXRoIGEgdGltZW91dFxuICAgICAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHF1ZXVlIHVwIGV4cGVjdGVkIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICRodHRwQmFja2VuZC53aGVuKCdHRVQnLCAnL2l0ZW0zLnN2ZycpLnJlc3BvbmQoJzxzdmc+PC9zdmc+JywgeydDb250ZW50LVR5cGUnOiAndGV4dC94bWwnfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgYWRkIHRoaXMgcmVjZW50IGNob2ljZSAobm9ybWFsbHkgd291bGQgYmUgZnJvbSB1c2VyIHNlbGVjdGluZyBmcm9tIGljb24tY29tbW9ucyBkaWFsb2dcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0UmVjZW50Q2hvaWNlcy5pY29ucy5hZGQoJy9pdGVtMy5zdmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgdHJpZ2dlcnMgYW4gdXBkYXRlIGFzIGlmIHVzZXIgdXNlZCB0aGUgZGlhbG9nXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJzLmdldFNjb3BlKGVsLmNoaWxkcmVuKCkpLl91cGRhdGVSZWNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIHNob3VsZCBiZSAzIGljb25zIG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hlblJlYWR5KGVsLCAkaHR0cEJhY2tlbmQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltZyA9IGVsLmZpbmQoJy5yZWNlbnQtaWNvbnMgaW1nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGltZy5sZW5ndGgpLnRvQmUoMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICR0aW1lb3V0LmZsdXNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0KCdzaG91bGQgYmluZCBhbmQgZWRpdCBzdmcnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gaGVscGVycy5jb21waWxlKFwiPGdyYXBoaWMtZWRpdG9yIHN5bWJvbD0ndGhpbmcnPjwvZ3JhcGhpYy1lZGl0b3I+XCIsIHt0aGluZzoge2dyYXBoaWM6ICcvaXRlbTEuc3ZnJ319KTtcbiAgICAgICAgICAgICAgICB3aGVuUmVhZHkoZWwsICRodHRwQmFja2VuZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltZyA9IGVsLmZpbmQoJy5yZWNlbnQtaWNvbnMgaW1nJyk7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChpbWcubGVuZ3RoKS50b0JlKDIpO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoaW1nLmF0dHIoJ3NyYycpLmluZGV4T2YoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJykpLnRvQmUoMCk7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkdGltZW91dC5mbHVzaCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnbGFiZWwtZWRpdG9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdzaG91bGQgYmluZCBhbmQgZWRpdCBhdHRyaWJ1dGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IHtcbiAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZVwiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwiZmlsbENvbG9yXCI6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgICAgIFwiZm9udEZhbWlseVwiOiBcIlNlcmlmXCIsXG4gICAgICAgICAgICAgICAgXCJmb250U2l6ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcImZvbnRTdHlsZVwiOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgICAgIFwiZm9udFdlaWdodFwiOiBcIm5vcm1hbFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBbXG4gICAgICAgICAgICAgICAge25hbWU6ICdhJywgdHlwZTogJ3N0cmluZyd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnYicsIHR5cGU6ICdpbnRlZ2VyJ31cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgZWwgPSBoZWxwZXJzLmNvbXBpbGUoXCI8bGFiZWwtZWRpdG9yIGxheWVyPWxheWVyIHN0LW1vZGVsPSd0aGluZyc+PC9ncmFwaGljLWVkaXRvcj5cIiwge1xuICAgICAgICAgICAgICAgIHRoaW5nOiB7bGFiZWw6IGxhYmVsfSxcbiAgICAgICAgICAgICAgICBsYXllcjoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9jayBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGVsLmZpbmQoJy5kcm9wZG93bi10b2dnbGUnKS5lcSgwKS50ZXh0KCkudHJpbSgpKS50b0JlKCdTZWxlY3QgQXR0cmlidXRlJyk7XG4gICAgICAgICAgICBoZWxwZXJzLmNsaWNrKGVsLmZpbmQoJy5kcm9wZG93bi1tZW51JykuZXEoMCkuZmluZCgnbGknKS5lcSgxKSk7XG4gICAgICAgICAgICBleHBlY3QobGFiZWwuYXR0cmlidXRlKS50b0JlKCdhJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2NsYXNzaWZ5LWVkaXRvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2xhc3NpZnksIGVsO1xuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2xhc3NpZnkgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBudWxsLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBtYXhDbGFzc2VzOiA1LFxuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgICAgICAgbWF4OiAxNlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IFtcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2EnLCB0eXBlOiAnc3RyaW5nJ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdiJywgdHlwZTogJ2ludGVnZXInfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGVsID0gaGVscGVycy5jb21waWxlKFwiPGNsYXNzaWZ5LWVkaXRvciBzaG93LW1heC1jbGFzc2VzPXRydWUgc2hvdy1maXhlZC1jbGFzc2VzPjwvY2xhc3NpZnktZWRpdG9yPlwiLCB7XG4gICAgICAgICAgICAgICAgbGF5ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhY3RpdmVTdHlsZToge2NsYXNzaWZ5OiBjbGFzc2lmeX0sXG4gICAgICAgICAgICAgICAgY2hhbmdlQ2xhc3NpZnlQcm9wZXJ0eTogZnVuY3Rpb24ocHJvcCwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzaWZ5W3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2hvd01heENsYXNzZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgc2hvd0ZpeGVkQ2xhc3NlczogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdCgnc2hvdWxkIGJpbmQgYW5kIGVkaXQgYXR0cmlidXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBoZWxwZXJzLmNsaWNrKGVsLmZpbmQoJ3VsLmRyb3Bkb3duLW1lbnUgbGknKS5nZXQoMSkpO1xuICAgICAgICAgICAgZXhwZWN0KGNsYXNzaWZ5LmF0dHJpYnV0ZSkudG9CZSgnYScpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3Nob3VsZCBiaW5kIGFuZCBlZGl0IG1heENsYXNzZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGhlbHBlcnMuc2V0SW5wdXRWYWx1ZShlbC5maW5kKCdbbmctaWY9c2hvd01heENsYXNzZXNdIGlucHV0JykuZXEoMCksICc3Jyk7XG4gICAgICAgICAgICBleHBlY3QoY2xhc3NpZnkubWF4Q2xhc3NlcykudG9CZSg3KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnc3Ryb2tlLWVkaXRvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnaGFzIGEgc21va2UgdGVzdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsID0gaGVscGVycy5jb21waWxlKFwiPHN0cm9rZS1lZGl0b3Igc3QtbW9kZWw9J3RoaW5nJz48L3N0cm9rZS1lZGl0b3I+XCIsIHt0aGluZzoge3N0cm9rZToge319fSk7XG4gICAgICAgICAgICBleHBlY3QoZWwuY2hpbGRyZW4oKS5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3J1bGVzLWVkaXRvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnaGFzIGEgc21va2UgdGVzdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsID0gaGVscGVycy5jb21waWxlKFwiPHJ1bGVzLWVkaXRvcj48L3J1bGVzLWVkaXRvcj5cIiwge30pO1xuICAgICAgICAgICAgZXhwZWN0KGVsLmNoaWxkcmVuKCkubGVuZ3RoKS50b0JlKDEpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdzeW1ib2wtZWRpdG9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdoYXMgYSBzbW9rZSB0ZXN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBoZWxwZXJzLmNvbXBpbGUoXCI8c3ltYm9sLWVkaXRvciBzdC1tb2RlbD0ndGhpbmcnPjwvc3ltYm9sLWVkaXRvcj5cIiwge3RoaW5nOiB7c3ltYm9sOiB7fX19KTtcbiAgICAgICAgICAgIGV4cGVjdChlbC5jaGlsZHJlbigpLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcbiIsInJlcXVpcmUoJy4uL2xpYi9uZy9lZGl0L3N0eWxlL3NlcnZpY2VzL3N0eWxlUnVsZUJ1aWxkZXIuanMnKTtcbnJlcXVpcmUoJy4uL2xpYi9uZy9lZGl0L3N0eWxlL3NlcnZpY2VzL3N0eWxlQ2hvaWNlcy5qcycpO1xucmVxdWlyZSgnLi4vbGliL25nL2VkaXQvc3R5bGUvc2VydmljZXMvc3R5bGVUeXBlcy5qcycpO1xuXG5kZXNjcmliZSgnc3R5bGVSdWxlQnVpbGRlcicsIGZ1bmN0aW9uKCkge1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUgaXMgd29yayBhcm91bmQgYnJvd3NlcmlmeSBjb25mbGljdFxuICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSgnc3Rvcnl0b29scy5lZGl0LnN0eWxlLnN0eWxlUnVsZUJ1aWxkZXInKTtcbiAgICAgICAgd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUoJ3N0b3J5dG9vbHMuZWRpdC5zdHlsZS5zdHlsZUNob2ljZXMnKTtcbiAgICAgICAgd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUoJ3N0b3J5dG9vbHMuZWRpdC5zdHlsZS5zdHlsZVR5cGVzJyk7XG5cbiAgICAgICAgaW5qZWN0KGZ1bmN0aW9uKHN0U3R5bGVSdWxlQnVpbGRlcikge1xuICAgICAgICAgICAgdGhpcy5zdFN0eWxlUnVsZUJ1aWxkZXIgPSBzdFN0eWxlUnVsZUJ1aWxkZXI7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwaWNrIHZhbHVlcyBmcm9tIGEgMi1zdG9wIGNvbG9yIHJhbXAnLCBpbmplY3QoZnVuY3Rpb24oc3RTdHlsZVJ1bGVCdWlsZGVyKSB7XG4gICAgICAgIHZhbHMgPSBzdFN0eWxlUnVsZUJ1aWxkZXIuX2NvbG9yUmFtcFZhbHVlcyh7MDonI2ZmMDAwMCcsMTonIzAwMDBmZid9LDIpO1xuICAgICAgICBleHBlY3QodmFscy5sZW5ndGgpLnRvQmUoMik7XG4gICAgICAgIGV4cGVjdCh2YWxzKS50b0VxdWFsKFsnI2ZmMDAwMCcsJyMwMDAwZmYnXSk7XG4gICAgfSkpO1xuXG4gICAgaXQoJ3Nob3VsZCBwaWNrIHZhbHVlcyBmcm9tIGEgMy1zdG9wIGNvbG9yIHJhbXAnLCBpbmplY3QoZnVuY3Rpb24oc3RTdHlsZVJ1bGVCdWlsZGVyKSB7XG4gICAgICAgIHZhbHMgPSBzdFN0eWxlUnVsZUJ1aWxkZXIuX2NvbG9yUmFtcFZhbHVlcyh7MDonI2ZmMDAwMCcsMTonIzAwMDBmZid9LDMpO1xuICAgICAgICBleHBlY3QodmFscy5sZW5ndGgpLnRvQmUoMyk7XG4gICAgICAgIGV4cGVjdCh2YWxzKS50b0VxdWFsKFsnI2ZmMDAwMCcsICcjN2YwMDdmJywgJyMwMDAwZmYnXSk7XG4gICAgfSkpO1xufSk7IiwicmVxdWlyZSgnLi4vbGliL25nL2VkaXQvdGltZS9kaXJlY3RpdmVzLmpzJyk7XG5oZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzLmpzJyk7XG5cbmRlc2NyaWJlKCd0ZXN0IHRpbWUgZGlyZWN0aXZlcycsIGZ1bmN0aW9uKCkge1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUgaXMgd29yayBhcm91bmQgYnJvd3NlcmlmeSBjb25mbGljdFxuICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSgnc3Rvcnl0b29scy5lZGl0LnRpbWUuZGlyZWN0aXZlcycpO1xuICAgICAgICB3aW5kb3cuYW5ndWxhci5tb2NrLm1vZHVsZSgnc3Rvcnl0b29scy5hbGxUZW1wbGF0ZXMnKTtcblxuICAgICAgICBpbmplY3QoaGVscGVycy5pbmplY3QpO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3N0LWRhdGUtdGltZS1maWVsZCBkaXJlY3RpdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXBvY2ggcHJvcGVybHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGhlbHBlcnMuY29tcGlsZSgnPHN0LWRhdGUtdGltZS1maWVsZCBkYXRlLXRpbWU9XCJ2YWx1ZVwiPjwvc3QtZGF0ZS10aW1lLWZpZWxkPicsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnB1dCA9IGVsLmZpbmQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBleHBlY3QoaW5wdXQudmFsKCkpLnRvQmUoJzE5NzAtMDEtMDFUMDA6MDA6MDAuMDAwWicpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pOyIsInN0b3J5dG9vbHMgPSB7XG4gICAgY29yZTogcmVxdWlyZSgnLi4vbGliL2NvcmUvaW5kZXguanMnKVxufTtcbnJlcXVpcmUoJy4uL2xpYi9uZy9jb3JlL3RpbWUvc2VydmljZXMuanMnKTtcblxuZGVzY3JpYmUoJ3Rlc3QgdGltZSBzZXJ2aWNlcycsIGZ1bmN0aW9uKCkge1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmFuZ3VsYXIubW9jay5tb2R1bGUoJ3N0b3J5dG9vbHMuY29yZS50aW1lLnNlcnZpY2VzJyk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnVGltZU1hY2hpbmUgd29ya3MnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gdGltZUxheWVycygpIHtcbiAgICAgICAgICAgIHZhciBsYXllcnMgPSBbXTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZm9yRWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGxheWVycztcbiAgICAgICAgfVxuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBpbmplY3QoZnVuY3Rpb24oJGluamVjdG9yKSB7XG4gICAgICAgICAgICAgICAgVGltZU1hY2hpbmUgPSAkaW5qZWN0b3IuZ2V0KCdUaW1lTWFjaGluZScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdCgnc2hvdWxkIGNvbXB1dGUgdGlja3MnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxheWVycyA9IHRpbWVMYXllcnMoXG4gICAgICAgICAgICAgICAgWzEsIDEwLCAxMDAwXSxcbiAgICAgICAgICAgICAgICBbMTAwMDAsIDEwLCAxMF1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBleHBlY3QoVGltZU1hY2hpbmUuY29tcHV0ZVRpY2tzKGxheWVycykpLnRvRXF1YWwoWyAxLCAxMCwgMTAwMCwgMTAwMDAgXSk7XG5cbiAgICAgICAgICAgIGxheWVycyA9IHRpbWVMYXllcnMoXG4gICAgICAgICAgICAgICAgWzEwMDAwLCA0MDAwMF0sXG4gICAgICAgICAgICAgICAgWzIwMDAwLCAzMDAwMF0sXG4gICAgICAgICAgICAgICAgbmV3IHN0b3J5dG9vbHMuY29yZS50aW1lLnV0aWxzLkludGVydmFsKHtzdGFydDogNTAwMCwgZW5kOiA1MDAwMCwgZHVyYXRpb246J1A1Uyd9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gNTAwMDsgaSA8PSA1MDAwMDsgaSs9IDUwMDAgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwZWN0KFRpbWVNYWNoaW5lLmNvbXB1dGVUaWNrcyhsYXllcnMpKS50b0VxdWFsKHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vbGliL2NvcmUvdGltZS91dGlscy5qcycpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJ3Zpcy9ub2RlX21vZHVsZXMvbW9tZW50Jyk7XG5cbi8qXG5OT1RFIC0gbnVtZXJpYyB2YWx1ZXMgaW4gdGhlc2UgdGVzdHMgKGFuZCB0aGUgQVBJKSBhcmUgYWxsIG1pbGxpc2Vjb25kc1xuICAgICAgIGRlc3BpdGUgbG9va2luZyBsaWtlIHllYXJzIC0gcGFydHkgbGlrZSBpdCdzIFwiMTk3MC0wMS0wMVQwMDowMDowMS45OTlaXCIhXG4qL1xuZGVzY3JpYmUoXCJ0ZXN0IHV0aWxzXCIsIGZ1bmN0aW9uKCkge1xuICAgIGl0KFwidGVzdHMgZmluZGluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBbMSw1LDEwXTtcbiAgICAgICAgZXhwZWN0KHV0aWxzLmZpbmQoZGF0YSwgMCkpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdCh1dGlscy5maW5kKGRhdGEsIDEpKS50b0JlKDApO1xuICAgICAgICBleHBlY3QodXRpbHMuZmluZChkYXRhLCAyKSkudG9CZSgwKTtcbiAgICAgICAgZXhwZWN0KHV0aWxzLmZpbmQoZGF0YSwgNSkpLnRvQmUoMSk7XG4gICAgICAgIGV4cGVjdCh1dGlscy5maW5kKGRhdGEsIDYpKS50b0JlKDEpO1xuICAgICAgICBleHBlY3QodXRpbHMuZmluZChkYXRhLCAxMCkpLnRvQmUoMik7XG4gICAgICAgIGV4cGVjdCh1dGlscy5maW5kKGRhdGEsIDExKSkudG9CZSgyKTtcbiAgICB9KTtcbiAgICBkZXNjcmliZShcInJhbmdlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdChcImNyZWF0ZVJhbmdlIHdvcmtzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHI7XG4gICAgICAgICAgICAvLyB0ZXh0XG4gICAgICAgICAgICByID0gdXRpbHMuY3JlYXRlUmFuZ2UoJzIwMDAnLCAnMjAwMScpO1xuICAgICAgICAgICAgZXhwZWN0KHIuc3RhcnQpLnRvQmUoRGF0ZS5wYXJzZSgnMjAwMCcpKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmVuZCkudG9CZShEYXRlLnBhcnNlKCcyMDAxJykpO1xuICAgICAgICAgICAgLy8gbnVtYmVycyAobWlsbGlzKVxuICAgICAgICAgICAgciA9IHV0aWxzLmNyZWF0ZVJhbmdlKDIwMDAsIDIwMDMpO1xuICAgICAgICAgICAgZXhwZWN0KHIuc3RhcnQpLnRvQmUoMjAwMCk7XG4gICAgICAgICAgICBleHBlY3Qoci5lbmQpLnRvQmUoMjAwMyk7XG4gICAgICAgICAgICAvLyBjb3B5XG4gICAgICAgICAgICByID0gdXRpbHMuY3JlYXRlUmFuZ2Uocik7XG4gICAgICAgICAgICBleHBlY3Qoci5zdGFydCkudG9CZSgyMDAwKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmVuZCkudG9CZSgyMDAzKTtcbiAgICAgICAgICAgIC8vIHNpbmdsZSBhcmdcbiAgICAgICAgICAgIHIgPSB1dGlscy5jcmVhdGVSYW5nZSgxOTk5KTtcbiAgICAgICAgICAgIGV4cGVjdChyLnN0YXJ0KS50b0JlKDE5OTkpO1xuICAgICAgICAgICAgZXhwZWN0KHIuZW5kKS50b0JlKDE5OTkpO1xuICAgICAgICAgICAgLy8gbnVsbCAxc3QgYXJnIChvcGVuIHJhbmdlKVxuICAgICAgICAgICAgciA9IHV0aWxzLmNyZWF0ZVJhbmdlKDE5OTksIG51bGwpO1xuICAgICAgICAgICAgZXhwZWN0KHIuc3RhcnQpLnRvQmUoMTk5OSk7XG4gICAgICAgICAgICBleHBlY3Qoci5lbmQpLnRvQmUobnVsbCk7XG4gICAgICAgICAgICAvLyBudWxsIDJuZCBhcmcgKG9wZW4gcmFuZ2UpXG4gICAgICAgICAgICByID0gdXRpbHMuY3JlYXRlUmFuZ2UobnVsbCwgNjc4OSk7XG4gICAgICAgICAgICBleHBlY3Qoci5zdGFydCkudG9CZShudWxsKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmVuZCkudG9CZSg2Nzg5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KFwiYmFzaWNzIHdvcmtcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgciA9IHV0aWxzLmNyZWF0ZVJhbmdlKDIwMDAsIDIwMDMpO1xuICAgICAgICAgICAgZXhwZWN0KHIuY2VudGVyKCkpLnRvQmUoMjAwMSk7XG4gICAgICAgICAgICBleHBlY3Qoci53aWR0aCgpKS50b0JlKDMpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoXCJleHRlbmQgd29ya3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgciA9IHV0aWxzLmNyZWF0ZVJhbmdlKDIwMDAsIDIwMDMpO1xuICAgICAgICAgICAgLy8gaWRlbXBvdGVudFxuICAgICAgICAgICAgci5leHRlbmQocik7XG4gICAgICAgICAgICBleHBlY3Qoci5zdGFydCkudG9CZSgyMDAwKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmVuZCkudG9CZSgyMDAzKTtcbiAgICAgICAgICAgIC8vIHNpbmdsZSBsZWZ0XG4gICAgICAgICAgICByLmV4dGVuZCgxOTk1KTtcbiAgICAgICAgICAgIGV4cGVjdChyLnN0YXJ0KS50b0JlKDE5OTUpO1xuICAgICAgICAgICAgZXhwZWN0KHIuZW5kKS50b0JlKDIwMDMpO1xuICAgICAgICAgICAgLy8gc2luZ2xlIHJpZ2h0XG4gICAgICAgICAgICByLmV4dGVuZCgyMDA0KTtcbiAgICAgICAgICAgIGV4cGVjdChyLnN0YXJ0KS50b0JlKDE5OTUpO1xuICAgICAgICAgICAgZXhwZWN0KHIuZW5kKS50b0JlKDIwMDQpO1xuICAgICAgICAgICAgLy8gYm90aCBzaWRlc1xuICAgICAgICAgICAgci5leHRlbmQodXRpbHMuY3JlYXRlUmFuZ2UoMTkwMCwgMjAxMCkpO1xuICAgICAgICAgICAgZXhwZWN0KHIuc3RhcnQpLnRvQmUoMTkwMCk7XG4gICAgICAgICAgICBleHBlY3Qoci5lbmQpLnRvQmUoMjAxMCk7XG4gICAgICAgICAgICAvLyBzdGFydCB3aXRoIG5vdGhpbmcsIGV4dGVuZCB3LyBub3RoaW5nXG4gICAgICAgICAgICByID0gdXRpbHMuY3JlYXRlUmFuZ2UobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICByLmV4dGVuZChyID0gdXRpbHMuY3JlYXRlUmFuZ2UobnVsbCwgbnVsbCkpO1xuICAgICAgICAgICAgZXhwZWN0KHIuaXNFbXB0eSgpKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgLy8gc3RhcnRpbmcgd2l0aCBub3RoaW5nLCBleHRlbmQgb3Blbi1lbmRlZCBzdGFydFxuICAgICAgICAgICAgciA9IHV0aWxzLmNyZWF0ZVJhbmdlKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgci5leHRlbmQodXRpbHMuY3JlYXRlUmFuZ2UoMTIzNCwgbnVsbCkpO1xuICAgICAgICAgICAgZXhwZWN0KHIuc3RhcnQpLnRvQmUoMTIzNCk7XG4gICAgICAgICAgICBleHBlY3Qoci5lbmQpLnRvQmUoMTIzNCk7XG4gICAgICAgICAgICAvLyBzdGFydGluZyB3aXRoIG5vdGhpbmcsIGV4dGVuZCBvcGVuLWVuZGVkIGVuZFxuICAgICAgICAgICAgciA9IHV0aWxzLmNyZWF0ZVJhbmdlKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgci5leHRlbmQodXRpbHMuY3JlYXRlUmFuZ2UobnVsbCwgNTY3OCkpO1xuICAgICAgICAgICAgZXhwZWN0KHIuc3RhcnQpLnRvQmUoNTY3OCk7XG4gICAgICAgICAgICBleHBlY3Qoci5lbmQpLnRvQmUoNTY3OCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdChcImludGVyc2VjdHMgd29ya3Mgd2l0aCBpbnN0YW50c1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByID0gdXRpbHMuY3JlYXRlUmFuZ2UoMjAwMCwgMjAwMyk7XG4gICAgICAgICAgICBleHBlY3Qoci5pbnRlcnNlY3RzKDE5OTkpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmludGVyc2VjdHMoMjAwMCkpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3Qoci5pbnRlcnNlY3RzKDIwMDEpKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KHIuaW50ZXJzZWN0cygyMDAzKSkudG9CZShmYWxzZSk7XG4gICAgICAgICAgICAvLyBpbnN0YW50IHJhbmdlLCB0b29cbiAgICAgICAgICAgIHIgPSB1dGlscy5jcmVhdGVSYW5nZSgyMDAwLCAyMDAwKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmludGVyc2VjdHMoMjAwMCkpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdChcImludGVyc2VjdHMgd29ya3Mgb24gb3BlbiByYW5nZSB3aXRoIGluc3RhbnRzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHIgPSB1dGlscy5jcmVhdGVSYW5nZShudWxsLCAyMDAzKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmludGVyc2VjdHMoMTk5OSkpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3Qoci5pbnRlcnNlY3RzKDIwMDQpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgIHIgPSB1dGlscy5jcmVhdGVSYW5nZSgyMDAzLCBudWxsKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmludGVyc2VjdHMoMTk5OSkpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgZXhwZWN0KHIuaW50ZXJzZWN0cygyMDA0KSkudG9CZSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KFwiaW50ZXJzZWN0cyB3b3JrcyBvbiBpbnN0YW50IHJhbmdlIHdpdGggb3BlbiByYW5nZXNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgciA9IHV0aWxzLmNyZWF0ZVJhbmdlKDIwMDMsIDIwMDMpO1xuICAgICAgICAgICAgZXhwZWN0KHIuaW50ZXJzZWN0cyh1dGlscy5jcmVhdGVSYW5nZSgxOTk5LCBudWxsKSkpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3Qoci5pbnRlcnNlY3RzKHV0aWxzLmNyZWF0ZVJhbmdlKG51bGwsIDIwMDQpKSkudG9CZSh0cnVlKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmludGVyc2VjdHModXRpbHMuY3JlYXRlUmFuZ2UoMjAwNCwgbnVsbCkpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmludGVyc2VjdHModXRpbHMuY3JlYXRlUmFuZ2UobnVsbCwgMjAwMikpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KFwiaW50ZXJzZWN0cyB3b3JrcyB3aXRoIGV4dGVudHNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgciA9IHV0aWxzLmNyZWF0ZVJhbmdlKDIwMDAsIDIwMDMpO1xuICAgICAgICAgICAgZXhwZWN0KHIuaW50ZXJzZWN0cyh1dGlscy5jcmVhdGVSYW5nZSgxOTk5LCAyMDAwKSkpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3Qoci5pbnRlcnNlY3RzKHV0aWxzLmNyZWF0ZVJhbmdlKDIwMDAsIDIwMDEpKSkudG9CZSh0cnVlKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmludGVyc2VjdHModXRpbHMuY3JlYXRlUmFuZ2UoMjAwMiwgMjAwMykpKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KHIuaW50ZXJzZWN0cyh1dGlscy5jcmVhdGVSYW5nZSgxOTk5LCAyMDAzKSkpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3Qoci5pbnRlcnNlY3RzKHV0aWxzLmNyZWF0ZVJhbmdlKDE5OTksIDIwMDQpKSkudG9CZSh0cnVlKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmludGVyc2VjdHModXRpbHMuY3JlYXRlUmFuZ2UoMjAwNCwgMjAwNSkpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgIGV4cGVjdChyLmludGVyc2VjdHModXRpbHMuY3JlYXRlUmFuZ2UoMTk5OCwgMTk5OSkpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KFwiaXNSYW5nZUxpa2Ugd29ya3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBleHBlY3QodXRpbHMuaXNSYW5nZUxpa2UobnVsbCkpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgZXhwZWN0KHV0aWxzLmlzUmFuZ2VMaWtlKHVuZGVmaW5lZCkpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgZXhwZWN0KHV0aWxzLmlzUmFuZ2VMaWtlKCd4JykpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgZXhwZWN0KHV0aWxzLmlzUmFuZ2VMaWtlKDIyKSkudG9CZShmYWxzZSk7XG4gICAgICAgICAgICBleHBlY3QodXRpbHMuaXNSYW5nZUxpa2Uoe3N0YXJ0OjF9KSkudG9CZSh0cnVlKTtcbiAgICAgICAgICAgIGV4cGVjdCh1dGlscy5pc1JhbmdlTGlrZSh7ZW5kOjF9KSkudG9CZSh0cnVlKTtcbiAgICAgICAgICAgIGV4cGVjdCh1dGlscy5pc1JhbmdlTGlrZSh7c3RhcnQ6MSwgZW5kOjF9KSkudG9CZSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaXQoXCJ0ZXN0cyBpbnRlcnZhbCBwaWNraW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QodXRpbHMucGlja0ludGVydmFsKHV0aWxzLmNyZWF0ZVJhbmdlKCcyMDAwJywnMjAwMScpKSkudG9CZShcbiAgICAgICAgICAgIG1vbWVudC5kdXJhdGlvbigxLCAnbW9udGhzJykuYXNNaWxsaXNlY29uZHMoKVxuICAgICAgICApO1xuICAgICAgICBleHBlY3QodXRpbHMucGlja0ludGVydmFsKHV0aWxzLmNyZWF0ZVJhbmdlKCcyMDAwLTAxLTAxJywnMjAwMC0wMi0wMScpKSkudG9CZShcbiAgICAgICAgICAgIG1vbWVudC5kdXJhdGlvbigxLCAnd2Vla3MnKS5hc01pbGxpc2Vjb25kcygpXG4gICAgICAgICk7XG4gICAgfSk7XG4gICAgaXQoXCJ0ZXN0cyBjb21wdXRlIHJhbmdlIHdvcmtzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgciA9IHV0aWxzLmNvbXB1dGVSYW5nZShbdXRpbHMuY3JlYXRlUmFuZ2UoMTAwLDIwMCldKTtcbiAgICAgICAgZXhwZWN0KHIuc3RhcnQpLnRvQmUoMTAwKTtcbiAgICAgICAgZXhwZWN0KHIuZW5kKS50b0JlKDIwMCk7XG4gICAgICAgIHIgPSB1dGlscy5jb21wdXRlUmFuZ2UoW3V0aWxzLmNyZWF0ZVJhbmdlKDEwMCw0MDApLCB1dGlscy5jcmVhdGVSYW5nZSgxMDAsMzAwKV0pO1xuICAgICAgICBleHBlY3Qoci5zdGFydCkudG9CZSgxMDApO1xuICAgICAgICBleHBlY3Qoci5lbmQpLnRvQmUoNDAwKTtcbiAgICAgICAgciA9IHV0aWxzLmNvbXB1dGVSYW5nZShbMjAsMTAsNTBdKTtcbiAgICAgICAgZXhwZWN0KHIuc3RhcnQpLnRvQmUoMTApO1xuICAgICAgICBleHBlY3Qoci5lbmQpLnRvQmUoNTApO1xuICAgIH0pO1xuICAgIGl0KFwidGVzdHMgY3JlYXRlT2Zmc2V0dGVyIHdvcmtzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBvZmZzZXRBc0lTTyh0aW1lc3RhbXAsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodXRpbHMuY3JlYXRlT2Zmc2V0dGVyKGR1cmF0aW9uKSh0aW1lc3RhbXApKS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdChvZmZzZXRBc0lTTygnMTk3MCcsICdQMVknKSkudG9CZSgnMTk3MS0wMS0wMVQwMDowMDowMC4wMDBaJyk7XG4gICAgICAgIGV4cGVjdChvZmZzZXRBc0lTTygnMTk3MC0wNi0wMScsICdQMVkxTScpKS50b0JlKCcxOTcxLTA3LTAxVDAwOjAwOjAwLjAwMFonKTtcbiAgICAgICAgZXhwZWN0KG9mZnNldEFzSVNPKCcxOTc0LTAyLTI4VDEyOjI0JywgJ1AyWTJNJykpLnRvQmUoJzE5NzYtMDQtMjhUMTI6MjQ6MDAuMDAwWicpO1xuICAgICAgICBleHBlY3Qob2Zmc2V0QXNJU08oJzE5NzQtMDItMjhUMTI6MjQnLCAnUDJZMk0nKSkudG9CZSgnMTk3Ni0wNC0yOFQxMjoyNDowMC4wMDBaJyk7XG4gICAgICAgIC8vIHZlcmlmeSBjdXJyZW50IGFsZ29yaXRobSBmYWlscyAtIGphbiAzMXN0ICsgMW1vbnRoIHdyYXBzIGludG8gbWFyY2hcbiAgICAgICAgZXhwZWN0KG9mZnNldEFzSVNPKCcxOTc0LTAxLTMxVDEyOjI0JywgJ1AyWTFNJykpLnRvQmUoJzE5NzYtMDMtMDJUMTI6MjQ6MDAuMDAwWicpO1xuICAgIH0pO1xuICAgICAgICBpdChcInBhcnNlSVNPRHVyYXRpb24gc2hvdWxkIHRocm93IHNvbWV0aW1lc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdXRpbHMucGFyc2VJU09EdXJhdGlvbignVFAxTScpO1xuICAgICAgICB9KS50b1Rocm93RXJyb3IoJ2V4cGVjdGVkIFAgYXMgc3RhcnRpbmcgZHVyYXRpb24gOiBUUDFNJyk7XG4gICAgICAgIGV4cGVjdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHV0aWxzLnBhcnNlSVNPRHVyYXRpb24oJ1AxWCcpO1xuICAgICAgICB9KS50b1Rocm93RXJyb3IoJ3Vua25vd24gZHVyYXRpb24gc3BlY2lmaWVyIDogWCcpO1xuICAgIH0pO1xuICAgIGl0KFwicGFyc2VJU09EdXJhdGlvbiBzaG91bGQgcGFyc2UgY29ycmVjdGx5XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QodXRpbHMucGFyc2VJU09EdXJhdGlvbignUFQxUycpKS50b0JlKDEwMDApO1xuICAgICAgICBleHBlY3QodXRpbHMucGFyc2VJU09EdXJhdGlvbignUFQxTScpKS50b0JlKDYwMDAwKTtcbiAgICAgICAgZXhwZWN0KHV0aWxzLnBhcnNlSVNPRHVyYXRpb24oJ1BUMUgnKSkudG9CZSgzNjAwMDAwKTtcbiAgICAgICAgZXhwZWN0KHV0aWxzLnBhcnNlSVNPRHVyYXRpb24oJ1AxRCcpKS50b0JlKDg2NDAwMDAwKTtcbiAgICAgICAgZXhwZWN0KHV0aWxzLnBhcnNlSVNPRHVyYXRpb24oJ1AxVycpKS50b0JlKDYwNDgwMDAwMCk7XG4gICAgICAgIGV4cGVjdCh1dGlscy5wYXJzZUlTT0R1cmF0aW9uKCdQMU0nKSkudG9CZSgyNTkyMDAwMDAwKTtcbiAgICAgICAgZXhwZWN0KHV0aWxzLnBhcnNlSVNPRHVyYXRpb24oJ1AxWScpKS50b0JlKDMxNTM2MDAwMDAwKTtcbiAgICAgICAgZXhwZWN0KHV0aWxzLnBhcnNlSVNPRHVyYXRpb24oJ1AxTVQxTScpKS50b0JlKDI1OTIwMDAwMDAgKyA2MDAwMCk7XG4gICAgfSk7XG59KTtcbiJdfQ==
